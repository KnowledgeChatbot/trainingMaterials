{"Title":"使用 AES-128 动态加密和密钥传送服务","Description":"借助 Azure 媒体服务，可传送使用 AES 128 位加密密钥加密的内容。 媒体服务还提供密钥传送服务，将加密密钥传送给已授权的用户。 本主题说明如何使用 AES-128 动态加密以及如何使用密钥传送服务。","Content":"# <a name=\"using-aes-128-dynamic-encryption-and-key-delivery-service\"></a>使用 AES-128 动态加密和密钥传送服务\r \r > [!div class=\"op_single_selector\"]\r > * [.NET](media-services-protect-with-aes128.md)\r > * [Java](https://github.com/southworkscom/azure-sdk-for-media-services-java-samples)\r > * [PHP](https://github.com/Azure/azure-sdk-for-php/tree/master/examples/MediaServices)\r > \r > \r \r ## <a name=\"overview\"></a>概述\r > [!NOTE]\r > 请参阅[此](https://channel9.msdn.com/Shows/Azure-Friday/Azure-Media-Services-Protecting-your-Media-Content-with-AES-Encryption)视频，获取有关如何使用 AES 加密保护媒体内容的概述。\r > \r > \r \r 借助 Microsoft Azure 媒体服务，可传送使用高级加密标准 (AES) 加密的 HTTP Live Streaming (HLS) 和平滑流（使用 128 位加密密钥）。 媒体服务还提供密钥传送服务，将加密密钥传送给已授权的用户。 如果需要媒体服务来加密资产，则需要将加密密钥与资产相关联，并配置密钥的授权策略。 当播放器请求流时，媒体服务使用指定的密钥通过 AES 加密来动态加密内容。 为了解密流，播放器将从密钥传送服务请求密钥。 为了确定用户是否有权获取密钥，服务会评估为密钥指定的授权策略。\r \r 媒体服务支持通过多种方式对发出密钥请求的用户进行身份验证。 内容密钥授权策略可能受到一种或多种授权限制：开放或令牌限制。 令牌限制策略必须附带由安全令牌服务 (STS) 颁发的令牌。 媒体服务支持采用[简单 Web 令牌](https://msdn.microsoft.com/library/gg185950.aspx#BKMK_2) (SWT) 格式和 [JSON Web 令牌](https://msdn.microsoft.com/library/gg185950.aspx#BKMK_3) (JWT) 格式的令牌。 有关详细信息，请参阅[配置内容密钥授权策略](media-services-protect-with-aes128.md#configure_key_auth_policy)。\r \r 为了充分利用动态加密，资产必须包含一组多码率 MP4 文件或多码率平滑流源文件。 还需要为资产配置传送策略（在本主题后面部分介绍）。 然后，根据流式处理 URL 中指定的格式，按需流式处理服务器会确保使用选定的协议来传送流。 因此，用户只需以单一存储格式存储文件并为其付费，媒体服务服务就会基于客户端的请求构建并提供相应响应。\r \r 本主题适合开发受保护媒体传送应用程序的开发人员。 本主题介绍如何使用授权策略来配置密钥传送服务，确保只有经过授权的客户端才能接收加密密钥。 此外还会介绍如何使用动态加密。\r \r ## <a name=\"aes-128-dynamic-encryption-and-key-delivery-service-workflow\"></a>AES-128 动态加密和密钥传送服务工作流\r \r 下面是使用 AES 加密资产时需要执行的常规步骤，这些步骤使用媒体服务密钥传送服务，也使用动态加密。\r \r 1. [创建资产并将文件上传到资产](media-services-protect-with-aes128.md#create_asset)。\r 2. [将包含文件的资产编码为自适应比特率 MP4 集](media-services-protect-with-aes128.md#encode_asset)。\r 3. [创建内容密钥并将其与编码资产相关联](media-services-protect-with-aes128.md#create_contentkey)。 在媒体服务中，内容密钥包含资产的加密密钥。\r 4. [配置内容密钥授权策略](media-services-protect-with-aes128.md#configure_key_auth_policy)。 必须配置内容密钥授权策略，客户端必须遵守该策略，才能将内容密钥传送到客户端。\r 5. [为资产配置传送策略](media-services-protect-with-aes128.md#configure_asset_delivery_policy)。 传送策略配置包括：密钥获取 URL 和初始化矢量 (IV)（进行加密和解密时，AES 128 要求提供同一个初始化向量）、传送协议（例如 MPEG DASH、HLS、平滑流式处理或全部）、动态加密类型（例如信封或无动态加密）。\r \r     可以将不同的策略应用到同一资产上的每个协议。 例如，可以将 PlayReady 加密应用到平滑流/DASH，将 AES 信封应用到 HLS。 将阻止流式处理传送策略中未定义的任何协议（例如，添加仅将 HLS 指定为协议的单个策略）。 如果根本没有定义任何传送策略，则情况不是这样。 此时，将允许所有明文形式的协议。\r \r 6. [创建 OnDemand 定位符](media-services-protect-with-aes128.md#create_locator)以获取流式处理 URL。\r \r 本主题还说明了[客户端应用程序如何从密钥传送服务请求密钥](media-services-protect-with-aes128.md#client_request)。\r \r 可以在主题末尾找到完整的 .NET [示例](media-services-protect-with-aes128.md#example)。\r \r 下图演示了上述工作流。 在图中，使用令牌进行了身份验证。\r \r ![使用 AES-128 提供保护](./media/media-services-content-protection-overview/media-services-content-protection-with-aes.png)\r \r 本主题的余下部分提供了详细说明、代码示例和主题链接，向你演示如何完成上述任务。\r \r ## <a name=\"current-limitations\"></a>当前限制\r 如果添加或更新资产的传送策略，则必须删除现有定位符（如果有）并创建新定位符。\r \r ## <a id=\"create_asset\"></a>创建资产并将文件上传到资产\r 为了对视频进行管理、编码和流式处理，必须首先将内容上传到 Microsoft Azure 媒体服务中。 上传完成后，相关内容即安全地存储在云中供后续处理和流式处理。 \r \r 有关详细信息，请参阅 [将文件上传到媒体服务帐户](media-services-dotnet-upload-files.md)。\r \r ## <a id=\"encode_asset\"></a>将包含文件的资产编码为自适应比特率 MP4 集\r 使用动态加密时，只需创建包含一组多码率 MP4 文件或多码率平滑流源文件的资产。 然后，点播流服务器会确保用户以选定的协议按清单或分段请求中的指定格式接收流。 因此，用户只需以单一存储格式存储文件并为其付费，媒体服务服务就会基于客户端的请求构建并提供相应响应。 有关详细信息，请参阅 [动态打包概述](media-services-dynamic-packaging-overview.md) 主题。\r \r >[!NOTE]\r >创建 AMS 帐户后，会将一个处于“已停止”状态的**默认**流式处理终结点添加到帐户。 若要开始流式传输内容并利用动态打包和动态加密，要从中流式传输内容的流式处理终结点必须处于“正在运行”状态。 \r >\r >此外，若要使用动态打包和动态加密，用户的资产必须包含一组自适应比特率 MP4 或自适应比特率平滑流式处理文件。\r \r 有关如何编码的说明，请参阅 [如何使用 Media Encoder Standard 对资产进行编码](media-services-dotnet-encode-with-media-encoder-standard.md)。\r \r ## <a id=\"create_contentkey\"></a>创建内容密钥并将其与编码资产相关联\r 在媒体服务中，内容密钥包含用于加密资产的密钥。\r \r 有关详细信息，请参阅 [创建内容密钥](media-services-dotnet-create-contentkey.md)。\r \r ## <a id=\"configure_key_auth_policy\"></a>配置内容密钥授权策略\r 媒体服务支持通过多种方式对发出密钥请求的用户进行身份验证。 必须配置内容密钥授权策略，客户端（播放器）必须遵守该策略，才能将密钥传送到客户端。 内容密钥授权策略可能受到一种或多种授权限制：开放、令牌限制或 IP 限制。\r \r 有关详细信息，请参阅 [配置内容密钥授权策略](media-services-dotnet-configure-content-key-auth-policy.md)。\r \r ## <a id=\"configure_asset_delivery_policy\"></a>配置资产传送策略\r 为资产配置传送策略。 资产传送策略配置包括：\r \r * 密钥获取 URL。 \r * 用于信封加密的初始化矢量 (IV)。 进行加密和解密时，AES - 128 要求提供同一个 IV。 \r * 资产传送协议（例如 MPEG DASH、HLS、平滑流式处理或全部）。\r * 动态加密类型（例如 AES 信封）或无动态加密。 \r \r 有关详细信息，请参阅 [配置资产传送策略 ](media-services-rest-configure-asset-delivery-policy.md)。\r \r ## <a id=\"create_locator\"></a>创建 OnDemand 流定位符以获取流 URL\r 需要为用户提供平滑流、DASH 或 HLS 的流 URL。\r \r >[!NOTE]\r >如果添加或更新资产的传送策略，则必须删除现有定位符（如果有）并创建新定位符。\r \r 有关如何发布资产和生成流 URL 的说明，请参阅 [生成流 URL](media-services-deliver-streaming-content.md)。\r \r ## <a name=\"get-a-test-token\"></a>获取测试令牌\r 获取用于密钥授权策略的基于令牌限制的测试令牌。\r \r     // Deserializes a string containing an Xml representation of a TokenRestrictionTemplate\r     // back into a TokenRestrictionTemplate class instance.\r     TokenRestrictionTemplate tokenTemplate = \r         TokenRestrictionTemplateSerializer.Deserialize(tokenTemplateString);\r \r     // Generate a test token based on the data in the given TokenRestrictionTemplate.\r     //The GenerateTestToken method returns the token without the word “Bearer” in front\r     //so you have to add it in front of the token string. \r     string testToken = TokenRestrictionTemplateSerializer.GenerateTestToken(tokenTemplate);\r     Console.WriteLine(\"The authorization token is:\\nBearer {0}\", testToken);\r \r 可以使用 [AMS Player](http://amsplayer.azurewebsites.net/azuremediaplayer.html) 来测试流。\r \r ## <a id=\"client_request\"></a>你的客户端如何从密钥传送服务请求密钥？\r 在上一步骤中，构造了指向清单文件的 URL。 客户端需要从流清单文件提取必要的信息，以便向密钥传送服务发出请求。\r \r ### <a name=\"manifest-files\"></a>清单文件\r 客户端需要从清单文件提取 URL（也包含内容密钥 ID (kid)）值。 然后，客户端将尝试从密钥传送服务获取加密密钥。 客户端还需要提取 IV 值，并使用该值来解密流。以下代码段显示了平滑流式处理清单的 <Protection> 元素。\r \r     <Protection>\r       <ProtectionHeader SystemID=\"B47B251A-2409-4B42-958E-08DBAE7B4EE9\">\r         <ContentProtection xmlns:sea=\"urn:mpeg:dash:schema:sea:2012\" schemeIdUri=\"urn:mpeg:dash:sea:2012\">\r           <sea:SegmentEncryption schemeIdUri=\"urn:mpeg:dash:sea:aes128-cbc:2013\"/>\r           <sea:KeySystem keySystemUri=\"urn:mpeg:dash:sea:keysys:http:2013\"/>\r           <sea:CryptoPeriod IV=\"0xD7D7D7D7D7D7D7D7D7D7D7D7D7D7D7D7\" \r                         keyUriTemplate=\"https://wamsbayclus001kd-hs.chinacloudapp.cn/HlsHandler.ashx?\r                                             kid=da3813af-55e6-48e7-aa9f-a4d6031f7b4d\"/>\r         </ContentProtection>\r       </ProtectionHeader>\r     </Protection>\r \r 对于 HLS，根清单将划分成段文件。 \r \r 例如，根清单为 http://test001.origin.mediaservices.chinacloudapi.cn/8bfe7d6f-34e3-4d1a-b289-3e48a8762490/BigBuckBunny.ism/manifest(format=m3u8-aapl) 并且包含段文件名的列表。\r \r     . . . \r     #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=630133,RESOLUTION=424x240,CODECS=\"avc1.4d4015,mp4a.40.2\",AUDIO=\"audio\"\r     QualityLevels(514369)/Manifest(video,format=m3u8-aapl)\r     #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=965441,RESOLUTION=636x356,CODECS=\"avc1.4d401e,mp4a.40.2\",AUDIO=\"audio\"\r     QualityLevels(842459)/Manifest(video,format=m3u8-aapl)\r     …\r \r 如果在文本编辑器中打开其中一个段文件（例如，http://test001.origin.mediaservices.chinacloudapi.cn/8bfe7d6f-34e3-4d1a-b289-3e48a8762490/BigBuckBunny.ism/QualityLevels(514369)/Manifest(video,format=m3u8-aapl)，则应包含 #EXT-X-KEY，表示文件已加密。\r \r     #EXTM3U\r     #EXT-X-VERSION:4\r     #EXT-X-ALLOW-CACHE:NO\r     #EXT-X-MEDIA-SEQUENCE:0\r     #EXT-X-TARGETDURATION:9\r     #EXT-X-KEY:METHOD=AES-128,\r     URI=\"https://wamsbayclus001kd-hs.chinacloudapp.cn/HlsHandler.ashx?\r      kid=da3813af-55e6-48e7-aa9f-a4d6031f7b4d\",\r         IV=0XD7D7D7D7D7D7D7D7D7D7D7D7D7D7D7D7\r     #EXT-X-PROGRAM-DATE-TIME:1970-01-01T00:00:00.000+00:00\r     #EXTINF:8.425708,no-desc\r     Fragments(video=0,format=m3u8-aapl)\r     #EXT-X-ENDLIST\r \r >[!NOTE] \r >如果打算在 Safari 中播放 AES 加密的 HLS，请参阅[此博客](https://azure.microsoft.com/blog/how-to-make-token-authorized-aes-encrypted-hls-stream-working-in-safari/)。\r \r ### <a name=\"request-the-key-from-the-key-delivery-service\"></a>从密钥传送服务请求密钥\r 以下代码演示如何使用密钥传送 Uri（从清单提取）和令牌（本主题不讨论如何从安全令牌服务获取简单 Web 令牌），向媒体服务密钥传送服务发送请求。\r \r     private byte[] GetDeliveryKey(Uri keyDeliveryUri, string token)\r     {\r         HttpWebRequest request = (HttpWebRequest)WebRequest.Create(keyDeliveryUri);\r \r         request.Method = \"POST\";\r         request.ContentType = \"text/xml\";\r         if (!string.IsNullOrEmpty(token))\r         {\r             request.Headers[AuthorizationHeader] = token;\r         }\r         request.ContentLength = 0;\r \r         var response = request.GetResponse();\r \r         var stream = response.GetResponseStream();\r         if (stream == null)\r         {\r             throw new NullReferenceException(\"Response stream is null\");\r         }\r \r         var buffer = new byte[256];\r         var length = 0;\r         while (stream.CanRead && length <= buffer.Length)\r         {\r             var nexByte = stream.ReadByte();\r             if (nexByte == -1)\r             {\r                 break;\r             }\r             buffer[length] = (byte)nexByte;\r             length++;\r         }\r         response.Close();\r \r         // AES keys must be exactly 16 bytes (128 bits).\r         var key = new byte[length];\r         Array.Copy(buffer, key, length);\r         return key;\r     }\r \r ## <a name=\"protect-your-content-with-aes-128-using-net\"></a>在 .NET 中使用 AES-128 保护内容\r \r ### <a name=\"create-and-configure-a-visual-studio-project\"></a>创建和配置 Visual Studio 项目\r \r 1. 设置开发环境，并根据[使用 .NET 进行媒体服务开发](media-services-dotnet-how-to-use.md)中所述，在 app.config 文件中填充连接信息。 \r 2. 将以下元素添加到 app.config 文件中定义的 **appSettings**：\r \r         <add key=\"Issuer\" value=\"http://testacs.com\"/>\r         <add key=\"Audience\" value=\"urn:test\"/>\r \r ### <a id=\"example\"></a>示例\r \r 使用本部分中所示的代码覆盖 Program.cs 文件中的代码。\r  \r >[!NOTE]\r >不同 AMS 策略的策略限制为 1,000,000 个（例如，对于定位器策略或 ContentKeyAuthorizationPolicy）。 如果始终使用相同的日期/访问权限，则应使用相同的策略 ID，例如，用于要长期就地保留的定位符的策略（非上传策略）。 有关详细信息，请参阅[此](media-services-dotnet-manage-entities.md#limit-access-policies)主题。\r \r 请务必将变量更新为指向输入文件所在的文件夹。\r \r ```CSharp\r using System;\r using System.Collections.Generic;\r using System.Configuration;\r using System.IO;\r using System.Linq;\r using System.Security.Cryptography;\r using Microsoft.WindowsAzure.MediaServices.Client;\r using System.Threading;\r using Microsoft.WindowsAzure.MediaServices.Client.ContentKeyAuthorization;\r using Microsoft.WindowsAzure.MediaServices.Client.DynamicEncryption;\r \r namespace DynamicEncryptionWithAES\r {\r     class Program\r     {\r         // Read values from the App.config file.\r         static string _AADTenantDomain =\r             ConfigurationManager.AppSettings[\"AMSAADTenantDomain\"];\r         static string _RESTAPIEndpoint =\r             ConfigurationManager.AppSettings[\"AMSRESTAPIEndpoint\"];\r \r         // A Uri describing the issuer of the token.  \r         // Must match the value in the token for the token to be considered valid.\r         private static readonly Uri _sampleIssuer =\r             new Uri(ConfigurationManager.AppSettings[\"Issuer\"]);\r         // The Audience or Scope of the token.  \r         // Must match the value in the token for the token to be considered valid.\r         private static readonly Uri _sampleAudience =\r             new Uri(ConfigurationManager.AppSettings[\"Audience\"]);\r \r         // Field for service context.\r         private static CloudMediaContext _context = null;\r \r         private static readonly string _mediaFiles =\r             Path.GetFullPath(@\"../..\\Media\");\r \r         private static readonly string _singleMP4File =\r             Path.Combine(_mediaFiles, @\"BigBuckBunny.mp4\");\r \r         static void Main(string[] args)\r         {\r             AzureAdTokenCredentials tokenCredentials = new AzureAdTokenCredentials(_AADTenantDomain, AzureEnvironments.AzureChinaCloudEnvironment);\r             AzureAdTokenProvider tokenProvider = new AzureAdTokenProvider(tokenCredentials);\r \r             _context = new CloudMediaContext(new Uri(_RESTAPIEndpoint), tokenProvider);\r \r             bool tokenRestriction = true;\r             string tokenTemplateString = null;\r \r             IAsset asset = UploadFileAndCreateAsset(_singleMP4File);\r             Console.WriteLine(\"Uploaded asset: {0}\", asset.Id);\r \r             IAsset encodedAsset = EncodeToAdaptiveBitrateMP4Set(asset);\r             Console.WriteLine(\"Encoded asset: {0}\", encodedAsset.Id);\r \r             IContentKey key = CreateEnvelopeTypeContentKey(encodedAsset);\r             Console.WriteLine(\"Created key {0} for the asset {1} \", key.Id, encodedAsset.Id);\r             Console.WriteLine();\r \r             if (tokenRestriction)\r                 tokenTemplateString = AddTokenRestrictedAuthorizationPolicy(key);\r             else\r                 AddOpenAuthorizationPolicy(key);\r \r             Console.WriteLine(\"Added authorization policy: {0}\", key.AuthorizationPolicyId);\r             Console.WriteLine();\r \r             CreateAssetDeliveryPolicy(encodedAsset, key);\r             Console.WriteLine(\"Created asset delivery policy. \\n\");\r             Console.WriteLine();\r \r             if (tokenRestriction && !String.IsNullOrEmpty(tokenTemplateString))\r             {\r                 // Deserializes a string containing an Xml representation of a TokenRestrictionTemplate\r                 // back into a TokenRestrictionTemplate class instance.\r                 TokenRestrictionTemplate tokenTemplate =\r                     TokenRestrictionTemplateSerializer.Deserialize(tokenTemplateString);\r \r                 // Generate a test token based on the data in the given TokenRestrictionTemplate.\r                 // Note, you need to pass the key id Guid because we specified \r                 // TokenClaim.ContentKeyIdentifierClaim in during the creation of TokenRestrictionTemplate.\r                 Guid rawkey = EncryptionUtils.GetKeyIdAsGuid(key.Id);\r \r                 //The GenerateTestToken method returns the token without the word “Bearer” in front\r                 //so you have to add it in front of the token string. \r                 string testToken = TokenRestrictionTemplateSerializer.GenerateTestToken(tokenTemplate, null, rawkey, DateTime.UtcNow.AddDays(365));\r \r                 Console.WriteLine(\"The authorization token is:\\nBearer {0}\", testToken);\r                 Console.WriteLine();\r             }\r \r             // You can use the bit.ly/aesplayer Flash player to test the URL \r             // (with open authorization policy). \r             // Paste the URL and click the Update button to play the video. \r             //\r             string URL = GetStreamingOriginLocator(encodedAsset);\r             Console.WriteLine(\"Smooth Streaming Url: {0}/manifest\", URL);\r             Console.WriteLine();\r             Console.WriteLine(\"HLS Url: {0}/manifest(format=m3u8-aapl)\", URL);\r             Console.WriteLine();\r \r             Console.ReadLine();\r         }\r \r         static public IAsset UploadFileAndCreateAsset(string singleFilePath)\r         {\r             if (!File.Exists(singleFilePath))\r             {\r                 Console.WriteLine(\"File does not exist.\");\r                 return null;\r             }\r \r             var assetName = Path.GetFileNameWithoutExtension(singleFilePath);\r             IAsset inputAsset = _context.Assets.Create(assetName, AssetCreationOptions.StorageEncrypted);\r \r             var assetFile = inputAsset.AssetFiles.Create(Path.GetFileName(singleFilePath));\r \r             Console.WriteLine(\"Created assetFile {0}\", assetFile.Name);\r \r             var policy = _context.AccessPolicies.Create(\r                                     assetName,\r                                     TimeSpan.FromDays(30),\r                                     AccessPermissions.Write | AccessPermissions.List);\r \r             var locator = _context.Locators.CreateLocator(LocatorType.Sas, inputAsset, policy);\r \r             Console.WriteLine(\"Upload {0}\", assetFile.Name);\r \r             assetFile.Upload(singleFilePath);\r             Console.WriteLine(\"Done uploading {0}\", assetFile.Name);\r \r             locator.Delete();\r             policy.Delete();\r \r             return inputAsset;\r         }\r \r         static public IAsset EncodeToAdaptiveBitrateMP4Set(IAsset asset)\r         {\r             // Declare a new job.\r             IJob job = _context.Jobs.Create(\"Media Encoder Standard Job\");\r             // Get a media processor reference, and pass to it the name of the \r             // processor to use for the specific task.\r             IMediaProcessor processor = GetLatestMediaProcessorByName(\"Media Encoder Standard\");\r \r             // Create a task with the encoding details, using a string preset.\r             // In this case \"H264 Multiple Bitrate 720p\" preset is used.\r             ITask task = job.Tasks.AddNew(\"My encoding task\",\r                 processor,\r                 \"H264 Multiple Bitrate 720p\",\r                 TaskOptions.None);\r \r             // Specify the input asset to be encoded.\r             task.InputAssets.Add(asset);\r             // Add an output asset to contain the results of the job. \r             // This output is specified as AssetCreationOptions.None, which \r             // means the output asset is not encrypted. \r             task.OutputAssets.AddNew(\"Output asset\",\r                 AssetCreationOptions.None);\r \r             job.StateChanged += new EventHandler<JobStateChangedEventArgs>(JobStateChanged);\r             job.Submit();\r             job.GetExecutionProgressTask(CancellationToken.None).Wait();\r \r             return job.OutputMediaAssets[0];\r         }\r \r         private static IMediaProcessor GetLatestMediaProcessorByName(string mediaProcessorName)\r         {\r             var processor = _context.MediaProcessors.Where(p => p.Name == mediaProcessorName).\r             ToList().OrderBy(p => new Version(p.Version)).LastOrDefault();\r \r             if (processor == null)\r                 throw new ArgumentException(string.Format(\"Unknown media processor\", mediaProcessorName));\r \r             return processor;\r         }\r \r         static public IContentKey CreateEnvelopeTypeContentKey(IAsset asset)\r         {\r             // Create envelope encryption content key\r             Guid keyId = Guid.NewGuid();\r             byte[] contentKey = GetRandomBuffer(16);\r \r             IContentKey key = _context.ContentKeys.Create(\r                                     keyId,\r                                     contentKey,\r                                     \"ContentKey\",\r                                     ContentKeyType.EnvelopeEncryption);\r \r             // Associate the key with the asset.\r             asset.ContentKeys.Add(key);\r \r             return key;\r         }\r \r         static public void AddOpenAuthorizationPolicy(IContentKey contentKey)\r         {\r             // Create ContentKeyAuthorizationPolicy with Open restrictions \r             // and create authorization policy             \r             IContentKeyAuthorizationPolicy policy = _context.\r                                     ContentKeyAuthorizationPolicies.\r                                     CreateAsync(\"Open Authorization Policy\").Result;\r \r             List<ContentKeyAuthorizationPolicyRestriction> restrictions =\r                 new List<ContentKeyAuthorizationPolicyRestriction>();\r \r             ContentKeyAuthorizationPolicyRestriction restriction =\r                 new ContentKeyAuthorizationPolicyRestriction\r                 {\r                     Name = \"HLS Open Authorization Policy\",\r                     KeyRestrictionType = (int)ContentKeyRestrictionType.Open,\r                     Requirements = null // no requirements needed for HLS\r                 };\r \r             restrictions.Add(restriction);\r \r             IContentKeyAuthorizationPolicyOption policyOption =\r                 _context.ContentKeyAuthorizationPolicyOptions.Create(\r                 \"policy\",\r                 ContentKeyDeliveryType.BaselineHttp,\r                 restrictions,\r                 \"\");\r \r             policy.Options.Add(policyOption);\r \r             // Add ContentKeyAutorizationPolicy to ContentKey\r             contentKey.AuthorizationPolicyId = policy.Id;\r             IContentKey updatedKey = contentKey.UpdateAsync().Result;\r             Console.WriteLine(\"Adding Key to Asset: Key ID is \" + updatedKey.Id);\r         }\r \r         public static string AddTokenRestrictedAuthorizationPolicy(IContentKey contentKey)\r         {\r             string tokenTemplateString = GenerateTokenRequirements();\r \r             IContentKeyAuthorizationPolicy policy = _context.\r                                     ContentKeyAuthorizationPolicies.\r                                     CreateAsync(\"HLS token restricted authorization policy\").Result;\r \r             List<ContentKeyAuthorizationPolicyRestriction> restrictions =\r                     new List<ContentKeyAuthorizationPolicyRestriction>();\r \r             ContentKeyAuthorizationPolicyRestriction restriction =\r                     new ContentKeyAuthorizationPolicyRestriction\r                     {\r                         Name = \"Token Authorization Policy\",\r                         KeyRestrictionType = (int)ContentKeyRestrictionType.TokenRestricted,\r                         Requirements = tokenTemplateString\r                     };\r \r             restrictions.Add(restriction);\r \r             //You could have multiple options \r             IContentKeyAuthorizationPolicyOption policyOption =\r                 _context.ContentKeyAuthorizationPolicyOptions.Create(\r                     \"Token option for HLS\",\r                     ContentKeyDeliveryType.BaselineHttp,\r                     restrictions,\r                     null  // no key delivery data is needed for HLS\r                     );\r \r             policy.Options.Add(policyOption);\r \r             // Add ContentKeyAutorizationPolicy to ContentKey\r             contentKey.AuthorizationPolicyId = policy.Id;\r             IContentKey updatedKey = contentKey.UpdateAsync().Result;\r             Console.WriteLine(\"Adding Key to Asset: Key ID is \" + updatedKey.Id);\r \r             return tokenTemplateString;\r         }\r \r         static public void CreateAssetDeliveryPolicy(IAsset asset, IContentKey key)\r         {\r             Uri keyAcquisitionUri = key.GetKeyDeliveryUrl(ContentKeyDeliveryType.BaselineHttp);\r \r             string envelopeEncryptionIV = Convert.ToBase64String(GetRandomBuffer(16));\r \r             // The following policy configuration specifies: \r             //   key url that will have KID=<Guid> appended to the envelope and\r             //   the Initialization Vector (IV) to use for the envelope encryption.\r             Dictionary<AssetDeliveryPolicyConfigurationKey, string> assetDeliveryPolicyConfiguration =\r                 new Dictionary<AssetDeliveryPolicyConfigurationKey, string>\r             {\r                         {AssetDeliveryPolicyConfigurationKey.EnvelopeKeyAcquisitionUrl, keyAcquisitionUri.ToString()}\r             };\r \r             IAssetDeliveryPolicy assetDeliveryPolicy =\r                 _context.AssetDeliveryPolicies.Create(\r                             \"AssetDeliveryPolicy\",\r                             AssetDeliveryPolicyType.DynamicEnvelopeEncryption,\r                             AssetDeliveryProtocol.SmoothStreaming | AssetDeliveryProtocol.HLS | AssetDeliveryProtocol.Dash,\r                             assetDeliveryPolicyConfiguration);\r \r             // Add AssetDelivery Policy to the asset\r             asset.DeliveryPolicies.Add(assetDeliveryPolicy);\r             Console.WriteLine();\r             Console.WriteLine(\"Adding Asset Delivery Policy: \" +\r                 assetDeliveryPolicy.AssetDeliveryPolicyType);\r         }\r \r         static public string GetStreamingOriginLocator(IAsset asset)\r         {\r \r             // Get a reference to the streaming manifest file from the  \r             // collection of files in the asset. \r \r             var assetFile = asset.AssetFiles.Where(f => f.Name.ToLower().\r                                         EndsWith(\".ism\")).\r                                         FirstOrDefault();\r \r             // Create a 30-day readonly access policy. \r             // You cannot create a streaming locator using an AccessPolicy that includes write or delete permissions.            \r             IAccessPolicy policy = _context.AccessPolicies.Create(\"Streaming policy\",\r                 TimeSpan.FromDays(30),\r                 AccessPermissions.Read);\r \r             // Create a locator to the streaming content on an origin. \r             ILocator originLocator = _context.Locators.CreateLocator(LocatorType.OnDemandOrigin, asset,\r                 policy,\r                 DateTime.UtcNow.AddMinutes(-5));\r \r             // Create a URL to the manifest file. \r             return originLocator.Path + assetFile.Name;\r         }\r \r         static private string GenerateTokenRequirements()\r         {\r             TokenRestrictionTemplate template = new TokenRestrictionTemplate(TokenType.SWT);\r \r             template.PrimaryVerificationKey = new SymmetricVerificationKey();\r             template.AlternateVerificationKeys.Add(new SymmetricVerificationKey());\r             template.Audience = _sampleAudience.ToString();\r             template.Issuer = _sampleIssuer.ToString();\r \r             template.RequiredClaims.Add(TokenClaim.ContentKeyIdentifierClaim);\r \r             return TokenRestrictionTemplateSerializer.Serialize(template);\r         }\r \r         static private void JobStateChanged(object sender, JobStateChangedEventArgs e)\r         {\r             Console.WriteLine(string.Format(\"{0}\\n  State: {1}\\n  Time: {2}\\n\\n\",\r                 ((IJob)sender).Name,\r                 e.CurrentState,\r                 DateTime.UtcNow.ToString(@\"yyyy_M_d__hh_mm_ss\")));\r         }\r \r         static private byte[] GetRandomBuffer(int size)\r         {\r             byte[] randomBytes = new byte[size];\r             using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())\r             {\r                 rng.GetBytes(randomBytes);\r             }\r \r             return randomBytes;\r         }\r     }\r }\r ```\r \r <!--Update_Description:wording update-->"}