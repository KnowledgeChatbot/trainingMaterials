{"Title":"如何通过 Node.js 使用 Azure 表存储","Description":"使用 Azure 表存储（一种 NoSQL 数据存储）将结构化数据存储在云中。","Content":"# <a name=\"how-to-use-azure-table-storage-from-nodejs\"></a>如何通过 Node.js 使用 Azure 表存储\r [!INCLUDE [storage-selector-table-include](../../includes/storage-selector-table-include.md)]\r [!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]\r \r ## <a name=\"overview\"></a>概述\r 本主题演示如何使用 Node.js 应用程序中的 Azure 表服务执行常见方案。\r \r 本主题中的代码示例假定用户已拥有 Node.js 应用程序。 有关如何在 Azure 中创建 Node.js 应用程序的信息，请参阅以下任何主题：\r \r * [在 Azure App Service 中创建 Node.js Web 应用](../app-service/app-service-web-get-started-nodejs.md)\r * [构建 Node.js 应用程序并将其部署到 Azure 云服务](../cloud-services/cloud-services-nodejs-develop-deploy-app.md)（使用 Windows PowerShell）\r \r [!INCLUDE [storage-table-concepts-include](../../includes/storage-table-concepts-include.md)]\r \r [!INCLUDE [storage-create-account-include](../../includes/storage-create-account-include.md)]\r \r ## <a name=\"configure-your-application-to-access-azure-storage\"></a>创建用于访问 Azure 存储的应用程序\r 若要使用 Azure 存储，需要用于 Node.js 的 Microsoft Azure 存储 SDK，其中包括一组便于与存储 REST 服务进行通信的库。\r \r ### <a name=\"use-node-package-manager-npm-to-install-the-package\"></a>使用节点包管理器 (NPM) 安装包\r 1. 使用 PowerShell (Windows)、Terminal (Mac) 或 Bash (Unix) 等命令行接口导航到在其中创建了应用程序的文件夹。\r 2. 在命令窗口中键入 **npm install azure-storage** 。 该命令的输出类似于以下示例。\r \r        azure-storage@0.5.0 node_modules\\azure-storage\r        +-- extend@1.2.1\r        +-- xmlbuilder@0.4.3\r        +-- mime@1.2.11\r        +-- node-uuid@1.4.3\r        +-- validator@3.22.2\r        +-- underscore@1.4.4\r        +-- readable-stream@1.0.33 (string_decoder@0.10.31, isarray@0.0.1, inherits@2.0.1, core-util-is@1.0.1)\r        +-- xml2js@0.2.7 (sax@0.5.2)\r        +-- request@2.57.0 (caseless@0.10.0, aws-sign2@0.5.0, forever-agent@0.6.1, stringstream@0.0.4, oauth-sign@0.8.0, tunnel-agent@0.4.1, isstream@0.1.2, json-stringify-safe@5.0.1, bl@0.9.4, combined-stream@1.0.5, qs@3.1.0, mime-types@2.0.14, form-data@0.2.0, http-signature@0.11.0, tough-cookie@2.0.0, hawk@2.3.1, har-validator@1.8.0)\r 3. 可以手动运行 **ls** 命令来验证是否创建了 **node\\_modules** 文件夹。 在该文件夹中将找到 **azure-storage** 包，其中包含访问存储所需的库。\r \r ### <a name=\"import-the-package\"></a>导入包\r 将以下代码添加到应用程序中 **server.js** 文件的顶部：\r \r ```nodejs\r var azure = require('azure-storage');\r ```\r \r ## <a name=\"set-up-an-azure-storage-connection\"></a>设置 Azure 存储连接\r Azure 模块将读取环境变量 AZURE\\_STORAGE\\_ACCOUNT 和 AZURE\\_STORAGE\\_ACCESS\\_KEY，或 AZURE\\_STORAGE\\_CONNECTION\\_STRING 以获取连接到 Azure 存储帐户所需的信息。 如果未设置这些环境变量，则必须在调用 **TableService**时指定帐户信息。\r \r ## <a name=\"create-a-table\"></a>创建表\r 下面的代码创建 **TableService** 对象并使用它来创建一个新表。 将以下代码添加到 **server.js** 的顶部附近。\r \r ```nodejs\r var tableSvc = azure.createTableService();\r ```\r \r 调用 **createTableIfNotExists** 会创建具有指定名称的一个新表（如果该表尚不存在）。 下面的示例创建一个名为“mytable”的新表（如果该表尚不存在）：\r \r ```nodejs\r tableSvc.createTableIfNotExists('mytable', function(error, result, response){\r   if(!error){\r     // Table exists or created\r   }\r });\r ```\r \r 如果创建了新表，`result.created` 将为 `true`，如果表已存在，则为 `false`。 `response` 包含有关该请求的信息。\r \r ### <a name=\"filters\"></a>筛选器\r 可选的筛选操作可应用于使用 TableService 执行的操作。 筛选操作可包括日志记录、自动重试等。筛选器是实现具有签名的方法的对象：\r \r ```nodejs\r function handle (requestOptions, next)\r ```\r \r 在对请求选项执行预处理后，该方法需要调用“next”并且传递具有以下签名的回调：\r \r ```nodejs\r function (returnObject, finalCallback, next)\r ```\r \r 在此回调中并且在处理 returnObject（来自对服务器请求的响应）后，回调需要调用 next（如果它已存在）以继续处理其他筛选器或只调用 finalCallback 以便结束服务调用。\r \r Azure SDK for Node.js 中附带了两个实现了重试逻辑的筛选器，分别是 **ExponentialRetryPolicyFilter** 和 **LinearRetryPolicyFilter**。 以下代码将创建使用 ExponentialRetryPolicyFilter 的 TableService 对象:\r \r ```nodejs\r var retryOperations = new azure.ExponentialRetryPolicyFilter();\r var tableSvc = azure.createTableService().withFilter(retryOperations);\r ```\r \r ## <a name=\"add-an-entity-to-a-table\"></a>向表中添加条目\r 若要添加实体，首先创建定义实体属性的对象。 所有实体都必须都包含 PartitionKey 和 RowKey，它们是实体的唯一标识符。\r \r * **PartitionKey** - 确定实体存储在其中的分区\r * **RowKey** - 唯一标识分区内的实体\r \r PartitionKey 和 RowKey 都必须是字符串值。 有关详细信息，请参阅 [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx)（了解表服务数据模型）。\r \r 下面是如何定义实体的示例。 请注意，dueDate 被定义为一种类型的 Edm.DateTime。 可以选择指定类型。如果未指定类型，系统会进行推断。\r \r ```nodejs\r var task = {\r   PartitionKey: {'_':'hometasks'},\r   RowKey: {'_': '1'},\r   description: {'_':'take out the trash'},\r   dueDate: {'_':new Date(2015, 6, 20), '$':'Edm.DateTime'}\r };\r ```\r \r > [!NOTE]\r > 每个记录还有一个“时间戳”字段，在插入或更新实体时，Azure 会设置该字段。\r >\r >\r \r 还可以使用 **entityGenerator** 来创建实体。 下面的示例使用 **entityGenerator**来创建相同的任务实体。\r \r ```nodejs\r var entGen = azure.TableUtilities.entityGenerator;\r var task = {\r   PartitionKey: entGen.String('hometasks'),\r   RowKey: entGen.String('1'),\r   description: entGen.String('take out the trash'),\r   dueDate: entGen.DateTime(new Date(Date.UTC(2015, 6, 20))),\r };\r ```\r \r 要将实体添加到表中，应将实体对象传递给 **insertEntity** 方法。\r \r ```nodejs\r tableSvc.insertEntity('mytable',task, function (error, result, response) {\r   if(!error){\r     // Entity inserted\r   }\r });\r ```\r \r 如果操作成功，`result` 将包含插入记录的 [ETag](http://en.wikipedia.org/wiki/HTTP_ETag)，并且 `response` 将包含有关操作的信息。\r \r 示例响应:\r \r ```nodejs\r { '.metadata': { etag: 'W/\"datetime\\'2015-02-25T01%3A22%3A22.5Z\\'\"' } }\r ```\r \r > [!NOTE]\r > 默认情况下，insertEntity 不会在 `response` 信息中返回插入的实体。 如果计划对此实体执行其他操作，或者希望对信息进行缓存，则可在 `result`中返回该实体。 可以通过启用 **echoContent** 来执行此操作，如下所示：\r >\r > `tableSvc.insertEntity('mytable', task, {echoContent: true}, function (error, result, response) {...}`\r >\r >\r \r ## <a name=\"update-an-entity\"></a>更新实体\r 可使用多种方法来更新现有实体：\r \r * **replaceEntity** - 通过替换现有实体来更新现有实体\r * **mergeEntity** - 通过将新属性值合并到现有实体来更新现有实体\r * **insertOrReplaceEntity** - 通过替换现有实体来更新现有实体。 如果不存在实体，将插入一个新实体\r * **insertOrMergeEntity** - 通过将新属性值合并到现有实体来更新现有实体。 如果不存在实体，将插入一个新实体\r \r 以下示例演示了使用 **replaceEntity**更新实体：\r \r ```nodejs\r tableSvc.replaceEntity('mytable', updatedTask, function(error, result, response){\r   if(!error) {\r     // Entity updated\r   }\r });\r ```\r \r > [!NOTE]\r > 默认情况下，更新某个实体时，不会查看要更新的数据是否曾被其他进程更新过。 若要支持并发更新，请执行以下步骤：\r >\r > 1. 获取要更新的对象的 ETag。 对于任何实体相关操作，该 ETag 将在 `response` 中返回，并且可通过 `response['.metadata'].etag` 检索。\r > 2. 对某个实体执行更新操作时，请将以前检索的 ETag 信息添加到新的实体。 例如：\r >\r >       entity2['.metadata'].etag = currentEtag;\r > 3. 执行更新操作。 如果实体在检索 ETag 值后已被修改，例如被应用程序的其他实例修改，则会返回一条 `error` ，指出未满足请求中指定的更新条件。\r >\r >\r \r 对于 replaceEntity 和 mergeEntity，如果待更新的实体不存在，更新操作将失败。 因此，如果希望存储某个实体而不考虑它是否已存在，请使用 insertOrReplaceEntity 或 insertOrMergeEntity。\r \r 如果更新操作成功，则 `result` 会包含所更新实体的 **Etag** 。\r \r ## <a name=\"work-with-groups-of-entities\"></a>使用实体组\r 有时，有必要成批地同时提交多项操作以确保通过服务器进行原子处理。 使用 TableBatch 类来创建一个批处理，然后使用 TableService 的 executeBatch 方法来执行批处理操作。\r \r  下面的示例演示了在一个批次中提交两个实体：\r \r ```nodejs\r var task1 = {\r   PartitionKey: {'_':'hometasks'},\r   RowKey: {'_': '1'},\r   description: {'_':'Take out the trash'},\r   dueDate: {'_':new Date(2015, 6, 20)}\r };\r var task2 = {\r   PartitionKey: {'_':'hometasks'},\r   RowKey: {'_': '2'},\r   description: {'_':'Wash the dishes'},\r   dueDate: {'_':new Date(2015, 6, 20)}\r };\r \r var batch = new azure.TableBatch();\r \r batch.insertEntity(task1, {echoContent: true});\r batch.insertEntity(task2, {echoContent: true});\r \r tableSvc.executeBatch('mytable', batch, function (error, result, response) {\r   if(!error) {\r     // Batch completed\r   }\r });\r ```\r \r 对于成功的批处理操作， `result` 包含批处理中每个操作的信息。\r \r ### <a name=\"work-with-batched-operations\"></a>使用批处理操作\r 可以通过查看 `operations` 属性来检查添加到批处理中的操作。 可以使用以下方法来处理操作：\r \r * **clear** - 清除批处理中的所有操作\r * **getOperations** - 获取批处理的操作\r * **hasOperations** - 如果批处理包含操作，则返回 true\r * **removeOperations** - 删除操作\r * **size** - 返回批处理中操作的数目\r \r ## <a name=\"retrieve-an-entity-by-key\"></a>通过键检索实体\r 如果想要返回基于 PartitionKey 和 RowKey 的特定实体，请使用 retrieveEntity 方法。\r \r ```nodejs\r tableSvc.retrieveEntity('mytable', 'hometasks', '1', function(error, result, response){\r   if(!error){\r     // result contains the entity\r   }\r });\r ```\r \r 此操作完成后， `result` 包含该实体。\r \r ## <a name=\"query-a-set-of-entities\"></a>查询实体集\r 若要查询表，请使用 **TableQuery** 对象生成一个使用以下子句的查询：\r \r * **select** - 要从查询返回的字段\r * **where** - where 子句\r \r   * and - 一个 `and` where 条件\r   * or - 一个 `or` where 条件\r * **top** - 要提取的项数\r \r 以下示例生成的查询返回 PartitionKey 为“hometasks”的前五项。\r \r ```nodejs\r var query = new azure.TableQuery()\r   .top(5)\r   .where('PartitionKey eq ?', 'hometasks');\r ```\r \r 由于未使用 **select** ，因此返回所有字段。 若要对表执行查询，请使用 **queryEntities**。 下面的示例使用此查询来返回“mytable”中的实体。\r \r ```nodejs\r tableSvc.queryEntities('mytable',query, null, function(error, result, response) {\r   if(!error) {\r     // query was successful\r   }\r });\r ```\r \r 如果成功， `result.entries` 包含与查询匹配的一组实体。 如果查询无法返回所有实体， `result.continuationToken` 就不会是*null* ，因此可用作 **queryEntities** 的第三个参数来检索更多结果。 对于初始查询，第三个参数请使用 *null* 。\r \r ### <a name=\"query-a-subset-of-entity-properties\"></a>查询一部分实体属性\r 对表的查询可以只检索实体中的少数几个字段。\r 这可以减少带宽并提高查询性能，尤其适用于大型实体。 使用 **select** 子句并传递要返回的字段的名称。 例如，下面的查询将只返回 description 和 dueDate 字段。\r \r ```nodejs\r var query = new azure.TableQuery()\r   .select(['description', 'dueDate'])\r   .top(5)\r   .where('PartitionKey eq ?', 'hometasks');\r ```\r \r ## <a name=\"delete-an-entity\"></a>删除实体\r 可以使用实体的分区键和行键删除实体。 在本例中，task1 对象包含要删除的实体的 RowKey 和 PartitionKey 值。 然后，该对象被传递给 **deleteEntity** 方法。\r \r ```nodejs\r var task = {\r   PartitionKey: {'_':'hometasks'},\r   RowKey: {'_': '1'}\r };\r \r tableSvc.deleteEntity('mytable', task, function(error, response){\r   if(!error) {\r     // Entity deleted\r   }\r });\r ```\r \r > [!NOTE]\r > 考虑在删除项时使用 ETag，以确保项尚未被其他进程修改。 请参阅 [更新实体](#update-an-entity) 了解如何使用 ETag。\r >\r >\r \r ## <a name=\"delete-a-table\"></a>删除表\r 以下代码从存储帐户中删除一个表。\r \r ```nodejs\r tableSvc.deleteTable('mytable', function(error, response){\r     if(!error){\r         // Table deleted\r     }\r });\r ```\r \r 如果不确定表是否存在，则使用 **deleteTableIfExists**。\r \r ## <a name=\"use-continuation-tokens\"></a>使用继续标记\r 在所查询的表有大量的结果时，请查找继续标记。 如果在生成时不能识别何时存在继续标记，可能存在大量未意识到的数据可用于查询。\r \r 查询实体在设置 `continuationToken` 属性（如果此类标记存在）期间，返回结果对象。 然后可以在执行查询时使用它，以继续在分区和表实体间移动。\r \r 在查询时，在查询对象实例和回调函数之间可能会提供继续标记参数：\r \r ```nodejs\r var nextContinuationToken = null;\r dc.table.queryEntities(tableName,\r     query,\r     nextContinuationToken,\r     function (error, results) {\r         if (error) throw error;\r \r         // iterate through results.entries with results\r \r         if (results.continuationToken) {\r             nextContinuationToken = results.continuationToken;\r         }\r \r     });\r ```\r \r 如果检查 `continuationToken` 对象，就会发现 `nextPartitionKey`、`nextRowKey` 和 `targetLocation` 等属性可用于循环访问所有结果。\r \r 在 GitHub 上的 Azure 存储 Node.js 存储库中还有一个继续样本。 查找 `examples/samples/continuationsample.js`。\r \r ## <a name=\"work-with-shared-access-signatures\"></a>使用共享访问签名\r 共享访问签名 (SAS) 是一种安全的方法，用于对表进行细致访问而无需提供存储帐户名或密钥。 通常使用 SAS 来提供对数据的有限访问权限，例如允许移动应用查询记录。\r \r 受信任的应用程序（例如基于云的服务）可使用 TableService 的 generateSharedAccessSignature 生成 SAS，然后将其提供给不受信任的或不完全受信任的应用程序，例如移动应用。 可使用策略生成 SAS，该策略描述了 SAS 的生效日期和失效日期，以及授予 SAS 持有者的访问级别。\r \r 下面的示例会生成一个新的共享访问策略，该策略将允许 SAS 持有者查询 ('r') 表，并在创建后 100 分钟过期。\r \r ```nodejs\r var startDate = new Date();\r var expiryDate = new Date(startDate);\r expiryDate.setMinutes(startDate.getMinutes() + 100);\r startDate.setMinutes(startDate.getMinutes() - 100);\r \r var sharedAccessPolicy = {\r   AccessPolicy: {\r     Permissions: azure.TableUtilities.SharedAccessPermissions.QUERY,\r     Start: startDate,\r     Expiry: expiryDate\r   },\r };\r \r var tableSAS = tableSvc.generateSharedAccessSignature('mytable', sharedAccessPolicy);\r var host = tableSvc.host;\r ```\r \r 请注意，还必须提供主机信息，因为 SAS 持有者尝试访问表时，必须提供该信息。\r \r 然后，客户端应用程序将 SAS 用于 **TableServiceWithSAS**，以便针对表执行操作。 下面的示例连接到该表，并执行一个查询。\r \r ```nodejs\r var sharedTableService = azure.createTableServiceWithSas(host, tableSAS);\r var query = azure.TableQuery()\r   .where('PartitionKey eq ?', 'hometasks');\r \r sharedTableService.queryEntities(query, null, function(error, result, response) {\r   if(!error) {\r     // result contains the entities\r   }\r });\r ```\r \r 由于 SAS 在生成时只具有查询访问权限，因此如果尝试插入、更新或删除实体，则会返回错误。\r \r ### <a name=\"access-control-lists\"></a>访问控制列表\r 还可以使用访问控制列表 (ACL) 为 SAS 设置访问策略。 如果希望允许多个客户端访问某个表，但为每个客户端提供了不同的访问策略，则访问控制列表会很有用。\r \r ACL 是使用一组访问策略实施的，每个策略都有一个关联的 ID。 以下示例定义了两个策略，一个用于“user1”，一个用于“user2”：\r \r ```nodejs\r var sharedAccessPolicy = {\r   user1: {\r     Permissions: azure.TableUtilities.SharedAccessPermissions.QUERY,\r     Start: startDate,\r     Expiry: expiryDate\r   },\r   user2: {\r     Permissions: azure.TableUtilities.SharedAccessPermissions.ADD,\r     Start: startDate,\r     Expiry: expiryDate\r   }\r };\r ```\r \r 下面的示例获取 hometasks 表的当前 ACL，然后使用 setTableAcl 添加新策略。 此方法具有以下用途：\r \r ```nodejs\r var extend = require('extend');\r tableSvc.getTableAcl('hometasks', function(error, result, response) {\r if(!error){\r     var newSignedIdentifiers = extend(true, result.signedIdentifiers, sharedAccessPolicy);\r     tableSvc.setTableAcl('hometasks', newSignedIdentifiers, function(error, result, response){\r       if(!error){\r         // ACL set\r       }\r     });\r   }\r });\r ```\r \r 设置 ACL 后，可以根据某个策略的 ID 创建 SAS。 以下示例为“user2”创建新的 SAS：\r \r ```nodejs\r tableSAS = tableSvc.generateSharedAccessSignature('hometasks', { Id: 'user2' });\r ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r 有关详细信息，请参阅以下资源。\r \r * [Azure 存储资源管理器](../vs-azure-tools-storage-manage-with-storage-explorer.md)是我们免费提供的独立应用，适用于在 Windows、macOS 和 Linux 上以可视方式处理 Azure 存储数据。\r * GitHub 上的[用于 Node 的 Microsoft Azure 存储 SDK](https://github.com/Azure/azure-storage-node) 存储库。\r * [Node.js 开发人员中心](/develop/nodejs/)\r * [创建 Node.js 应用程序并将其部署到 Azure 网站](../app-service/app-service-web-get-started-nodejs.md)\r \r <!--Update_Description: update meta properties，update link, wording update -->"}