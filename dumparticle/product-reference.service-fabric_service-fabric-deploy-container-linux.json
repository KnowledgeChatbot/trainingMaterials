{"Title":"Service Fabric 和在 Linux 中部署容器","Description":"介绍 Service Fabric，以及如何使用 Linux 容器部署微服务应用程序。 本文介绍 Service Fabric 为容器提供的功能，以及如何在群集中部署 Linux 容器映像","Content":"# <a name=\"deploy-a-linux-container-to-service-fabric\"></a>将 Linux 容器部署到 Service Fabric\r > [!div class=\"op_single_selector\"]\r <!-- Not Available > * [Deploy Windows Container](service-fabric-deploy-container.md)-->\r > * [部署 Linux 容器](service-fabric-deploy-container-linux.md)\r >\r >\r \r 本文介绍在 Linux 上的 Docker 容器中构建容器化服务的步骤。\r \r Service Fabric 提供多种容器功能，可帮助构建由容器化的微服务组成的应用程序。 这些服务称为容器化服务。\r \r 功能包括：\r \r * 容器映像部署和激活\r * 资源调控\r * 存储库身份验证\r * 容器端口到主机端口的映射\r * 容器到容器的发现和通信\r * 能够配置和设置环境变量\r \r ## <a name=\"packaging-a-docker-container-with-yeoman\"></a>使用 yeoman 打包 docker 容器\r 在 Linux 上打包容器时，可以选择使用 yeoman 模板，或者 [手动创建应用程序包](#manually)。\r \r Service Fabric 应用程序可以包含一个或多个容器，每个容器都在提供应用程序功能时具有特定角色。 用于 Linux 的 Service Fabric SDK 包括 [Yeoman](http://yeoman.io/) 生成器，利用它可以轻松地创建第一个服务应用程序和添加容器映像。 让我们使用 Yeoman 创建具有单个 Docker 容器（名为 *SimpleContainerApp*）的应用程序。 稍后，可以通过编辑生成的清单文件添加更多服务。\r \r ## <a name=\"install-docker-on-your-development-box\"></a>在开发环境中安装 Docker\r \r 运行以下命令以在 Linux 开发环境中安装 docker（如果是在 OSX 上使用 vagrant 映像，则已安装 docker）：\r \r ```bash\r     sudo apt-get install wget\r     wget -qO- https://get.docker.io/ | sh\r ```\r \r ## <a name=\"create-the-application\"></a>创建应用程序\r 1. 在终端中，键入 `yo azuresfcontainer`。\r 2. 为应用程序命名，例如 mycontainerap\r 3. 从 DockerHub 存储库提供容器映像的 URL。 此映像参数采用的格式为 [repo]/[image name]\r 4. 如果映像没有定义工作负荷入口点，则需要显式指定输入命令以及要在容器内运行的一组以逗号分隔的命令，这些命令将使容器在启动后保持运行。\r \r ![适用于容器的 Service Fabric Yeoman 生成器][sf-yeoman]\r \r ## <a name=\"deploy-the-application\"></a>部署应用程序\r \r ### <a name=\"using-xplat-cli\"></a>使用 XPlat CLI\r 生成应用程序后，可以使用 Azure CLI 将其部署到本地群集。\r \r 1. 连接到本地 Service Fabric 群集。\r \r     ```bash\r     azure servicefabric cluster connect\r     ```\r \r 2. 使用模板中提供的安装脚本，将应用程序包复制到群集的映像存储、注册应用程序类型，并创建应用程序的实例。\r \r     ```bash\r     ./install.sh\r     ```\r \r 3. 打开浏览器并导航到 http://localhost:19080/Explorer 的 Service Fabric Explorer（如果在 Mac OS X 上使用 Vagrant，则使用 VM 的专用 IP 替换 localhost）。\r 4. 展开应用程序节点，注意现在有一个条目是用于应用程序类型，另一个条目用于该类型的第一个实例。\r 5. 使用模板中提供的卸载脚本删除应用程序实例并取消注册应用程序类型。\r \r     ```bash\r     ./uninstall.sh\r     ```\r \r ### <a name=\"using-azure-cli-20\"></a>使用 Azure CLI 2.0\r \r 请参阅[使用 Azure CLI 2.0 管理应用程序生命周期](service-fabric-application-lifecycle-azure-cli-2-0.md)的参考文档。\r \r 有关示例应用程序，请[查看 GitHub 上的 Service Fabric 容器代码示例](https://github.com/Azure-Samples/service-fabric-dotnet-containers)\r \r ## <a name=\"adding-more-services-to-an-existing-application\"></a>将更多服务添加到现有应用程序\r \r 要将另一个容器服务添加到已使用 `yo` 创建的应用程序，请执行以下步骤：\r \r 1. 将目录更改为现有应用程序的根目录。  例如 `cd ~/YeomanSamples/MyApplication`（如果 `MyApplication` 是 Yeoman 创建的应用程序）。\r 2. 运行 `yo azuresfcontainer:AddService`\r \r <a name=\"manually\"></a>\r \r ## <a name=\"manually-package-and-deploy-a-container-image\"></a>手动打包和部署容器映像\r 手动打包容器化服务的过程基于以下步骤进行：\r \r 1. 将容器发布到存储库。\r 2. 创建包目录结构。\r 3. 编辑服务清单文件。\r 4. 编辑应用程序清单文件。\r \r ## <a name=\"deploy-and-activate-a-container-image\"></a>部署和激活容器映像\r 在 Service Fabric [应用程序模型](service-fabric-application-model.md)中，容器表示放置多个服务副本的应用程序主机。 若要部署和激活某个容器，请在服务清单的 `ContainerHost` 元素中输入容器映像的名称。\r \r 在服务清单中，为入口点添加 `ContainerHost` 。 然后将 `ImageName` 设置为容器存储库和映像的名称。 下面的不完整清单演示如何从名为 `myrepo` 的存储库部署名为 `myimage:v1` 的容器：\r \r ```xml\r     <CodePackage Name=\"Code\" Version=\"1.0\">\r         <EntryPoint>\r           <ContainerHost>\r             <ImageName>myrepo/myimage:v1</ImageName>\r             <Commands></Commands>\r           </ContainerHost>\r         </EntryPoint>\r     </CodePackage>\r ```\r \r 可以指定含有逗号分隔命令集的可选 `Commands` 元素在容器内部运行，来提供输入命令。\r \r > [!NOTE]\r > 如果映像没有定义工作负荷入口点，则需要在 `Commands` 元素内显式指定输入命令，以及要在容器内运行的一组以逗号分隔的命令，这些命令将使容器在启动后保持运行。\r \r ## <a name=\"understand-resource-governance\"></a>了解资源调控\r 资源调控是一项容器功能，限制容器可在主机上使用的资源。 在应用程序清单中指定的 `ResourceGovernancePolicy`可用于声明服务代码包的资源限制。 可以为以下资源设置资源限制：\r \r * 内存\r * MemorySwap\r * CpuShares（CPU 相对权重）\r * MemoryReservationInMB  \r * BlkioWeight（BlockIO 相对权重）\r \r > [!NOTE]\r > 在以后版本中，将包含对指定特定块 IO 限制（例如 IOPs、读/写 BPS 等）的支持。\r >\r >\r \r ```xml\r     <ServiceManifestImport>\r         <ServiceManifestRef ServiceManifestName=\"FrontendServicePackage\" ServiceManifestVersion=\"1.0\"/>\r         <Policies>\r             <ResourceGovernancePolicy CodePackageRef=\"FrontendService.Code\" CpuShares=\"500\"\r             MemoryInMB=\"1024\" MemorySwapInMB=\"4084\" MemoryReservationInMB=\"1024\" />\r         </Policies>\r     </ServiceManifestImport>\r ```\r \r ## <a name=\"authenticate-a-repository\"></a>对存储库进行身份验证\r 若要下载容器，可能必须向容器存储库提供登录凭据。 应用程序清单中指定的登录凭据用于指定从映像存储库下载容器映像所需的登录信息或 SSH 密钥。 以下示例显示名为 *TestUser* 的帐户以及明文密码（*不*建议使用）：\r \r ```xml\r     <ServiceManifestImport>\r         <ServiceManifestRef ServiceManifestName=\"FrontendServicePackage\" ServiceManifestVersion=\"1.0\"/>\r         <Policies>\r             <ContainerHostPolicies CodePackageRef=\"FrontendService.Code\">\r                 <RepositoryCredentials AccountName=\"TestUser\" Password=\"12345\" PasswordEncrypted=\"false\"/>\r             </ContainerHostPolicies>\r         </Policies>\r     </ServiceManifestImport>\r ```\r \r 建议使用已部署到计算机的证书加密密码。\r \r 以下示例显示名为 *TestUser* 的帐户，其密码已使用名为 *MyCert* 的证书加密。 可以使用 `Invoke-ServiceFabricEncryptText` PowerShell 命令创建密码的机密加密文本。 有关详细信息，请参阅文章[管理 Service Fabric 应用程序中的密钥](service-fabric-application-secret-management.md)。\r \r 用于解密密码的证书私钥必须使用带外方法部署到本地计算机。 （在 Azure 中，此方法为 Azure Resource Manager。）然后，当 Service Fabric 将服务包部署到计算机时，可解密机密。 通过使用密钥和帐户名称，它可以对容器存储库进行身份验证。\r \r ```xml\r     <ServiceManifestImport>\r         <ServiceManifestRef ServiceManifestName=\"FrontendServicePackage\" ServiceManifestVersion=\"1.0\"/>\r         <Policies>\r             <ContainerHostPolicies CodePackageRef=\"FrontendService.Code\">\r                 <RepositoryCredentials AccountName=\"TestUser\" Password=\"[Put encrypted password here using MyCert certificate ]\" PasswordEncrypted=\"true\"/>\r             </ContainerHostPolicies>\r         </Policies>\r     </ServiceManifestImport>\r ```\r \r ## <a name=\"configure-container-port-to-host-port-mapping\"></a>配置容器端口到主机端口的映射\r 可以在应用程序清单中指定 `PortBinding` ，配置用来与容器通信的主机端口。 端口绑定将服务在容器内侦听的端口映射到主机上的端口。\r \r ```xml\r     <ServiceManifestImport>\r         <ServiceManifestRef ServiceManifestName=\"FrontendServicePackage\" ServiceManifestVersion=\"1.0\"/>\r         <Policies>\r             <ContainerHostPolicies CodePackageRef=\"FrontendService.Code\">\r                 <PortBinding ContainerPort=\"8905\"/>\r             </ContainerHostPolicies>\r         </Policies>\r     </ServiceManifestImport>\r ```\r \r ## <a name=\"configure-container-to-container-discovery-and-communication\"></a>配置容器到容器的发现和通信\r 通过使用 `PortBinding` 策略，可以将容器端口映射到服务清单中的 `Endpoint`。 终结点 `Endpoint1` 可以指定固定端口（例如端口 80）。 也可不指定任何端口，在此情况下，将从群集的应用程序端口范围内选择一个随机端口。\r \r 如果使用来宾容器的服务清单中的 `Endpoint` 标记指定终结点，Service Fabric 可以自动将此终结点发布到命名服务。 因此，在群集中运行的其他服务可以通过用于解析的 REST 查询来发现此容器。\r \r ```xml\r     <ServiceManifestImport>\r         <ServiceManifestRef ServiceManifestName=\"FrontendServicePackage\" ServiceManifestVersion=\"1.0\"/>\r         <Policies>\r             <ContainerHostPolicies CodePackageRef=\"FrontendService.Code\">\r                 <PortBinding ContainerPort=\"8905\" EndpointRef=\"Endpoint1\"/>\r             </ContainerHostPolicies>\r         </Policies>\r     </ServiceManifestImport>\r ```\r \r 在命名服务中注册后，可以轻松地在容器中的代码内使用[反向代理](service-fabric-reverseproxy.md)来执行容器到容器的通信。 通过提供反向代理 http 侦听端口和要作为环境变量与其通信的服务的名称来执行通信。 有关详细信息，请参阅下一部分。\r \r ## <a name=\"configure-and-set-environment-variables\"></a>配置和设置环境变量\r 对于部署在容器中的服务，或者部署为进程/来宾可执行文件的服务，可以在服务清单中为每个代码包指定环境变量。 这些环境变量的值可以在应用程序清单中明确重写，也可在部署期间以应用程序参数的形式指定。\r \r 以下服务清单 XML 代码片段演示如何指定代码包的环境变量：\r \r ```xml\r     <ServiceManifest Name=\"FrontendServicePackage\" Version=\"1.0\" xmlns=\"http://schemas.microsoft.com/2011/01/fabric\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\r         <Description>a guest executable service in a container</Description>\r         <ServiceTypes>\r             <StatelessServiceType ServiceTypeName=\"StatelessFrontendService\"  UseImplicitHost=\"true\"/>\r         </ServiceTypes>\r         <CodePackage Name=\"FrontendService.Code\" Version=\"1.0\">\r             <EntryPoint>\r             <ContainerHost>\r                 <ImageName>myrepo/myimage:v1</ImageName>\r                 <Commands></Commands>\r             </ContainerHost>\r             </EntryPoint>\r             <EnvironmentVariables>\r                 <EnvironmentVariable Name=\"HttpGatewayPort\" Value=\"\"/>\r                 <EnvironmentVariable Name=\"BackendServiceName\" Value=\"\"/>\r             </EnvironmentVariables>\r         </CodePackage>\r     </ServiceManifest>\r ```\r \r 可在应用程序清单级别重写这些环境变量：\r \r ```xml\r     <ServiceManifestImport>\r         <ServiceManifestRef ServiceManifestName=\"FrontendServicePackage\" ServiceManifestVersion=\"1.0\"/>\r         <EnvironmentOverrides CodePackageRef=\"FrontendService.Code\">\r             <EnvironmentVariable Name=\"BackendServiceName\" Value=\"[BackendSvc]\"/>\r             <EnvironmentVariable Name=\"HttpGatewayPort\" Value=\"19080\"/>\r         </EnvironmentOverrides>\r     </ServiceManifestImport>\r ```\r \r 在前面示例中，我们为 `HttpGateway` 环境变量指定了显式值 (19000)，`BackendServiceName` 参数的值是通过 `[BackendSvc]` 应用程序参数设置的。 通过这些设置可以在部署应用程序时指定 `BackendServiceName` 的值，而无需在清单中使用固定值。\r \r ## <a name=\"complete-examples-for-application-and-service-manifest\"></a>应用程序清单和服务清单的完整示例\r \r 下面是应用程序清单示例：\r \r ```xml\r     <ApplicationManifest ApplicationTypeName=\"SimpleContainerApp\" ApplicationTypeVersion=\"1.0\" xmlns=\"http://schemas.microsoft.com/2011/01/fabric\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\r         <Description>A simple service container application</Description>\r         <Parameters>\r             <Parameter Name=\"ServiceInstanceCount\" DefaultValue=\"3\"></Parameter>\r             <Parameter Name=\"BackEndSvcName\" DefaultValue=\"bkend\"></Parameter>\r         </Parameters>\r         <ServiceManifestImport>\r             <ServiceManifestRef ServiceManifestName=\"FrontendServicePackage\" ServiceManifestVersion=\"1.0\"/>\r             <EnvironmentOverrides CodePackageRef=\"FrontendService.Code\">\r                 <EnvironmentVariable Name=\"BackendServiceName\" Value=\"[BackendSvcName]\"/>\r                 <EnvironmentVariable Name=\"HttpGatewayPort\" Value=\"19080\"/>\r             </EnvironmentOverrides>\r             <Policies>\r                 <ResourceGovernancePolicy CodePackageRef=\"Code\" CpuShares=\"500\" MemoryInMB=\"1024\" MemorySwapInMB=\"4084\" MemoryReservationInMB=\"1024\" />\r                 <ContainerHostPolicies CodePackageRef=\"FrontendService.Code\">\r                     <RepositoryCredentials AccountName=\"username\" Password=\"****\" PasswordEncrypted=\"true\"/>\r                     <PortBinding ContainerPort=\"8905\" EndpointRef=\"Endpoint1\"/>\r                 </ContainerHostPolicies>\r             </Policies>\r         </ServiceManifestImport>\r     </ApplicationManifest>\r ```\r \r 下面是服务清单示例（在前面的应用程序清单中指定）：\r \r ```xml\r     <ServiceManifest Name=\"FrontendServicePackage\" Version=\"1.0\" xmlns=\"http://schemas.microsoft.com/2011/01/fabric\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\r         <Description> A service that implements a stateless front end in a container</Description>\r         <ServiceTypes>\r             <StatelessServiceType ServiceTypeName=\"StatelessFrontendService\"  UseImplicitHost=\"true\"/>\r         </ServiceTypes>\r         <CodePackage Name=\"FrontendService.Code\" Version=\"1.0\">\r             <EntryPoint>\r             <ContainerHost>\r                 <ImageName>myrepo/myimage:v1</ImageName>\r                 <Commands></Commands>\r             </ContainerHost>\r             </EntryPoint>\r             <EnvironmentVariables>\r                 <EnvironmentVariable Name=\"HttpGatewayPort\" Value=\"\"/>\r                 <EnvironmentVariable Name=\"BackendServiceName\" Value=\"\"/>\r             </EnvironmentVariables>\r         </CodePackage>\r         <ConfigPackage Name=\"FrontendService.Config\" Version=\"1.0\" />\r         <DataPackage Name=\"FrontendService.Data\" Version=\"1.0\" />\r         <Resources>\r             <Endpoints>\r                 <Endpoint Name=\"Endpoint1\" UriScheme=\"http\" Port=\"80\" Protocol=\"http\"/>\r             </Endpoints>\r         </Resources>\r     </ServiceManifest>\r ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r 现在已部署了容器化服务，请通过阅读 [Service Fabric 应用程序生命周期](service-fabric-application-lifecycle.md)了解如何管理其生命周期。\r \r * [Service Fabric 和容器概述](service-fabric-containers-overview.md)\r * [使用 Azure CLI 与 Service Fabric 群集交互](service-fabric-azure-cli.md)\r \r <!-- Images -->\r [sf-yeoman]: ./media/service-fabric-deploy-container-linux/sf-container-yeoman1.png\r \r ## <a name=\"related-articles\"></a>相关文章\r \r * [Service Fabric 和 Azure CLI 2.0 入门](service-fabric-azure-cli-2-0.md)\r * [Service Fabric XPlat CLI 入门](service-fabric-azure-cli.md)\r \r <!--Update_Description: update meta properties, add reference link, wording update -->"}