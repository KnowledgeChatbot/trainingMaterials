{"Title":"序列化 Hadoop 中的数据 - Microsoft Avro Library - Azure","Description":"了解如何使用 Microsoft Avro Library 将 Hadoop on HDInsight 中的数据串行化和反序列化，以将其保留在内存、数据库或文件中。","Content":"# <a name=\"serialize-data-in-hadoop-with-the-microsoft-avro-library\"></a>使用 Microsoft Avro Library 序列化 Hadoop 中的数据\r \r >[!NOTE]\r >Microsoft 不再支持 Avro SDK。 开源社区支持此库。 此库的源位于 [Github](https://github.com/Azure/azure-sdk-for-net/tree/master/src/ServiceManagement/HDInsight/Microsoft.Hadoop.Avro)。\r \r 本主题介绍如何使用 [Microsoft Avro Library](https://github.com/Azure/azure-sdk-for-net/tree/master/src/ServiceManagement/HDInsight/Microsoft.Hadoop.Avro) 将对象及其他数据结构串行化为流，以将其保留在内存、数据库或文件中。 它还演示如何对这些流进行反序列化以恢复原始对象。\r \r [!INCLUDE [windows-only](../../../includes/hdinsight-windows-only.md)]\r \r ## <a name=\"apache-avro\"></a>Apache Avro\r <a href=\"https://hadoopsdk.codeplex.com/wikipage?title=Avro%20Library\" target=\"_blank\">Microsoft Avro Library</a> 针对 Microsoft.NET 环境实现了 Apache Avro 数据序列化系统。 Apache Avro 为序列化提供了一种紧凑的二进制数据交换格式。 它使用 <a href=\"http://www.json.org\" target=\"_blank\">JSON</a> 定义与语言无关的架构，以支持语言互操作性。 以一种语言序列化的数据可以用另一种语言读取。 目前支持 C、C++、C#、Java、PHP、Python 和 Ruby。 有关格式的详细信息可以在 <a href=\"http://avro.apache.org/docs/current/spec.html\" target=\"_blank\">Apache Avro 规范</a>中找到。 \r \r >[!NOTE]\r >Microsoft Avro Library 不支持此规范的远程过程调用 (RPC) 部分。\r >\r \r Avro 系统中的对象的序列化表示形式由两部分组成：架构和实际值。 Avro 架构使用 JSON 描述已序列化数据的与语言无关的数据模型。 它与数据的二进制表示形式并排显示。 将架构与二进制表示形式分离，使写入每个对象时没有针对值的开销，从而实现快速序列化和较小的表示形式。\r \r ## <a name=\"the-hadoop-scenario\"></a>Hadoop 应用场景\r Apache Avro 序列化格式广泛应用于 Azure HDInsight 及其他 Apache Hadoop 环境中。 Avro 提供了简便的方法来表示 Hadoop MapReduce 作业内的复杂数据结构。 Avro 文件（Avro 对象容器文件）格式已设计为支持分布式 MapReduce 编程模型。 实现分布的关键功能是文件是“可拆分的”，也就是说，用户可以在文件中搜寻任一点，然后即可从某一特定块开始读取。\r \r ## <a name=\"serialization-in-avro-library\"></a>Avro Library 中的序列化\r .NET Library for Avro 支持通过两种方式序列化对象：\r \r * **反射** - 自动从要序列化的 .NET 类型的数据协定特性生成这些类型的 JSON 架构。\r * 通用记录 - 没有 .NET 类型可以用来描述要序列化的数据的架构时，系统会在以 [AvroRecord](http://msdn.microsoft.com/library/microsoft.hadoop.avro.avrorecord.aspx) 类表示的记录中显式指定 JSON 架构。\r \r 当流的写入器和读取器都知道数据架构时，可以发送没有架构的数据。 在未使用 Avro 对象容器文件的情况下，架构将存储在文件中。 可以指定其他参数，例如用于数据压缩的编解码器。 这些情况会在以下代码示例中进一步详述和说明：\r \r ## <a name=\"install-avro-library\"></a>安装 Avro Library\r 以下是安装此库之前所需具备的先决条件：\r \r * <a href=\"http://www.microsoft.com/download/details.aspx?id=17851\" target=\"_blank\">Microsoft .NET Framework 4</a>\r * <a href=\"http://james.newtonking.com/json\" target=\"_blank\">Newtonsoft Json.NET</a>（6.0.4 或更高版本）\r \r 请注意，Newtonsoft.Json.dll 依赖项已随着 Microsoft Avro Library 的安装自动下载。 下一部分将提供相关过程：\r \r Microsoft Avro Library 以 NuGet 包发行，可以使用以下过程在 Visual Studio 中安装 NuGet 程序包：\r \r 1. 选择“项目”选项卡 ->“管理 NuGet 包...”\r 2. 在“联机搜索”框中，搜索“Microsoft.Hadoop.Avro”  。\r 3. 单击“Azure HDInsight Avro Library”旁边的“安装”按钮。\r \r 请注意，Newtonsoft.Json.dll (>= 6.0.4) 依赖项也将随 Microsoft Avro Library 一起自动下载。\r \r [Github](https://github.com/Azure/azure-sdk-for-net/tree/master/src/ServiceManagement/HDInsight/Microsoft.Hadoop.Avro) 中提供了 Microsoft Avro Library 源代码。\r \r ## <a name=\"compile-schemas-using-avro-library\"></a>使用 Avro Library 编译架构\r Microsoft Avro Library 包含代码生成实用工具，可让你自动根据先前定义的 JSON 架构来创建 C# 类型。 代码生成实用工具不是以二进制可执行文件的形式分发的，但你可使用以下过程轻松生成：\r \r 1. 从 <a href=\"http://hadoopsdk.codeplex.com/SourceControl/latest#\" target=\"_blank\">Microsoft .NET SDK For Hadoop</a> 下载包含最新版 HDInsight SDK 源代码的 ZIP 文件。 （单击“下载”图标，而不是“下载”选项卡。）\r 2. 将 HDInsight SDK 解压缩到已安装 .NET Framework 4.0 并连接到 Internet 的计算机上的目录，以下载必要的依赖项 NuGet 包。 下面我们假设源代码已解压缩到 C:\\SDK。\r 3. 转到文件夹 C:\\SDK\\src\\Microsoft.Hadoop.Avro.Tools 并运行 build.bat。 （此文件将从 .NET Framework 的 32 位分发版调用 MSBuild。 如果你想要使用 64 位版本，请编辑 build.bat 文件注释后的列。）确保生成成功。 （在某些系统上，MSBuild 可能生成警告。 只要没有生成错误，这些警告就不影响实用工具。）\r 4. 编译的实用工具位于 C:\\SDK\\Bin\\Unsigned\\Release\\Microsoft.Hadoop.Avro.Tools 中。\r \r 若要熟悉命令行语法，请从代码生成实用工具所在的文件夹运行以下命令： `Microsoft.Hadoop.Avro.Tools help /c:codegen`\r \r 若要测试实用工具，你可以从随着源代码提供的示例 JSON 架构文件生成 C# 类。 运行以下命令：\r \r     Microsoft.Hadoop.Avro.Tools codegen /i:C:\\SDK\\src\\Microsoft.Hadoop.Avro.Tools\\SampleJSON\\SampleJSONSchema.avsc /o:\r \r 这应该在当前目录中生成两个 C# 文件：SensorData.cs 和 Location.cs。\r \r 若要了解代码生成实用工具在转换 JSON 架构为 C# 类型时使用的逻辑，请参阅 C:\\SDK\\src\\Microsoft.Hadoop.Avro.Tools\\Doc 中的 GenerationVerification.feature 文件。\r \r 命名空间是使用上一个段落中提及的文件中所描述的逻辑，从 JSON 架构中提取的。 从架构提取的命名空间，将比实用工具命令行中使用 /n 参数提供的设置具有优先权。 如果想要重写架构中包含的命名空间，请确保使用 /nf 参数。 例如，要将所有命名空间从 SampleJSONSchema.avsc 更改为 my.own.nspace，请运行以下命令：\r \r     Microsoft.Hadoop.Avro.Tools codegen /i:C:\\SDK\\src\\Microsoft.Hadoop.Avro.Tools\\SampleJSON\\SampleJSONSchema.avsc /o:. /nf:my.own.nspace\r \r ## <a name=\"about-the-samples\"></a>关于示例\r 本主题中提供的六个示例演示了 Microsoft Avro Library 所支持的不同方案。 Microsoft Avro Library 设计为可处理任何流。 在这些示例中，为保持简单性和一致性，是使用内存流（而不是文件流或数据库）来操作数据的。 在生产环境中所采取的方法将取决于实际的方案要求、数据源和卷、性能约束及其他因素。\r \r 前两个示例显示如何使用反射和通用记录将数据序列化到内存流缓冲区，以及如何进行反序列化。 这两个方案假设在读取器和写入器之间共享架构。\r \r 第三和第四个示例说明如何使用 Avro 对象容器文件，将数据序列化与反序列化。 当数据存储在 Avro 容器文件中时，其架构始终随之一起存储，因为必须共享架构才能进行反序列化。\r \r 包含前四个示例的样例可以从 <a href=\"http://code.msdn.microsoft.com/Serialize-data-with-the-86055923\" target=\"_blank\">Azure 代码示例</a>站点下载。\r \r 第五个示例演示如何将自定义压缩编解码器用于 Avro 对象容器文件。 包含此示例代码的样例可以从 <a href=\"http://code.msdn.microsoft.com/Serialize-data-with-the-67159111\" target=\"_blank\">Azure 代码示例</a>站点下载。\r \r 第六个示例显示如何使用 Avro 序列化来上传数据到 Azure Blob 存储，然后使用具有 HDInsight (Hadoop) 群集的 Hive 加以分析。 可以从 <a href=\"https://code.msdn.microsoft.com/Using-Avro-to-upload-data-ae81b1e3\" target=\"_blank\">Azure 代码示例</a>站点下载该示例。\r \r 本主题所讨论六个示例的链接如下：\r \r * <a href=\"#Scenario1\">通过反射进行序列化</a> - 自动从数据协定特性生成要序列化的类型的 JSON 架构。\r * <a href=\"#Scenario2\">通过通用记录进行序列化</a> - 当没有可用于反射的 .NET 类型时，在记录中显式指定 JSON 架构。\r * <a href=\"#Scenario3\">使用对象容器文件与反射进行序列化</a> - JSON 架构自动生成并使用 Avro 对象容器文件随着序列化的数据共享。\r * <a href=\"#Scenario4\">使用对象容器文件与通用记录进行序列化</a> - JSON 架构是在序列化前显式指定的，并使用 Avro 对象容器文件随着序列化的数据共享。\r * <a href=\"#Scenario5\">使用对象容器文件和自定义压缩编解码器进行序列化</a> - 该示例演示如何使用 Deflate 数据压缩编解码器的自定义 .NET 实现，来创建 Avro 对象容器文件。\r * <a href=\"#Scenario6\">使用 Avro 来上传 Azure HDInsight 服务的数据</a> - 该示例演示 Avro 序列化如何与 HDInsight 服务交互。 要运行此示例，必须具备有效的 Azure 订阅并且可以访问 Microsoft Azure HDInsight 群集。\r \r ## <a name=\"Scenario1\"></a>示例 1：通过反射进行序列化\r Microsoft Avro Library 可以使用反射从要序列化的 C# 对象的数据协定特性自动生成类型的 JSON 架构。 Microsoft Avro Library 将创建一个 [IAvroSeralizer<T>](http://msdn.microsoft.com/library/dn627341.aspx) 以标识要序列化的字段。\r \r 在此示例中，将对象（具有成员 Location 结构的 SensorData 类）序列化到内存流，继而又将此流反序列化。 然后，将结果与初始实例进行比较，以确认恢复的 SensorData 对象与原始对象相同。\r \r 此示例中的架构假定在读取器与写入器之间共享，因此无需采用 Avro 对象容器格式。 有关在架构必须与数据一起共享时，如何使用反射和对象容器格式将数据序列化到内存缓冲区，以及如何对内存缓冲区中的数据进行反序列化的示例，请参阅<a href=\"#Scenario3\">使用对象容器文件通过反射进行序列化</a>。\r \r     namespace Microsoft.Hadoop.Avro.Sample\r     {\r         using System;\r         using System.Collections.Generic;\r         using System.IO;\r         using System.Linq;\r         using System.Runtime.Serialization;\r         using Microsoft.Hadoop.Avro.Container;\r         using Microsoft.Hadoop.Avro;\r \r         //Sample class used in serialization samples\r         [DataContract(Name = \"SensorDataValue\", Namespace = \"Sensors\")]\r         internal class SensorData\r         {\r             [DataMember(Name = \"Location\")]\r             public Location Position { get; set; }\r \r             [DataMember(Name = \"Value\")]\r             public byte[] Value { get; set; }\r         }\r \r         //Sample struct used in serialization samples\r         [DataContract]\r         internal struct Location\r         {\r             [DataMember]\r             public int Floor { get; set; }\r \r             [DataMember]\r             public int Room { get; set; }\r         }\r \r         //This class contains all methods demonstrating\r         //the usage of Microsoft Avro Library\r         public class AvroSample\r         {\r \r             //Serialize and deserialize sample data set represented as an object using reflection.\r             //No explicit schema definition is required - schema of serialized objects is automatically built.\r             public void SerializeDeserializeObjectUsingReflection()\r             {\r \r                 Console.WriteLine(\"SERIALIZATION USING REFLECTION\\n\");\r                 Console.WriteLine(\"Serializing Sample Data Set...\");\r \r                 //Create a new AvroSerializer instance and specify a custom serialization strategy AvroDataContractResolver\r                 //for serializing only properties attributed with DataContract/DateMember\r                 var avroSerializer = AvroSerializer.Create<SensorData>();\r \r                 //Create a memory stream buffer\r                 using (var buffer = new MemoryStream())\r                 {\r                     //Create a data set by using sample class and struct\r                     var expected = new SensorData { Value = new byte[] { 1, 2, 3, 4, 5 }, Position = new Location { Room = 243, Floor = 1 } };\r \r                     //Serialize the data to the specified stream\r                     avroSerializer.Serialize(buffer, expected);\r \r                     Console.WriteLine(\"Deserializing Sample Data Set...\");\r \r                     //Prepare the stream for deserializing the data\r                     buffer.Seek(0, SeekOrigin.Begin);\r \r                     //Deserialize data from the stream and cast it to the same type used for serialization\r                     var actual = avroSerializer.Deserialize(buffer);\r \r                     Console.WriteLine(\"Comparing Initial and Deserialized Data Sets...\");\r \r                     //Finally, verify that deserialized data matches the original one\r                     bool isEqual = this.Equal(expected, actual);\r \r                     Console.WriteLine(\"Result of Data Set Identity Comparison is {0}\", isEqual);\r \r                 }\r             }\r \r             //\r             //Helper methods\r             //\r \r             //Comparing two SensorData objects\r             private bool Equal(SensorData left, SensorData right)\r             {\r                 return left.Position.Equals(right.Position) && left.Value.SequenceEqual(right.Value);\r             }\r \r             static void Main()\r             {\r \r                 string sectionDivider = \"---------------------------------------- \";\r \r                 //Create an instance of AvroSample Class and invoke methods\r                 //illustrating different serializing approaches\r                 AvroSample Sample = new AvroSample();\r \r                 //Serialization to memory using reflection\r                 Sample.SerializeDeserializeObjectUsingReflection();\r \r                 Console.WriteLine(sectionDivider);\r                 Console.WriteLine(\"Press any key to exit.\");\r                 Console.Read();\r             }\r         }\r     }\r     // The example is expected to display the following output:\r     // SERIALIZATION USING REFLECTION\r     //\r     // Serializing Sample Data Set...\r     // Deserializing Sample Data Set...\r     // Comparing Initial and Deserialized Data Sets...\r     // Result of Data Set Identity Comparison is True\r     // ----------------------------------------\r     // Press any key to exit.\r \r ## <a name=\"sample-2-serialization-with-a-generic-record\"></a>示例 2：通过通用记录进行序列化\r 当数据无法使用具有数据协定的 .NET 类表示而导致不能使用反射时，可以在通用记录中显式指定 JSON 架构。 此方法比使用反射要慢。 在这种情况下，数据架构也可能是动态的，即在编译时是未知的。 以逗号分隔值 (CSV) 文件表示的数据（在运行时转换为 Avro 格式之前，其架构一直是未知的）是这种动态方案的一个示例。\r \r 此示例演示如何创建 [AvroRecord](http://msdn.microsoft.com/library/microsoft.hadoop.avro.avrorecord.aspx) 并使用它显式指定 JSON 架构，如何为其填充数据，然后对其进行序列化和反序列化。 然后，将结果与初始实例进行比较，以确认恢复的记录与原始记录相同。\r \r 此示例中的架构假定在读取器与写入器之间共享，因此无需采用 Avro 对象容器格式。 有关在架构必须包含在已序列化的数据中时，如何使用通用记录和对象容器格式将数据序列化到内存缓冲区，以及对内存缓冲区中的数据进行反序列化的示例，请参阅<a href=\"#Scenario4\">使用对象容器文件通过通用记录进行序列化</a>示例。\r \r     namespace Microsoft.Hadoop.Avro.Sample\r     {\r     using System;\r     using System.Collections.Generic;\r     using System.IO;\r     using System.Linq;\r     using System.Runtime.Serialization;\r     using Microsoft.Hadoop.Avro.Container;\r     using Microsoft.Hadoop.Avro.Schema;\r     using Microsoft.Hadoop.Avro;\r \r     //This class contains all methods demonstrating\r     //the usage of Microsoft Avro Library\r     public class AvroSample\r     {\r \r         //Serialize and deserialize sample data set by using a generic record.\r         //A generic record is a special class with the schema explicitly defined in JSON.\r         //All serialized data should be mapped to the fields of the generic record,\r         //which in turn is then serialized.\r         public void SerializeDeserializeObjectUsingGenericRecords()\r         {\r             Console.WriteLine(\"SERIALIZATION USING GENERIC RECORD\\n\");\r             Console.WriteLine(\"Defining the Schema and creating Sample Data Set...\");\r \r             //Define the schema in JSON\r             const string Schema = @\"{\r                                 \"\"type\"\":\"\"record\"\",\r                                 \"\"name\"\":\"\"Microsoft.Hadoop.Avro.Specifications.SensorData\"\",\r                                 \"\"fields\"\":\r                                     [\r                                         {\r                                             \"\"name\"\":\"\"Location\"\",\r                                             \"\"type\"\":\r                                                 {\r                                                     \"\"type\"\":\"\"record\"\",\r                                                     \"\"name\"\":\"\"Microsoft.Hadoop.Avro.Specifications.Location\"\",\r                                                     \"\"fields\"\":\r                                                         [\r                                                             { \"\"name\"\":\"\"Floor\"\", \"\"type\"\":\"\"int\"\" },\r                                                             { \"\"name\"\":\"\"Room\"\", \"\"type\"\":\"\"int\"\" }\r                                                         ]\r                                                 }\r                                         },\r                                         { \"\"name\"\":\"\"Value\"\", \"\"type\"\":\"\"bytes\"\" }\r                                     ]\r                             }\";\r \r             //Create a generic serializer based on the schema\r             var serializer = AvroSerializer.CreateGeneric(Schema);\r             var rootSchema = serializer.WriterSchema as RecordSchema;\r \r             //Create a memory stream buffer\r             using (var stream = new MemoryStream())\r             {\r                 //Create a generic record to represent the data\r                 dynamic location = new AvroRecord(rootSchema.GetField(\"Location\").TypeSchema);\r                 location.Floor = 1;\r                 location.Room = 243;\r \r                 dynamic expected = new AvroRecord(serializer.WriterSchema);\r                 expected.Location = location;\r                 expected.Value = new byte[] { 1, 2, 3, 4, 5 };\r \r                 Console.WriteLine(\"Serializing Sample Data Set...\");\r \r                 //Serialize the data\r                 serializer.Serialize(stream, expected);\r \r                 stream.Seek(0, SeekOrigin.Begin);\r \r                 Console.WriteLine(\"Deserializing Sample Data Set...\");\r \r                 //Deserialize the data into a generic record\r                 dynamic actual = serializer.Deserialize(stream);\r \r                 Console.WriteLine(\"Comparing Initial and Deserialized Data Sets...\");\r \r                 //Finally, verify the results\r                 bool isEqual = expected.Location.Floor.Equals(actual.Location.Floor);\r                 isEqual = isEqual && expected.Location.Room.Equals(actual.Location.Room);\r                 isEqual = isEqual && ((byte[])expected.Value).SequenceEqual((byte[])actual.Value);\r                 Console.WriteLine(\"Result of Data Set Identity Comparison is {0}\", isEqual);\r             }\r         }\r \r         static void Main()\r         {\r \r             string sectionDivider = \"---------------------------------------- \";\r \r             //Create an instance of AvroSample class and invoke methods\r             //illustrating different serializing approaches\r             AvroSample Sample = new AvroSample();\r \r             //Serialization to memory using generic record\r             Sample.SerializeDeserializeObjectUsingGenericRecords();\r \r             Console.WriteLine(sectionDivider);\r             Console.WriteLine(\"Press any key to exit.\");\r             Console.Read();\r         }\r     }\r     }\r     // The example is expected to display the following output:\r     // SERIALIZATION USING GENERIC RECORD\r     //\r     // Defining the Schema and creating Sample Data Set...\r     // Serializing Sample Data Set...\r     // Deserializing Sample Data Set...\r     // Comparing Initial and Deserialized Data Sets...\r     // Result of Data Set Identity Comparison is True\r     // ----------------------------------------\r     // Press any key to exit.\r \r ## <a name=\"sample-3-serialization-using-object-container-files-and-serialization-with-reflection\"></a>示例 3：使用对象容器文件进行序列化与使用反射进行序列化\r 此示例与<a href=\"#Scenario1\">第一个示例</a>中使用反射隐式指定架构的方案类似。 除了本示例假设要将架构反序列化的读取器不知道架构以外。 要序列化的 SensorData 对象及其隐式指定的架构存储在由 [AvroContainer](http://msdn.microsoft.com/library/microsoft.hadoop.avro.container.avrocontainer.aspx) 类表示的 Avro 对象容器文件中。\r \r 在此示例中，数据使用 [SequentialWriter<SensorData>](http://msdn.microsoft.com/library/dn627340.aspx) 进行序列化，使用 [SequentialReader<SensorData>](http://msdn.microsoft.com/library/dn627340.aspx) 进行反序列化。 然后，将结果与初始实例比较，以确保相同。\r \r 对象容器文件中的数据是通过 .NET Framework 4 中的默认 [**Deflate**][deflate-100] 压缩编解码器压缩的。 请参阅本主题中的<a href=\"#Scenario5\">第五个示例</a>，了解如何使用 .NET Framework 4.5 中提供的更新的 [Deflate][deflate-110] 压缩编解码器高级版。\r \r     namespace Microsoft.Hadoop.Avro.Sample\r     {\r         using System;\r         using System.Collections.Generic;\r         using System.IO;\r         using System.Linq;\r         using System.Runtime.Serialization;\r         using Microsoft.Hadoop.Avro.Container;\r         using Microsoft.Hadoop.Avro;\r \r         //Sample class used in serialization samples\r         [DataContract(Name = \"SensorDataValue\", Namespace = \"Sensors\")]\r         internal class SensorData\r         {\r             [DataMember(Name = \"Location\")]\r             public Location Position { get; set; }\r \r             [DataMember(Name = \"Value\")]\r             public byte[] Value { get; set; }\r         }\r \r         //Sample struct used in serialization samples\r         [DataContract]\r         internal struct Location\r         {\r             [DataMember]\r             public int Floor { get; set; }\r \r             [DataMember]\r             public int Room { get; set; }\r         }\r \r         //This class contains all methods demonstrating\r         //the usage of Microsoft Avro Library\r         public class AvroSample\r         {\r \r             //Serializes and deserializes the sample data set by using reflection and Avro object container files.\r             //Serialized data is compressed with the Deflate codec.\r             public void SerializeDeserializeUsingObjectContainersReflection()\r             {\r \r                 Console.WriteLine(\"SERIALIZATION USING REFLECTION AND AVRO OBJECT CONTAINER FILES\\n\");\r \r                 //Path for Avro object container file\r                 string path = \"AvroSampleReflectionDeflate.avro\";\r \r                 //Create a data set by using sample class and struct\r                 var testData = new List<SensorData>\r                         {\r                             new SensorData { Value = new byte[] { 1, 2, 3, 4, 5 }, Position = new Location { Room = 243, Floor = 1 } },\r                             new SensorData { Value = new byte[] { 6, 7, 8, 9 }, Position = new Location { Room = 244, Floor = 1 } }\r                         };\r \r                 //Serializing and saving data to file.\r                 //Creating a memory stream buffer.\r                 using (var buffer = new MemoryStream())\r                 {\r                     Console.WriteLine(\"Serializing Sample Data Set...\");\r \r                     //Create a SequentialWriter instance for type SensorData, which can serialize a sequence of SensorData objects to stream.\r                     //Data is compressed using the Deflate codec.\r                     using (var w = AvroContainer.CreateWriter<SensorData>(buffer, Codec.Deflate))\r                     {\r                         using (var writer = new SequentialWriter<SensorData>(w, 24))\r                         {\r                             // Serialize the data to stream by using the sequential writer\r                             testData.ForEach(writer.Write);\r                         }\r                     }\r \r                     //Save stream to file\r                     Console.WriteLine(\"Saving serialized data to file...\");\r                     if (!WriteFile(buffer, path))\r                     {\r                         Console.WriteLine(\"Error during file operation. Quitting method\");\r                         return;\r                     }\r                 }\r \r                 //Reading and deserializing data.\r                 //Creating a memory stream buffer.\r                 using (var buffer = new MemoryStream())\r                 {\r                     Console.WriteLine(\"Reading data from file...\");\r \r                     //Reading data from object container file\r                     if (!ReadFile(buffer, path))\r                     {\r                         Console.WriteLine(\"Error during file operation. Quitting method\");\r                         return;\r                     }\r \r                     Console.WriteLine(\"Deserializing Sample Data Set...\");\r \r                     //Prepare the stream for deserializing the data\r                     buffer.Seek(0, SeekOrigin.Begin);\r \r                     //Create a SequentialReader instance for type SensorData, which deserializes all serialized objects from the given stream.\r                     //It allows iterating over the deserialized objects because it implements the IEnumerable<T> interface.\r                     using (var reader = new SequentialReader<SensorData>(\r                         AvroContainer.CreateReader<SensorData>(buffer, true)))\r                     {\r                         var results = reader.Objects;\r \r                         //Finally, verify that deserialized data matches the original one\r                         Console.WriteLine(\"Comparing Initial and Deserialized Data Sets...\");\r                         int count = 1;\r                         var pairs = testData.Zip(results, (serialized, deserialized) => new { expected = serialized, actual = deserialized });\r                         foreach (var pair in pairs)\r                         {\r                             bool isEqual = this.Equal(pair.expected, pair.actual);\r                             Console.WriteLine(\"For Pair {0} result of Data Set Identity Comparison is {1}\", count, isEqual);\r                             count++;\r                         }\r                     }\r                 }\r \r                 //Delete the file\r                 RemoveFile(path);\r             }\r \r             //\r             //Helper methods\r             //\r \r             //Comparing two SensorData objects\r             private bool Equal(SensorData left, SensorData right)\r             {\r                 return left.Position.Equals(right.Position) && left.Value.SequenceEqual(right.Value);\r             }\r \r             //Saving memory stream to a new file with the given path\r             private bool WriteFile(MemoryStream InputStream, string path)\r             {\r                 if (!File.Exists(path))\r                 {\r                     try\r                     {\r                         using (FileStream fs = File.Create(path))\r                         {\r                             InputStream.Seek(0, SeekOrigin.Begin);\r                             InputStream.CopyTo(fs);\r                         }\r                         return true;\r                     }\r                     catch (Exception e)\r                     {\r                         Console.WriteLine(\"The following exception was thrown during creation and writing to the file \\\"{0}\\\"\", path);\r                         Console.WriteLine(e.Message);\r                         return false;\r                     }\r                 }\r                 else\r                 {\r                     Console.WriteLine(\"Can not create file \\\"{0}\\\". File already exists\", path);\r                     return false;\r \r                 }\r             }\r \r             //Reading a file content by using the given path to a memory stream\r             private bool ReadFile(MemoryStream OutputStream, string path)\r             {\r                 try\r                 {\r                     using (FileStream fs = File.Open(path, FileMode.Open))\r                     {\r                         fs.CopyTo(OutputStream);\r                     }\r                     return true;\r                 }\r                 catch (Exception e)\r                 {\r                     Console.WriteLine(\"The following exception was thrown during reading from the file \\\"{0}\\\"\", path);\r                     Console.WriteLine(e.Message);\r                     return false;\r                 }\r             }\r \r             //Deleting file by using given path\r             private void RemoveFile(string path)\r             {\r                 if (File.Exists(path))\r                 {\r                     try\r                     {\r                         File.Delete(path);\r                     }\r                     catch (Exception e)\r                     {\r                         Console.WriteLine(\"The following exception was thrown during deleting the file \\\"{0}\\\"\", path);\r                         Console.WriteLine(e.Message);\r                     }\r                 }\r                 else\r                 {\r                     Console.WriteLine(\"Can not delete file \\\"{0}\\\". File does not exist\", path);\r                 }\r             }\r \r             static void Main()\r             {\r \r                 string sectionDivider = \"---------------------------------------- \";\r \r                 //Create an instance of AvroSample class and invoke methods\r                 //illustrating different serializing approaches\r                 AvroSample Sample = new AvroSample();\r \r                 //Serialization using reflection to Avro object container file\r                 Sample.SerializeDeserializeUsingObjectContainersReflection();\r \r                 Console.WriteLine(sectionDivider);\r                 Console.WriteLine(\"Press any key to exit.\");\r                 Console.Read();\r             }\r         }\r     }\r     // The example is expected to display the following output:\r     // SERIALIZATION USING REFLECTION AND AVRO OBJECT CONTAINER FILES\r     //\r     // Serializing Sample Data Set...\r     // Saving serialized data to file...\r     // Reading data from file...\r     // Deserializing Sample Data Set...\r     // Comparing Initial and Deserialized Data Sets...\r     // For Pair 1 result of Data Set Identity Comparison is True\r     // For Pair 2 result of Data Set Identity Comparison is True\r     // ----------------------------------------\r     // Press any key to exit.\r \r ## <a name=\"sample-4-serialization-using-object-container-files-and-serialization-with-generic-record\"></a>示例 4：使用对象容器文件进行序列化与使用通用记录进行序列化\r 此示例与<a href=\"#Scenario2\">第二个示例</a>中使用 JSON 显式指定架构的方案类似。 除了本示例假设要将架构反序列化的读取器不知道架构以外。\r \r 测试数据集将通过显式定义的 JSON 架构收集到 [AvroRecord](http://msdn.microsoft.com/library/microsoft.hadoop.avro.avrorecord.aspx) 对象列表中，然后存储在由 [AvroContainer](http://msdn.microsoft.com/library/microsoft.hadoop.avro.container.avrocontainer.aspx) 类表示的对象容器文件中。 此容器文件将创建一个写入器，该写入器用于将未压缩的数据序列化到内存流，并将该内存流保存到文件中。 指定不要压缩此数据的是创建读取器时所用的 [**Codec.Null**](http://msdn.microsoft.com/library/microsoft.hadoop.avro.container.codec.null.aspx) 参数。\r \r 然后，从文件中读取数据，并将数据反序列化为对象的集合。 将此集合与 Avro 记录的初始列表进行比较，以确认它们相同。\r \r     namespace Microsoft.Hadoop.Avro.Sample\r     {\r         using System;\r         using System.Collections.Generic;\r         using System.IO;\r         using System.Linq;\r         using System.Runtime.Serialization;\r         using Microsoft.Hadoop.Avro.Container;\r         using Microsoft.Hadoop.Avro.Schema;\r         using Microsoft.Hadoop.Avro;\r \r         //This class contains all methods demonstrating\r         //the usage of Microsoft Avro Library\r         public class AvroSample\r         {\r \r             //Serializes and deserializes a sample data set by using a generic record and Avro object container files.\r             //Serialized data is not compressed.\r             public void SerializeDeserializeUsingObjectContainersGenericRecord()\r             {\r                 Console.WriteLine(\"SERIALIZATION USING GENERIC RECORD AND AVRO OBJECT CONTAINER FILES\\n\");\r \r                 //Path for Avro object container file\r                 string path = \"AvroSampleGenericRecordNullCodec.avro\";\r \r                 Console.WriteLine(\"Defining the Schema and creating Sample Data Set...\");\r \r                 //Define the schema in JSON\r                 const string Schema = @\"{\r                                 \"\"type\"\":\"\"record\"\",\r                                 \"\"name\"\":\"\"Microsoft.Hadoop.Avro.Specifications.SensorData\"\",\r                                 \"\"fields\"\":\r                                     [\r                                         {\r                                             \"\"name\"\":\"\"Location\"\",\r                                             \"\"type\"\":\r                                                 {\r                                                     \"\"type\"\":\"\"record\"\",\r                                                     \"\"name\"\":\"\"Microsoft.Hadoop.Avro.Specifications.Location\"\",\r                                                     \"\"fields\"\":\r                                                         [\r                                                             { \"\"name\"\":\"\"Floor\"\", \"\"type\"\":\"\"int\"\" },\r                                                             { \"\"name\"\":\"\"Room\"\", \"\"type\"\":\"\"int\"\" }\r                                                         ]\r                                                 }\r                                         },\r                                         { \"\"name\"\":\"\"Value\"\", \"\"type\"\":\"\"bytes\"\" }\r                                     ]\r                             }\";\r \r                 //Create a generic serializer based on the schema\r                 var serializer = AvroSerializer.CreateGeneric(Schema);\r                 var rootSchema = serializer.WriterSchema as RecordSchema;\r \r                 //Create a generic record to represent the data\r                 var testData = new List<AvroRecord>();\r \r                 dynamic expected1 = new AvroRecord(rootSchema);\r                 dynamic location1 = new AvroRecord(rootSchema.GetField(\"Location\").TypeSchema);\r                 location1.Floor = 1;\r                 location1.Room = 243;\r                 expected1.Location = location1;\r                 expected1.Value = new byte[] { 1, 2, 3, 4, 5 };\r                 testData.Add(expected1);\r \r                 dynamic expected2 = new AvroRecord(rootSchema);\r                 dynamic location2 = new AvroRecord(rootSchema.GetField(\"Location\").TypeSchema);\r                 location2.Floor = 1;\r                 location2.Room = 244;\r                 expected2.Location = location2;\r                 expected2.Value = new byte[] { 6, 7, 8, 9 };\r                 testData.Add(expected2);\r \r                 //Serializing and saving data to file.\r                 //Create a MemoryStream buffer.\r                 using (var buffer = new MemoryStream())\r                 {\r                     Console.WriteLine(\"Serializing Sample Data Set...\");\r \r                     //Create a SequentialWriter instance for type SensorData, which can serialize a sequence of SensorData objects to stream.\r                     //Data is not compressed (Null compression codec).\r                     using (var writer = AvroContainer.CreateGenericWriter(Schema, buffer, Codec.Null))\r                     {\r                         using (var streamWriter = new SequentialWriter<object>(writer, 24))\r                         {\r                             // Serialize the data to stream by using the sequential writer\r                             testData.ForEach(streamWriter.Write);\r                         }\r                     }\r \r                     Console.WriteLine(\"Saving serialized data to file...\");\r \r                     //Save stream to file\r                     if (!WriteFile(buffer, path))\r                     {\r                         Console.WriteLine(\"Error during file operation. Quitting method\");\r                         return;\r                     }\r                 }\r \r                 //Reading and deserializing the data.\r                 //Create a memory stream buffer.\r                 using (var buffer = new MemoryStream())\r                 {\r                     Console.WriteLine(\"Reading data from file...\");\r \r                     //Reading data from object container file\r                     if (!ReadFile(buffer, path))\r                     {\r                         Console.WriteLine(\"Error during file operation. Quitting method\");\r                         return;\r                     }\r \r                     Console.WriteLine(\"Deserializing Sample Data Set...\");\r \r                     //Prepare the stream for deserializing the data\r                     buffer.Seek(0, SeekOrigin.Begin);\r \r                     //Create a SequentialReader instance for type SensorData, which deserializes all serialized objects from the given stream.\r                     //It allows iterating over the deserialized objects because it implements the IEnumerable<T> interface.\r                     using (var reader = AvroContainer.CreateGenericReader(buffer))\r                     {\r                         using (var streamReader = new SequentialReader<object>(reader))\r                         {\r                             var results = streamReader.Objects;\r \r                             Console.WriteLine(\"Comparing Initial and Deserialized Data Sets...\");\r \r                             //Finally, verify the results\r                             var pairs = testData.Zip(results, (serialized, deserialized) => new { expected = (dynamic)serialized, actual = (dynamic)deserialized });\r                             int count = 1;\r                             foreach (var pair in pairs)\r                             {\r                                 bool isEqual = pair.expected.Location.Floor.Equals(pair.actual.Location.Floor);\r                                 isEqual = isEqual && pair.expected.Location.Room.Equals(pair.actual.Location.Room);\r                                 isEqual = isEqual && ((byte[])pair.expected.Value).SequenceEqual((byte[])pair.actual.Value);\r                                 Console.WriteLine(\"For Pair {0} result of Data Set Identity Comparison is {1}\", count, isEqual.ToString());\r                                 count++;\r                             }\r                         }\r                     }\r                 }\r \r                 //Delete the file\r                 RemoveFile(path);\r             }\r \r             //\r             //Helper methods\r             //\r \r             //Saving memory stream to a new file with the given path\r             private bool WriteFile(MemoryStream InputStream, string path)\r             {\r                 if (!File.Exists(path))\r                 {\r                     try\r                     {\r                         using (FileStream fs = File.Create(path))\r                         {\r                             InputStream.Seek(0, SeekOrigin.Begin);\r                             InputStream.CopyTo(fs);\r                         }\r                         return true;\r                     }\r                     catch (Exception e)\r                     {\r                         Console.WriteLine(\"The following exception was thrown during creation and writing to the file \\\"{0}\\\"\", path);\r                         Console.WriteLine(e.Message);\r                         return false;\r                     }\r                 }\r                 else\r                 {\r                     Console.WriteLine(\"Can not create file \\\"{0}\\\". File already exists\", path);\r                     return false;\r \r                 }\r             }\r \r             //Reading a file content by using the given path to a memory stream\r             private bool ReadFile(MemoryStream OutputStream, string path)\r             {\r                 try\r                 {\r                     using (FileStream fs = File.Open(path, FileMode.Open))\r                     {\r                         fs.CopyTo(OutputStream);\r                     }\r                     return true;\r                 }\r                 catch (Exception e)\r                 {\r                     Console.WriteLine(\"The following exception was thrown during reading from the file \\\"{0}\\\"\", path);\r                     Console.WriteLine(e.Message);\r                     return false;\r                 }\r             }\r \r             //Deleting file by using the given path\r             private void RemoveFile(string path)\r             {\r                 if (File.Exists(path))\r                 {\r                     try\r                     {\r                         File.Delete(path);\r                     }\r                     catch (Exception e)\r                     {\r                         Console.WriteLine(\"The following exception was thrown during deleting the file \\\"{0}\\\"\", path);\r                         Console.WriteLine(e.Message);\r                     }\r                 }\r                 else\r                 {\r                     Console.WriteLine(\"Can not delete file \\\"{0}\\\". File does not exist\", path);\r                 }\r             }\r \r             static void Main()\r             {\r \r                 string sectionDivider = \"---------------------------------------- \";\r \r                 //Create an instance of the AvroSample class and invoke methods\r                 //illustrating different serializing approaches\r                 AvroSample Sample = new AvroSample();\r \r                 //Serialization using generic record to Avro object container file\r                 Sample.SerializeDeserializeUsingObjectContainersGenericRecord();\r \r                 Console.WriteLine(sectionDivider);\r                 Console.WriteLine(\"Press any key to exit.\");\r                 Console.Read();\r             }\r         }\r     }\r     // The example is expected to display the following output:\r     // SERIALIZATION USING GENERIC RECORD AND AVRO OBJECT CONTAINER FILES\r     //\r     // Defining the Schema and creating Sample Data Set...\r     // Serializing Sample Data Set...\r     // Saving serialized data to file...\r     // Reading data from file...\r     // Deserializing Sample Data Set...\r     // Comparing Initial and Deserialized Data Sets...\r     // For Pair 1 result of Data Set Identity Comparison is True\r     // For Pair 2 result of Data Set Identity Comparison is True\r     // ----------------------------------------\r     // Press any key to exit.\r \r ## <a name=\"sample-5-serialization-using-object-container-files-with-a-custom-compression-codec\"></a>示例 5：使用对象容器文件通过自定义压缩编解码器进行序列化\r 第五个示例演示如何将自定义压缩编解码器用于 Avro 对象容器文件。 包含此示例代码的样例可以从 [Azure 代码示例](http://code.msdn.microsoft.com/Serialize-data-with-the-67159111)站点下载。\r \r [Avro 规范](http://avro.apache.org/docs/current/spec.html#Required+Codecs)允许使用可选的压缩编解码器（除了 **Null** 和 **Deflate** 默认压缩编解码器外）。 此示例未实现类似 Snappy（在 [Avro 规范](http://avro.apache.org/docs/current/spec.html#snappy)中作为支持的可选编解码器提及）的新编解码器。 它演示如何使用 [Deflate][deflate-110] 编解码器的 .NET Framework 4.5 实现，该编解码器基于 [zlib](http://zlib.net/) 压缩库提供比默认的 .NET Framework 4.0 版本更好的压缩算法。\r \r     //\r     // This code needs to be compiled with the parameter Target Framework set as \".NET Framework 4.5\"\r     // to ensure the desired implementation of the Deflate compression algorithm is used.\r     // Ensure your C# project is set up accordingly.\r     //\r \r     namespace Microsoft.Hadoop.Avro.Sample\r     {\r         using System;\r         using System.Collections.Generic;\r         using System.Diagnostics;\r         using System.IO;\r         using System.IO.Compression;\r         using System.Linq;\r         using System.Runtime.Serialization;\r         using Microsoft.Hadoop.Avro.Container;\r         using Microsoft.Hadoop.Avro;\r \r         #region Defining objects for serialization\r         //Sample class used in serialization samples\r         [DataContract(Name = \"SensorDataValue\", Namespace = \"Sensors\")]\r         internal class SensorData\r         {\r             [DataMember(Name = \"Location\")]\r             public Location Position { get; set; }\r \r             [DataMember(Name = \"Value\")]\r             public byte[] Value { get; set; }\r         }\r \r         //Sample struct used in serialization samples\r         [DataContract]\r         internal struct Location\r         {\r             [DataMember]\r             public int Floor { get; set; }\r \r             [DataMember]\r             public int Room { get; set; }\r         }\r         #endregion\r \r         #region Defining custom codec based on .NET Framework V.4.5 Deflate\r         //Avro.NET codec class contains two methods,\r         //GetCompressedStreamOver(Stream uncompressed) and GetDecompressedStreamOver(Stream compressed),\r         //which are the key ones for data compression.\r         //To enable a custom codec, one needs to implement these methods for the required codec.\r \r         #region Defining Compression and Decompression Streams\r         //DeflateStream (class from System.IO.Compression namespace that implements Deflate algorithm)\r         //cannot be directly used for Avro because it does not support vital operations like Seek.\r         //Thus one needs to implement two classes inherited from stream\r         //(one for compressed and one for decompressed stream)\r         //that use Deflate compression and implement all required features.\r         internal sealed class CompressionStreamDeflate45 : Stream\r         {\r             private readonly Stream buffer;\r             private DeflateStream compressionStream;\r \r             public CompressionStreamDeflate45(Stream buffer)\r             {\r                 Debug.Assert(buffer != null, \"Buffer is not allowed to be null.\");\r \r                 this.compressionStream = new DeflateStream(buffer, CompressionLevel.Fastest, true);\r                 this.buffer = buffer;\r             }\r \r             public override bool CanRead\r             {\r                 get { return this.buffer.CanRead; }\r             }\r \r             public override bool CanSeek\r             {\r                 get { return true; }\r             }\r \r             public override bool CanWrite\r             {\r                 get { return this.buffer.CanWrite; }\r             }\r \r             public override void Flush()\r             {\r                 this.compressionStream.Close();\r             }\r \r             public override long Length\r             {\r                 get { return this.buffer.Length; }\r             }\r \r             public override long Position\r             {\r                 get\r                 {\r                     return this.buffer.Position;\r                 }\r \r                 set\r                 {\r                     this.buffer.Position = value;\r                 }\r             }\r \r             public override int Read(byte[] buffer, int offset, int count)\r             {\r                 return this.buffer.Read(buffer, offset, count);\r             }\r \r             public override long Seek(long offset, SeekOrigin origin)\r             {\r                 return this.buffer.Seek(offset, origin);\r             }\r \r             public override void SetLength(long value)\r             {\r                 throw new NotSupportedException();\r             }\r \r             public override void Write(byte[] buffer, int offset, int count)\r             {\r                 this.compressionStream.Write(buffer, offset, count);\r             }\r \r             protected override void Dispose(bool disposed)\r             {\r                 base.Dispose(disposed);\r \r                 if (disposed)\r                 {\r                     this.compressionStream.Dispose();\r                     this.compressionStream = null;\r                 }\r             }\r         }\r \r         internal sealed class DecompressionStreamDeflate45 : Stream\r         {\r             private readonly DeflateStream decompressed;\r \r             public DecompressionStreamDeflate45(Stream compressed)\r             {\r                 this.decompressed = new DeflateStream(compressed, CompressionMode.Decompress, true);\r             }\r \r             public override bool CanRead\r             {\r                 get { return true; }\r             }\r \r             public override bool CanSeek\r             {\r                 get { return true; }\r             }\r \r             public override bool CanWrite\r             {\r                 get { return false; }\r             }\r \r             public override void Flush()\r             {\r                 this.decompressed.Close();\r             }\r \r             public override long Length\r             {\r                 get { return this.decompressed.Length; }\r             }\r \r             public override long Position\r             {\r                 get\r                 {\r                     return this.decompressed.Position;\r                 }\r \r                 set\r                 {\r                     throw new NotSupportedException();\r                 }\r             }\r \r             public override int Read(byte[] buffer, int offset, int count)\r             {\r                 return this.decompressed.Read(buffer, offset, count);\r             }\r \r             public override long Seek(long offset, SeekOrigin origin)\r             {\r                 throw new NotSupportedException();\r             }\r \r             public override void SetLength(long value)\r             {\r                 throw new NotSupportedException();\r             }\r \r             public override void Write(byte[] buffer, int offset, int count)\r             {\r                 throw new NotSupportedException();\r             }\r \r             protected override void Dispose(bool disposing)\r             {\r                 base.Dispose(disposing);\r \r                 if (disposing)\r                 {\r                     this.decompressed.Dispose();\r                 }\r             }\r         }\r         #endregion\r \r         #region Define Codec\r         //Define the actual codec class containing the required methods for manipulating streams:\r         //GetCompressedStreamOver(Stream uncompressed) and GetDecompressedStreamOver(Stream compressed).\r         //Codec class uses classes for compressed and decompressed streams defined above.\r         internal sealed class DeflateCodec45 : Codec\r         {\r \r             //We merely use different IMPLEMENTATIONS of Deflate, so CodecName remains \"deflate\"\r             public static readonly string CodecName = \"deflate\";\r \r             public DeflateCodec45()\r                 : base(CodecName)\r             {\r             }\r \r             public override Stream GetCompressedStreamOver(Stream decompressed)\r             {\r                 if (decompressed == null)\r                 {\r                     throw new ArgumentNullException(\"decompressed\");\r                 }\r \r                 return new CompressionStreamDeflate45(decompressed);\r             }\r \r             public override Stream GetDecompressedStreamOver(Stream compressed)\r             {\r                 if (compressed == null)\r                 {\r                     throw new ArgumentNullException(\"compressed\");\r                 }\r \r                 return new DecompressionStreamDeflate45(compressed);\r             }\r         }\r         #endregion\r \r         #region Define modified Codec Factory\r         //Define modified codec factory to be used in the reader.\r         //It catches the attempt to use \"Deflate\" and provide  a custom codec.\r         //For all other cases, it relies on the base class (CodecFactory).\r         internal sealed class CodecFactoryDeflate45 : CodecFactory\r         {\r \r             public override Codec Create(string codecName)\r             {\r                 if (codecName == DeflateCodec45.CodecName)\r                     return new DeflateCodec45();\r                 else\r                     return base.Create(codecName);\r             }\r         }\r         #endregion\r \r         #endregion\r \r         #region Sample Class with demonstration methods\r         //This class contains methods demonstrating\r         //the usage of Microsoft Avro Library\r         public class AvroSample\r         {\r \r             //Serializes and deserializes sample data set by using reflection and Avro object container files.\r             //Serialized data is compressed with the custom compression codec (Deflate of .NET Framework 4.5).\r             //\r             //This sample uses memory stream for all operations related to serialization, deserialization and\r             //object container manipulation, though file stream could be easily used.\r             public void SerializeDeserializeUsingObjectContainersReflectionCustomCodec()\r             {\r \r                 Console.WriteLine(\"SERIALIZATION USING REFLECTION, AVRO OBJECT CONTAINER FILES AND CUSTOM CODEC\\n\");\r \r                 //Path for Avro object container file\r                 string path = \"AvroSampleReflectionDeflate45.avro\";\r \r                 //Create a data set by using sample class and struct\r                 var testData = new List<SensorData>\r                         {\r                             new SensorData { Value = new byte[] { 1, 2, 3, 4, 5 }, Position = new Location { Room = 243, Floor = 1 } },\r                             new SensorData { Value = new byte[] { 6, 7, 8, 9 }, Position = new Location { Room = 244, Floor = 1 } }\r                         };\r \r                 //Serializing and saving data to file.\r                 //Creating a memory stream buffer.\r                 using (var buffer = new MemoryStream())\r                 {\r                     Console.WriteLine(\"Serializing Sample Data Set...\");\r \r                     //Create a SequentialWriter instance for type SensorData, which can serialize a sequence of SensorData objects to stream.\r                     //Here the custom codec is introduced. For convenience, the next commented code line shows how to use built-in Deflate.\r                     //Note that because the sample deals with different IMPLEMENTATIONS of Deflate, built-in and custom codecs are interchangeable\r                     //in read-write operations.\r                     //using (var w = AvroContainer.CreateWriter<SensorData>(buffer, Codec.Deflate))\r                     using (var w = AvroContainer.CreateWriter<SensorData>(buffer, new DeflateCodec45()))\r                     {\r                         using (var writer = new SequentialWriter<SensorData>(w, 24))\r                         {\r                             // Serialize the data to stream using the sequential writer\r                             testData.ForEach(writer.Write);\r                         }\r                     }\r \r                     //Save stream to file\r                     Console.WriteLine(\"Saving serialized data to file...\");\r                     if (!WriteFile(buffer, path))\r                     {\r                         Console.WriteLine(\"Error during file operation. Quitting method\");\r                         return;\r                     }\r                 }\r \r                 //Reading and deserializing data.\r                 //Creating a memory stream buffer.\r                 using (var buffer = new MemoryStream())\r                 {\r                     Console.WriteLine(\"Reading data from file...\");\r \r                     //Reading data from object container file\r                     if (!ReadFile(buffer, path))\r                     {\r                         Console.WriteLine(\"Error during file operation. Quitting method\");\r                         return;\r                     }\r \r                     Console.WriteLine(\"Deserializing Sample Data Set...\");\r \r                     //Prepare the stream for deserializing the data\r                     buffer.Seek(0, SeekOrigin.Begin);\r \r                     //Because of SequentialReader<T> constructor signature, an AvroSerializerSettings instance is required\r                     //when codec factory is explicitly specified.\r                     //You may comment the line below if you want to use built-in Deflate (see next comment).\r                     AvroSerializerSettings settings = new AvroSerializerSettings();\r \r                     //Create a SequentialReader instance for type SensorData, which deserializes all serialized objects from the given stream.\r                     //It allows iterating over the deserialized objects because it implements the IEnumerable<T> interface.\r                     //Here the custom codec factory is introduced.\r                     //For convenience, the next commented code line shows how to use built-in Deflate\r                     //(no explicit Codec Factory parameter is required in this case).\r                     //Note that because the sample deals with different IMPLEMENTATIONS of Deflate, built-in and custom codecs are interchangeable\r                     //in read-write operations.\r                     //using (var reader = new SequentialReader<SensorData>(AvroContainer.CreateReader<SensorData>(buffer, true)))\r                     using (var reader = new SequentialReader<SensorData>(\r                         AvroContainer.CreateReader<SensorData>(buffer, true, settings, new CodecFactoryDeflate45())))\r                     {\r                         var results = reader.Objects;\r \r                         //Finally, verify that deserialized data matches the original one\r                         Console.WriteLine(\"Comparing Initial and Deserialized Data Sets...\");\r                         bool isEqual;\r                         int count = 1;\r                         var pairs = testData.Zip(results, (serialized, deserialized) => new { expected = serialized, actual = deserialized });\r                         foreach (var pair in pairs)\r                         {\r                             isEqual = this.Equal(pair.expected, pair.actual);\r                             Console.WriteLine(\"For Pair {0} result of Data Set Identity Comparison is {1}\", count, isEqual.ToString());\r                             count++;\r                         }\r                     }\r                 }\r \r                 //Delete the file\r                 RemoveFile(path);\r             }\r         #endregion\r \r             #region Helper Methods\r \r             //Comparing two SensorData objects\r             private bool Equal(SensorData left, SensorData right)\r             {\r                 return left.Position.Equals(right.Position) && left.Value.SequenceEqual(right.Value);\r             }\r \r             //Saving memory stream to a new file with the given path\r             private bool WriteFile(MemoryStream InputStream, string path)\r             {\r                 if (!File.Exists(path))\r                 {\r                     try\r                     {\r                         using (FileStream fs = File.Create(path))\r                         {\r                             InputStream.Seek(0, SeekOrigin.Begin);\r                             InputStream.CopyTo(fs);\r                         }\r                         return true;\r                     }\r                     catch (Exception e)\r                     {\r                         Console.WriteLine(\"The following exception was thrown during creation and writing to the file \\\"{0}\\\"\", path);\r                         Console.WriteLine(e.Message);\r                         return false;\r                     }\r                 }\r                 else\r                 {\r                     Console.WriteLine(\"Can not create file \\\"{0}\\\". File already exists\", path);\r                     return false;\r \r                 }\r             }\r \r             //Reading file content by using the given path to a memory stream\r             private bool ReadFile(MemoryStream OutputStream, string path)\r             {\r                 try\r                 {\r                     using (FileStream fs = File.Open(path, FileMode.Open))\r                     {\r                         fs.CopyTo(OutputStream);\r                     }\r                     return true;\r                 }\r                 catch (Exception e)\r                 {\r                     Console.WriteLine(\"The following exception was thrown during reading from the file \\\"{0}\\\"\", path);\r                     Console.WriteLine(e.Message);\r                     return false;\r                 }\r             }\r \r             //Deleting file by using given path\r             private void RemoveFile(string path)\r             {\r                 if (File.Exists(path))\r                 {\r                     try\r                     {\r                         File.Delete(path);\r                     }\r                     catch (Exception e)\r                     {\r                         Console.WriteLine(\"The following exception was thrown during deleting the file \\\"{0}\\\"\", path);\r                         Console.WriteLine(e.Message);\r                     }\r                 }\r                 else\r                 {\r                     Console.WriteLine(\"Can not delete file \\\"{0}\\\". File does not exist\", path);\r                 }\r             }\r             #endregion\r \r             static void Main()\r             {\r \r                 string sectionDivider = \"---------------------------------------- \";\r \r                 //Create an instance of AvroSample Class and invoke methods\r                 //illustrating different serializing approaches\r                 AvroSample Sample = new AvroSample();\r \r                 //Serialization using reflection to Avro object container file using custom codec\r                 Sample.SerializeDeserializeUsingObjectContainersReflectionCustomCodec();\r \r                 Console.WriteLine(sectionDivider);\r                 Console.WriteLine(\"Press any key to exit.\");\r                 Console.Read();\r             }\r         }\r     }\r     // The example is expected to display the following output:\r     // SERIALIZATION USING REFLECTION, AVRO OBJECT CONTAINER FILES AND CUSTOM CODEC\r     //\r     // Serializing Sample Data Set...\r     // Saving serialized data to file...\r     // Reading data from file...\r     // Deserializing Sample Data Set...\r     // Comparing Initial and Deserialized Data Sets...\r     // For Pair 1 result of Data Set Identity Comparison is True\r     //For Pair 2 result of Data Set Identity Comparison is True\r     // ----------------------------------------\r     // Press any key to exit.\r \r ## <a name=\"sample-6-using-avro-to-upload-data-for-the-azure-hdinsight-service\"></a>示例 6：使用 Avro 上传 Azure HDInsight 服务的数据\r 第六个示例演示与 Microsoft Azure HDInsight 服务交互相关的一些编程技巧。 包含此示例代码的样例可以从 [Azure 代码示例](https://code.msdn.microsoft.com/Using-Avro-to-upload-data-ae81b1e3)站点下载。\r \r 该示例将执行以下任务：\r \r * 连接到现有的 HDInsight 服务群集。\r * 序列化多个 CSV 文件并将结果上传到 Azure Blob 存储。 （CSV 文件随着示例一起分发，而且代表 [Infochimps](http://www.infochimps.com/) 在 1970 年到 2010 年期间提取自 AMEX 股票的历史记录数据。 该示例将读取 CSV 文件数据、将记录转换为 **Stock** 类的实例，并使用反射序列化这些实例。 Stock 类型定义是使用 Microsoft Avro Library 代码生成实用工具从 JSON 架构创建的。\r * 在 Hive 中创建名为 **Stocks** 的新外部表，并将它链接到前一个步骤中上传的数据。\r * 使用 Hive 对 **Stocks** 表执行查询。\r \r 此外，该示例会在执行主要操作之前和之后执行清理过程。 在清理期间，将删除所有相关的 Azure Blob 数据和文件夹，并删除 Hive 表。 也可以从示例命令行调用清理过程。\r \r 该示例要求满足以下先决条件：\r \r * 有效的 Azure 订阅及其订阅 ID。\r * 包含相应私钥的订阅管理证书。 该证书应安装在用于运行示例的计算机上的当前用户私用存储中。\r * 活动的 HDInsight 群集。\r * 在先前的必要条件中链接到 HDInsight 群集的 Azure 存储帐户，以及相应的主要或辅助访问密钥。\r \r 运行示例之前，必要条件中的所有信息均应输入到示例配置文件中。 要运行此操作有两个可行的方式：\r \r * 编辑示例根目录中的 app.config 文件，并生成示例，或\r * 先生成示例，并在生成目录中编辑 AvroHDISample.exe.config\r \r 在这两种情况下，所有编辑均应该在 <appSettings> 设置节中完成。 请遵循文件中的注释。\r 执行以下命令从命令行运行该示例（其中，包含该示例的 .zip 文件假设已解压缩到 C:\\AvroHDISample；如果不是，请使用相关的文件路径）：\r \r     AvroHDISample run C:\\AvroHDISample\\Data\r \r 若要清理群集，请运行以下命令：\r \r     AvroHDISample clean\r \r [deflate-100]: http://msdn.microsoft.com/library/system.io.compression.deflatestream(v=vs.100).aspx\r [deflate-110]: http://msdn.microsoft.com/library/system.io.compression.deflatestream(v=vs.110).aspx\r \r \r \r <!--Update_Description: update wording and link references-->"}