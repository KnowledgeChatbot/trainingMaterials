{"Title":"如何通过 PHP 使用表存储","Description":"了解如何通过 PHP 使用表服务来创建和删除表以及插入、删除和查询表。","Content":"# <a name=\"how-to-use-azure-table-storage-from-php\"></a>如何通过 PHP 使用 Azure 表存储\r [!INCLUDE [storage-selector-table-include](../../includes/storage-selector-table-include.md)]\r [!INCLUDE [storage-table-cosmos-db-langsoon-tip-include](../../includes/storage-table-cosmos-db-langsoon-tip-include.md)]\r \r ## <a name=\"overview\"></a>概述\r 本指南演示如何使用 Azure 表服务执行常见任务。 示例是用 PHP 编写的，并使用了 [Azure SDK for PHP][download]。 涉及的方案包括**创建和删除表以及在表中插入、删除和查询实体**。 有关 Azure 表服务的详细信息，请参阅[后续步骤](#next-steps)部分。\r \r [!INCLUDE [storage-table-concepts-include](../../includes/storage-table-concepts-include.md)]\r \r [!INCLUDE [storage-create-account-include](../../includes/storage-create-account-include.md)]\r \r ## <a name=\"create-a-php-application\"></a>创建 PHP 应用程序\r 创建访问 Azure 表服务的 PHP 应用程序的唯一要求是从代码中引用 Azure SDK for PHP 中的类。 可使用任何开发工具（包括“记事本”）创建应用程序。\r \r 本指南涉及使用表服务功能，可在 PHP 应用程序中本地调用，或在 Azure Web 角色、辅助角色或网站中运行的代码内调用这些功能。\r \r ## <a name=\"get-the-azure-client-libraries\"></a>获取 Azure 客户端库\r [!INCLUDE [get-client-libraries](../../includes/get-client-libraries.md)]\r \r ## <a name=\"configure-your-application-to-access-the-table-service\"></a>配置应用程序以访问表服务\r 若要使用 Azure 表服务 API，需执行以下操作：\r \r 1. 使用 [require_once][require_once]语句引用 autoloader 文件，并\r 2. 引用所用的任意类。\r \r 下面的示例演示了如何包括 autoloader 文件并引用 **ServicesBuilder** 类。\r \r > [!NOTE]\r > 本文的示例假定用户已通过 Composer 安装了用于 Azure 的 PHP 客户端库。 如果已手动安装这些库，则需要引用 <code>WindowsAzure.php</code> autoloader 文件。\r >\r >\r \r ```php\r require_once 'vendor/autoload.php';\r use WindowsAzure\\Common\\ServicesBuilder;\r ```\r \r 在下面的示例中，始终显示 `require_once` 语句，但只会引用执行该示例所需的类。\r \r ## <a name=\"set-up-an-azure-storage-connection\"></a>设置 Azure 存储连接\r 若要实例化 Azure 表服务客户端，必须首先具有有效的连接字符串。 表服务连接字符串的格式如下：\r \r 若要访问实时服务：\r \r ```php\r DefaultEndpointsProtocol=[http|https];AccountName=[yourAccount];AccountKey=[yourKey];EndpointSuffix=core.chinacloudapi.cn\r ```\r \r 若要访问模拟器存储：\r \r ```php\r UseDevelopmentStorage=true\r ```\r \r 若要创建任何 Azure 服务客户端，需要使用 **ServicesBuilder** 类。 可执行以下操作：\r \r * 将连接字符串直接传递给此类或\r * 使用 **CloudConfigurationManager (CCM)** 检查多个外部源以获取连接字符串：\r   * 它默认支持一个外部源 - 环境变量\r   * 可通过扩展 **ConnectionStringSource** 类来添加新源\r \r 在此处列出的示例中，直接传递连接字符串。\r \r ```php\r require_once 'vendor/autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r \r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r ```\r \r ## <a name=\"create-a-table\"></a>创建表\r 利用 **TableRestProxy** 对象，可以使用 **createTable** 方法创建表。 创建表时，可以设置表服务超时。 （有关表服务超时的详细信息，请参阅[为表服务操作设置超时][table-service-timeouts]。）\r \r ```php\r require_once 'vendor\\autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r use MicrosoftAzure\\Storage\\Common\\ServiceException;\r \r // Create table REST proxy.\r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r \r try    {\r     // Create table.\r     $tableRestProxy->createTable(\"mytable\");\r }\r catch(ServiceException $e){\r     $code = $e->getCode();\r     $error_message = $e->getMessage();\r     // Handle exception based on error codes and messages.\r     // Error codes and messages can be found here:\r     // http://msdn.microsoft.com/library/azure/dd179438.aspx\r }\r ```\r \r 有关表名称的限制的信息，请参阅 [了解表服务数据模型][table-data-model]。\r \r ## <a name=\"add-an-entity-to-a-table\"></a>向表中添加条目\r 若要将实体添加到表，请创建新的 **Entity** 对象并将其传递到 **TableRestProxy->insertEntity**。 请注意，在创建实体时，你必须指定 `PartitionKey` 和 `RowKey`。 这些值是实体的唯一标识符，并且其查询速度比其他实体属性的查询速度快得多。 系统使用 `PartitionKey` 自动将表的实体分发到多个存储节点上。 具有相同 `PartitionKey` 的实体存储在同一个节点上。 （对存储在同一节点上的多个实体执行操作要将比对存储在不同节点上的实体执行的操作的效果更佳。）`RowKey` 是实体在分区中的唯一 ID。\r \r ```php\r require_once 'vendor/autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r use MicrosoftAzure\\Storage\\Common\\ServiceException;\r use MicrosoftAzure\\Storage\\Table\\Models\\Entity;\r use MicrosoftAzure\\Storage\\Table\\Models\\EdmType;\r \r // Create table REST proxy.\r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r \r $entity = new Entity();\r $entity->setPartitionKey(\"tasksSeattle\");\r $entity->setRowKey(\"1\");\r $entity->addProperty(\"Description\", null, \"Take out the trash.\");\r $entity->addProperty(\"DueDate\",\r                         EdmType::DATETIME,\r                         new DateTime(\"2012-11-05T08:15:00-08:00\"));\r $entity->addProperty(\"Location\", EdmType::STRING, \"Home\");\r \r try{\r     $tableRestProxy->insertEntity(\"mytable\", $entity);\r }\r catch(ServiceException $e){\r     // Handle exception based on error codes and messages.\r     // Error codes and messages are here:\r     // http://msdn.microsoft.com/library/azure/dd179438.aspx\r     $code = $e->getCode();\r     $error_message = $e->getMessage();\r }\r ```\r \r 有关表属性和类型的信息，请参阅 [了解表服务数据模型][table-data-model]。\r \r **TableRestProxy** 类提供了用于插入实体的两个替代方法：**insertOrMergeEntity** 和 **insertOrReplaceEntity**。 要使用这些方法，请创建一个新的 **Entity** ，并将其作为参数传递到上述任一方法。 如果条目不存在，则每种方法都会插入条目。 在实体已存在的情况下，如果属性已存在，则 **insertOrMergeEntity** 更新属性值；如果属性不存在，则该方法添加新属性，而 **insertOrReplaceEntity** 会完全替换现有实体。 下面的示例演示如何使用 **insertOrMergeEntity**。 如果实体具有 `PartitionKey`“tasksSeattle”并且 `RowKey`“1”不存在，则将插入该实体。 但是，如果之前已插入该实体（如上面的示例所示），则将更新 `DueDate` 属性并添加 `Status` 属性。 系统还将更新 `Description` 和 `Location` 属性，但使用的值实际上会使其保持不变。 如果并非如示例所示添加后两个属性，而这两个数学已存在于目标条目上，则其现有值保持不变。\r \r ```php\r require_once 'vendor/autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r use MicrosoftAzure\\Storage\\Common\\ServiceException;\r use MicrosoftAzure\\Storage\\Table\\Models\\Entity;\r use MicrosoftAzure\\Storage\\Table\\Models\\EdmType;\r \r // Create table REST proxy.\r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r \r //Create new entity.\r $entity = new Entity();\r \r // PartitionKey and RowKey are required.\r $entity->setPartitionKey(\"tasksSeattle\");\r $entity->setRowKey(\"1\");\r \r // If entity exists, existing properties are updated with new values and\r // new properties are added. Missing properties are unchanged.\r $entity->addProperty(\"Description\", null, \"Take out the trash.\");\r $entity->addProperty(\"DueDate\", EdmType::DATETIME, new DateTime()); // Modified the DueDate field.\r $entity->addProperty(\"Location\", EdmType::STRING, \"Home\");\r $entity->addProperty(\"Status\", EdmType::STRING, \"Complete\"); // Added Status field.\r \r try    {\r     // Calling insertOrReplaceEntity, instead of insertOrMergeEntity as shown,\r     // would simply replace the entity with PartitionKey \"tasksSeattle\" and RowKey \"1\".\r     $tableRestProxy->insertOrMergeEntity(\"mytable\", $entity);\r }\r catch(ServiceException $e){\r     // Handle exception based on error codes and messages.\r     // Error codes and messages are here:\r     // http://msdn.microsoft.com/library/azure/dd179438.aspx\r     $code = $e->getCode();\r     $error_message = $e->getMessage();\r     echo $code.\": \".$error_message.\"<br />\";\r }\r ```\r \r ## <a name=\"retrieve-a-single-entity\"></a>检索单个条目\r 利用 **TableRestProxy->getEntity** 方法，可以通过查询实体的 `PartitionKey` 和 `RowKey` 来检索它。 在以下示例中，分区键 `tasksSeattle` 和行键 `1` 传递给 **getEntity** 方法。\r \r ```php\r require_once 'vendor/autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r use MicrosoftAzure\\Storage\\Common\\ServiceException;\r \r // Create table REST proxy.\r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r \r try    {\r     $result = $tableRestProxy->getEntity(\"mytable\", \"tasksSeattle\", 1);\r }\r catch(ServiceException $e){\r     // Handle exception based on error codes and messages.\r     // Error codes and messages are here:\r     // http://msdn.microsoft.com/library/azure/dd179438.aspx\r     $code = $e->getCode();\r     $error_message = $e->getMessage();\r     echo $code.\": \".$error_message.\"<br />\";\r }\r \r $entity = $result->getEntity();\r \r echo $entity->getPartitionKey().\":\".$entity->getRowKey();\r ```\r \r ## <a name=\"retrieve-all-entities-in-a-partition\"></a>检索分区中的所有实体\r 使用筛选器来构造实体查询（有关详细信息，请参阅[查询表和实体][filters]）。 若要检索分区中的所有实体，请使用筛选器“PartitionKey eq *partition_name*”。 下面的示例演示了如何通过将筛选器传递到 **queryEntities** 方法来检索 `tasksSeattle` 分区中的所有实体。\r \r ```php\r require_once 'vendor/autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r use MicrosoftAzure\\Storage\\Common\\ServiceException;\r \r // Create table REST proxy.\r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r \r $filter = \"PartitionKey eq 'tasksSeattle'\";\r \r try    {\r     $result = $tableRestProxy->queryEntities(\"mytable\", $filter);\r }\r catch(ServiceException $e){\r     // Handle exception based on error codes and messages.\r     // Error codes and messages are here:\r     // http://msdn.microsoft.com/library/azure/dd179438.aspx\r     $code = $e->getCode();\r     $error_message = $e->getMessage();\r     echo $code.\": \".$error_message.\"<br />\";\r }\r \r $entities = $result->getEntities();\r \r foreach($entities as $entity){\r     echo $entity->getPartitionKey().\":\".$entity->getRowKey().\"<br />\";\r }\r ```\r \r ## <a name=\"retrieve-a-subset-of-entities-in-a-partition\"></a>检索分区中条目的子集\r 可以使用上一示例中使用的同一模式来检索分区中的部分实体。 检索的实体子集将由所使用的筛选器确定（有关详细信息，请参阅[查询表和实体][filters]）。下面的示例演示如何使用筛选器检索具有特定的 `Location` 和早于 `DueDate` 的所有实体。\r \r ```php\r require_once 'vendor/autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r use MicrosoftAzure\\Storage\\Common\\ServiceException;\r \r // Create table REST proxy.\r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r \r $filter = \"Location eq 'Office' and DueDate lt '2012-11-5'\";\r \r try    {\r     $result = $tableRestProxy->queryEntities(\"mytable\", $filter);\r }\r catch(ServiceException $e){\r     // Handle exception based on error codes and messages.\r     // Error codes and messages are here:\r     // http://msdn.microsoft.com/library/azure/dd179438.aspx\r     $code = $e->getCode();\r     $error_message = $e->getMessage();\r     echo $code.\": \".$error_message.\"<br />\";\r }\r \r $entities = $result->getEntities();\r \r foreach($entities as $entity){\r     echo $entity->getPartitionKey().\":\".$entity->getRowKey().\"<br />\";\r }\r ```\r \r ## <a name=\"retrieve-a-subset-of-entity-properties\"></a>检索条目属性的子集\r 查询可检索一部分实体属性。 此方法称为“投影” ，可减少带宽并提高查询性能，尤其适用于大型实体。 若要指定要检索的属性，请将该属性的名称传递到 **Query->addSelectField** 方法。 可以多次调用此方法来添加更多属性。 执行 **TableRestProxy->queryEntities** 后，返回的实体将仅具有选定的属性。 （若要返回一部分表实体，请使用上述查询中所示的筛选器。）\r \r ```php\r require_once 'vendor/autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r use MicrosoftAzure\\Storage\\Common\\ServiceException;\r use MicrosoftAzure\\Storage\\Table\\Models\\QueryEntitiesOptions;\r \r // Create table REST proxy.\r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r \r $options = new QueryEntitiesOptions();\r $options->addSelectField(\"Description\");\r \r try    {\r     $result = $tableRestProxy->queryEntities(\"mytable\", $options);\r }\r catch(ServiceException $e){\r     // Handle exception based on error codes and messages.\r     // Error codes and messages are here:\r     // http://msdn.microsoft.com/library/azure/dd179438.aspx\r     $code = $e->getCode();\r     $error_message = $e->getMessage();\r     echo $code.\": \".$error_message.\"<br />\";\r }\r \r // All entities in the table are returned, regardless of whether\r // they have the Description field.\r // To limit the results returned, use a filter.\r $entities = $result->getEntities();\r \r foreach($entities as $entity){\r     $description = $entity->getProperty(\"Description\")->getValue();\r     echo $description.\"<br />\";\r }\r ```\r \r ## <a name=\"update-an-entity\"></a>更新条目\r 可通过对现有实体使用 **Entity->setProperty** 和 **Entity->addProperty** 方法并调用 **TableRestProxy->updateEntity** 来更新该实体。 下面的示例检索一个条目、修改一个属性、删除另一个属性并添加一个新属性。 请注意，通过将属性的值设为 **null** 可删除该属性。\r \r ```php\r require_once 'vendor/autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r use MicrosoftAzure\\Storage\\Common\\ServiceException;\r use MicrosoftAzure\\Storage\\Table\\Models\\Entity;\r use MicrosoftAzure\\Storage\\Table\\Models\\EdmType;\r \r // Create table REST proxy.\r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r \r $result = $tableRestProxy->getEntity(\"mytable\", \"tasksSeattle\", 1);\r \r $entity = $result->getEntity();\r \r $entity->setPropertyValue(\"DueDate\", new DateTime()); //Modified DueDate.\r \r $entity->setPropertyValue(\"Location\", null); //Removed Location.\r \r $entity->addProperty(\"Status\", EdmType::STRING, \"In progress\"); //Added Status.\r \r try    {\r     $tableRestProxy->updateEntity(\"mytable\", $entity);\r }\r catch(ServiceException $e){\r     // Handle exception based on error codes and messages.\r     // Error codes and messages are here:\r     // http://msdn.microsoft.com/library/azure/dd179438.aspx\r     $code = $e->getCode();\r     $error_message = $e->getMessage();\r     echo $code.\": \".$error_message.\"<br />\";\r }\r ```\r \r ## <a name=\"delete-an-entity\"></a>删除实体\r 若要删除实体，请将表名称以及实体的 `PartitionKey` 和 `RowKey` 传递到 **TableRestProxy->deleteEntity** 方法。\r \r ```php\r require_once 'vendor/autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r use MicrosoftAzure\\Storage\\Common\\ServiceException;\r \r // Create table REST proxy.\r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r \r try    {\r     // Delete entity.\r     $tableRestProxy->deleteEntity(\"mytable\", \"tasksSeattle\", \"2\");\r }\r catch(ServiceException $e){\r     // Handle exception based on error codes and messages.\r     // Error codes and messages are here:\r     // http://msdn.microsoft.com/library/azure/dd179438.aspx\r     $code = $e->getCode();\r     $error_message = $e->getMessage();\r     echo $code.\": \".$error_message.\"<br />\";\r }\r ```\r \r 请注意，为了进行并发检查，可以使用 **DeleteEntityOptions->setEtag** 方法并将 **DeleteEntityOptions** 对象作为第四个参数传递到 **deleteEntity**，来为要删除的实体设置 Etag。\r \r ## <a name=\"batch-table-operations\"></a>批量进行表操作\r 利用 **TableRestProxy->batch** 方法，可以通过一个请求执行多个操作。 此处的模式涉及将操作添加到 **BatchRequest**对象，然后将 **BatchRequest** 对象传递到 **TableRestProxy->batch** 方法。 要将操作添加到 **BatchRequest** 对象，可以多次调用以下任一方法：\r \r * **addInsertEntity**（添加 insertEntity 操作）\r * **addUpdateEntity**（添加 updateEntity 操作）\r * **addMergeEntity**（添加 mergeEntity 操作）\r * **addInsertOrReplaceEntity**（添加 insertOrReplaceEntity 操作）\r * **addInsertOrMergeEntity**（添加 insertOrMergeEntity 操作）\r * **addDeleteEntity**（添加 deleteEntity 操作）\r \r 下面的示例演示了如何通过单个请求执行 **insertEntity** 和 **deleteEntity** 操作：\r \r ```php\r require_once 'vendor/autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r use MicrosoftAzure\\Storage\\Common\\ServiceException;\r use MicrosoftAzure\\Storage\\Table\\Models\\Entity;\r use MicrosoftAzure\\Storage\\Table\\Models\\EdmType;\r use MicrosoftAzure\\Storage\\Table\\Models\\BatchOperations;\r \r     // Create table REST proxy.\r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r \r // Create list of batch operation.\r $operations = new BatchOperations();\r \r $entity1 = new Entity();\r $entity1->setPartitionKey(\"tasksSeattle\");\r $entity1->setRowKey(\"2\");\r $entity1->addProperty(\"Description\", null, \"Clean roof gutters.\");\r $entity1->addProperty(\"DueDate\",\r                         EdmType::DATETIME,\r                         new DateTime(\"2012-11-05T08:15:00-08:00\"));\r $entity1->addProperty(\"Location\", EdmType::STRING, \"Home\");\r \r // Add operation to list of batch operations.\r $operations->addInsertEntity(\"mytable\", $entity1);\r \r // Add operation to list of batch operations.\r $operations->addDeleteEntity(\"mytable\", \"tasksSeattle\", \"1\");\r \r try    {\r     $tableRestProxy->batch($operations);\r }\r catch(ServiceException $e){\r     // Handle exception based on error codes and messages.\r     // Error codes and messages are here:\r     // http://msdn.microsoft.com/library/azure/dd179438.aspx\r     $code = $e->getCode();\r     $error_message = $e->getMessage();\r     echo $code.\": \".$error_message.\"<br />\";\r }\r ```\r \r 有关对表操作进行批处理的详细信息，请参阅 [执行实体组事务][entity-group-transactions]。\r \r ## <a name=\"delete-a-table\"></a>删除表\r 最后，若要删除表，请将表名传递到 **TableRestProxy->deleteTable** 方法。\r \r ```php\r require_once 'vendor/autoload.php';\r \r use WindowsAzure\\Common\\ServicesBuilder;\r use MicrosoftAzure\\Storage\\Common\\ServiceException;\r \r // Create table REST proxy.\r $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r \r try    {\r     // Delete table.\r     $tableRestProxy->deleteTable(\"mytable\");\r }\r catch(ServiceException $e){\r     // Handle exception based on error codes and messages.\r     // Error codes and messages are here:\r     // http://msdn.microsoft.com/library/azure/dd179438.aspx\r     $code = $e->getCode();\r     $error_message = $e->getMessage();\r     echo $code.\": \".$error_message.\"<br />\";\r }\r ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r 既已了解 Azure 表服务的基础知识，可单击以下链接了解有关更复杂的存储任务的信息。\r \r * [Azure 存储资源管理器](../vs-azure-tools-storage-manage-with-storage-explorer.md)是我们免费提供的独立应用，适用于在 Windows、macOS 和 Linux 上以可视方式处理 Azure 存储数据。\r \r * [PHP 开发人员中心](/develop/php/)。\r \r [download]: /php-download-sdk\r [require_once]: http://php.net/require_once\r [table-service-timeouts]: http://msdn.microsoft.com/library/azure/dd894042.aspx\r \r [table-data-model]: http://msdn.microsoft.com/library/azure/dd179338.aspx\r [filters]: http://msdn.microsoft.com/library/azure/dd894031.aspx\r [entity-group-transactions]: http://msdn.microsoft.com/library/azure/dd894038.aspx\r \r <!-- Update_Description: update meta properties, wording update -->"}