{"Title":"使用 Visual Studio 和 C# 的 Apache Storm 拓扑 - Azure HDInsight","Description":"了解如何在 C# 中创建 Storm 拓扑。 在 Visual Studio 中使用针对 Visual Studio 的 Hadoop 工具创建简单的字数统计拓扑。","Content":"# <a name=\"develop-c-topologies-for-apache-storm-by-using-the-data-lake-tools-for-visual-studio\"></a>使用针对 Visual Studio 的 Data Lake 工具开发 Apache Storm 的 C# 拓扑\r \r 了解如何使用针对 Visual Studio 的 Azure Data Lake (Hadoop) 工具创建 C# Storm 拓扑。 本文档逐步说明在 Visual Studio 中创建 Storm 项目、在本地测试该项目，然后将它部署到 Apache Storm on Azure HDInsight 群集的过程。\r \r [!INCLUDE [azure-visual-studio-login-guide](../../../includes/azure-visual-studio-login-guide.md)]\r \r 同时还说明了如何创建使用 C# 和 Java 组件的混合拓扑。\r \r [!INCLUDE [hdinsight-linux-acn-version.md](../../../includes/hdinsight-linux-acn-version.md)]\r \r > [!NOTE]\r > 虽然本文档中的步骤依赖于具有 Visual Studio 的 Windows 开发环境，但编译后的项目可以提交到基于 Linux 或基于 Windows 的 HDInsight 群集。 仅在 2016 年 10 月 28 日以后创建的基于 Linux 的群集支持 SCP.NET 拓扑。\r \r 若要将 C# 拓扑与基于 Linux 的群集配合使用，必须将项目使用的 Microsoft.SCP.Net.SDK NuGet 包更新到 0.10.0.6 或更高版本。 包的版本还必须与 HDInsight 上安装的 Storm 的主要版本相符。\r \r | HDInsight 版本 | Storm 版本 | SCP.NET 版本 | 默认 Mono 版本 |\r |:-----------------:|:-------------:|:---------------:|:--------------------:|\r | 3.3 |0.10.x |0.10.x.x</br>（仅在基于 Windows 的 HDInsight 上） | 不可用 |\r | 3.4 | 0.10.0.x | 0.10.0.x | 3.2.8 |\r | 3.5 | 1.0.2.x | 1.0.0.x | 4.2.1 |\r | 3.6 | 1.1.0.x | 1.0.0.x | 4.2.8 |\r \r > [!IMPORTANT]\r > 基于 Linux 的群集上的 C# 拓扑必须使用 .NET 4.5，并使用 Mono 在 HDInsight 群集上运行。 请查看 [Mono 兼容性](http://www.mono-project.com/docs/about-mono/compatibility/)，了解可能的不兼容性。\r \r > [!WARNING]\r > 如果你在构建使用 SCP.NET 版本 1.0.0.x 的项目时遇到问题，请联系 Microsoft 支持部门以寻求帮助。\r \r ## <a name=\"install-visual-studio\"></a>安装 Visual Studio\r \r 通过安装以下 Visual Studio 版本之一，可以使用 SCP.NET 开发 C# 拓扑：\r \r * Visual Studio 2012 [Update 4](http://www.microsoft.com/download/details.aspx?id=39305)\r \r * Visual Studio 2013 [Update 4](http://www.microsoft.com/download/details.aspx?id=44921) 或 [Visual Studio 2013 Community](http://go.microsoft.com/fwlink/?LinkId=517284)\r \r * Visual Studio 2015 或 [Visual Studio 2015 Community](https://go.microsoft.com/fwlink/?LinkId=532606)\r \r * Visual Studio 2017（任何版本）\r \r ## <a name=\"install-data-lake-tools-for-visual-studio\"></a>安装针对 Visual Studio 的 Data Lake 工具\r \r 若要安装针对 Visual Studio 的 Data Lake 工具，请执行[针对 Visual Studio 的 Data Lake 工具使用入门](../hadoop/apache-hadoop-visual-studio-tools-get-started.md)中的步骤。\r \r ## <a name=\"install-java\"></a>安装 Java\r \r 从 Visual Studio 提交 Storm 拓扑时，SCP.NET 会生成一个包含拓扑和依赖项的 zip 文件。 使用 Java 来创建这些 zip 文件是因为其采用的格式更兼容基于 Linux 的群集。\r \r 1. 在开发环境中安装 Java 开发人员工具包 (JDK) 7 或更高版本。 可以从 [Oracle](http://www.oracle.com/technetwork/java/javase/downloads/index.html) 获取 Oracle JDK。 也可使用[其他 Java 发行版](http://openjdk.java.net/)。\r \r 2. `JAVA_HOME` 环境变量必须指向包含 Java 的目录。\r \r 3. `PATH` 环境变量必须包含 `%JAVA_HOME%\\bin` 目录。\r \r 可以使用以下 C# 控制台应用程序来验证 Java 和 JDK 是否已正确安装：\r \r ```csharp\r using System;\r using System.IO;\r namespace ConsoleApplication2\r {\r    class Program\r    {\r        static void Main(string[] args)\r        {\r            string javaHome = Environment.GetEnvironmentVariable(\"JAVA_HOME\");\r            if (!string.IsNullOrEmpty(javaHome))\r            {\r                string jarExe = Path.Combine(javaHome + @\"\\bin\", \"jar.exe\");\r                if (File.Exists(jarExe))\r                {\r                    Console.WriteLine(\"JAVA Is Installed properly\");\r                     return;\r                }\r                else\r                {\r                    Console.WriteLine(\"A valid JAVA JDK is not found. Looks like JRE is installed instead of JDK.\");\r                }\r            }\r            else\r            {\r              Console.WriteLine(\"A valid JAVA JDK is not found. JAVA_HOME environment variable is not set.\");\r            }\r        }  \r    }\r }\r ```\r \r ## <a name=\"storm-templates\"></a>Storm 模板\r \r 针对 Visual Studio 的 Data Lake 工具提供以下模板：\r \r | 项目类型 | 演示 |\r | --- | --- |\r | Storm 应用程序 |空的 Storm 拓扑项目。 |\r | Storm Azure SQL 写入器示例 |如何写入 Azure SQL 数据库。 |\r | Storm Azure Cosmos DB 读取器示例 |如何从 Azure Cosmos DB 读取。 |\r | Storm Azure Cosmos DB 写入器示例 |如何写入 Azure Cosmos DB。 |\r | Storm EventHub 读取器示例 |如何从 Azure 事件中心读取。 |\r | Storm EventHub 写入器示例 |如何写入 Azure 事件中心。 |\r | Storm HBase 读取器示例 |如何从 HBase on HDInsight 群集读取。 |\r | Storm HBase 写入器示例 |如何写入 HBase on HDInsight 群集。 |\r | Storm 混合示例 |如何使用 Java 组件。 |\r | Storm 示例 |基本的字数统计拓扑。 |\r \r > [!WARNING]\r > 并非所有的模板都可用于基于 Linux 的 HDInsight。 模板使用的 NuGet 程序包可能与 Mono 不兼容。 查看 [Mono 兼容性](http://www.mono-project.com/docs/about-mono/compatibility/)文档并使用 [.NET Portability Analyzer](../hdinsight-hadoop-migrate-dotnet-to-linux.md#automated-portability-analysis) 确定潜在问题。\r \r 在本文档的步骤中，使用基本 Storm 应用程序项目类型创建拓扑。\r \r ### <a name=\"hbase-templates-notes\"></a>HBase 模板说明\r \r HBase 读取器和写入器模板使用 HBase REST API（而不是 HBase Java API）与 HBase on HDInsight 群集通信。\r \r ### <a name=\"eventhub-templates-notes\"></a>EventHub 模板说明\r \r > [!IMPORTANT]\r > EventHub 读取器模板随附的基于 Java 的 EventHub Spout 组件不适用于 Storm on HDInsight 3.5 或更高版本。 [GitHub](https://github.com/hdinsight/hdinsight-storm-examples/tree/master/HDI3.5/lib) 上提供此组件的更新版本。\r \r 如需使用此组件且适用于 Storm on HDInsight 3.5 的示例拓扑，请参阅 [GitHub](https://github.com/Azure-Samples/hdinsight-dotnet-java-storm-eventhub)。\r \r ## <a name=\"create-a-c-topology\"></a>创建 C# 拓扑\r \r 1. 打开 Visual Studio，选择“文件” > “新建”，然后选择“项目”。\r \r 2. 在“新建项目”窗口中，展开“已安装” > “模板”，然后选择“Azure Data Lake”。 从模板列表中，选择“Storm 应用程序”。 在屏幕底部，输入 WordCount 作为应用程序名称。\r \r     ![“新建项目”窗口的屏幕截图](./media/apache-storm-develop-csharp-visual-studio-topology/new-project.png)\r \r 3. 创建项目后，应有以下文件：\r \r    * **Program.cs**：此文件定义项目的拓扑。 默认情况下会创建包含一个 Spout 和一个 Bolt 的默认拓扑。\r \r    * **Spout.cs**：发出随机数的示例 Spout。\r \r    * **Bolt.cs**：保留 Spout 所发出数字计数的示例 Bolt。\r \r      创建项目时，NuGet 会下载最新的 [SCP.NET 包](https://www.nuget.org/packages/Microsoft.SCP.Net.SDK/)。\r \r      [!INCLUDE [scp.net version important](../../../includes/hdinsight-storm-scpdotnet-version.md)]\r \r ### <a name=\"implement-the-spout\"></a>实现 Spout\r \r 1. 打开 **Spout.cs**。 Spout 用于将外部源中的数据读入拓扑。 Spout 的主要组件如下：\r \r    * **NextTuple**：允许 Spout 发出新的 Tuple 时由 Storm 调用。\r \r    * Ack（仅限事务拓扑）：针对从此 Spout 发送的元组，处理拓扑中其他组件发起的确认。 确认元组可让 Spout 知了解下游组件已成功处理元组。\r \r    * 失败（仅限事务拓扑）：处理无法处理拓扑中其他组件的元组。 实现 Fail 方法可以重新发出元组，以便对其再次处理。\r \r 2. 将 **Spout** 类的内容替换为以下文本。 此 Spout 随机将句子发出到拓扑中。\r \r     ```csharp\r     private Context ctx;\r     private Random r = new Random();\r     string[] sentences = new string[] {\r         \"the cow jumped over the moon\",\r         \"an apple a day keeps the doctor away\",\r         \"four score and seven years ago\",\r         \"snow white and the seven dwarfs\",\r         \"i am at two with nature\"\r     };\r \r     public Spout(Context ctx)\r     {\r         // Set the instance context\r         this.ctx = ctx;\r \r         Context.Logger.Info(\"Generator constructor called\");\r \r         // Declare Output schema\r         Dictionary<string, List<Type>> outputSchema = new Dictionary<string, List<Type>>();\r         // The schema for the default output stream is\r         // a tuple that contains a string field\r         outputSchema.Add(\"default\", new List<Type>() { typeof(string) });\r         this.ctx.DeclareComponentSchema(new ComponentStreamSchema(null, outputSchema));\r     }\r \r     // Get an instance of the spout\r     public static Spout Get(Context ctx, Dictionary<string, Object> parms)\r     {\r         return new Spout(ctx);\r     }\r \r     public void NextTuple(Dictionary<string, Object> parms)\r     {\r         Context.Logger.Info(\"NextTuple enter\");\r         // The sentence to be emitted\r         string sentence;\r \r         // Get a random sentence\r         sentence = sentences[r.Next(0, sentences.Length - 1)];\r         Context.Logger.Info(\"Emit: {0}\", sentence);\r         // Emit it\r         this.ctx.Emit(new Values(sentence));\r \r         Context.Logger.Info(\"NextTuple exit\");\r     }\r \r     public void Ack(long seqId, Dictionary<string, Object> parms)\r     {\r         // Only used for transactional topologies\r     }\r \r     public void Fail(long seqId, Dictionary<string, Object> parms)\r     {\r         // Only used for transactional topologies\r     }\r     ```\r \r ### <a name=\"implement-the-bolts\"></a>实现 Bolt\r \r 1. 删除项目中的现有 **Bolt.cs** 文件。\r \r 2. 在“解决方案资源管理器”中，右键单击该项目，然后选择“添加” > “新建项”。 从列表中选择“Storm Bolt”，然后输入 Splitter.cs 作为名称。 **Counter.cs**的另一个 Bolt。\r \r    * Splitter.cs：实现 Bolt，将句子拆分成不同的单词并发出一串新单词。\r \r    * Counter.cs：实现 Bolt，对每个单词计数，并发出一串新单词和每个单词的计数。\r \r      > [!NOTE]\r      > 这些 Bolt 读取和写入流，但是你也可以使用 Bolt 来与数据库或服务等源进行通信。\r \r 3. 打开 **Splitter.cs**。 默认情况下它只包含一个方法： **Execute**。 在 Bolt 收到要处理的元组时会调用 Execute 方法。 此时，可读取和处理传入元组，以及发出传出元组。\r \r 4. 将 **Splitter** 类的内容替换为以下代码：\r \r     ```csharp\r     private Context ctx;\r \r     // Constructor\r     public Splitter(Context ctx)\r     {\r         Context.Logger.Info(\"Splitter constructor called\");\r         this.ctx = ctx;\r \r         // Declare Input and Output schemas\r         Dictionary<string, List<Type>> inputSchema = new Dictionary<string, List<Type>>();\r         // Input contains a tuple with a string field (the sentence)\r         inputSchema.Add(\"default\", new List<Type>() { typeof(string) });\r         Dictionary<string, List<Type>> outputSchema = new Dictionary<string, List<Type>>();\r         // Outbound contains a tuple with a string field (the word)\r         outputSchema.Add(\"default\", new List<Type>() { typeof(string) });\r         this.ctx.DeclareComponentSchema(new ComponentStreamSchema(inputSchema, outputSchema));\r     }\r \r     // Get a new instance of the bolt\r     public static Splitter Get(Context ctx, Dictionary<string, Object> parms)\r     {\r         return new Splitter(ctx);\r     }\r \r     // Called when a new tuple is available\r     public void Execute(SCPTuple tuple)\r     {\r         Context.Logger.Info(\"Execute enter\");\r \r         // Get the sentence from the tuple\r         string sentence = tuple.GetString(0);\r         // Split at space characters\r         foreach (string word in sentence.Split(' '))\r         {\r             Context.Logger.Info(\"Emit: {0}\", word);\r             //Emit each word\r             this.ctx.Emit(new Values(word));\r         }\r \r         Context.Logger.Info(\"Execute exit\");\r     }\r     ```\r \r 5. 打开 Counter.cs，将类内容替换为以下内容：\r \r     ```csharp\r     private Context ctx;\r \r     // Dictionary for holding words and counts\r     private Dictionary<string, int> counts = new Dictionary<string, int>();\r \r     // Constructor\r     public Counter(Context ctx)\r     {\r         Context.Logger.Info(\"Counter constructor called\");\r         // Set instance context\r         this.ctx = ctx;\r \r         // Declare Input and Output schemas\r         Dictionary<string, List<Type>> inputSchema = new Dictionary<string, List<Type>>();\r         // A tuple containing a string field - the word\r         inputSchema.Add(\"default\", new List<Type>() { typeof(string) });\r \r         Dictionary<string, List<Type>> outputSchema = new Dictionary<string, List<Type>>();\r         // A tuple containing a string and integer field - the word and the word count\r         outputSchema.Add(\"default\", new List<Type>() { typeof(string), typeof(int) });\r         this.ctx.DeclareComponentSchema(new ComponentStreamSchema(inputSchema, outputSchema));\r     }\r \r     // Get a new instance\r     public static Counter Get(Context ctx, Dictionary<string, Object> parms)\r     {\r         return new Counter(ctx);\r     }\r \r     // Called when a new tuple is available\r     public void Execute(SCPTuple tuple)\r     {\r         Context.Logger.Info(\"Execute enter\");\r \r         // Get the word from the tuple\r         string word = tuple.GetString(0);\r         // Do we already have an entry for the word in the dictionary?\r         // If no, create one with a count of 0\r         int count = counts.ContainsKey(word) ? counts[word] : 0;\r         // Increment the count\r         count++;\r         // Update the count in the dictionary\r         counts[word] = count;\r \r         Context.Logger.Info(\"Emit: {0}, count: {1}\", word, count);\r         // Emit the word and count information\r         this.ctx.Emit(Constants.DEFAULT_STREAM_ID, new List<SCPTuple> { tuple }, new Values(word, count));\r         Context.Logger.Info(\"Execute exit\");\r     }\r     ```\r \r ### <a name=\"define-the-topology\"></a>定义拓扑\r \r Spout 和 Bolt 以图形方式排列，用于定义数据在组件之间的流动方式。 此拓扑的图形如下：\r \r ![组件排列方式图](./media/apache-storm-develop-csharp-visual-studio-topology/wordcount-topology.png)\r \r 句子从 Spout 发出，然后分布到 Splitter Bolt 的实例。 Splitter Bolt 将句子分割成多个单词，并将这些单词分布到 Counter Bolt。\r \r 因为字数会本地保留在 Counter 实例中，所以我们想要确保特定单词流向相同的 Counter Bolt 实例。 每个实例都会跟踪特定的单词。 由于 Splitter Bolt 不保留任何状态，因此哪个 Splitter 实例接收哪个语句无关紧要。\r \r 打开 **Program.cs**。 重要的方法是 **GetTopologyBuilder**，用于定义提交到 Storm 的拓扑。 将 **GetTopologyBuilder** 的内容替换为以下代码，以实现上面所述的拓扑：\r \r ```csharp\r // Create a new topology named 'WordCount'\r TopologyBuilder topologyBuilder = new TopologyBuilder(\"WordCount\" + DateTime.Now.ToString(\"yyyyMMddHHmmss\"));\r \r // Add the spout to the topology.\r // Name the component 'sentences'\r // Name the field that is emitted as 'sentence'\r topologyBuilder.SetSpout(\r     \"sentences\",\r     Spout.Get,\r     new Dictionary<string, List<string>>()\r     {\r         {Constants.DEFAULT_STREAM_ID, new List<string>(){\"sentence\"}}\r     },\r     1);\r // Add the splitter bolt to the topology.\r // Name the component 'splitter'\r // Name the field that is emitted 'word'\r // Use suffleGrouping to distribute incoming tuples\r //   from the 'sentences' spout across instances\r //   of the splitter\r topologyBuilder.SetBolt(\r     \"splitter\",\r     Splitter.Get,\r     new Dictionary<string, List<string>>()\r     {\r         {Constants.DEFAULT_STREAM_ID, new List<string>(){\"word\"}}\r     },\r     1).shuffleGrouping(\"sentences\");\r \r // Add the counter bolt to the topology.\r // Name the component 'counter'\r // Name the fields that are emitted 'word' and 'count'\r // Use fieldsGrouping to ensure that tuples are routed\r //   to counter instances based on the contents of field\r //   position 0 (the word). This could also have been\r //   List<string>(){\"word\"}.\r //   This ensures that the word 'jumped', for example, will always\r //   go to the same instance\r topologyBuilder.SetBolt(\r     \"counter\",\r     Counter.Get,\r     new Dictionary<string, List<string>>()\r     {\r         {Constants.DEFAULT_STREAM_ID, new List<string>(){\"word\", \"count\"}}\r     },\r     1).fieldsGrouping(\"splitter\", new List<int>() { 0 });\r \r // Add topology config\r topologyBuilder.SetTopologyConfig(new Dictionary<string, string>()\r {\r     {\"topology.kryo.register\",\"[\\\"[B\\\"]\"}\r });\r \r return topologyBuilder;\r ```\r \r ## <a name=\"submit-the-topology\"></a>提交拓扑\r \r 1. 在“解决方案资源管理器”中，右键单击项目，并选择“提交到 Storm on HDInsight”。\r \r    > [!NOTE]\r    > 如果出现提示，请输入 Azure 订阅的凭据。 如果有多个订阅，请登录到包含 Storm on HDInsight 群集的订阅。\r \r 2. 从“Storm 群集”下拉列表中选择 Storm on HDInsight 群集，并选择“提交”。 可使用“输出”窗口监视提交是否成功。\r \r 3. 成功提交拓扑之后，应该会出现群集的“Storm 拓扑”。 从列表中选择“WordCount”拓扑，查看正在运行的拓扑的信息。\r \r    > [!NOTE]\r    > 也可在“服务器资源管理器”中查看“Storm 拓扑”。 展开“Azure” > “HDInsight”，右键单击 Storm on HDInsight 群集，然后选择“查看 Storm 拓扑”。\r \r     若要查看拓扑中组件的信息，请双击图中的组件。\r \r 4. 在“拓扑摘要”视图中，单击“终止”以停止拓扑。\r \r    > [!NOTE]\r    > Storm 拓扑会一直运行，直到它被停用，或者群集被删除。\r \r ## <a name=\"transactional-topology\"></a>事务拓扑\r \r 前面的拓扑是非事务性的拓扑中的组件不实现重播消息的功能。 拓扑中的组件不会实现重播消息的功能。 如需事务拓扑的示例，请创建一个项目，然后选择“Storm 示例”作为项目类型。\r \r 事务拓扑会实现以下项来支持重播数据：\r \r * 元数据缓存：Spout 必须存储所发出数据的元数据，这样，在失败时，就可以再次检索和发出数据。 此示例所发出的数据较少，因此将每个元组的原始数据存储在字典中以便重播。\r \r * Ack：拓扑中的每个 Bolt 都可以调用 `this.ctx.Ack(tuple)` 来确认它已成功处理元组。 所有 Bolt 都已确认 Tuple 之后，即会调用 Spout 的 `Ack` 方法。 `Ack` 方法允许 Spout 删除为重放而缓存的数据。\r \r * 失败：每个 Bolt 都可以调用 `this.ctx.Fail(tuple)`，指出元组的处理失败。 这项失败会传播到 Spout 的 `Fail` 方法，在其中，可以使用缓存的元数据来重放 Tuple。\r \r * **序列 ID**：发出元组时，可以指定唯一的序列 ID。 此值标识要进行重播（确认和失败）处理的元组。 例如，发出数据时， **Storm 示例** 项目中的 Spout 会使用以下项：\r \r         this.ctx.Emit(Constants.DEFAULT_STREAM_ID, new Values(sentence), lastSeqId);\r \r     此代码会发出包含默认数据流的句子的元组，以及 **lastSeqId** 中所含的序列 ID 值。 在此示例中，会递增每个发出的元组的 **lastSeqId** 。\r \r 如“Storm 示例”项目所示，在运行时，可以根据配置来设置组件是否为事务性。\r \r ## <a name=\"hybrid-topology-with-c-and-java\"></a>使用 C# 和 Java 的混合拓扑\r \r 还可使用针对 Visual Studio 的 Data Lake 工具来创建混合拓扑，其中的某些组件采用 C# 编写，另一些组件采用 Java 编写。\r \r 如需混合拓扑的示例，请创建一个项目，然后选择“Storm 混合示例”。 此示例类型演示以下概念：\r \r * Java Spout 和 C# Bolt：在 HybridTopology_javaSpout_csharpBolt 中定义。\r \r     * 事务版本在 HybridTopologyTx_javaSpout_csharpBolt 中定义。\r \r * C# Spout 和 Java Bolt：在 HybridTopology_csharpSpout_javaBolt 中定义。\r \r     * 事务版本在 HybridTopologyTx_csharpSpout_javaBolt 中定义。\r \r   > [!NOTE]\r   > 此版本还演示了如何使用文本文件中的 clojure 代码作为 Java 组件。\r \r 若要切换在提交项目时使用的拓扑，只需将 `[Active(true)]` 语句移到要在提交给群集之前使用的拓扑即可。\r \r > [!NOTE]\r > 在 **JavaDependency** 文件夹中，所需的所有 Java 文件都会提供为此项目的一部分。\r \r 创建和提交混合拓扑时，需注意以下事项：\r \r * 必须使用 JavaComponentConstructor 来创建 Spout 或 Bolt 的 Java 类的实例。\r \r * 应该使用 microsoft.scp.storm.multilang.CustomizedInteropJSONSerializer 将传入或传出 Java 组件的数据从 Java 对象序列化为 JSON。\r \r * 将拓扑提交到服务器时，必须使用“其他配置”选项指定 Java 文件路径。 指定的路径应该是包含 JAR 文件的目录，而 JAR 文件包含 Java 类。\r \r ### <a name=\"azure-event-hubs\"></a>Azure 事件中心\r \r SCP.NET 版本 0.9.4.203 引入了专用于事件中心 Spout（从事件中心读取数据的 Java Spout）的新类和方法。 创建采用事件中心 Spout 的拓扑时，请使用以下方法：\r \r * EventHubSpoutConfig 类：创建一个对象，其中包含 Spout 组件的配置。\r \r * TopologyBuilder.SetEventHubSpout 方法：将事件中心 Spout 组件添加到拓扑。\r \r > [!NOTE]\r > 仍然必须使用 CustomizedInteropJSONSerializer 来序列化 Spout 所生成的数据。\r \r ## <a id=\"configurationmanager\"></a>使用 ConfigurationManager\r \r 请勿使用 ConfigurationManager 从 Bolt 和 Spout 组件检索配置值。 这样做可能导致空指针异常。 而项目的配置将作为拓扑上下文中的键值对传递到 Storm 拓扑中。 每个依赖于配置值的组件都必须在初始化过程中从上下文检索这些值。\r \r 下面的代码演示如何检索这些值：\r \r ```csharp\r public class MyComponent : ISCPBolt\r {\r     // To hold configuration information loaded from context\r     Configuration configuration;\r     ...\r     public MyComponent(Context ctx, Dictionary<string, Object> parms)\r     {\r         // Save a copy of the context for this component instance\r         this.ctx = ctx;\r         // If it exists, load the configuration for the component\r         if(parms.ContainsKey(Constants.USER_CONFIG))\r         {\r             this.configuration = parms[Constants.USER_CONFIG] as System.Configuration.Configuration;\r         }\r         // Retrieve the value of \"Foo\" from configuration\r         var foo = this.configuration.AppSettings.Settings[\"Foo\"].Value;\r     }\r     ...\r }\r ```\r \r 如果使用 `Get` 方法返回组件的实例，则必须确保它将 `Context` 和 `Dictionary<string, Object>` 参数都传递给构造函数。 以下示例是一个基本的 `Get` 方法，用于正确传递这些值：\r \r ```csharp\r public static MyComponent Get(Context ctx, Dictionary<string, Object> parms)\r {\r     return new MyComponent(ctx, parms);\r }\r ```\r \r ## <a name=\"how-to-update-scpnet\"></a>如何更新 SCP.NET\r \r 最新版 SCP.NET 支持通过 NuGet 进行包升级。 有新的更新可用时，会收到升级通知。 若要手动检查升级，请执行以下步骤：\r \r 1. 在“解决方案资源管理器”中，右键单击项目，然后选择“管理 NuGet 包”。\r \r 2. 从包管理器中选择“更新”。 有可用更新时会将其列出。 单击“更新”可让包安装更新。\r \r > [!IMPORTANT]\r > 如果项目是通过未使用 NuGet 的旧版 SCP.NET 创建的，则必须执行以下步骤以更新到新版本：\r >\r > 1. 在“解决方案资源管理器”中，右键单击项目，然后选择“管理 NuGet 包”。\r > 2. 使用“搜索”字段搜索 Microsoft.SCP.Net.SDK，然后将其添加到项目中。\r \r ## <a name=\"troubleshoot-common-issues-with-topologies\"></a>排查拓扑常见问题\r \r ### <a name=\"null-pointer-exceptions\"></a>空指针异常\r \r 在基于 Linux 的 HDInsight 集群中使用 C＃ 拓扑时，使用 ConfigurationManager 在运行时读取配置设置的 bolt 和 spout 组件可能会返回空指针异常。\r \r 项目的配置将作为拓扑上下文中的键值对传递到 Storm 拓扑中。 该配置可以从字典对象进行检索，字典对象是在初始化组件时传递到组件的。\r \r 有关详细信息，请参阅本文档的 [ConfigurationManager](#configurationmanager) 部分。\r \r ### <a name=\"systemtypeloadexception\"></a>System.TypeLoadException\r \r 在基于 Linux 的 HDInsight 群集中使用 C＃ 拓扑时，可能会遇到以下错误：\r \r     System.TypeLoadException: Failure has occurred while loading a type.\r \r 如果使用二进制文件，而该文件不兼容 Mono 支持的 .NET 版本，通常会发生此错误。\r \r 对于基于 Linux 的 HDInsight 群集，请确保项目使用的二进制文件是针对 .NET 4.5 编译的。\r \r ### <a name=\"test-a-topology-locally\"></a>在本地测试拓扑\r \r 虽然很容易就可以将拓扑部署到群集，但是，在某些情况下，可能需要在本地测试拓扑。 使用以下步骤，在开发环境上本地执行和测试本教程中的示例拓扑。\r \r > [!WARNING]\r > 本地测试只适用于仅限 C# 的基本拓扑。 不能将本地测试用于混合拓扑或使用多个流的拓扑。\r \r 1. 在“解决方案资源管理器”中，右键单击项目，然后选择“属性”。 在项目属性中，将“输出类型”更改为“控制台应用程序”。\r \r     ![项目属性的屏幕截图，已突出显示输出类型](./media/apache-storm-develop-csharp-visual-studio-topology/outputtype.png)\r \r    > [!NOTE]\r    > 将拓扑部署到群集之前，请记得将“输出类型”改回“类库”。\r \r 2. 在“解决方案资源管理器”中，右键单击项目，然后选择“添加” > “新建项”。 选择“类”，并输入 LocalTest.cs 作为类名称。 最后，单击“添加”。\r \r 3. 打开 LocalTest.cs，在顶部添加以下 using 语句：\r \r     ```csharp\r     using Microsoft.SCP;\r     ```\r \r 4. 使用以下代码作为 **LocalTest** 类的内容：\r \r     ```csharp\r     // Drives the topology components\r     public void RunTestCase()\r     {\r         // An empty dictionary for use when creating components\r         Dictionary<string, Object> emptyDictionary = new Dictionary<string, object>();\r \r         #region Test the spout\r         {\r             Console.WriteLine(\"Starting spout\");\r             // LocalContext is a local-mode context that can be used to initialize\r             // components in the development environment.\r             LocalContext spoutCtx = LocalContext.Get();\r             // Get a new instance of the spout, using the local context\r             Spout sentences = Spout.Get(spoutCtx, emptyDictionary);\r \r             // Emit 10 tuples\r             for (int i = 0; i < 10; i++)\r             {\r                 sentences.NextTuple(emptyDictionary);\r             }\r             // Use LocalContext to persist the data stream to file\r             spoutCtx.WriteMsgQueueToFile(\"sentences.txt\");\r             Console.WriteLine(\"Spout finished\");\r         }\r         #endregion\r \r         #region Test the splitter bolt\r         {\r             Console.WriteLine(\"Starting splitter bolt\");\r             // LocalContext is a local-mode context that can be used to initialize\r             // components in the development environment.\r             LocalContext splitterCtx = LocalContext.Get();\r             // Get a new instance of the bolt\r             Splitter splitter = Splitter.Get(splitterCtx, emptyDictionary);\r \r             // Set the data stream to the data created by the spout\r             splitterCtx.ReadFromFileToMsgQueue(\"sentences.txt\");\r             // Get a batch of tuples from the stream\r             List<SCPTuple> batch = splitterCtx.RecvFromMsgQueue();\r             // Process each tuple in the batch\r             foreach (SCPTuple tuple in batch)\r             {\r                 splitter.Execute(tuple);\r             }\r             // Use LocalContext to persist the data stream to file\r             splitterCtx.WriteMsgQueueToFile(\"splitter.txt\");\r             Console.WriteLine(\"Splitter bolt finished\");\r         }\r         #endregion\r \r         #region Test the counter bolt\r         {\r             Console.WriteLine(\"Starting counter bolt\");\r             // LocalContext is a local-mode context that can be used to initialize\r             // components in the development environment.\r             LocalContext counterCtx = LocalContext.Get();\r             // Get a new instance of the bolt\r             Counter counter = Counter.Get(counterCtx, emptyDictionary);\r \r             // Set the data stream to the data created by splitter bolt\r             counterCtx.ReadFromFileToMsgQueue(\"splitter.txt\");\r             // Get a batch of tuples from the stream\r             List<SCPTuple> batch = counterCtx.RecvFromMsgQueue();\r             // Process each tuple in the batch\r             foreach (SCPTuple tuple in batch)\r             {\r                 counter.Execute(tuple);\r             }\r             // Use LocalContext to persist the data stream to file\r             counterCtx.WriteMsgQueueToFile(\"counter.txt\");\r             Console.WriteLine(\"Counter bolt finished\");\r         }\r         #endregion\r     }\r     ```\r \r     花费片刻时间通读代码注释。 此代码使用 **LocalContext** 在开发环境中运行组件，并将组件之间的数据流保存到本地磁盘驱动器上的文本文件中。\r \r 1. 打开 Program.cs，将以下代码添加到 Main 方法中：\r \r     ```csharp\r     Console.WriteLine(\"Starting tests\");\r     System.Environment.SetEnvironmentVariable(\"microsoft.scp.logPrefix\", \"WordCount-LocalTest\");\r     // Initialize the runtime\r     SCPRuntime.Initialize();\r \r     //If we are not running under the local context, throw an error\r     if (Context.pluginType != SCPPluginType.SCP_NET_LOCAL)\r     {\r         throw new Exception(string.Format(\"unexpected pluginType: {0}\", Context.pluginType));\r     }\r     // Create test instance\r     LocalTest tests = new LocalTest();\r     // Run tests\r     tests.RunTestCase();\r     Console.WriteLine(\"Tests finished\");\r     Console.ReadKey();\r     ```\r \r 2. 保存更改，然后单击“F5”，或选择“调试” > “开始调试”以启动项目。 此时会出现一个控制台窗口，该窗口会在测试进行过程中记录状态。 显示“测试已完成”后，按任意键关闭窗口。\r \r 3. 使用 Windows 资源管理器找到包含项目的目录。 例如：**C:\\Users\\<your_user_name>\\Documents\\Visual Studio 2013\\Projects\\WordCount\\WordCount**。 在此目录中打开 Bin，然后单击“调试”。 应可看到运行测试时生成的文本文件：sentences.txt、counter.txt 和 splitter.txt。 打开每个文本文件并检查数据。\r \r    > [!NOTE]\r    > 字符串数据在这些文件中持久保存为十进制值数组。 例如，splitter.txt 文件中的 \\[[97,103,111]] 是单词“and”。\r \r > [!NOTE]\r > 在部署到 Storm on HDInsight 群集之前，请确保将“项目类型”设置回“类库”。\r \r ### <a name=\"log-information\"></a>记录信息\r \r 可以使用 `Context.Logger`轻松记录拓扑组件中的信息。 例如，以下代码会创建一个信息日志条目：\r \r ```csharp\r Context.Logger.Info(\"Component started\");\r ```\r \r 可从“服务器资源管理器”中的“Hadoop 服务日志”查看记录的信息。 展开 Storm on HDInsight 群集的条目，然后展开“Hadoop 服务日志”。 最后，选择要查看的日志文件。\r \r > [!NOTE]\r > 日志存储在群集使用的 Azure 存储帐户中。 若要查看 Visual Studio 中的日志，必须登录到拥有存储帐户的 Azure 订阅。\r \r ### <a name=\"view-error-information\"></a>查看错误信息\r \r 若要查看运行中拓扑中所发生的错误，请使用以下步骤：\r \r 1. 在“服务器资源管理器”中，右键单击 Storm on HDInsight 群集，然后选择“查看 Storm 拓扑”。\r \r 2. 对于 Spout 和 Bolt，“上一错误”列包含有关上次错误的信息。\r \r 3. 选择有错误列出的组件的“Spout ID”或“Bolt ID”。 在显示的详细信息页上，页面底部的“错误”部分中列出了其他错误信息。\r \r 4. 若要获取详细信息，请从页面的“执行器”部分中选择“端口”，以查看最后几分钟的 Storm 工作进程日志。\r \r ### <a name=\"errors-submitting-topologies\"></a>提交拓扑时出错\r \r 如果将拓扑提交到 HDInsight 时遇到错误，可在 HDInsight 群集上找到处理拓扑提交的服务器端组件的日志。 若要检索这些日志，请从命令行使用以下命令：\r \r     scp sshuser@clustername-ssh.azurehdinsight.cn:/var/log/hdinsight-scpwebapi/hdinsight-scpwebapi.out .\r \r 将 __sshuser__ 替换为群集的 SSH 用户帐户。 将 __clustername__ 替换为 HDInsight 群集的名称。 有关将 `scp` 和 `ssh` 与 HDInsight 配合使用的详细信息，请参阅[将 SSH 与 HDInsight 配合使用](../hdinsight-hadoop-linux-use-ssh-unix.md)。\r \r 提交失败可能有多个原因：\r \r * JDK 未安装或不在路径中。\r * 提交中不包括必需的 Java 依赖项。\r * 依赖项不兼容。\r * 拓扑名称重复。\r \r 如果 `hdinsight-scpwebapi.out` 日志包含 `FileNotFoundException`，则可能是由以下情况导致的：\r \r * JDK 不在开发环境的路径中。 请验证 JDK 是否安装在开发环境中，以及 `%JAVA_HOME%/bin` 是否在路径中。\r * 缺少 Java 依赖项。 请确保提交内容包括任何必需的 .jar 文件。\r \r ## <a name=\"next-steps\"></a>后续步骤\r \r 如需处理事件中心数据的示例，请参阅[使用 Storm on HDInsight 处理 Azure 事件中心的事件](apache-storm-develop-csharp-event-hub-topology.md)。\r \r 如需将流数据拆分为多个流的 C# 拓扑示例，请参阅 [C# Storm 示例](https://github.com/Blackmist/csharp-storm-example)。\r \r 若要详细了解如何创建 C# 拓扑，请查看 [GitHub](https://github.com/hdinsight/hdinsight-storm-examples/blob/master/SCPNet-GettingStarted.md)。\r \r 有关 HDInsight 的其他用法和其他 Storm on HDinsight 示例，请参阅以下文档：\r \r **Microsoft SCP.NET**\r \r * [SCP 编程指南](apache-storm-scp-programming-guide.md)\r \r **Apache Storm on HDInsight**\r \r * [使用 Apache Storm on HDInsight 部署和监视拓扑](apache-storm-deploy-monitor-topology.md)\r * [Storm on HDInsight 的示例拓扑](apache-storm-example-topology.md)\r \r **Apache HDInsight 上的 Hadoop**\r \r * [将 Hive 与 Hadoop on HDInsight 配合使用](../hadoop/hdinsight-use-hive.md)\r * [将 Pig 与 Hadoop on HDInsight 配合使用](../hadoop/hdinsight-use-pig.md)\r * [将 MapReduce 与 HDInsight 上的 Hadoop 配合使用](../hadoop/hdinsight-use-mapreduce.md)\r \r **Apache HBase on HDInsight**\r \r * [HBase on HDInsight 入门](../hbase/apache-hbase-tutorial-get-started-linux.md)\r \r <!--Update_Description: update wording and link references-->"}