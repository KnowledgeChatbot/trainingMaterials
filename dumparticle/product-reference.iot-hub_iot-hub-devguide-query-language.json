{"Title":"了解 IoT 中心查询语言","Description":"开发人员指南 - 介绍类似 SQL 的 IoT 中心查询语言，该语言用于在 IoT 中心检索设备孪生和作业的相关信息。","Content":"# <a name=\"reference---iot-hub-query-language-for-device-twins-jobs-and-message-routing\"></a>参考 - 用于设备孪生、作业和消息路由的 IoT 中心查询语言\r \r IoT 中心提供类似于 SQL 的强大语言，用于检索有关[设备孪生][lnk-twins]和[作业][lnk-jobs]以及[消息路由][lnk-devguide-messaging-routes]的信息。 本文内容：\r \r * IoT 中心查询语言的主要功能简介，以及\r * 语言的详细说明。\r \r ## <a name=\"device-twin-queries\"></a>设备孪生查询\r [设备孪生][lnk-twins] 可以包含标记和属性形式的任意 JSON 对象。 通过 IoT 中心，可将设备孪生作为包含所有设备孪生信息的 JSON 文档进行查询。\r 例如，假设 IoT 中心设备孪生采用以下结构：\r \r ```json\r {\r     \"deviceId\": \"myDeviceId\",\r     \"etag\": \"AAAAAAAAAAc=\",\r     \"tags\": {\r         \"location\": {\r             \"region\": \"CN\",\r             \"plant\": \"Redmond43\"\r         }\r     },\r     \"properties\": {\r         \"desired\": {\r             \"telemetryConfig\": {\r                 \"configId\": \"db00ebf5-eeeb-42be-86a1-458cccb69e57\",\r                 \"sendFrequencyInSecs\": 300\r             },\r             \"$metadata\": {\r             ...\r             },\r             \"$version\": 4\r         },\r         \"reported\": {\r             \"connectivity\": {\r                 \"type\": \"cellular\"\r             },\r             \"telemetryConfig\": {\r                 \"configId\": \"db00ebf5-eeeb-42be-86a1-458cccb69e57\",\r                 \"sendFrequencyInSecs\": 300,\r                 \"status\": \"Success\"\r             },\r             \"$metadata\": {\r             ...\r             },\r             \"$version\": 7\r         }\r     }\r }\r ```\r \r IoT 中心将设备孪生公开为名为 **设备**的文档集合。\r 因此，以下查询将检索设备孪生的整个集：\r \r ```sql\r SELECT * FROM devices\r ```\r \r > [!NOTE]\r > [Azure IoT SDK][lnk-hub-sdks] 支持将大型结果分页：\r >\r >\r \r \r IoT 中心允许使用任意条件检索设备孪生筛选结果。 例如，若要接收 **location.region** 标记设置为 **CN** 的设备孪生，请使用以下查询：\r \r ```sql\r SELECT * FROM devices\r WHERE tags.location.region = 'CN'\r ```\r \r 还支持布尔运算符和算术比较。 例如，若要接收位于中国且配置为每隔不到一分钟就发送遥测数据的设备孪生，请使用以下查询：\r \r ```sql\r SELECT * FROM devices\r WHERE tags.location.region = 'CN'\r     AND properties.reported.telemetryConfig.sendFrequencyInSecs >= 60\r ```\r \r 方便起见，还可将数组常量与 **IN** 和 **NIN**（不包含）运算符结合使用。 例如，若要检索报告了 WiFi 或有线连接的设备孪生，请使用以下查询：\r \r ```sql\r SELECT * FROM devices\r WHERE properties.reported.connectivity IN ['wired', 'wifi']\r ```\r \r 通常需要它才能识别包含特定属性的所有设备孪生。 为此，IoT 中心支持函数 `is_defined()` 。 例如，若要检索定义了 `connectivity` 属性的设备孪生，请使用以下查询：\r \r ```SQL\r SELECT * FROM devices\r WHERE is_defined(properties.reported.connectivity)\r ```\r \r 有关筛选功能的完整参考，请参阅 [WHERE 子句][lnk-query-where] 部分。\r \r 此外还支持分组与聚合。 例如，若要查明每个遥测配置中的设备计数，请使用以下查询：\r \r ```sql\r SELECT properties.reported.telemetryConfig.status AS status,\r     COUNT() AS numberOfDevices\r FROM devices\r GROUP BY properties.reported.telemetryConfig.status\r ```\r \r 此分组查询将返回类似于以下示例的结果。 这里，三个设备报告了成功配置，两个仍在应用配置，一个报告了错误。 \r \r ```json\r [\r     {\r         \"numberOfDevices\": 3,\r         \"status\": \"Success\"\r     },\r     {\r         \"numberOfDevices\": 2,\r         \"status\": \"Pending\"\r     },\r     {\r         \"numberOfDevices\": 1,\r         \"status\": \"Error\"\r     }\r ]\r ```\r \r ### <a name=\"c-example\"></a>C# 示例\r 查询功能由 [C# 服务 SDK][lnk-hub-sdks] 在 **RegistryManager** 类中公开。\r 下面是一个简单的查询示例：\r \r ```csharp\r var query = registryManager.CreateQuery(\"SELECT * FROM devices\", 100);\r while (query.HasMoreResults)\r {\r     var page = await query.GetNextAsTwinAsync();\r     foreach (var twin in page)\r     {\r         // do work on twin object\r     }\r }\r ```\r \r 请注意如何使用页面大小（最大 1000）实例化 **query** 对象，并通过调用 **GetNextAsTwinAsync** 方法多次来检索多个页面。\r 请注意，查询对象会公开多个 **Next\\***，具体取决于查询所需的反序列化选项（如设备孪生或作业对象）或者使用投影时要用的普通 JSON。\r \r ### <a name=\"nodejs-example\"></a>Node.js 示例\r 查询功能由 [适用于 Node.js 的 Azure IoT 服务 SDK][lnk-hub-sdks] 在 **Registry** 对象中公开。\r 下面是一个简单的查询示例：\r \r ```nodejs\r var query = registry.createQuery('SELECT * FROM devices', 100);\r var onResults = function(err, results) {\r     if (err) {\r         console.error('Failed to fetch the results: ' + err.message);\r     } else {\r         // Do something with the results\r         results.forEach(function(twin) {\r             console.log(twin.deviceId);\r         });\r \r         if (query.hasMoreResults) {\r             query.nextAsTwin(onResults);\r         }\r     }\r };\r query.nextAsTwin(onResults);\r ```\r \r 请注意如何使用页面大小（最大 1000）实例化 **query** 对象，并通过调用 **nextAsTwin** 方法多次来检索多个页面。\r 请注意，查询对象会公开多个 **next\\***，具体取决于查询所需的反序列化选项（如设备孪生或作业对象）或者使用投影时要用的普通 JSON。\r \r ### <a name=\"limitations\"></a>限制\r > [!IMPORTANT]\r > 关于设备孪生中的最新值，查询结果可能有几分钟的延迟。 如果按 ID 查询单个设备孪生，将始终优先使用检索设备孪生 API，它始终包含最新值并具有较高的限制。\r >\r >\r \r 目前，仅支持在基元类型（无对象）之间进行比较，例如，仅在这些属性具有基元值时才支持 `... WHERE properties.desired.config = properties.reported.config`。\r \r ## <a name=\"get-started-with-jobs-queries\"></a>作业查询入门\r [Jobs][lnk-jobs] 可对一组设备执行操作。 每个设备孪生包含名为 **作业**的集合中该设备参与的作业的信息。\r 从逻辑上讲，\r \r ```json\r {\r     \"deviceId\": \"myDeviceId\",\r     \"etag\": \"AAAAAAAAAAc=\",\r     \"tags\": {\r         ...\r     },\r     \"properties\": {\r         ...\r     },\r     \"jobs\": [\r         {\r             \"deviceId\": \"myDeviceId\",\r             \"jobId\": \"myJobId\",\r             \"jobType\": \"scheduleTwinUpdate\",\r             \"status\": \"completed\",\r             \"startTimeUtc\": \"2016-09-29T18:18:52.7418462\",\r             \"endTimeUtc\": \"2016-09-29T18:20:52.7418462\",\r             \"createdDateTimeUtc\": \"2016-09-29T18:18:56.7787107Z\",\r             \"lastUpdatedDateTimeUtc\": \"2016-09-29T18:18:56.8894408Z\",\r             \"outcome\": {\r                 \"deviceMethodResponse\": null\r             }\r         },\r         ...\r     ]\r }\r ```\r \r 目前，可以使用 IoT 中心查询语言以 **devices.jobs** 形式查询此集合。\r \r > [!IMPORTANT]\r > 目前，查询设备孪生（即包含“FROM devices”的查询）时不会返回作业属性。 它仅可使用 `FROM devices.jobs` 通过查询直接访问。\r >\r >\r \r 例如，若要获取影响单个设备的所有作业（过去和计划的作业），可以使用以下查询：\r \r ```sql\r SELECT * FROM devices.jobs\r WHERE devices.jobs.deviceId = 'myDeviceId'\r ```\r \r 请注意此查询如何提供每个返回的作业的设备特定状态（可能还会提供直接方法响应）。\r 还可针对 **devices.jobs** 集合中的所有对象属性，使用任意布尔条件进行筛选。\r 若要为特定设备检索在 2016 年 9 月之后创建的所有已完成的设备孪生更新作业，请使用以下查询：\r \r ```sql\r SELECT * FROM devices.jobs\r WHERE devices.jobs.deviceId = 'myDeviceId'\r     AND devices.jobs.jobType = 'scheduleTwinUpdate'\r     AND devices.jobs.status = 'completed'\r     AND devices.jobs.createdTimeUtc > '2016-09-01'\r ```\r \r 还可以检索单个作业在每个设备上的结果。\r \r ```sql\r SELECT * FROM devices.jobs\r WHERE devices.jobs.jobId = 'myJobId'\r ```\r \r ### <a name=\"limitations\"></a>限制\r 目前，对 **devices.jobs** 的查询不支持：\r \r * 投影，因此仅可使用 `SELECT *`。\r * 引用设备孪生和作业属性的条件（参见上一节）。\r * 执行聚合，例如 count、avg、group by。\r \r ## <a name=\"device-to-cloud-message-routes-query-expressions\"></a>设备到云消息路由查询表达式\r \r 可通过[设备到云的路由][lnk-devguide-messaging-routes]配置 IoT 中心，根据按各消息计算的表达式将设备到云的消息分派给不同的终结点。\r \r 在克隆和作业查询中，路由 [条件][lnk-query-expressions] 使用相同的 IoT 中心查询语言作为条件。 根据消息标头和正文评估路由条件。 路由查询表达式可能只涉及到消息标头、消息正文，或者同时涉及到消息标头和消息正文。 为了对消息进行路由，IoT 中心为标头和消息正文采用了特定的架构。 以下各节介绍了 IoT 中心正确进行路由所需满足的要求。\r \r ### <a name=\"routing-on-message-headers\"></a>根据消息标头路由\r \r IoT 中心采用消息标头的以下 JSON 表示形式来路由消息：\r \r ```json\r     {\r         \"$messageId\": \"\",\r         \"$enqueuedTime\": \"\",\r         \"$to\": \"\",\r         \"$expiryTimeUtc\": \"\",\r         \"$correlationId\": \"\",\r         \"$userId\": \"\",\r         \"$ack\": \"\",\r         \"$connectionDeviceId\": \"\",\r         \"$connectionDeviceGenerationId\": \"\",\r         \"$connectionAuthMethod\": \"\",\r         \"$content-type\": \"\",\r         \"$content-encoding\": \"\",\r \r         \"userProperty1\": \"\",\r         \"userProperty2\": \"\"\r     }\r ```\r \r 消息系统属性以 `'$'` 符号作为前缀。\r 用户属性始终使用其名称进行访问。 如果用户属性名恰好与系统属性（例如 `$to`）完全一致，则将使用 `$to` 表达式检索用户属性。\r 始终可以使用括号 `{}` 访问系统属性：例如，可以使用表达式 `{$to}` 访问系统属性 `to`。 将属性名称括在括号中始终可检索相应的系统属性。\r \r 请记住，属性名称不区分大小写。\r \r > [!NOTE]\r > 消息属性均为字符串。 如 [开发人员指南][lnk-devguide-messaging-format]所述，目前不能在查询中使用系统属性。\r >\r \r 例如，如果使用 `messageType` 属性，可能需要将所有遥测和所有警报路由到两个不同的终结点。 可编写以下表达式进行遥测路由：\r \r ```sql\r messageType = 'telemetry'\r ```\r \r 编写以下表达式进行警报消息路由：\r \r ```sql\r messageType = 'alert'\r ```\r \r 此外，还支持布尔表达式和函数。 通过此功能可区分严重性级别，例如：\r \r ```sql\r messageType = 'alerts' AND as_number(severity) <= 2\r ```\r \r 请参阅 [表达式和条件][lnk-query-expressions] 部分，了解受支持的运算符和函数的完整列表。\r \r ### <a name=\"routing-on-message-bodies\"></a>根据消息正文路由\r \r 如果消息正文采用适当的 UTF-8、UTF-16 或 UTF-32 格式进行 JSON 编码，则 IoT 中心只能根据消息正文内容路由。 在消息标头中，将消息的内容类型设置为 `application/json`，并将内容编码设置为一个受支持 UTF 编码。 如果未指定任一标头，IoT 中心不会针对消息尝试评估涉及到正文的任何查询表达式。 如果消息不是 JSON 消息，或者消息未指定内容类型和内容编码，你仍可以使用消息路由根据消息标头来路由消息。\r \r 可以在查询表达式中使用 `$body` 来路由消息。 可以在查询表达式中使用简单正文引用、正文数组引用或多个正文引用。 查询表达式还可以将正文引用与消息标头引用相结合。 例如，下面的所有查询表达式都有效：\r \r ```sql\r $body.message.Weather.Location.State = 'WA'\r $body.Weather.HistoricalData[0].Month = 'Feb'\r $body.Weather.Temperature = 50 AND $body.message.Weather.IsEnabled\r length($body.Weather.Location.State) = 2\r $body.Weather.Temperature = 50 AND Status = 'Active'\r ```\r \r ## <a name=\"basics-of-an-iot-hub-query\"></a>IoT 中心查询基础知识\r 每个 IoT 中心查询都包括 SELECT 和 FROM 子句，以及可选的 WHERE 和 GROUP BY 子句。 每个查询针对 JSON 文档的集合（例如，设备孪生）运行。 FROM 子句指示要迭代的文档集合（**devices** 或 **devices.jobs**）。 然后，应用 WHERE 子句中的筛选器。 使用聚合时，根据 GROUP BY 子句中的指定将此步骤的结果分组；对于每个组，根据 SELECT 子句中的指定生成一行。\r \r ```sql\r SELECT <select_list>\r FROM <from_specification>\r [WHERE <filter_condition>]\r [GROUP BY <group_specification>]\r ```\r \r ## <a name=\"from-clause\"></a>FROM 子句\r **FROM <from_specification>** 子句只能采用两个值：**FROM devices** 用来查询设备孪生；**FROM devices.jobs** 用来查询每个设备上的作业详细信息。\r \r ## <a name=\"where-clause\"></a>WHERE 子句\r **WHERE <filter_condition>** 子句是可选的。 它指定要将 FROM 集合中的 JSON 文档内含在结果中时需满足的一项或多项条件。 任何 JSON 文档必须将指定的条件求值为“true”才能包含在结果中。\r \r [表达式和条件][lnk-query-expressions]部分中介绍了允许的条件。\r \r ## <a name=\"select-clause\"></a>SELECT 子句\r **SELECT <select_list>** 是必需的，用于指定要通过查询检索的值。 它指定用于生成新 JSON 对象的 JSON 值。\r 对于 FROM 集合中已筛选子集（且可选择性分组）的每个元素，投影阶段将生成一个新 JSON 对象，其由 SELECT 子句中指定的值构造而成。\r \r SELECT 子句的语法如下：\r \r ```\r     SELECT [TOP <max number>] <projection list>\r \r     <projection_list> ::=\r         '*'\r         | <projection_element> AS alias [, <projection_element> AS alias]+\r \r     <projection_element> :==\r         attribute_name\r         | <projection_element> '.' attribute_name\r         | <aggregate>\r \r     <aggregate> :==\r         count()\r         | avg(<projection_element>)\r         | sum(<projection_element>)\r         | min(<projection_element>)\r         | max(<projection_element>)\r ```\r \r **Attribute_name** 引用 FROM 集合中 JSON 文档的任一属性。 在[设备孪生查询入门][lnk-query-getstarted]部分可以找到 SELECT 子句的一些示例。\r \r 目前，仅支持在针对设备孪生执行的聚合查询中使用除 **SELECT \\*** 以外的选择子句。\r \r ## <a name=\"group-by-clause\"></a>GROUP BY 子句\r **GROUP BY <group_specification>** 子句是可选步骤，可在 WHERE 子句中指定的筛选器后、在 SELECT 中指定的投影前执行该子句。 它根据属性值来分组文档。 这些组用于生成 SELECT 子句中指定的聚合值。\r \r 下面是使用 GROUP BY 的查询示例：\r \r ```sql\r SELECT properties.reported.telemetryConfig.status AS status,\r     COUNT() AS numberOfDevices\r FROM devices\r GROUP BY properties.reported.telemetryConfig.status\r ```\r \r GROUP BY 的正式语法为：\r \r ```\r     GROUP BY <group_by_element>\r     <group_by_element> :==\r         attribute_name\r         | < group_by_element > '.' attribute_name\r ```\r \r **Attribute_name** 引用 FROM 集合中 JSON 文档的任一属性。\r \r 目前，仅在查询设备孪生时才支持使用 GROUP BY 子句。\r \r ## <a name=\"expressions-and-conditions\"></a>表达式和条件\r 从较高层面讲，*表达式*可以：\r \r * 求值结果为 JSON 类型的实例（例如布尔值、数字、字符串、数组或对象）。\r * 由设备 JSON 文档中的操作数据以及使用内置运算符和函数的常量定义。\r \r 条件是求值为布尔值的表达式。 除布尔值 **true** 以外的任何常量均被视为 **false**（包括 **null**、**undefined**、任何对象或数组实例、任何字符串，当然还有布尔值 **false**）。\r \r 表达式的语法为：\r \r ```\r     <expression> ::=\r         <constant> |\r         attribute_name |\r         <function_call> |\r         <expression> binary_operator <expression> |\r         <create_array_expression> |\r         '(' <expression> ')'\r \r     <function_call> ::=\r         <function_name> '(' expression ')'\r \r     <constant> ::=\r         <undefined_constant>\r         | <null_constant>\r         | <number_constant>\r         | <string_constant>\r         | <array_constant>\r \r     <undefined_constant> ::= undefined\r     <null_constant> ::= null\r     <number_constant> ::= decimal_literal | hexadecimal_literal\r     <string_constant> ::= string_literal\r     <array_constant> ::= '[' <constant> [, <constant>]+ ']'\r ```\r \r 若要了解表达式语法中的每个符号表示什么，请参阅下表：\r \r | 符号 | 定义 |\r | --- | --- |\r | attribute_name | **FROM** 集合中 JSON 文档的任一属性。 |\r | binary_operator | [运算符](#operators)部分列出的任意二进制运算符。 |\r | function_name| [函数](#functions)部分列出的任一函数。 |\r | decimal_literal |以十进制表示法表示的浮点数。 |\r | hexadecimal_literal |以字符串“0x”后接十六进制数字符串表示的数字。 |\r | string_literal |字符串文本是以零个或多个 Unicode 字符序列或转义符序列表示的 Unicode 字符串。 字符串文本括在单引号或双引号中。 允许的转义符：`\\'`、`\\\"`、`\\\\`、`\\uXXXX`（由 4 个十六进制数字定义的 Unicode 字符）。 |\r \r ### <a name=\"operators\"></a>运算符\r 支持以下运算符：\r \r | 系列 | 运算符 |\r | --- | --- |\r | 算术 |+,-,*,/,% |\r | 逻辑 |AND、OR、NOT |\r | 比较 |=、!=、<、>、<=、>=、<> |\r \r ### <a name=\"functions\"></a>函数\r 查询克隆和作业时唯一受支持的函数是：\r \r | 函数 | 说明 |\r | -------- | ----------- |\r | IS_DEFINED(property) | 返回一个布尔值，指示是否已向属性分配值（包括 `null`）。 |\r \r 在路由情况下，支持以下数学函数：\r \r | 函数 | 说明 |\r | -------- | ----------- |\r | ABS(x) | 返回指定数值表达式的绝对（正）值。 |\r | EXP(x) | 返回指定数值表达式 (e^x) 的指数值。 |\r | POWER(x,y) | 返回指定表达式相对指定幂 (x^y) 的值。|\r | SQUARE(x) | 返回指定数字值的平方。 |\r | CEILING(x) | 返回大于或等于指定数值表达式的最小整数值。 |\r | FLOOR(x) | 返回小于或等于指定数值表达式的最大整数。 |\r | SIGN(x) | 返回指定数值表达式的正数 (+1)、零 (0) 或负数 (-1)。|\r | SQRT(x) | 返回指定数值的平方根。 |\r \r 在路由情况下，支持以下检查和强制转换类型的函数：\r \r | 函数 | 说明 |\r | -------- | ----------- |\r | AS_NUMBER | 将输入字符串转换为数字。 如果输入数字，则为 `noop`；如果字符串不表示数字，则为 `Undefined`。|\r | IS_ARRAY | 返回一个布尔值，指示指定表达式类型是否为数组。 |\r | IS_BOOL | 返回一个布尔值，指示指定表达式的类型是否为布尔表达式。 |\r | IS_DEFINED | 返回一个布尔，它指示属性是否已经分配了值。 |\r | IS_NULL | 返回一个布尔值，指示指定表达式的类型是否为 null。 |\r | IS_NUMBER | 返回一个布尔值，指示指定表达式的类型是否为数字。 |\r | IS_OBJECT | 返回一个布尔值，指示指定表达式的类型是否为 JSON 对象。 |\r | IS_PRIMITIVE | 返回一个布尔值，指示指定表达式的类型是否为基元（字符串、布尔值、数字或 `null`）。 |\r | IS_STRING | 返回一个布尔值，指示指定表达式的类型是否为字符串。 |\r \r 在路由情况下，支持以下字符串函数：\r \r | 函数 | 说明 |\r | -------- | ----------- |\r | CONCAT(x, y, …) | 返回一个字符串，该字符串是连接两个或多个字符串值的结果。 |\r | LENGTH(x) | 返回指定字符串表达式的字符数。|\r | LOWER(x) | 返回在将大写字符数据转换为小写后的字符串表达式。 |\r | UPPER(x) | 返回在将小写字符数据转换为大写后的字符串表达式。 |\r | SUBSTRING(string, start [, length]) | 返回字符串表达式的部分内容，该内容起于指定字符从零开始的位置，继续到指定长度或字符串结尾。 |\r | INDEX_OF(string, fragment) | 返回第一个指定的字符串表达式中第一次出现第二个字符串表达式的起始位置，如果未找到字符串，则返回 -1。|\r | STARTS_WITH(x, y) | 返回一个布尔值，指示第一个字符串表达式是否以第二个字符串表达式开头。 |\r | ENDS_WITH(x, y) | 返回一个布尔值，指示第一个字符串表达式是否以第二个字符串表达式结尾。 |\r | CONTAINS(x,y) | 返回一个布尔值，该值指示第一个字符串表达式是否包含第二个字符串表达式。 |\r \r ## <a name=\"next-steps\"></a>后续步骤\r 了解如何使用 [Azure IoT SDK][lnk-hub-sdks]在应用中执行查询。\r \r [lnk-query-where]: ./iot-hub-devguide-query-language.md#where-clause\r [lnk-query-expressions]: ./iot-hub-devguide-query-language.md#expressions-and-conditions\r [lnk-query-getstarted]: ./iot-hub-devguide-query-language.md#get-started-with-device-twin-queries\r \r [lnk-twins]: ./iot-hub-devguide-device-twins.md\r [lnk-jobs]: ./iot-hub-devguide-jobs.md\r [lnk-devguide-endpoints]: ./iot-hub-devguide-endpoints.md\r [lnk-devguide-quotas]: ./iot-hub-devguide-quotas-throttling.md\r [lnk-devguide-mqtt]: ./iot-hub-mqtt-support.md\r [lnk-devguide-messaging-routes]: ./iot-hub-devguide-messages-read-custom.md\r [lnk-devguide-messaging-format]: ./iot-hub-devguide-messages-construct.md\r [lnk-devguide-messaging-routes]: ./iot-hub-devguide-messages-read-custom.md\r \r [lnk-hub-sdks]: ./iot-hub-devguide-sdks.md\r \r \r <!--Update_Description: update wording and link references-->"}