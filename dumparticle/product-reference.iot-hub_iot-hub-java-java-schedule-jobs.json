{"Title":"使用 Azure IoT 中心安排作业 (Java)","Description":"如何安排 Azure IoT 中心作业对多台设备调用直接方法并设置必需属性。 使用适用于 Java 的 Azure IoT 设备 SDK 实现模拟设备应用，并使用适用于 Java 的 Azure IoT 服务 SDK 实现用于运行作业的服务应用。","Content":"# <a name=\"schedule-and-broadcast-jobs-java\"></a>计划和广播作业 (Java)\r \r [!INCLUDE [iot-hub-selector-schedule-jobs](../../includes/iot-hub-selector-schedule-jobs.md)]\r \r 使用 Azure IoT 中心来计划和跟踪可更新数百万台设备的作业。 使用作业可以：\r \r * 更新所需属性\r * 更新标记\r * 调用直接方法\r \r 作业包装上述一项操作，并跟踪一组设备中的执行情况。 设备孪生查询定义作业执行的一组设备。 例如，后端应用可以使用作业在 10,000 台设备上调用直接方法来重启设备。 使用设备孪生查询指定设备集，并将作业计划为在以后运行。 每个设备接收和执行 reboot 直接方法时，该作业会跟踪进度。\r \r 若要详细了解其中的每项功能，请参阅：\r \r * 设备孪生和属性：[设备孪生入门](iot-hub-java-java-twin-getstarted.md)\r * 直接方法：[IoT 中心开发人员指南 - 直接方法](iot-hub-devguide-direct-methods.md)和[教程：使用直接方法](iot-hub-java-java-direct-methods.md)\r \r 本教程演示如何：\r \r * 创建设备应用，用于实现名为 lockDoor 的直接方法。 该设备应用还从后端应用接收所需的属性更改。\r * 创建一个后端应用，该应用创建一个作业以在多台设备上调用 **lockDoor** 直接方法。 另一个作业将所需的属性更新发送到多个设备。\r \r 本教程结束时，将有一个 java 控制台设备应用，以及一个 java 控制台后端应用：\r \r simulated-device：连接到 IoT 中心、实现 lockDoor 直接方法，并处理所需的属性更改。\r \r schedule-jobs：使用作业来调用 lockDoor 直接方法，并在多个设备上更新设备孪生的必需属性。\r \r > [!NOTE]\r > [Azure IoT SDK](iot-hub-devguide-sdks.md) 一文介绍了可用于构建设备和后端应用的 Azure IoT SDK。\r \r ## <a name=\"prerequisites\"></a>先决条件\r \r 要完成本教程，需要：\r \r * 最新的 [Java SE 开发工具包 8](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)\r * [Maven 3](https://maven.apache.org/install.html)\r * 有效的 Azure 帐户。 （如果没有帐户，只需几分钟即可创建一个[试用帐户](http://www.azure.cn/pricing/1rmb-trial/)。）\r \r [!INCLUDE [iot-hub-get-started-create-hub](../../includes/iot-hub-get-started-create-hub.md)]\r \r [!INCLUDE [iot-hub-get-started-create-device-identity-portal](../../includes/iot-hub-get-started-create-device-identity-portal.md)]\r \r 若要以编程方式创建设备标识，请参阅[使用 Java 将设备连接到 IoT 中心](iot-hub-java-java-getstarted.md#create-a-device-identity)一文中的相应部分。 还可使用 [iothub-explorer](https://github.com/Azure/iothub-explorer) 工具向 IoT 中心添加设备。\r \r ## <a name=\"create-the-service-app\"></a>创建服务应用\r \r 本部分中将创建一个使用作业进行如下操作的 Java 控制台应用：\r \r * 在多台设备上调用 lockDoor 直接方法。\r * 向多台设备发送必需属性。\r \r 创建应用：\r \r 1. 在开发计算机上，创建名为 `iot-java-schedule-jobs` 的空文件夹。\r \r 1. 在 `iot-java-schedule-jobs` 文件夹中，通过命令提示符使用以下命令创建名为 schedule-jobs 的 Maven 项目。 请注意，这是一条很长的命令：\r \r     `mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=schedule-jobs -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false`\r \r 1. 在命令提示符下，导航到 `schedule-jobs` 文件夹。\r \r 1. 使用文本编辑器打开 `schedule-jobs` 文件夹中的 `pom.xml` 文件，在 **dependencies** 节点中添加以下依赖项。 通过此依赖项可以使用应用中的 **iot-service-client** 包来与 IoT 中心通信：\r \r     ```xml\r     <dependency>\r       <groupId>com.microsoft.azure.sdk.iot</groupId>\r       <artifactId>iot-service-client</artifactId>\r       <version>1.7.23</version>\r       <type>jar</type>\r     </dependency>\r     ```\r \r     > [!NOTE]\r     > 可以使用 [Maven 搜索](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22iot-service-client%22%20g%3A%22com.microsoft.azure.sdk.iot%22)检查是否有最新版本的 **iot-service-client**。\r \r 1. 在 **dependencies** 节点后添加以下 **build** 节点。 此配置指示 Maven 使用 Java 1.8 来生成应用：\r \r     ```xml\r     <build>\r       <plugins>\r         <plugin>\r           <groupId>org.apache.maven.plugins</groupId>\r           <artifactId>maven-compiler-plugin</artifactId>\r           <version>3.3</version>\r           <configuration>\r             <source>1.8</source>\r             <target>1.8</target>\r           </configuration>\r         </plugin>\r       </plugins>\r     </build>\r     ```\r \r 1. 保存并关闭 `pom.xml` 文件。\r \r 1. 使用文本编辑器打开 `schedule-jobs\\src\\main\\java\\com\\mycompany\\app\\App.java` 文件。\r \r 1. 在该文件中添加以下 **import** 语句：\r \r     ```java\r     import com.microsoft.azure.sdk.iot.service.devicetwin.DeviceTwinDevice;\r     import com.microsoft.azure.sdk.iot.service.devicetwin.Pair;\r     import com.microsoft.azure.sdk.iot.service.devicetwin.Query;\r     import com.microsoft.azure.sdk.iot.service.devicetwin.SqlQuery;\r     import com.microsoft.azure.sdk.iot.service.jobs.JobClient;\r     import com.microsoft.azure.sdk.iot.service.jobs.JobResult;\r     import com.microsoft.azure.sdk.iot.service.jobs.JobStatus;\r \r     import java.util.Date;\r     import java.time.Instant;\r     import java.util.HashSet;\r     import java.util.Set;\r     import java.util.UUID;\r     ```\r \r 1. 将以下类级变量添加到 **App** 类。 将 `{youriothubconnectionstring}` 替换为在“创建 IoT 中心”部分记下的 IoT 中心连接字符串：\r \r     ```java\r     public static final String iotHubConnectionString = \"{youriothubconnectionstring}\";\r     public static final String deviceId = \"myDeviceId\";\r \r     // How long the job is permitted to run without\r     // completing its work on the set of devices\r     private static final long maxExecutionTimeInSeconds = 30;\r     ```\r \r 1. 向 App 类添加以下方法，以安排作业更新设备孪生中的 Building 和 Floor 必需属性：\r \r     ```java\r     private static JobResult scheduleJobSetDesiredProperties(JobClient jobClient, String jobId) {\r       DeviceTwinDevice twin = new DeviceTwinDevice(deviceId);\r       Set<Pair> desiredProperties = new HashSet<Pair>();\r       desiredProperties.add(new Pair(\"Building\", 43));\r       desiredProperties.add(new Pair(\"Floor\", 3));\r       twin.setDesiredProperties(desiredProperties);\r       // Optimistic concurrency control\r       twin.setETag(\"*\");\r \r       // Schedule the update twin job to run now\r       // against a single device\r       System.out.println(\"Schedule job \" + jobId + \" for device \" + deviceId);\r       try {\r         JobResult jobResult = jobClient.scheduleUpdateTwin(jobId, \r           \"deviceId='\" + deviceId + \"'\",\r           twin,\r           new Date(),\r           maxExecutionTimeInSeconds);\r         return jobResult;\r       } catch (Exception e) {\r         System.out.println(\"Exception scheduling desired properties job: \" + jobId);\r         System.out.println(e.getMessage());\r         return null;\r       }\r     }\r     ```\r \r 1. 若要安排作业调用 lockDoor 方法，请向 App 类添加以下方法：\r \r     ```java\r     private static JobResult scheduleJobCallDirectMethod(JobClient jobClient, String jobId) {\r       // Schedule a job now to call the lockDoor direct method\r       // against a single device. Response and connection\r       // timeouts are set to 5 seconds.\r       System.out.println(\"Schedule job \" + jobId + \" for device \" + deviceId);\r       try {\r         JobResult jobResult = jobClient.scheduleDeviceMethod(jobId,\r           \"deviceId='\" + deviceId + \"'\",\r           \"lockDoor\",\r           5L, 5L, null,\r           new Date(),\r           maxExecutionTimeInSeconds);\r         return jobResult;\r       } catch (Exception e) {\r         System.out.println(\"Exception scheduling direct method job: \" + jobId);\r         System.out.println(e.getMessage());\r         return null;\r       }\r     };\r     ```\r \r 1. 若要监视作业，请向 App 类添加以下方法：\r \r     ```java\r     private static void monitorJob(JobClient jobClient, String jobId) {\r       try {\r         JobResult jobResult = jobClient.getJob(jobId);\r         if(jobResult == null)\r         {\r           System.out.println(\"No JobResult for: \" + jobId);\r           return;\r         }\r         // Check the job result until it's completed\r         while(jobResult.getJobStatus() != JobStatus.completed)\r         {\r           Thread.sleep(100);\r           jobResult = jobClient.getJob(jobId);\r           System.out.println(\"Status \" + jobResult.getJobStatus() + \" for job \" + jobId);\r         }\r         System.out.println(\"Final status \" + jobResult.getJobStatus() + \" for job \" + jobId);\r       } catch (Exception e) {\r         System.out.println(\"Exception monitoring job: \" + jobId);\r         System.out.println(e.getMessage());\r         return;\r       }\r     }\r     ```\r \r 1. 若要查询已运行作业的详细信息，请添加以下方法：\r \r     ```java\r     private static void queryDeviceJobs(JobClient jobClient, String start) throws Exception {\r       System.out.println(\"\\nQuery device jobs since \" + start);\r \r       // Create a jobs query using the time the jobs started\r       Query deviceJobQuery = jobClient\r           .queryDeviceJob(SqlQuery.createSqlQuery(\"*\", SqlQuery.FromType.JOBS, \"devices.jobs.startTimeUtc > '\" + start + \"'\", null).getQuery());\r \r       // Iterate over the list of jobs and print the details\r       while (jobClient.hasNextJob(deviceJobQuery)) {\r         System.out.println(jobClient.getNextJob(deviceJobQuery));\r       }\r     }\r     ```\r \r 1. 更新 **main** 方法签名，以包含以下 `throws` 子句：\r \r     ```java\r     public static void main( String[] args ) throws Exception\r     ```\r \r 1. 若要依次运行和监视两个作业，请向 main 方法添加以下代码：\r \r     ```java\r     // Record the start time\r     String start = Instant.now().toString();\r \r     // Create JobClient\r     JobClient jobClient = JobClient.createFromConnectionString(iotHubConnectionString);\r     System.out.println(\"JobClient created with success\");\r \r     // Schedule twin job desired properties\r     // Maximum concurrent jobs is 1 for Free and S1 tiers\r     String desiredPropertiesJobId = \"DPCMD\" + UUID.randomUUID();\r     scheduleJobSetDesiredProperties(jobClient, desiredPropertiesJobId);\r     monitorJob(jobClient, desiredPropertiesJobId);\r \r     // Schedule twin job direct method\r     String directMethodJobId = \"DMCMD\" + UUID.randomUUID();\r     scheduleJobCallDirectMethod(jobClient, directMethodJobId);\r     monitorJob(jobClient, directMethodJobId);\r \r     // Run a query to show the job detail\r     queryDeviceJobs(jobClient, start);\r \r     System.out.println(\"Shutting down schedule-jobs app\");\r     ```\r \r 1. 保存并关闭 `schedule-jobs\\src\\main\\java\\com\\mycompany\\app\\App.java` 文件\r \r 1. 生成 schedule-jobs 应用并更正任何错误。 在命令提示符下，导航到 `schedule-jobs` 文件夹并运行以下命令：\r \r     `mvn clean package -DskipTests`\r \r ## <a name=\"create-a-device-app\"></a>创建设备应用\r \r 本部分中将创建一个 Java 控制台应用，处理从 IoT 中心发送的必需属性并实现直接方法调用。\r \r 1. 在命令提示符下使用以下命令，在 `iot-java-schedule-jobs` 文件夹中创建名为 **simulated-device** 的 Maven 项目。 请注意，这是一条很长的命令：\r \r     `mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=simulated-device -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false`\r \r 1. 在命令提示符下，导航到 `simulated-device` 文件夹。\r \r 1. 使用文本编辑器打开 `simulated-device` 文件夹中的 `pom.xml` 文件，在 **dependencies** 节点中添加以下依赖项。 通过此依赖项可以使用应用中的 **iot-device-client** 包来与 IoT 中心进行通信：\r \r     ```xml\r     <dependency>\r       <groupId>com.microsoft.azure.sdk.iot</groupId>\r       <artifactId>iot-device-client</artifactId>\r       <version>1.3.32</version>\r     </dependency>\r     ```\r \r     > [!NOTE]\r     > 可以使用 [Maven 搜索](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22iot-device-client%22%20g%3A%22com.microsoft.azure.sdk.iot%22)检查是否有最新版本的 **iot-device-client**。\r \r 1. 在 **dependencies** 节点后添加以下 **build** 节点。 此配置指示 Maven 使用 Java 1.8 来生成应用：\r \r     ```xml\r     <build>\r       <plugins>\r         <plugin>\r           <groupId>org.apache.maven.plugins</groupId>\r           <artifactId>maven-compiler-plugin</artifactId>\r           <version>3.3</version>\r           <configuration>\r             <source>1.8</source>\r             <target>1.8</target>\r           </configuration>\r         </plugin>\r       </plugins>\r     </build>\r     ```\r \r 1. 保存并关闭 `pom.xml` 文件。\r \r 1. 使用文本编辑器打开 `simulated-device\\src\\main\\java\\com\\mycompany\\app\\App.java` 文件。\r \r 1. 在该文件中添加以下 **import** 语句：\r \r     ```java\r     import com.microsoft.azure.sdk.iot.device.*;\r     import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\r \r     import java.io.IOException;\r     import java.net.URISyntaxException;\r     import java.util.Scanner;\r     ```\r \r 1. 将以下类级变量添加到 **App** 类。 将 `{youriothubname}` 替换为 IoT 中心名称，将 `{yourdevicekey}` 替换为在“创建设备标识”部分中生成的设备密钥值：\r \r     ```java\r     private static String connString = \"HostName={youriothubname}.azure-devices.cn;DeviceId=myDeviceID;SharedAccessKey={yourdevicekey}\";\r     private static IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\r     private static final int METHOD_SUCCESS = 200;\r     private static final int METHOD_NOT_DEFINED = 404;\r     ```\r \r     本示例应用在实例化 **DeviceClient** 对象时使用 **protocol** 变量。\r \r 1. 若要在控制台中列显设备孪生通知，请向 App 类添加以下嵌套类：\r \r     ```java\r     // Handler for device twin operation notifications from IoT Hub\r     protected static class DeviceTwinStatusCallBack implements IotHubEventCallback {\r       public void execute(IotHubStatusCode status, Object context) {\r         System.out.println(\"IoT Hub responded to device twin operation with status \" + status.name());\r       }\r     }\r     ```\r \r 1. 若要在控制台中列显直接方法通知，请向 App 类添加以下嵌套类：\r \r     ```java\r     // Handler for direct method notifications from IoT Hub\r     protected static class DirectMethodStatusCallback implements IotHubEventCallback {\r       public void execute(IotHubStatusCode status, Object context) {\r         System.out.println(\"IoT Hub responded to direct method operation with status \" + status.name());\r       }\r     }\r     ```\r \r 1. 若要处理 IoT 中心的直接方法调用，请向 App 类添加以下嵌套类：\r \r     ```java\r     // Handler for direct method calls from IoT Hub\r     protected static class DirectMethodCallback\r         implements DeviceMethodCallback {\r       @Override\r       public DeviceMethodData call(String methodName, Object methodData, Object context) {\r         DeviceMethodData deviceMethodData;\r         switch (methodName) {\r           case \"lockDoor\": {\r             System.out.println(\"Executing direct method: \" + methodName);\r             deviceMethodData = new DeviceMethodData(METHOD_SUCCESS, \"Executed direct method \" + methodName);\r             break;\r           }\r           default: {\r             deviceMethodData = new DeviceMethodData(METHOD_NOT_DEFINED, \"Not defined direct method \" + methodName);\r           }\r         }\r         // Notify IoT Hub of result\r         return deviceMethodData;\r       }\r     }\r     ```\r \r 1. 更新 **main** 方法签名，以包含以下 `throws` 子句：\r \r     ```java\r     public static void main( String[] args ) throws IOException, URISyntaxException\r     ```\r \r 1. 将以下代码添加到 **main** 方法，以便：\r     * 创建用来与 IoT 中心通信的设备客户端。\r     * 创建一个 **Device** 对象用于存储设备孪生属性。\r \r     ```java\r     // Create a device client\r     DeviceClient client = new DeviceClient(connString, protocol);\r \r     // An object to manage device twin desired and reported properties\r     Device dataCollector = new Device() {\r       @Override\r       public void PropertyCall(String propertyKey, Object propertyValue, Object context)\r       {\r         System.out.println(\"Received desired property change: \" + propertyKey + \" \" + propertyValue);\r       }\r     };\r     ```\r \r 1. 若要启动设备客户端服务，请向 main 方法添加以下代码：\r \r     ```java\r     try {\r       // Open the DeviceClient\r       // Start the device twin services\r       // Subscribe to direct method calls\r       client.open();\r       client.startDeviceTwin(new DeviceTwinStatusCallBack(), null, dataCollector, null);\r       client.subscribeToDeviceMethod(new DirectMethodCallback(), null, new DirectMethodStatusCallback(), null);\r     } catch (Exception e) {\r       System.out.println(\"Exception, shutting down \\n\" + \" Cause: \" + e.getCause() + \" \\n\" + e.getMessage());\r       dataCollector.clean();\r       client.closeNow();\r       System.out.println(\"Shutting down...\");\r     }\r     ```\r \r 1. 若要在关闭前等待用户按 Enter 键，请向 main 方法末尾添加以下代码：\r \r     ```java\r     // Close the app\r     System.out.println(\"Press any key to exit...\");\r     Scanner scanner = new Scanner(System.in);\r     scanner.nextLine();\r     dataCollector.clean();\r     client.closeNow();\r     scanner.close();\r     ```\r \r 1. 保存并关闭 `simulated-device\\src\\main\\java\\com\\mycompany\\app\\App.java` 文件。\r \r 1. 生成 **simulated-device** 应用并更正任何错误。 在命令提示符下，导航到 `simulated-device` 文件夹并运行以下命令：\r \r     `mvn clean package -DskipTests`\r \r ## <a name=\"run-the-apps\"></a>运行应用\r \r 现在可以运行控制台应用了。\r \r 1. 在 `simulated-device` 文件夹中的命令提示符处，运行以下命令启动设备应用用于侦听所需属性更改和直接方法调用：\r \r     `mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\"`\r \r     ![设备客户端启动](./media/iot-hub-java-java-schedule-jobs/device-app-1.png)\r \r 1. 在 `schedule-jobs` 文件夹中的命令提示符处，运行以下命令以运行 schedule-jobs 服务应用，从而运行两个作业。 第一个作业设置所需的属性值，第二个作业调用直接方法：\r \r     `mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\"`\r \r     ![Java IoT 中心服务应用创建两个作业](./media/iot-hub-java-java-schedule-jobs/service-app-1.png)\r \r 1. 设备应用处理所需的属性更改和直接方法调用：\r \r     ![设备客户端对更改作出响应](./media/iot-hub-java-java-schedule-jobs/device-app-2.png)\r \r ## <a name=\"next-steps\"></a>后续步骤\r \r 本教程中，在 Azure 门户中配置了新的 IoT 中心，并在 IoT 中心的标识注册表中创建了设备标识。 创建了运行两个作业的后端应用。 第一个作业设置了所需的属性值，第二个作业调用了直接方法。\r \r 使用下列资源了解如何执行以下操作：\r \r * 通过 [IoT 中心入门](iot-hub-java-java-getstarted.md)教程学习如何从设备发送遥测数据。\r * 通过[使用直接方法](iot-hub-java-java-direct-methods.md)教程学习如何以交互方式控制设备（例如从用户控制的应用打开风扇）。\r "}