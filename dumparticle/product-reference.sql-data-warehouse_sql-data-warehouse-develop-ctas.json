{"Title":"SQL 数据仓库中的 Create Table As Select (CTAS)","Description":"有关在开发解决方案时使用 Azure SQL 数据仓库中的 create table as select (CTAS) 语句编写代码的技巧。","Content":"\r # SQL 数据仓库中的 Create Table As Select (CTAS)\r Create Table As Select (`CTAS`) 是所提供的最重要的 T-SQL 功能之一。它是根据 SELECT 语句的输出创建新表的完全并行化操作。若要创建表的副本，`CTAS` 是最简便快速的方法。本文档提供 `CTAS` 的示例和最佳实践。\r \r ## SELECT..INTO vs.CTAS\r 可以将 `CTAS` 视为 `SELECT..INTO` 的增压版本。\r \r 下面是简单 `SELECT..INTO` 语句的一个示例：\r \r ```sql\r SELECT *\r INTO    [dbo].[FactInternetSales_new]\r FROM    [dbo].[FactInternetSales]\r ```\r \r 在上面的示例中，`[dbo].[FactInternetSales_new]` 被创建为 ROUND\\_ROBIN 分布式表，其中包含 CLUSTERED COLUMNSTORE INDEX，因为这些是 Azure SQL 数据仓库中的表默认值。\r \r 但是，`SELECT..INTO` 不允许在操作过程中更改分布方法或索引类型。此时 `CTAS` 便派上了用场。\r \r 将上述代码转换为 `CTAS` 相当直接：\r \r ```sql\r CREATE TABLE [dbo].[FactInternetSales_new]\r WITH\r (\r     DISTRIBUTION = ROUND_ROBIN\r ,    CLUSTERED COLUMNSTORE INDEX\r )\r AS\r SELECT  *\r FROM    [dbo].[FactInternetSales]\r ;\r ```\r \r 通过 `CTAS`，可以更改表数据的分布以及表类型。\r \r > [!NOTE]\r > 如果只希望更改 `CTAS` 操作中的索引，并且源表是哈希分布的，那么只要维持相同的分布列和数据类型，`CTAS` 操作便将实现最佳效果。这将避免操作期间的交叉分布数据移动，从而更加高效。\r > \r > \r \r ## 使用 CTAS 复制表\r `CTAS` 最常见的用途之一就是创建表副本，使你可以更改 DDL。例如，如果最初你将表创建为 `ROUND_ROBIN`，现在想要改为在列上分布的表，则可以使用 `CTAS` 来更改分布列。也可使用 `CTAS` 来更改分区、索引或列类型。\r \r 假设你在 `CREATE TABLE` 中没有指定分布列，因而使用 `ROUND_ROBIN` 分布的默认分布类型创建此表。\r \r ```sql\r CREATE TABLE FactInternetSales\r (\r     ProductKey int NOT NULL,\r     OrderDateKey int NOT NULL,\r     DueDateKey int NOT NULL,\r     ShipDateKey int NOT NULL,\r     CustomerKey int NOT NULL,\r     PromotionKey int NOT NULL,\r     CurrencyKey int NOT NULL,\r     SalesTerritoryKey int NOT NULL,\r     SalesOrderNumber nvarchar(20) NOT NULL,\r     SalesOrderLineNumber tinyint NOT NULL,\r     RevisionNumber tinyint NOT NULL,\r     OrderQuantity smallint NOT NULL,\r     UnitPrice money NOT NULL,\r     ExtendedAmount money NOT NULL,\r     UnitPriceDiscountPct float NOT NULL,\r     DiscountAmount float NOT NULL,\r     ProductStandardCost money NOT NULL,\r     TotalProductCost money NOT NULL,\r     SalesAmount money NOT NULL,\r     TaxAmt money NOT NULL,\r     Freight money NOT NULL,\r     CarrierTrackingNumber nvarchar(25),\r     CustomerPONumber nvarchar(25)\r );\r ```\r \r 现在想要创建此表的新副本并包含群集列存储索引，以便可以使用群集列存储表的性能。还想在 ProductKey 上分布此表（因为预期此列会发生联接）并在联接 ProductKey 期间避免数据移动。最后，还希望在 OrderDateKey 上添加分区，以便通过删除旧分区来快速删除旧数据。以下是可将旧表复制到新表的 CTAS 语句。\r \r ```sql\r CREATE TABLE FactInternetSales_new\r WITH\r (\r     CLUSTERED COLUMNSTORE INDEX,\r     DISTRIBUTION = HASH(ProductKey),\r     PARTITION\r     (\r         OrderDateKey RANGE RIGHT FOR VALUES\r         (\r         20000101,20010101,20020101,20030101,20040101,20050101,20060101,20070101,20080101,20090101,\r         20100101,20110101,20120101,20130101,20140101,20150101,20160101,20170101,20180101,20190101,\r         20200101,20210101,20220101,20230101,20240101,20250101,20260101,20270101,20280101,20290101\r         )\r     )\r )\r AS SELECT * FROM FactInternetSales;\r ```\r \r 最后，你可以重命名表以切换到新表，然后删除旧表。\r \r ```sql\r RENAME OBJECT FactInternetSales TO FactInternetSales_old;\r RENAME OBJECT FactInternetSales_new TO FactInternetSales;\r \r DROP TABLE FactInternetSales_old;\r ```\r \r > [!NOTE]\r > Azure SQL 数据仓库尚不支持自动创建或自动更新统计信息。为了从查询中获得最佳性能，首次加载数据或者在数据发生重大更改之后，创建所有表的所有列统计信息非常重要。有关统计信息的详细说明，请参阅开发主题组中的[统计信息][Statistics]主题。\r > \r > \r \r ## <a name=\"using-ctas-to-work-around-unsupported-features\"></a>使用 CTAS 解决不支持的功能\r `CTAS` 还可用于解决以下多种不支持的功能。这往往是一种经过证实的双赢局面，因为代码不但能够兼容，而且通常可以在 SQL 数据仓库中更快速执行。这是完全并行化设计的结果。可以使用 CTAS 解决的方案包括：\r \r * UPDATE 中的 ANSI JOIN\r * DELETE 中的 ANSI JOIN\r * MERGE 语句\r \r > [!NOTE]\r > 尽量考虑“CTAS 优先”。如果你认为可以使用 `CTAS` 解决问题，则它往往就是最佳的解决方法，即使你要因此写入更多的数据。\r > \r > \r \r ## <a name=\"ansi-join-replacement-for-update-statements\"></a>替换 Update 语句的 ANSI Join\r \r 你可能有一个复杂的更新使用 ANSI 联接语法来执行 UPDATE 或 DELETE，以将两个以上的表联接在一起。\r \r 假设必须更新此表：\r \r ```sql\r CREATE TABLE [dbo].[AnnualCategorySales]\r (    [EnglishProductCategoryName]    NVARCHAR(50)    NOT NULL\r ,    [CalendarYear]                    SMALLINT        NOT NULL\r ,    [TotalSalesAmount]                MONEY            NOT NULL\r )\r WITH\r (\r     DISTRIBUTION = ROUND_ROBIN\r )\r ;\r ```\r \r 原始查询看起来可能类似于：\r \r ```sql\r UPDATE    acs\r SET        [TotalSalesAmount] = [fis].[TotalSalesAmount]\r FROM    [dbo].[AnnualCategorySales]     AS acs\r JOIN    (\r         SELECT    [EnglishProductCategoryName]\r         ,        [CalendarYear]\r         ,        SUM([SalesAmount])                AS [TotalSalesAmount]\r         FROM    [dbo].[FactInternetSales]        AS s\r         JOIN    [dbo].[DimDate]                    AS d    ON s.[OrderDateKey]                = d.[DateKey]\r         JOIN    [dbo].[DimProduct]                AS p    ON s.[ProductKey]                = p.[ProductKey]\r         JOIN    [dbo].[DimProductSubCategory]    AS u    ON p.[ProductSubcategoryKey]    = u.[ProductSubcategoryKey]\r         JOIN    [dbo].[DimProductCategory]        AS c    ON u.[ProductCategoryKey]        = c.[ProductCategoryKey]\r         WHERE     [CalendarYear] = 2004\r         GROUP BY\r                 [EnglishProductCategoryName]\r         ,        [CalendarYear]\r         ) AS fis\r ON    [acs].[EnglishProductCategoryName]    = [fis].[EnglishProductCategoryName]\r AND    [acs].[CalendarYear]                = [fis].[CalendarYear]\r ;\r ```\r \r 由于 SQL 数据仓库不支持在 `UPDATE` 语句的 `FROM` 子句中使用 ANSI Join，因此无法在不稍微更改此代码的情况下将它复制过去。\r \r 你可以使用 `CTAS` 和隐式联接的组合来替换此代码：\r \r ```sql\r -- Create an interim table\r CREATE TABLE CTAS_acs\r WITH (DISTRIBUTION = ROUND_ROBIN)\r AS\r SELECT    ISNULL(CAST([EnglishProductCategoryName] AS NVARCHAR(50)),0)    AS [EnglishProductCategoryName]\r ,        ISNULL(CAST([CalendarYear] AS SMALLINT),0)                         AS [CalendarYear]\r ,        ISNULL(CAST(SUM([SalesAmount]) AS MONEY),0)                        AS [TotalSalesAmount]\r FROM    [dbo].[FactInternetSales]        AS s\r JOIN    [dbo].[DimDate]                    AS d    ON s.[OrderDateKey]                = d.[DateKey]\r JOIN    [dbo].[DimProduct]                AS p    ON s.[ProductKey]                = p.[ProductKey]\r JOIN    [dbo].[DimProductSubCategory]    AS u    ON p.[ProductSubcategoryKey]    = u.[ProductSubcategoryKey]\r JOIN    [dbo].[DimProductCategory]        AS c    ON u.[ProductCategoryKey]        = c.[ProductCategoryKey]\r WHERE     [CalendarYear] = 2004\r GROUP BY\r         [EnglishProductCategoryName]\r ,        [CalendarYear]\r ;\r \r -- Use an implicit join to perform the update\r UPDATE  AnnualCategorySales\r SET     AnnualCategorySales.TotalSalesAmount = CTAS_ACS.TotalSalesAmount\r FROM    CTAS_acs\r WHERE   CTAS_acs.[EnglishProductCategoryName] = AnnualCategorySales.[EnglishProductCategoryName]\r AND     CTAS_acs.[CalendarYear]               = AnnualCategorySales.[CalendarYear]\r ;\r \r --Drop the interim table\r DROP TABLE CTAS_acs\r ;\r ```\r \r ## <a name=\"ansi-join-replacement-for-delete-statements\"></a> 替换 Delete 语句的 ANSI Join\r 有时，删除数据的最佳方法是使用 `CTAS`。除了删除数据以外，可以只选择想要保留的数据。这对于使用 ANSI 联接语法的 `DELETE` 语句尤其适用，因为 SQL 数据仓库不支持在 `DELETE` 语句的 `FROM` 子句中使用 ANSI Join。\r \r 转换后的 DELETE 语句示例如下所示：\r \r ```sql\r CREATE TABLE dbo.DimProduct_upsert\r WITH\r (   Distribution=HASH(ProductKey)\r ,   CLUSTERED INDEX (ProductKey)\r )\r AS -- Select Data you wish to keep\r SELECT     p.ProductKey\r ,          p.EnglishProductName\r ,          p.Color\r FROM       dbo.DimProduct p\r RIGHT JOIN dbo.stg_DimProduct s\r ON         p.ProductKey = s.ProductKey\r ;\r \r RENAME OBJECT dbo.DimProduct        TO DimProduct_old;\r RENAME OBJECT dbo.DimProduct_upsert TO DimProduct;\r ```\r \r ## <a name=\"replace-merge-statements\"></a>替换 merge 语句\r 使用 `CTAS` 至少可以部分替换 Merge 语句。可以将 `INSERT` 和 `UPDATE` 合并成单个语句。任何已删除的记录都需要在第二个语句中隔离。\r \r `UPSERT` 的示例如下：\r \r ```sql\r CREATE TABLE dbo.[DimProduct_upsert]\r WITH\r (   DISTRIBUTION = HASH([ProductKey])\r ,   CLUSTERED INDEX ([ProductKey])\r )\r AS\r -- New rows and new versions of rows\r SELECT      s.[ProductKey]\r ,           s.[EnglishProductName]\r ,           s.[Color]\r FROM      dbo.[stg_DimProduct] AS s\r UNION ALL  \r -- Keep rows that are not being touched\r SELECT      p.[ProductKey]\r ,           p.[EnglishProductName]\r ,           p.[Color]\r FROM      dbo.[DimProduct] AS p\r WHERE NOT EXISTS\r (   SELECT  *\r     FROM    [dbo].[stg_DimProduct] s\r     WHERE   s.[ProductKey] = p.[ProductKey]\r )\r ;\r \r RENAME OBJECT dbo.[DimProduct]          TO [DimProduct_old];\r RENAME OBJECT dbo.[DimpProduct_upsert]  TO [DimProduct];\r ```\r \r ## CTAS 建议：显式声明数据类型和输出是否可为 null\r 迁移代码时，可能会遇到这种类型的编码模式：\r \r ```sql\r DECLARE @d decimal(7,2) = 85.455\r ,       @f float(24)    = 85.455\r \r CREATE TABLE result\r (result DECIMAL(7,2) NOT NULL\r )\r WITH (DISTRIBUTION = ROUND_ROBIN)\r \r INSERT INTO result\r SELECT @d*@f\r ;\r ```\r \r 你可能自然而然地认为应该将此代码迁移到 CTAS。这是对的。但是，这里有一个隐含的问题。\r \r 以下代码不会生成相同的结果：\r \r ```sql\r DECLARE @d decimal(7,2) = 85.455\r ,       @f float(24)    = 85.455\r ;\r \r CREATE TABLE ctas_r\r WITH (DISTRIBUTION = ROUND_ROBIN)\r AS\r SELECT @d*@f as result\r ;\r ```\r \r 请注意，列“result”沿用表达式的数据类型和可为 null 的值。如果不小心处理，可能会导致值存在细微的差异。\r \r 请尝试使用以下内容作为示例：\r \r ```sql\r SELECT result,result*@d\r from result\r ;\r \r SELECT result,result*@d\r from ctas_r\r ;\r ```\r \r 为结果存储的值不相同。因为结果列中保留的值用于其他表达式，错误变得更加严重。\r \r ![][1]\r \r 这对于数据迁移特别重要。尽管第二个查询看起来更准确，但仍有一个问题。与源系统相比，此数据有所不同，会在迁移中造成完整性问题。这是“错误”答案其实是正确答案的极少见情况之一！\r \r 我们看到这两个结果之间有差异，追根究底的原因是隐式类型转型。在第一个示例中，表定义了列定义。插入行后，将发生隐式类型转换。在第二个示例中，没有隐式类型转换，因为表达式定义了列的数据类型。请注意，第二个示例中的列已定义为可为 Null 的列，而在第一个示例中还没有定义。在第一个示例中创建表时，尚未显式定义列可为 null。在第二个示例中，它只留给了表达式，默认情况下，这会导致 NULL 定义。\r \r 若要解决这些问题，必须在 `CTAS` 语句的 `SELECT` 部分中明确设置类型转换和可为 null 属性。无法在创建表的部分中设置这些属性。\r \r 以下示例演示如何修复代码：\r \r ```sql\r DECLARE @d decimal(7,2) = 85.455\r ,       @f float(24)    = 85.455\r \r CREATE TABLE ctas_r\r WITH (DISTRIBUTION = ROUND_ROBIN)\r AS\r SELECT ISNULL(CAST(@d*@f AS DECIMAL(7,2)),0) as result\r ```\r \r 注意以下事项：\r \r * CAST 或 CONVERT 可能已被使用\r * 使用 ISNULL 而非 COALESCE 来强制可为 NULL 属性\r * ISNULL 是最外层的函数\r * ISNULL 的第二个部分是常量，即 0\r \r > [!NOTE]\r > 若要正确设置可为 null 属性，必须使用 `ISNULL` 而不是 `COALESCE`。`COALESCE` 不是确定性的函数 ，因此表达式的结果始终可为 NULL。`ISNULL` 则不同。它是确定性的。因此当 `ISNULL` 函数的第二个部分是常量或文本时，结果值将是 NOT NULL。\r > \r > \r \r 此技巧不仅可用于确保计算的完整性，它对表分区切换也很重要。假设已将此表定义为事实：\r \r ```sql\r CREATE TABLE [dbo].[Sales]\r (\r     [date]      INT     NOT NULL\r ,   [product]   INT     NOT NULL\r ,   [store]     INT     NOT NULL\r ,   [quantity]  INT     NOT NULL\r ,   [price]     MONEY   NOT NULL\r ,   [amount]    MONEY   NOT NULL\r )\r WITH\r (   DISTRIBUTION = HASH([product])\r ,   PARTITION   (   [date] RANGE RIGHT FOR VALUES\r                     (20000101,20010101,20020101\r                     ,20030101,20040101,20050101\r                     )\r                 )\r )\r ;\r ```\r \r 然而，值字段是计算的表达式，而不是源数据的一部分。\r \r 若要创建分区数据集，可能需要执行以下操作：\r \r ```sql\r CREATE TABLE [dbo].[Sales_in]\r WITH    \r (   DISTRIBUTION = HASH([product])\r ,   PARTITION   (   [date] RANGE RIGHT FOR VALUES\r                     (20000101,20010101\r                     )\r                 )\r )\r AS\r SELECT\r     [date]    \r ,   [product]\r ,   [store]\r ,   [quantity]\r ,   [price]   \r ,   [quantity]*[price]  AS [amount]\r FROM [stg].[source]\r OPTION (LABEL = 'CTAS : Partition IN table : Create')\r ;\r ```\r \r 该查询会顺利运行。但是，尝试执行分区切换时，将会出现问题。表定义不匹配。若要使表定义匹配，需要修改 CTAS。\r \r ```sql\r CREATE TABLE [dbo].[Sales_in]\r WITH    \r (   DISTRIBUTION = HASH([product])\r ,   PARTITION   (   [date] RANGE RIGHT FOR VALUES\r                     (20000101,20010101\r                     )\r                 )\r )\r AS\r SELECT\r     [date]    \r ,   [product]\r ,   [store]\r ,   [quantity]\r ,   [price]   \r ,   ISNULL(CAST([quantity]*[price] AS MONEY),0) AS [amount]\r FROM [stg].[source]\r OPTION (LABEL = 'CTAS : Partition IN table : Create');\r ```\r \r 因此，可以看出，保持类型一致性并维护 CTAS 上的可为 null 属性是良好的工程最佳实践。这有助于维护计算的完整性，而且还可确保分区切换能够实现。\r \r 有关使用 [CTAS][CTAS] 的详细信息，请参阅 MSDN。CTAS 是 Azure SQL 数据仓库中最重要的语句之一。请确保全面了解该语句。\r \r ## 后续步骤\r 有关更多开发技巧，请参阅[开发概述][development overview]。\r \r <!--Image references-->\r [1]: ./media/sql-data-warehouse-develop-ctas/ctas-results.png\r \r <!--Article references-->\r [development overview]: ./sql-data-warehouse-overview-develop.md\r [Statistics]: ./sql-data-warehouse-tables-statistics.md\r \r <!--MSDN references-->\r [CTAS]: https://msdn.microsoft.com/zh-cn/library/mt204041.aspx\r \r <!--Other Web references-->\r \r <!---HONumber=Mooncake_0313_2017-->\r <!--Update_Description:update meta properties;wroding update;add Select into vs CATS compare-->"}