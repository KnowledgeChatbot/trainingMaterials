{"Title":"开始使用 node.js 进行 Azure AD 登录和注销","Description":"如何生成一个与 Azure AD 集成以方便登录的 node.js Express MVC Web 应用。","Content":"\r # 使用 Azure AD 执行 NodeJS Web 应用登录和注销\r 我们将在此处使用 Passport 来执行以下操作：\r \r - 使用 Azure AD 将用户登录到应用。\r - 显示有关用户的一些信息。\r - 从应用中注销用户。\r \r **Passport** 是 Node.js 的身份验证中间件。Passport 极其灵活并且采用模块化结构，可以在不造成干扰的情况下放入任何基于 Express 的应用程序或 Resitify Web 应用程序。一套综合性策略支持使用用户名和密码、Facebook、Twitter 等进行身份验证。我们针对 Azure Active directory 开发了一项策略。我们将安装此模块，然后添加 Azure Active Directory `passport-azure-ad` 插件。\r \r 为此，你需要：\r \r 1. 注册应用。\r 2. 将应用设置为使用 Passport-azure-ad 策略。\r 3. 使用 Passport 向 Azure AD 发出登录和注销请求。\r 4. 列显有关用户的数据。\r \r 本教程的代码[在 GitHub 上](https://github.com/AzureADQuickStarts/WebApp-OpenIDConnect-NodeJS)维护。若要遵照该代码，你可以[下载 .zip 格式应用骨架](https://github.com/AzureADQuickStarts/WebApp-OpenIDConnect-NodeJS/archive/skeleton.zip)，或克隆该骨架：\r \r ```\r git clone --branch skeleton https://github.com/AzureADQuickStarts/WebApp-OpenIDConnect-NodeJS.git\r ```\r \r 本教程末尾也提供完成的应用程序。\r \r ## 1\\.注册应用\r - 登录到 Azure 管理门户。\r - 在左侧的导航栏中单击“Active Directory”。\r - 选择你要在其中注册应用程序的租户。\r - 单击“应用程序”选项卡，然后在底部抽屉中单击“添加”。\r - 根据提示创建一个新的 **Web 应用程序和/或 WebAPI**。\r     - 应用程序的**名称**向最终用户描述你的应用程序\r     - “登录 URL”是应用程序的基本 URL。框架的默认值为 http://localhost:3000/auth/openid/return``。\r     - “应用程序 ID URI”是应用程序的唯一标识符。约定是使用 `https://<tenant-domain>/<app-name>`，例如 `https://contoso.partner.onmschina.cn/my-first-aad-app`\r - 完成注册后，AAD 将为应用分配唯一的客户端标识符。在后面的部分中将会用到此值，因此，请从“配置”选项卡复制此值。\r \r ## 2\\.将先决条件添加到目录\r 在命令行中，将目录切换到根文件夹（如果尚未这样做），然后运行以下命令：\r \r - `npm install express`\r - `npm install ejs`\r - `npm install ejs-locals`\r - `npm install restify`\r - `npm install mongoose`\r - `npm install bunyan`\r - `npm install assert-plus`\r - `npm install passport`\r - 此外，你还需要我们的 `passport-azure-ad`：\r - `npm install passport-azure-ad`\r \r 这将会安装 passport-azure-ad 所依赖的库。\r \r ## 3\\.将应用设置为使用 passport-node-js 策略\r 在这里，我们要将 Express 中间件配置为使用 OpenID Connect 身份验证协议。Passport 将用于发出登录和注销请求、管理用户的会话、获取有关用户的信息，等等。\r \r - 首先，打开位于项目根目录中的 `config.js` 文件，并在 `exports.creds` 节中输入应用的配置值。\r \r   - `clientID:` 是在注册门户中为应用分配的**应用程序 ID**。\r   - `returnURL` 是在门户中输入的**重定向 URI**。\r   - `clientSecret` 是在门户中生成的密码。\r - 接下来，打开项目根目录中的 `app.js` 文件，并添加以下调用以调用 `passport-azure-ad` 随附的 `OIDCStrategy` 策略\r \r     ```JavaScript\r     var OIDCStrategy = require('passport-azure-ad').OIDCStrategy;\r \r     // add a logger\r \r     var log = bunyan.createLogger({\r         name: 'Microsoft OIDC Example Web Application'\r     });\r     ```\r \r - 然后，使用我们刚刚提到的策略来处理登录请求\r \r     ```JavaScript\r     // Use the OIDCStrategy within Passport. (Section 2) \r     // \r     //   Strategies in passport require a `validate` function, which accept\r     //   credentials (in this case, an OpenID identifier), and invoke a callback\r     //   with a user object.\r     passport.use(new OIDCStrategy({\r         callbackURL: config.creds.returnURL,\r         realm: config.creds.realm,\r         clientID: config.creds.clientID,\r         clientSecret: config.creds.clientSecret,\r         oidcIssuer: config.creds.issuer,\r         identityMetadata: config.creds.identityMetadata,\r         skipUserProfile: config.creds.skipUserProfile,\r         responseType: config.creds.responseType,\r         responseMode: config.creds.responseMode\r       },\r       function(iss, sub, profile, accessToken, refreshToken, done) {\r         if (!profile.email) {\r           return done(new Error(\"No email found\"), null);\r         }\r         // asynchronous verification, for effect...\r         process.nextTick(function () {\r           findByEmail(profile.email, function(err, user) {\r             if (err) {\r               return done(err);\r             }\r             if (!user) {\r               // \"Auto-registration\"\r               users.push(profile);\r               return done(null, profile);\r             }\r             return done(null, user);\r           });\r         });\r       }\r     ));\r     ```\r \r     Passport 对其所有策略（Twitter、Facebook 等）都使用所有策略写入器都依循的类似模式。查看该策略，你会发现，我们已将它作为 function() 来传递，其中包含一个令牌和一个用作参数的 done。策略完成所有工作之后，将按计划返回。然后，我们需要存储用户和令牌，因此不需要再次请求。\r \r     > [!IMPORTANT]\r     > 上述代码接受正好向服务器进行身份验证的任何用户。这便是自动注册。在生产服务器中，你希望所有人都必须先经历你确定的注册过程。这通常是在使用者应用中看到的模式，允许注册 Facebook，但接着请求填写其他信息。如果这不是示例应用程序，我们就只能从返回的令牌对象中提取电子邮件，然后请求他们填写其他信息。由于这是测试服务器，我们直接将它们加入到内存中的数据库。\r     > \r     > \r \r - 接下来，让我们添加方法，以便根据 Passport 的要求，持续跟踪已登录的用户。这包括将用户信息序列化和反序列化：\r \r     ```JavaScript\r     // Passport session setup. (Section 2)\r \r     //   To support persistent login sessions, Passport needs to be able to\r     //   serialize users into and deserialize users out of the session.  Typically,\r     //   this will be as simple as storing the user ID when serializing, and finding\r     //   the user by ID when deserializing.\r     passport.serializeUser(function(user, done) {\r       done(null, user.email);\r     });\r \r     passport.deserializeUser(function(id, done) {\r       findByEmail(id, function (err, user) {\r         done(err, user);\r       });\r     });\r \r     // array to hold logged in users\r     var users = [];\r \r     var findByEmail = function(email, fn) {\r       for (var i = 0, len = users.length; i < len; i++) {\r         var user = users[i];\r        log.info('we are using user: ', user);\r         if (user.email === email) {\r           return fn(null, user);\r         }\r       }\r       return fn(null, null);\r     };\r     ```\r \r - 接下来，让我们添加可加载 Express 引擎的代码。在此处，你将看到我们使用了 Express 提供的默认 /views 和 /routes 模式。\r \r     ```JavaScript\r     // configure Express (Section 2)\r \r     var app = express();\r \r     app.configure(function() {\r       app.set('views', __dirname + '/views');\r       app.set('view engine', 'ejs');\r       app.use(express.logger());\r       app.use(express.methodOverride());\r       app.use(cookieParser());\r       app.use(expressSession({ secret: 'keyboard cat', resave: true, saveUninitialized: false }));\r       app.use(bodyParser.urlencoded({ extended : true }));\r       // Initialize Passport!  Also use passport.session() middleware, to support\r       // persistent login sessions (recommended).\r       app.use(passport.initialize());\r       app.use(passport.session());\r       app.use(app.router);\r       app.use(express.static(__dirname + '/../../public'));\r     });\r     ```\r \r - 最后，让我们添加路由，以便将实际的登录请求递交到 `passport-azure-ad` 引擎：\r \r     ```JavaScript\r     // Our Auth routes (Section 3)\r \r     // GET /auth/openid\r     //   Use passport.authenticate() as route middleware to authenticate the\r     //   request.  The first step in OpenID authentication will involve redirecting\r     //   the user to their OpenID provider.  After authenticating, the OpenID\r     //   provider will redirect the user back to this application at\r     //   /auth/openid/return\r     app.get('/auth/openid',\r       passport.authenticate('azuread-openidconnect', { failureRedirect: '/login' }),\r       function(req, res) {\r         log.info('Authentication was called in the Sample');\r         res.redirect('/');\r       });\r \r     // GET /auth/openid/return\r     //   Use passport.authenticate() as route middleware to authenticate the\r     //   request.  If authentication fails, the user will be redirected back to the\r     //   login page.  Otherwise, the primary route function function will be called,\r     //   which, in this example, will redirect the user to the home page.\r     app.get('/auth/openid/return',\r       passport.authenticate('azuread-openidconnect', { failureRedirect: '/login' }),\r       function(req, res) {\r         log.info('We received a return from AzureAD.');\r         res.redirect('/');\r       });\r \r     // POST /auth/openid/return\r     //   Use passport.authenticate() as route middleware to authenticate the\r     //   request.  If authentication fails, the user will be redirected back to the\r     //   login page.  Otherwise, the primary route function function will be called,\r     //   which, in this example, will redirect the user to the home page.\r     app.post('/auth/openid/return',\r       passport.authenticate('azuread-openidconnect', { failureRedirect: '/login' }),\r       function(req, res) {\r         log.info('We received a return from AzureAD.');\r         res.redirect('/');\r       });\r     ```\r \r ## 4\\.使用 Passport 向 Azure AD 发出登录和注销请求\r \r 现在，应用已正确配置为使用 OpenID Connect 身份验证协议与 v2.0 终结点通信。`passport-azure-ad` 会代你处理有关创建身份验证消息、验证 Azure AD 提供的令牌以及保留用户会话的繁琐细节。你要做的就是为用户提供登录和注销方式，以及收集有关已登录用户的其他信息。\r \r - 首先，让我们在 `app.js` 文件中添加 default、login、account 和 logout 方法：\r \r     ```JavaScript\r     //Routes (Section 4)\r \r     app.get('/', function(req, res){\r       res.render('index', { user: req.user });\r     });\r \r     app.get('/account', ensureAuthenticated, function(req, res){\r       res.render('account', { user: req.user });\r     });\r \r     app.get('/login',\r       passport.authenticate('azuread-openidconnect', { failureRedirect: '/login' }),\r       function(req, res) {\r         log.info('Login was called in the Sample');\r         res.redirect('/');\r     });\r \r     app.get('/logout', function(req, res){\r       req.logout();\r       res.redirect('/');\r     });\r     ```\r \r - 我们详细探讨一下：\r \r   - `/` 路由将重定向到 index.ejs 视图，并在请求中传递用户（如果存在）\r   - `/account` 路由首先***确保我们已经过身份验证***（下面我们将会实现），然后在请求中传递用户，以便我们可以获取有关该用户的其他信息。\r   - `/login` 路由将从 `passport-azuread` 调用 azuread-openidconnect 验证器，如果该操作不成功，则将用户重定向回到 /login\r   - `/logout` 只是调用 logout.ejs（和路由），以便清除 Cookie 并将用户返回到 index.ejs\r - 对于 `app.js` 的最后一个部分，让我们添加上述 `/account` 中使用的 EnsureAuthenticated 方法。\r \r     ```JavaScript\r     // Simple route middleware to ensure user is authenticated. (Section 4)\r \r     //   Use this route middleware on any resource that needs to be protected.  If\r     //   the request is authenticated (typically via a persistent login session),\r     //   the request will proceed.  Otherwise, the user will be redirected to the\r     //   login page.\r     function ensureAuthenticated(req, res, next) {\r       if (req.isAuthenticated()) { return next(); }\r       res.redirect('/login')\r     }\r     ```\r \r - 最后，在 `app.js` 中实际创建服务器本身：\r \r     ```JavaScript\r     app.listen(3000);\r     ```\r \r ## 5\\.在 Express 中创建视图与路由，以在网站中显示用户\r 我们已完成 `app.js`。现在只需添加路由和视图即可，两者将向用户显示我们获取的信息，并处理我们创建的 `/logout` 和 `/login` 路由。\r \r - 在根目录下创建 `/routes/index.js` 路由。\r \r     ```JavaScript\r     /*\r      * GET home page.\r      */\r \r     exports.index = function(req, res){\r       res.render('index', { title: 'Express' });\r     };\r     ```\r \r - 在根目录下创建 `/routes/user.js` 路由\r \r     ```JavaScript\r     /*\r      * GET users listing.\r      */\r \r     exports.list = function(req, res){\r       res.send(\"respond with a resource\");\r     };\r     ```\r \r     这些简单路由只将请求传递到我们的视图，包括用户（如果存在）。\r \r - 在根目录下创建 `/views/index.ejs` 视图。这是一个简单的页面，将调用我们的登录和注销方法，并允许我们捕获帐户信息。请注意，如果在请求中传递的用户证明我们拥有已登录的用户，就能使用条件性 `if (!user)`。\r \r     ```JavaScript\r     <% if (!user) { %>\r         <h2>Welcome! Please log in.</h2>\r         <a href=\"/login\">Log In</a>\r     <% } else { %>\r         <h2>Hello, <%= user.displayName %>.</h2>\r         <a href=\"/account\">Account Info</a></br>\r         <a href=\"/logout\">Log Out</a>\r     <% } %>\r     ```\r \r - 在根目录下创建 `/views/account.ejs` 视图，以便能够查看 `passport-azuread` 放置在用户请求中的其他信息。\r \r     ```Javascript\r     <% if (!user) { %>\r         <h2>Welcome! Please log in.</h2>\r         <a href=\"/login\">Log In</a>\r     <% } else { %>\r     <p>displayName: <%= user.displayName %></p>\r     <p>givenName: <%= user.name.givenName %></p>\r     <p>familyName: <%= user.name.familyName %></p>\r     <p>UPN: <%= user._json.upn %></p>\r     <p>Profile ID: <%= user.id %></p>\r     <p>Full Claimes</p>\r     <%- JSON.stringify(user) %>\r     <p></p>\r     <a href=\"/logout\">Log Out</a>\r     <% } %>\r     ```\r \r - 最后，可以通过添加布局，使视图变得美观。在根目录下创建 '/views/layout.ejs' 视图\r \r     ```HTML\r     <!DOCTYPE html>\r     <html>\r         <head>\r             <title>Passport-OpenID Example</title>\r         </head>\r         <body>\r             <% if (!user) { %>\r                 <p>\r                 <a href=\"/\">Home</a> | \r                 <a href=\"/login\">Log In</a>\r                 </p>\r             <% } else { %>\r                 <p>\r                 <a href=\"/\">Home</a> | \r                 <a href=\"/account\">Account</a> | \r                 <a href=\"/logout\">Log Out</a>\r                 </p>\r             <% } %>\r             <%- body %>\r         </body>\r     </html>\r     ```\r \r 最后，生成并运行应用！\r \r 运行 `node app.js` 并导航到 `http://localhost:3000`\r \r 使用个人 Microsoft 帐户或者工作或学校帐户登录，随后你会看到该用户的标识已出现在 /account 列表中。Web 应用现在使用行业标准协议进行保护，你可以使用个人和工作/学校帐户来验证用户。\r \r [此处以 .zip 格式提供了](https://github.com/AzureADQuickStarts/WebApp-OpenIDConnect-NodeJS/archive/complete.zip)完整示例（不包括配置值），你也可以从 GitHub 克隆该示例：\r \r ```\r git clone --branch complete https://github.com/AzureADQuickStarts/WebApp-OpenIDConnect-NodeJS.git\r ```\r \r 现在，可以转到更高级的主题。你可能想要尝试：\r \r [使用 Azure AD 保护 Web API >>](./active-directory-devquickstarts-webapi-nodejs.md)\r \r [!INCLUDE [active-directory-devquickstarts-additional-resources](../../../includes/active-directory-devquickstarts-additional-resources.md)]\r \r <!---HONumber=Mooncake_0120_2017-->\r <!---Update_Description: wording update -->"}