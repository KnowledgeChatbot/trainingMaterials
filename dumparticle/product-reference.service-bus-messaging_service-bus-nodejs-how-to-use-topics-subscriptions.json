{"Title":"如何通过 Node.js 使用 Azure 服务总线主题和订阅","Description":"了解如何通过 Node.js 应用在 Azure 中使用服务总线主题和订阅。","Content":"# <a name=\"how-to-use-service-bus-topics-and-subscriptions-with-nodejs\"></a>如何通过 Node.js 使用服务总线主题和订阅\r \r [!INCLUDE [service-bus-selector-topics](../../includes/service-bus-selector-topics.md)]\r \r 本指南介绍如何从 Node.js 应用程序使用服务总线主题和订阅。 涉及的应用场景包括创建主题和订阅、创建订阅筛选器、将消息发送到主题、从订阅接收消息以及删除主题和订阅。 有关主题和订阅的详细信息，请参阅 [后续步骤](#next-steps) 部分。\r \r [!INCLUDE [howto-service-bus-topics](../../includes/howto-service-bus-topics.md)]\r \r ## <a name=\"create-a-nodejs-application\"></a>创建 Node.js 应用程序\r 创建一个空的 Node.js 应用程序。 有关创建 Node.js 应用程序的说明，请参阅[创建 Node.js 应用程序并将其部署到 Azure 网站]、使用 Windows PowerShell [创建 Node.js 云服务][Node.js Cloud Service]或使用 WebMatrix 创建网站。\r \r ## <a name=\"configure-your-application-to-use-service-bus\"></a>配置应用程序以使用 Service Bus\r \r 若要使用服务总线，请下载 Node.js Azure 包。 此程序包包括一组用来与服务总线 REST 服务通信的库。\r \r ### <a name=\"use-node-package-manager-npm-to-obtain-the-package\"></a>使用 Node 包管理器 (NPM) 可获取该程序包\r \r 1.  使用 PowerShell (Windows)、Terminal (Mac) 或 Bash (Unix) 等命令行接口导航到在其中创建了示例应用程序的文件夹。\r \r 2.  在命令窗口中键入 **npm install azure**，这应会生成以下输出：\r \r     ```\r     azure@0.7.5 node_modules\\azure\r         ├── dateformat@1.0.2-1.2.3\r         ├── xmlbuilder@0.4.2\r         ├── node-uuid@1.2.0\r         ├── mime@1.2.9\r         ├── underscore@1.4.4\r         ├── validator@1.1.1\r         ├── tunnel@0.0.2\r         ├── wns@0.5.3\r         ├── xml2js@0.2.7 (sax@0.5.2)\r         └── request@2.21.0 (json-stringify-safe@4.0.0, forever-agent@0.5.0, aws-sign@0.3.0, tunnel-agent@0.3.0, oauth-sign@0.3.0, qs@0.6.5, cookie-jar@0.3.0, node-uuid@1.4.0, http-signature@0.9.11, form-data@0.0.8, hawk@0.13.1)\r     ```\r \r 3.  可以手动运行 **ls** 命令来验证是否创建了 **node\\_modules** 文件夹。在该文件夹中，找到 **azure** 程序包，其中包含访问服务总线主题所需的库。\r \r ### <a name=\"import-the-module\"></a>导入模块\r \r 使用记事本或其他文本编辑器将以下内容添加到应用程序的 **server.js** 文件的顶部：\r \r ```javascript\r     var azure = require('azure');\r ```\r \r ### <a name=\"set-up-a-service-bus-connection\"></a>设置服务总线连接\r Azure 模块读取环境变量 `AZURE_SERVICEBUS_NAMESPACE` 和 `AZURE_SERVICEBUS_ACCESS_KEY`，获取连接到服务总线所需的信息。 如果未设置这些环境变量，则必须在调用 `createServiceBusService` 时指定帐户信息。\r \r 有关设置 Azure 云服务环境变量的示例，请参阅[使用存储的 Node.js 云服务][Node.js Cloud Service with Storage]。\r \r 有关设置 Azure 网站环境变量的示例，请参阅[使用存储的 Node.js Web 应用程序][Node.js Web Application with Storage]。\r \r ## <a name=\"create-a-topic\"></a>创建主题\r \r 可以通过 **ServiceBusService** 对象处理主题。以下代码创建 **ServiceBusService** 对象。将它添加到靠近 **server.js** 文件顶部、用于导入 azure 模块的语句之后的位置：\r \r ```javascript\r     var serviceBusService = azure.createServiceBusService();\r ```\r \r 通过对 ServiceBusService 对象调用 createTopicIfNotExists，将返回指定的主题（如果存在），否则将使用指定名称创建新主题。 以下代码使用 **createTopicIfNotExists** 创建或连接到名为“MyTopic”的主题：\r \r ```javascript\r     serviceBusService.createTopicIfNotExists('MyTopic',function(error){\r         if(!error){\r             // Topic was created or exists\r             console.log('topic created or exists.');\r         }\r     });\r ```\r \r `createServiceBusService` 方法还支持其他选项，通过这些选项可以重写默认主题设置，例如消息生存时间或最大主题大小。 以下示例将最大主题大小设置为 5GB，将生存时间设置为 1 分钟：\r \r ```javascript\r     var topicOptions = {\r             MaxSizeInMegabytes: '5120',\r             DefaultMessageTimeToLive: 'PT1M'\r         };\r \r     serviceBusService.createTopicIfNotExists('MyTopic', topicOptions, function(error){\r         if(!error){\r             // topic was created or exists\r         }\r     });\r ```\r \r ### <a name=\"filters\"></a>筛选器\r 可选的筛选操作可应用于使用 **ServiceBusService** 执行的操作。 筛选操作可包括日志记录、自动重试等。筛选器是实现具有签名的方法的对象：\r \r ```javascript\r     function handle (requestOptions, next)\r ```\r \r 在对请求选项执行预处理后，该方法会调用 `next`，传递具有以下签名的回调：\r \r ```javascript\r     function (returnObject, finalCallback, next)\r ```\r \r 在此回调中并且在处理 `returnObject`（来自对服务器请求的响应）后，回调需要调用 next（如果存在）以继续处理其他筛选器，或者调用 `finalCallback` 结束服务调用。\r \r Azure SDK for Node.js 中附带了两个实现了重试逻辑的筛选器，分别是 **ExponentialRetryPolicyFilter** 和 **LinearRetryPolicyFilter**。以下代码创建一个 **ServiceBusService** 对象，该对象使用 **ExponentialRetryPolicyFilter**：\r \r ```javascript\r var retryOperations = new azure.ExponentialRetryPolicyFilter();\r var serviceBusService = azure.createServiceBusService().withFilter(retryOperations);\r ```\r \r ## <a name=\"create-subscriptions\"></a>创建订阅\r \r 主题订阅也是使用 **ServiceBusService** 对象创建的。订阅已命名，并且具有一个限制传递到订阅的虚拟队列的消息集的可选筛选器。\r \r > [!NOTE]\r > 订阅是永久性的，除非删除它或删除与之相关的主题，否则订阅将一直存在。 如果应用程序包含创建订阅的逻辑，则它应首先使用 `getSubscription` 方法检查该订阅是否已经存在。\r >\r >\r \r ### <a name=\"create-a-subscription-with-the-default-matchall-filter\"></a>创建具有默认 (MatchAll) 筛选器的订阅\r \r **MatchAll** 筛选器是默认筛选器，在创建新订阅时未指定筛选器的情况下使用。 使用 **MatchAll** 筛选器时，发布到主题的所有消息都会置于订阅的虚拟队列中。 以下示例创建名为“AllMessages”的订阅，并使用默认的 **MatchAll** 筛选器。\r \r ```javascript\r     serviceBusService.createSubscription('MyTopic','AllMessages',function(error){\r         if(!error){\r             // subscription created\r         }\r     });\r ```\r \r ### <a name=\"create-subscriptions-with-filters\"></a>创建具有筛选器的订阅\r \r 还可以创建筛选器，以确定发送到主题的哪些消息应该在特定主题订阅中显示。\r \r 订阅支持的最灵活的一种筛选器是 **SqlFilter**，它实现了一部分 SQL92 功能。 SQL 筛选器将对发布到主题的消息的属性进行操作。 有关可用于 SQL 筛选器的表达式的更多详细信息，请参阅 [SqlFilter.SqlExpression][SqlFilter.SqlExpression] 语法。\r \r 可以使用 ServiceBusService 对象的 `createRule` 方法向订阅中添加筛选器。 此方法允许向现有订阅中添加新筛选器。\r \r > [!NOTE]\r > 由于默认筛选器会自动应用到所有新订阅，因此，必须首先删除默认筛选器，否则 **MatchAll** 会替代你可能指定的任何其他筛选器。 可以使用 ServiceBusService 对象的 `deleteRule` 方法删除默认规则。\r >\r >\r \r 以下示例创建一个名为 `HighMessages` 的订阅，该订阅包含一个 SqlFilter，它仅选择自定义 `messagenumber` 属性大于 3 的消息：\r \r ```javascript\r     serviceBusService.createSubscription('MyTopic', 'HighMessages', function (error){\r         if(!error){\r             // subscription created\r             rule.create();\r         }\r     });\r     var rule={\r         deleteDefault: function(){\r             serviceBusService.deleteRule('MyTopic',\r                 'HighMessages', \r                 azure.Constants.ServiceBusConstants.DEFAULT_RULE_NAME, \r                 rule.handleError);\r         },\r         create: function(){\r             var ruleOptions = {\r                 sqlExpressionFilter: 'messagenumber > 3'\r             };\r             rule.deleteDefault();\r             serviceBusService.createRule('MyTopic', \r                 'HighMessages', \r                 'HighMessageFilter', \r                 ruleOptions, \r                 rule.handleError);\r         },\r         handleError: function(error){\r             if(error){\r                 console.log(error)\r             }\r         }\r     }\r ```\r \r 同样，以下示例创建一个名为 `LowMessages` 的订阅，该订阅包含一个 SqlFilter，它仅选择 `messagenumber` 属性小于或等于 3 的消息：\r \r ```javascript\r     serviceBusService.createSubscription('MyTopic', 'LowMessages', function (error){\r         if(!error){\r             // subscription created\r             rule.create();\r         }\r     });\r     var rule={\r         deleteDefault: function(){\r             serviceBusService.deleteRule('MyTopic',\r                 'LowMessages', \r                 azure.Constants.ServiceBusConstants.DEFAULT_RULE_NAME, \r                 rule.handleError);\r         },\r         create: function(){\r             var ruleOptions = {\r                 sqlExpressionFilter: 'messagenumber <= 3'\r             };\r             rule.deleteDefault();\r             serviceBusService.createRule('MyTopic', \r                 'LowMessages', \r                 'LowMessageFilter', \r                 ruleOptions, \r                 rule.handleError);\r         },\r         handleError: function(error){\r             if(error){\r                 console.log(error)\r             }\r         }\r     }\r ```\r \r 现在，当消息发送到 `MyTopic` 时，它始终会传送给订阅了 `AllMessages` 主题订阅的接收者，并且选择性地传送给订阅了 `HighMessages` 和 `LowMessages` 主题订阅的接收者（具体取决于消息内容）。\r \r ## <a name=\"how-to-send-messages-to-a-topic\"></a>如何将消息发送到主题\r \r 要将消息发送到服务总线主题，应用程序必须使用 ServiceBusService 对象的 `sendTopicMessage` 方法。\r 发送到服务总线主题的消息是 **BrokeredMessage** 对象。\r BrokeredMessage 对象具有一组标准属性（如 `Label` 和 `TimeToLive`）、一个用于保存特定于应用程序的自定义属性的字典，以及一段字符串数据正文。 应用程序可以通过将字符串值传递给 `sendTopicMessage` 设置消息正文，并且任何必需的标准属性将用默认值填充。\r \r 以下示例演示如何向 `MyTopic`发送五条测试消息。 请注意，每条消息的 `messagenumber` 属性值因循环迭代而异（这会确定接收消息的订阅）：\r \r ```javascript\r     var message = {\r         body: '',\r         customProperties: {\r             messagenumber: 0\r         }\r     }\r \r     for (i = 0;i < 5;i++) {\r         message.customProperties.messagenumber=i;\r         message.body='This is Message #'+i;\r         serviceBusService.sendTopicMessage(topic, message, function(error) {\r           if (error) {\r             console.log(error);\r           }\r         });\r     }\r ```\r \r 服务总线主题在标准层中支持的最大消息大小为 256 KB。标头最大为 64 KB，其中包括标准和自定义应用程序属性。一个主题中包含的消息数量不受限制，但消息的总大小受限制。此主题大小是在创建时定义的，上限为 5 GB。\r \r ## <a name=\"receive-messages-from-a-subscription\"></a>从订阅接收消息\r 对 ServiceBusService 对象使用 `receiveSubscriptionMessage` 方法可从订阅接收消息。 默认情况下，消息被读取后即从订阅删除；但是可以读取（速览）并锁定消息而不将其从订阅删除，只要将可选参数 `isPeekLock` 设置为“true”即可。\r \r 在接收过程中读取并删除消息的默认行为是最简单的模式，并且最适合在发生故障时应用程序可以容忍不处理消息的情况。 为了理解这一点，可以考虑这样一种情形：使用方发出接收请求，但在处理该请求前发生了崩溃。 由于服务总线会将消息标记为“已使用”，因此当应用程序重启并重新开始使用消息时，它会遗漏在发生崩溃前使用的消息。\r \r 如果将 `isPeekLock` 参数设置为“true”，则接收会变成一个两阶段操作，从而可支持无法容忍遗漏消息的应用程序。 当 Service Bus 收到请求时，它会查找下一条要使用的消息，锁定该消息以防其他使用者接收，并将该消息返回到应用程序。\r 应用程序处理完该消息（或将它可靠地存储起来留待将来处理）后，通过调用 **deleteMessage** 方法并提供要删除的消息作为参数来完成接收过程的第二阶段。 **deleteMessage** 方法会将消息标记为已使用，并将其从订阅中删除。\r \r 以下示例演示如何使用 `receiveSubscriptionMessage` 接收和处理消息。 该示例先从“LowMessages”订阅接收并删除一条消息，然后将 `isPeekLock` 设置为“true”，从“HighMessages”订阅接收一条消息。 最后使用 `deleteMessage` 删除该消息：\r \r ```javascript\r     serviceBusService.receiveSubscriptionMessage('MyTopic', 'LowMessages', function(error, receivedMessage){\r         if(!error){\r             // Message received and deleted\r             console.log(receivedMessage);\r         }\r     });\r     serviceBusService.receiveSubscriptionMessage('MyTopic', 'HighMessages', { isPeekLock: true }, function(error, lockedMessage){\r         if(!error){\r             // Message received and locked\r             console.log(lockedMessage);\r             serviceBusService.deleteMessage(lockedMessage, function (deleteError){\r                 if(!deleteError){\r                     // Message deleted\r                     console.log('message has been deleted.');\r                 }\r             }\r         }\r     });\r ```\r \r ## <a name=\"how-to-handle-application-crashes-and-unreadable-messages\"></a>如何处理应用程序崩溃和不可读消息\r \r Service Bus 提供了相关功能来帮助你轻松地从应用程序错误或消息处理问题中恢复。 如果接收方应用程序因某种原因无法处理消息，则它可以对 ServiceBusService 对象调用 `unlockMessage` 方法。 这会导致 Service Bus 在订阅中将该消息解锁，使之再次可供同一使用方应用程序或其他使用方应用程序接收。\r \r 另外，还存在与订阅中已锁定消息关联的超时，并且如果应用程序无法在锁定超时到期之前处理消息（例如，如果应用程序崩溃），则服务总线将自动解锁该消息并使其可再次被接收。\r \r 如果应用程序在处理消息之后，但在调用 `deleteMessage` 方法之前崩溃，则在应用程序重启时会将该消息重新传送给它。 此情况通常称作*至少处理一次*，即每条消息至少被处理一次，但在某些情况下，同一消息可能会被重新传送。 如果方案无法容忍重复处理，则应用程序开发人员应向其应用程序添加更多逻辑以处理重复消息传送。 这通常可以通过使用消息的 **MessageId** 属性来实现，该属性在多次传送尝试中保持不变。\r \r ## <a name=\"delete-topics-and-subscriptions\"></a>删除主题和订阅\r \r 主题和订阅具有持久性，必须通过 [Azure 门户][Azure portal]或以编程方式显式删除。\r 以下示例演示了如何删除名为 `MyTopic`的主题：\r \r ```javascript\r     serviceBusService.deleteTopic('MyTopic', function (error) {\r         if (error) {\r             console.log(error);\r         }\r     });\r ```\r \r 删除某个主题也会删除向该主题注册的所有订阅。 也可以单独删除订阅。 以下示例说明如何从 `MyTopic` 主题删除名为 `HighMessages` 的订阅：\r \r ```javascript\r     serviceBusService.deleteSubscription('MyTopic', 'HighMessages', function (error) {\r         if(error) {\r             console.log(error);\r         }\r     });\r ```\r \r ## <a name=\"next-steps\"></a> 后续步骤\r \r 现在，已了解有关 Service Bus 主题的基础知识，单击下面的链接可了解更多信息。\r \r * 请参阅[队列、主题和订阅][Queues, topics, and subscriptions]。\r * [SqlFilter][SqlFilter] 的 API 参考。\r * 访问 GitHub 上的 [Azure SDK for Node][Azure SDK for Node] 存储库。\r \r [Azure SDK for Node]: https://github.com/Azure/azure-sdk-for-node\r \r [Azure portal]: https://portal.azure.cn\r [SqlFilter.SqlExpression]: ./service-bus-messaging-sql-filter.md\r [Queues, topics, and subscriptions]: ./service-bus-queues-topics-subscriptions.md\r [SqlFilter]: https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.sqlfilter\r   [Node.js Cloud Service]: ../cloud-services/cloud-services-nodejs-develop-deploy-app.md\r [创建 Node.js 应用程序并将其部署到 Azure 网站]: ../app-service/app-service-web-get-started-nodejs.md\r   [Node.js Cloud Service with Storage]: ../cloud-services/cloud-services-nodejs-develop-deploy-app.md\r [Node.js Web Application with Storage]:../cosmos-db/table-storage-cloud-service-nodejs.md\r \r \r <!--Update_Description:update link references and wording-->"}