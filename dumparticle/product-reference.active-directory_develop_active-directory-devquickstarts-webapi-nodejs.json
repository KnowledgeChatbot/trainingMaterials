{"Title":"Azure Active Directory Node.js 入门","Description":"如何生成一个与 Azure AD 集成、可用于身份验证的 Node.js REST Web API。","Content":"# <a name=\"getting-started-with-web-api-for-node\"></a>节点 WEB API 入门\r [!INCLUDE [active-directory-devguide](../../../includes/active-directory-devguide.md)]\r \r **Passport** 是 Node.js 的身份验证中间件。 Passport 极其灵活并且采用模块化结构，可以在不造成干扰的情况下放入任何基于 Express 的应用程序或 Resitify Web 应用程序。 可以使用一套综合性策略，通过用户名、密码等进行身份验证。 我们针对 Azure Active directory 开发了一个策略。 我们将安装此模块，并添加 Azure Active Directory `passport-azure-ad` 插件。\r \r 为此，需要：\r \r 1. 将应用程序注册到 Azure AD\r 2. 将应用设置为使用 Passport 的 azure-ad-passport 插件。\r 3. 配置一个客户端应用程序用于调用待办事项列表 Web API\r \r 本教程的代码 [在 GitHub 上](https://github.com/Azure-Samples/active-directory-node-webapi)维护。\r \r > [!NOTE]\r > 本文未涵盖如何使用 Azure AD B2C 来实施登录、注册和配置文件管理，  而是着重介绍如何在用户通过身份验证后调用 Web API。  如果尚未开始，应该先从[如何与 Azure Active Directory 集成文档](active-directory-how-to-integrate.md)入手，了解 Azure Active Directory 的基础知识。\r > \r > \r \r 我们已在 GitHub 中的 MIT 许可证下发布了此运行示例的所有源代码，用户可以任意克隆（甚至分发！）这些代码，并提供反馈和拉取请求。\r \r ## <a name=\"about-nodejs-modules\"></a>关于 Node.js 模块\r 在本演练中，我们使用 Node.js 模块。 模块是可加载的 JavaScript 包，可为应用程序提供特定功能。 通常会使用 Node.js NPM 命令行工具在 NPM 安装目录中安装模块，但一些模块（如 HTTP 模块）是作为核心 Node.js 包的一部分提供的。\r 安装的模块保存在 Node.js 安装目录的根目录下的 node_modules 目录中。 node_modules 目录中的每个模块都保留自己的 node_modules 目录，其中包含它依赖的所有模块，每个必需的模块都有一个 node_modules 目录。 这种递归的目录结构表示了依赖关系链。\r \r 这种依赖关系链结构会导致应用程序占用空间变大，但保证满足所有依赖项的要求，并且开发中使用的模块版本也会在生产中使用。 这使得生产应用程序的行为更有预测性，并防止出现影响用户的版本控制问题。\r \r ## <a name=\"1-register-a-azure-ad-tenant\"></a>1.注册 Azure AD 租户\r 若要使用本示例，需要一个 Azure Active Directory 租户。 如果不确定什么是租户或者如何获取租户，请参阅[如何获取 Azure AD 租户](./active-directory-howto-tenant.md)。\r \r ## <a name=\"2-create-an-application\"></a>2.创建应用程序\r 现在需要在目录中创建应用，以便为 Azure AD 提供一些必要信息，让它与应用安全地通信。  在此案例中，因为客户端应用和 Web API 会组成一个逻辑应用，所以由单一**应用程序 ID** 表示。  若要创建应用，请遵循[这些说明](./active-directory-how-applications-are-added.md)。 如果要生成业务线应用，[这些附加说明可能很有用](../active-directory-applications-guiding-developers-for-lob-applications.md)。\r \r 请务必：\r \r - 登录到 Azure 管理门户。\r - 在左侧的导航栏中单击“Active Directory” 。\r - 选择要在其中注册应用程序的租户。\r - 单击“应用程序”选项卡，并在底部抽屉中单击“添加”  。\r - 根据提示创建一个新的 **Web 应用程序和/或 WebAPI**。\r     - 应用程序的**名称**向最终用户描述应用程序\r     - “登录 URL”  是应用程序的基本 URL。  示例代码的默认值是 `https://localhost:8080`。\r     - “应用程序 ID URI”是应用程序的唯一标识符  。  约定是使用 `https://<tenant-domain>/<app-name>`，例如 `https://contoso.partner.onmschina.cn/my-first-aad-app`\r - 完成注册后，AAD 为应用分配唯一的客户端标识符。  在后面的部分中会用到此值，因此，请从“配置”选项卡复制此值。\r - 提醒：为应用程序创建一个 **应用程序密码** 并复制下来。  稍后需要它。\r - 提醒：复制分配给应用的 **应用程序 ID** 。  稍后也会用到。\r \r ## <a name=\"3-download-nodejs-for-your-platform\"></a>3.下载适用于平台的 node.js\r 要成功使用本示例，必须正确安装 Node.js。\r \r 请从 [http://nodejs.org](http://nodejs.org)安装 Node.js。\r \r ## <a name=\"4-install-mongodb-on-to-your-platform\"></a>4.在平台上安装 MongoDB\r 要成功使用本示例，必须正确安装 MongoDB。 我们使用 MongoDB 使 REST API 持久保留在服务器实例之间。\r \r 从 [http://www.mongodb.org](http://www.mongodb.org) 安装 MongoDB。\r \r > [!NOTE]\r > 本演练假定为 MongoDB 使用默认的安装与服务器终结点，在编写本文时，该终结点为：mongodb://localhost\r > \r > \r \r ## <a name=\"5-install-the-restify-modules-in-to-your-web-api\"></a>5.将 Restify 模块安装到 Web API 中\r 我们使用 Resitfy 生成 REST API。 Restify 是从 Express 派生的精简灵活 Node.js 应用程序框架，它提供一套可靠的功能用于在 Connect 顶层生成 REST API。\r \r ### <a name=\"install-restify\"></a>安装 Restify\r 在命令行中，将目录切换到 azuread 目录。 如果 **azuread** 目录不存在，请创建该目录。\r \r ```\r cd azuread - or- mkdir azuread; cd azuread \r ```\r \r 输入以下命令：\r \r ```\r npm install restify \r ```\r \r 此命令安装 Restify。\r \r #### <a name=\"did-you-get-an-error\"></a>遇到了错误吗？\r 在某些操作系统上使用 npm 时，可能会收到错误“错误: EPERM, chmod '/usr/local/bin/..'” 和一个尝试以管理员身份运行帐户的请求。 如果发生这种情况，请使用 sudo 命令以更高的权限级别运行 npm。\r \r #### <a name=\"did-you-get-an-error-regarding-dtrace\"></a>遇到了有关 DTRACE 的错误吗？\r 在安装 Restify 时，可能会看到类似于下面的内容：\r \r ```Shell\r clang: error: no such file or directory: 'HD/azuread/node_modules/restify/node_modules/dtrace-provider/libusdt'\r make: *** [Release/DTraceProviderBindings.node] Error 1\r gyp ERR! build error\r gyp ERR! stack Error: `make` failed with exit code: 2\r gyp ERR! stack     at ChildProcess.onExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:267:23)\r gyp ERR! stack     at ChildProcess.EventEmitter.emit (events.js:98:17)\r gyp ERR! stack     at Process.ChildProcess._handle.onexit (child_process.js:789:12)\r gyp ERR! System Darwin 13.1.0\r gyp ERR! command \"node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"\r gyp ERR! cwd /Volumes/Development HD/azuread/node_modules/restify/node_modules/dtrace-provider\r gyp ERR! node -v v0.10.11\r gyp ERR! node-gyp -v v0.10.0\r gyp ERR! not ok\r npm WARN optional dep failed, continuing dtrace-provider@0.2.8\r ```\r \r Restify 提供强大的机制来使用 DTrace 跟踪 REST 调用。 但是，许多操作系统不提供 DTrace。 可以安全地忽略这些错误。\r \r 此命令的输出看上去应如下所示：\r \r ```\r restify@2.6.1 node_modules/restify\r +-- assert-plus@0.1.4\r +-- once@1.3.0\r +-- deep-equal@0.0.0\r +-- escape-regexp-component@1.0.2\r +-- qs@0.6.5\r +-- tunnel-agent@0.3.0\r +-- keep-alive-agent@0.0.1\r +-- lru-cache@2.3.1\r +-- node-uuid@1.4.0\r +-- negotiator@0.3.0\r +-- mime@1.2.11\r +-- semver@2.2.1\r +-- spdy@1.14.12\r +-- backoff@2.3.0\r +-- formidable@1.0.14\r +-- verror@1.3.6 (extsprintf@1.0.2)\r +-- csv@0.3.6\r +-- http-signature@0.10.0 (assert-plus@0.1.2, asn1@0.1.11, ctype@0.5.2)\r +-- bunyan@0.22.0 (mv@0.0.5)\r ```\r \r ## <a name=\"6-install-passportjs-in-to-your-web-api\"></a>6.将 Passport.js 安装到 Web API 中\r [Passport](http://passportjs.org/) 是 Node.js 的身份验证中间件。 Passport 极其灵活并且采用模块化结构，可以在不造成干扰的情况下放入任何基于 Express 的应用程序或 Resitify Web 应用程序。 一套综合性策略支持使用用户名和密码、Facebook、Twitter 等进行身份验证。 我们针对 Azure Active directory 开发了一个策略。 我们安装此模块，然后添加 Azure Active Directory 策略插件。\r \r 在命令行中，将目录切换到 azuread 目录。\r \r 输入以下命令以安装 passport.js\r \r ```\r npm install passport \r ```\r \r 该命令的输出应如下所示：\r \r ```\r passport@0.1.17 node_modules\\passport\r +-- pause@0.0.1\r +-- pkginfo@0.2.3\r ```\r \r ## <a name=\"7-add-passport-azure-ad-to-your-web-api\"></a>7.将 Passport-Azure-AD 添加到 Web API\r 接下来，我们将使用 passport-azuread 来添加 OAuth 策略，这是一套将 Azure Active Directory 连接到 Passport 的策略。 在此 Rest API 示例中，我们针对持有者令牌使用此策略。\r \r > [!NOTE]\r > 尽管 OAuth2 提供了可以颁发任何已知令牌类型的框架，但只有一部分令牌类型已得到广泛使用。 用于保护终结点的令牌是持有者令牌。 持有者令牌是 OAuth2 中最广泛颁发的令牌，许多实现假定持有者令牌是唯一颁发的令牌类型。\r > \r > \r \r 在命令行中，将目录切换到 azuread 目录\r \r 键入以下命令以安装 Passport.js passport-azure-ad 模块：\r \r ```\r npm install passport-azure-ad\r ```\r \r 该命令的输出应如下所示：\r \r ```\r passport-azure-ad@1.0.0 node_modules/passport-azure-ad\r +-- xtend@4.0.0\r +-- xmldom@0.1.19\r +-- passport-http-bearer@1.0.1 (passport-strategy@1.0.0)\r +-- underscore@1.8.3\r +-- async@1.3.0\r +-- jsonwebtoken@5.0.2\r +-- xml-crypto@0.5.27 (xpath.js@1.0.6)\r +-- ursa@0.8.5 (bindings@1.2.1, nan@1.8.4)\r +-- jws@3.0.0 (jwa@1.0.1, base64url@1.0.4)\r +-- request@2.58.0 (caseless@0.10.0, aws-sign2@0.5.0, forever-agent@0.6.1, stringstream@0.0.4, tunnel-agent@0.4.1, oauth-sign@0.8.0, isstream@0.1.2, extend@2.0.1, json-stringify-safe@5.0.1, node-uuid@1.4.3, qs@3.1.0, combined-stream@1.0.5, mime-types@2.0.14, form-data@1.0.0-rc1, http-signature@0.11.0, bl@0.9.4, tough-cookie@2.0.0, hawk@2.3.1, har-validator@1.8.0)\r +-- xml2js@0.4.9 (sax@0.6.1, xmlbuilder@2.6.4)\r ```\r \r ## <a name=\"8-add-mongodb-modules-to-your-web-api\"></a>8.将 MongoDB 模块添加到 Web API\r 我们将使用 MongoDB 作为数据存储。为此，我们需要安装这两个广泛使用的插件来管理名为 Mongoose 的模型和架构，以及 MongoDB 的数据库驱动程序（也称为 MongoDB）。\r \r - `npm install mongoose`\r \r ## <a name=\"9--install-additional-modules\"></a>9.安装其他模块\r 接下来，我们安装剩余的所需模块。\r \r 在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r \r ```\r cd azuread \r ```\r \r 输入以下命令，在 node_modules 目录中安装以下模块：\r \r - `npm install assert-plus`\r - `npm install bunyan`\r - `npm update`\r \r ## <a name=\"10-create-a-serverjs-with-your-dependencies\"></a>10.创建包含依赖项的 server.js\r server.js 文件会提供 Web API 服务器的大多数功能。 我们要将大部分代码添加到此文件。 用于生产目的，需要将功能重构为较小的文件，例如单独的路由和控制器。 在本演示中，我们为此功能使用 server.js。\r \r 在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r \r ```\r cd azuread \r ```\r \r 在偏好的编辑器中创建 `server.js` 文件，并添加以下信息：\r \r ```Javascript\r     'use strict';\r \r     /**\r      * Module dependencies.\r      */\r \r     var fs = require('fs');\r     var path = require('path');\r     var util = require('util');\r     var assert = require('assert-plus');\r     var bunyan = require('bunyan');\r     var getopt = require('posix-getopt');\r     var mongoose = require('mongoose/');\r     var restify = require('restify');\r     var passport = require('passport');\r       var BearerStrategy = require('passport-azure-ad').BearerStrategy;\r ```\r \r 保存文件。 稍后我们会使用该文件。\r \r ## <a name=\"11-create-a-config-file-to-store-your-azure-ad-settings\"></a>11.创建一个配置文件用于存储 Azure AD 设置\r \r 此代码文件会将配置参数从 Azure Active Directory 门户传递到 Passport.js。 在本演练的第一部分中向门户添加 Web API 时，已经创建了这些配置值。 我们会解释在复制代码后，要输入其中的哪些参数值。\r \r 在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r \r ```\r cd azuread \r ```\r \r 在偏好的编辑器中创建 `config.js` 文件，并添加以下信息：\r \r ```Javascript\r      exports.creds = {\r          mongoose_auth_local: 'mongodb://localhost/tasklist', // Your mongo auth uri goes here\r          clientID: 'your client ID',\r          audience: 'your application URL',\r         // you cannot have users from multiple tenants sign in to your server unless you use the common endpoint\r       // example: https://login.microsoftonline.com/common/.well-known/openid-configuration\r          identityMetadata: 'https://login.microsoftonline.com/<your tenant id>/.well-known/openid-configuration', \r          validateIssuer: true, // if you have validation on, you cannot have users from multiple tenants sign in to your server\r          passReqToCallback: false,\r          loggingLevel: 'info' // valid are 'info', 'warn', 'error'. Error always goes to stderr in Unix.\r \r      };\r ```\r \r 保存文件。 \r \r ## <a name=\"12-add-configuration-to-your-serverjs-file\"></a>12.将配置添加到 server.js 文件\r \r 我们需要在应用程序中，从你刚刚创建的配置文件读取这些值。 为此，我们只需在应用程序中添加 .config 文件作为所需的资源，然后将全局变量设置为 config.js 文档中的值\r \r 在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r \r ```\r cd azuread \r ```\r \r 在偏好的编辑器中打开 `server.js` 文件，并添加以下信息：\r \r ```Javascript\r var config = require('./config');\r ```\r \r 然后，将包含以下代码的新节添加到 `server.js` 中：\r \r ```Javascript\r     var options = {\r         // The URL of the metadata document for your app. We will put the keys for token validation from the URL found in the jwks_uri tag of the in the metadata.\r         identityMetadata: config.creds.identityMetadata,\r         clientID: config.creds.clientID,\r         validateIssuer: config.creds.validateIssuer,\r         audience: config.creds.audience,\r         passReqToCallback: config.creds.passReqToCallback,\r         loggingLevel: config.creds.loggingLevel\r \r     };\r \r     // array to hold logged in users and the current logged in user (owner)\r     var users = [];\r     var owner = null;\r \r     // Our logger\r     var log = bunyan.createLogger({\r         name: 'Azure Active Directory Bearer Sample',\r              streams: [\r             {\r                 stream: process.stderr,\r                 level: \"error\",\r                 name: \"error\"\r             }, \r             {\r                 stream: process.stdout,\r                 level: \"warn\",\r                 name: \"console\"\r             }, ]\r     });\r \r       // if logging level specified, switch to it.\r       if (config.creds.loggingLevel) { log.levels(\"console\", config.creds.loggingLevel); }\r \r     // MongoDB setup\r     // Setup some configuration\r     var serverPort = process.env.PORT || 8080;\r     var serverURI = (process.env.PORT) ? config.creds.mongoose_auth_mongohq : config.creds.mongoose_auth_local;\r ```\r \r 保存文件。 \r \r ## <a name=\"13-add-the-mongodb-model-and-schema-information-using-moongoose\"></a>13.使用 Moongoose 添加 MongoDB 模型和架构信息\r \r 现在，我们已将这三个文件统一放在 REST API 服务中，接下来让我们的准备工作发挥作用。\r \r 对于本演练，我们将使用 MongoDB 来存储***步骤 4*** 中所述的任务。\r \r 回顾我们在***步骤 11*** 中创建的 `config.js` 文件，我们将数据库称为 `tasklist`，因为这是我们在 mogoose_auth_local 连接 URL 的末尾放置的内容。 无需事先在 MongoDB 中创建此数据库，首次运行服务器应用程序时，系统便会创建此数据库（假定它不存在）。\r \r 现在，我们已告诉服务器要使用哪个 MongoDB 数据库，接下来我们需要编写一些附加的代码，以便为服务器任务创建模型和架构。\r \r #### <a name=\"discussion-of-the-model\"></a>模型介绍\r \r 我们的架构模型非常简单，可以根据需要对其进行扩展。\r \r NAME - 分配到任务的用户名。 ***字符串***\r \r TASK - 任务本身。 ***字符串***\r \r DATE - 任务截止日期。 ***日期时间***\r \r COMPLETED - 任务是否已完成。 ***布尔值***\r \r #### <a name=\"creating-the-schema-in-the-code\"></a>在代码中创建架构\r \r 在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r \r ```\r cd azuread \r ```\r \r 在偏好的编辑器中打开 `server.js` 文件，并在配置条目下面添加以下信息：\r \r ```Javascript\r     // Connect to MongoDB\r     global.db = mongoose.connect(serverURI);\r     var Schema = mongoose.Schema;\r     log.info('MongoDB Schema loaded');\r \r     // Here we create a schema to store our tasks and users. Pretty simple schema for now.\r     var TaskSchema = new Schema({\r         owner: String,\r         task: String,\r         completed: Boolean,\r         date: Date\r     });\r \r     // Use the schema to register a model\r     mongoose.model('Task', TaskSchema);\r     var Task = mongoose.model('Task');\r ```\r \r 从该代码中可以看到，我们会创建架构，然后创建在定义***路由***时，将在整个代码中用于存储数据的模型对象。\r \r ## <a name=\"14-add-our-routes-for-our-task-rest-api-server\"></a>14.为任务 REST API 服务器添加路由\r \r 现在，我们已经创建了一个可用的数据库模型，接下来让我们添加用于 REST API 服务器的路由。\r \r ### <a name=\"about-routes-in-restify\"></a>关于 Restify 中的路由\r \r Restify 中路由的工作原理，与使用 Express 堆栈时的路由工作原理完全相同。 可以使用客户端应用程序应该调用的 URI 定义路由。 通常，需要在单独的文件中定义路由。 对于本演练，我们会在 server.js 文件中定义路由。 对于生产用途，我们建议在各自的文件中定义路由。\r \r Restify 路由的典型模式是：\r \r ```Javascript\r     function createObject(req, res, next) {\r \r     // do work on Object\r \r      _object.name = req.params.object; // passed value is in req.params under object\r \r      ///...\r \r     return next(); // keep the server going\r     }\r \r     ....\r \r     server.post('/service/:add/:object', createObject); // calls createObject on routes that match this.\r ```\r \r 这是最基本级别的模式。 Resitfy（和 Express）提供更深层的功能，例如，定义应用程序类型，以及跨不同的终结点执行复杂路由。 对于本演练，我们会保持这些路由的简炼性。\r \r ### <a name=\"1-add-default-routes-to-our-server\"></a>1.将默认路由添加到服务器\r \r 现在，我们添加 Create、Retrieve、Update 和 Delete 的基本 CRUD 路由。\r \r 在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r \r ```\r cd azuread \r ```\r \r 在偏好的编辑器中打开 `server.js` 文件，并在前面创建的数据库条目下面添加以下信息：\r \r ```Javascript\r     /**\r      *\r      * APIs for our REST Task server\r      */\r \r     // Create a task\r \r     function createTask(req, res, next) {\r \r         // Resitify currently has a bug which doesn't allow you to set default headers\r         // This headers comply with CORS and allow us to mongodbServer our response to any origin\r \r         res.header(\"Access-Control-Allow-Origin\", \"*\");\r         res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\r \r         // Create a new task model, fill it up and save it to Mongodb\r         var _task = new Task();\r \r         if (!req.params.task) {\r             req.log.warn('createTodo: missing task');\r             next(new MissingTaskError());\r             return;\r         }\r \r         _task.owner = owner;\r         _task.task = req.params.task;\r         _task.date = new Date();\r \r         _task.save(function(err) {\r             if (err) {\r                 req.log.warn(err, 'createTask: unable to save');\r                 next(err);\r             } else {\r                 res.send(201, _task);\r \r             }\r         });\r \r         return next();\r \r     }\r \r     // Delete a task by name\r \r     function removeTask(req, res, next) {\r \r         Task.remove({\r             task: req.params.task,\r             owner: owner\r         }, function(err) {\r             if (err) {\r                 req.log.warn(err,\r                     'removeTask: unable to delete %s',\r                     req.params.task);\r                 next(err);\r             } else {\r                 log.info('Deleted task:', req.params.task);\r                 res.send(204);\r                 next();\r             }\r         });\r     }\r \r     // Delete all tasks\r \r     function removeAll(req, res, next) {\r         Task.remove();\r         res.send(204);\r         return next();\r     }\r \r     // Get a specific task based on name\r \r     function getTask(req, res, next) {\r \r         log.info('getTask was called for: ', owner);\r         Task.find({\r             owner: owner\r         }, function(err, data) {\r             if (err) {\r                 req.log.warn(err, 'get: unable to read %s', owner);\r                 next(err);\r                 return;\r             }\r \r             res.json(data);\r         });\r \r         return next();\r     }\r \r     /// Simple returns the list of TODOs that were loaded.\r \r     function listTasks(req, res, next) {\r         // Resitify currently has a bug which doesn't allow you to set default headers\r         // This headers comply with CORS and allow us to mongodbServer our response to any origin\r \r         res.header(\"Access-Control-Allow-Origin\", \"*\");\r         res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\r \r         log.info(\"listTasks was called for: \", owner);\r \r         Task.find({\r             owner: owner\r         }).limit(20).sort('date').exec(function(err, data) {\r \r             if (err) {\r                 return next(err);\r             }\r \r             if (data.length > 0) {\r                 log.info(data);\r             }\r \r             if (!data.length) {\r                 log.warn(err, \"There is no tasks in the database. Did you initalize the database as stated in the README?\");\r             }\r \r             if (!owner) {\r                 log.warn(err, \"You did not pass an owner when listing tasks.\");\r             } else {\r \r                 res.json(data);\r \r             }\r         });\r \r         return next();\r     }\r ```\r \r ### <a name=\"2-next-lets-add-some-error-handling-in-our-apis\"></a>2.接下来，让我们在 API 中添加一些错误处理方式：\r \r ```\r     ///--- Errors for communicating something interesting back to the client\r \r     function MissingTaskError() {\r         restify.RestError.call(this, {\r             statusCode: 409,\r             restCode: 'MissingTask',\r             message: '\"task\" is a required parameter',\r             constructorOpt: MissingTaskError\r         });\r \r         this.name = 'MissingTaskError';\r     }\r     util.inherits(MissingTaskError, restify.RestError);\r \r     function TaskExistsError(owner) {\r         assert.string(owner, 'owner');\r \r         restify.RestError.call(this, {\r             statusCode: 409,\r             restCode: 'TaskExists',\r             message: owner + ' already exists',\r             constructorOpt: TaskExistsError\r         });\r \r         this.name = 'TaskExistsError';\r     }\r     util.inherits(TaskExistsError, restify.RestError);\r \r     function TaskNotFoundError(owner) {\r         assert.string(owner, 'owner');\r \r         restify.RestError.call(this, {\r             statusCode: 404,\r             restCode: 'TaskNotFound',\r             message: owner + ' was not found',\r             constructorOpt: TaskNotFoundError\r         });\r \r         this.name = 'TaskNotFoundError';\r     }\r \r     util.inherits(TaskNotFoundError, restify.RestError);\r ```\r \r ## <a name=\"15-create-your-server\"></a>15.创建服务器！\r 我们已经定义了数据库和路由，最后一件事就是添加用于管理调用的服务器实例。\r \r Restify（和 Express）允许对 REST API 服务器执行大量的深度自定义，但同样，本演练将使用最基本的设置。\r \r ```Javascript\r     /**\r      * Our Server\r      */\r \r     var server = restify.createServer({\r         name: \"Azure Active Directroy TODO Server\",\r         version: \"2.0.1\"\r     });\r \r     // Ensure we don't drop data on uploads\r     server.pre(restify.pre.pause());\r \r     // Clean up sloppy paths like //todo//////1//\r     server.pre(restify.pre.sanitizePath());\r \r     // Handles annoying user agents (curl)\r     server.pre(restify.pre.userAgentConnection());\r \r     // Set a per request bunyan logger (with requestid filled in)\r     server.use(restify.requestLogger());\r \r     // Allow 5 requests/second by IP, and burst to 10\r     server.use(restify.throttle({\r         burst: 10,\r         rate: 5,\r         ip: true,\r     }));\r \r     // Use the common stuff you probably want\r     server.use(restify.acceptParser(server.acceptable));\r     server.use(restify.dateParser());\r     server.use(restify.queryParser());\r     server.use(restify.gzipResponse());\r     server.use(restify.bodyParser({\r         mapParams: true\r     })); // Allows for JSON mapping to REST\r ```\r \r ## <a name=\"16-adding-the-routes-to-the-server-without-authentication-for-now\"></a>16.将路由添加到服务器（目前不包括身份验证）\r \r ```Javascript\r     /// Now the real handlers. Here we just CRUD\r     /**\r     /*\r     /* Each of these handlers are protected by our OIDCBearerStrategy by invoking 'oidc-bearer'\r     /* in the pasport.authenticate() method. We set 'session: false' as REST is stateless and\r     /* we don't need to maintain session state. You can experiement removing API protection\r     /* by removing the passport.authenticate() method like so:\r     /*\r     /* server.get('/tasks', listTasks);\r     /*\r     **/\r     server.get('/tasks', listTasks);\r     server.get('/tasks', listTasks);\r     server.get('/tasks/:owner', getTask);\r     server.head('/tasks/:owner', getTask);\r     server.post('/tasks/:owner/:task', createTask);\r     server.post('/tasks', createTask);\r     server.del('/tasks/:owner/:task', removeTask);\r     server.del('/tasks/:owner', removeTask);\r     server.del('/tasks', removeTask);\r     server.del('/tasks', removeAll, function respond(req, res, next) {\r     res.send(204);\r     next();\r     });\r     // Register a default '/' handler\r     server.get('/', function root(req, res, next) {\r     var routes = [\r     'GET /',\r     'POST /tasks/:owner/:task',\r     'POST /tasks (for JSON body)',\r     'GET /tasks',\r     'PUT /tasks/:owner',\r     'GET /tasks/:owner',\r     'DELETE /tasks/:owner/:task'\r     ];\r     res.send(200, routes);\r     next();\r     });\r     server.listen(serverPort, function() {\r     var consoleMessage = '\\n Azure Active Directory Tutorial';\r     consoleMessage += '\\n +++++++++++++++++++++++++++++++++++++++++++++++++++++';\r     consoleMessage += '\\n %s server is listening at %s';\r     consoleMessage += '\\n Open your browser to %s/tasks\\n';\r     consoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n';\r     consoleMessage += '\\n !!! why not try a $curl -isS %s | json to get some ideas? \\n';\r     consoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n\\n';\r     });\r ```\r \r ## <a name=\"17-before-we-add-oauth-support-lets-run-the-server\"></a>17.在添加 OAuth 支持之前，让我们先运行服务器。\r 添加身份验证之前，请先测试服务器\r \r 最简单的检查方法是在命令行中使用 curl。 在这样做之前，我们需要一个用于分析 JSON 输出的简单实用工具。 为此，请安装 json 工具，因为下面的所有示例都要使用该工具。\r \r ```\r $npm install -g jsontool \r ```\r \r 这会全局安装 JSON 工具。 现在，我们已安装了工具，让我们试运行服务器：\r \r 首先，请确保 monogoDB 实例正在运行。\r \r ```\r $sudo mongod \r ```\r \r 然后，切换到目录并开始运行。\r \r ```\r $ cd azuread \r $ node server.js \r \r $ curl -isS http://127.0.0.1:8080 | json \r ```\r \r ```Shell\r     HTTP/1.1 200 OK\r     Connection: close\r     Content-Type: application/json\r     Content-Length: 171\r     Date: Tue, 14 Jul 2015 05:43:38 GMT\r     [\r     \"GET /\",\r     \"POST /tasks/:owner/:task\",\r     \"POST /tasks (for JSON body)\",\r     \"GET /tasks\",\r     \"PUT /tasks/:owner\",\r     \"GET /tasks/:owner\",\r     \"DELETE /tasks/:owner/:task\"\r     ]\r ```\r \r 然后，我们按如下所示添加一个任务：\r \r ```\r $ curl -isS -X POST http://127.0.0.1:8080/tasks/brandon/Hello \r ```\r \r 响应应为：\r \r ```Shell\r     HTTP/1.1 201 Created\r     Connection: close\r     Access-Control-Allow-Origin: *\r     Access-Control-Allow-Headers: X-Requested-With\r     Content-Type: application/x-www-form-urlencoded\r     Content-Length: 5\r     Date: Tue, 04 Feb 2014 01:02:26 GMT\r     Hello\r ```\r \r 我们可以按如下所示列出 Brandon 的任务：\r \r ```\r $ curl -isS http://127.0.0.1:8080/tasks/brandon/ \r ```\r \r 如果一切正常，我们可以将 OAuth 添加到 REST API 服务器。\r \r **已有一台装有 MongoDB 的 REST API 服务器！**\r \r ## <a name=\"18-add-authentication-to-our-rest-api-server\"></a>18.将身份验证添加到 REST API 服务器\r 现在，我们已经运行了 REST API（顺便祝贺你！），接下来，让我们在 Azure AD 中利用它。\r \r 在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r \r ```\r cd azuread \r ```\r \r ### <a name=\"1-use-the-oidcbearerstrategy-that-is-included-with-passport-azure-ad\"></a>1：使用 passport-azure-ad 随附的 OIDCBearerStrategy\r 到目前为止，我们已构建一个典型的 REST TODO 服务器，其中不包含任何授权种类。 这是我们将其结合在一起的起点。\r \r 首先，需指出要使用 Passport。 在其他服务器配置之后紧接着执行此操作：\r \r ```Javascript\r     // Let's start using Passport.js\r \r     server.use(passport.initialize()); // Starts passport\r     server.use(passport.session()); // Provides session support\r ```\r \r > [!TIP]\r > 编写 API 时，应始终将数据链接到令牌中用户无法欺骗的独特内容。 此服务器在存储 TODO 项目时，会根据我们放在“所有者”字段的令牌中的用户对象 ID（通过 token.oid 调用）来存储。 这可确保只有该用户可以访问其 TODO，其他任何人都不可以访问输入的 TODO。 API 中不公开“所有者”信息，因此，外部用户可以请求其他人的 TODO，即使它们已经过身份验证也一样。\r > \r > \r \r 接下来，我们使用 passport-azure-ad 随附的 Bearer 策略。 先看看下面的代码，稍后我会进行解释。 将此代码放在上面粘贴的内容后面：\r \r ```Javascript\r     /**\r     /*\r     /* Calling the OIDCBearerStrategy and managing users\r     /*\r     /* Passport pattern provides the need to manage users and info tokens\r     /* with a FindorCreate() method that must be provided by the implementor.\r     /* Here we just autoregister any user and implement a FindById().\r     /* You'll want to do something smarter.\r     **/\r \r     var findById = function(id, fn) {\r         for (var i = 0, len = users.length; i < len; i++) {\r             var user = users[i];\r             if (user.sub === id) {\r                 log.info('Found user: ', user);\r                 return fn(null, user);\r             }\r         }\r         return fn(null, null);\r     };\r \r     var bearerStrategy = new BearerStrategy(options,\r         function(token, done) {\r             log.info('verifying the user');\r             log.info(token, 'was the token retreived');\r             findById(token.sub, function(err, user) {\r                 if (err) {\r                     return done(err);\r                 }\r                 if (!user) {\r                     // \"Auto-registration\"\r                     log.info('User was added automatically as they were new. Their sub is: ', token.sub);\r                     users.push(token);\r                     owner = token.sub;\r                     return done(null, token);\r                 }\r                 owner = token.sub;\r                 return done(null, user, token);\r             });\r         }\r     );\r \r     passport.use(bearerStrategy);\r ```\r \r Passport 对其所有策略（Twitter、Facebook 等）都使用相似的模式，所有策略写入器都遵循该模式。 查看该策略可以发现，我们已将它作为函数来传递，其中包含一个令牌和一个用作参数的 done。 策略完成所有工作之后，便尽责地返回。 完成后，需要存储用户并储藏令牌，以免再次请求它。\r \r > [!IMPORTANT]\r > 上述代码使用了正好地服务器上进行身份验证的任何用户。 这就是所谓的自动注册。 在生产服务器中，所有人都必须先完成已确定的注册过程。 这通常是在使用者应用中看到的模式，可让向 Facebook 注册，但接着请求填写其他信息。 如果这不是命令行程序，我们本可以从返回的令牌对象中提取电子邮件，然后请求使用者填写其他信息。 由于这是测试服务器，因此，我们直接将它们加入到内存中的数据库。\r > \r > \r \r ### <a name=\"2-finally-protect-some-endpoints\"></a>2.最后保护一些终结点\r \r 通过结合要使用的协议指定 `passport.authenticate()` 调用来保护终结点。\r \r 让我们在服务器代码中编辑路由，做一些更有趣的事情：\r \r ```Javascript\r     server.get('/tasks', passport.authenticate('oauth-bearer', {\r     session: false\r     }), listTasks);\r     server.get('/tasks', passport.authenticate('oauth-bearer', {\r     session: false\r     }), listTasks);\r     server.get('/tasks/:owner', passport.authenticate('oauth-bearer', {\r     session: false\r     }), getTask);\r     server.head('/tasks/:owner', passport.authenticate('oauth-bearer', {\r     session: false\r     }), getTask);\r     server.post('/tasks/:owner/:task', passport.authenticate('oauth-bearer', {\r     session: false\r     }), createTask);\r     server.post('/tasks', passport.authenticate('oauth-bearer', {\r     session: false\r     }), createTask);\r     server.del('/tasks/:owner/:task', passport.authenticate('oauth-bearer', {\r     session: false\r     }), removeTask);\r     server.del('/tasks/:owner', passport.authenticate('oauth-bearer', {\r     session: false\r     }), removeTask);\r     server.del('/tasks', passport.authenticate('oauth-bearer', {\r     session: false\r     }), removeTask);\r     server.del('/tasks', passport.authenticate('oauth-bearer', {\r     session: false\r     }), removeAll, function respond(req, res, next) {\r     res.send(204);\r     next();\r     });\r ```\r \r ## <a name=\"19-run-your-server-application-again-and-ensure-it-rejects-you\"></a>19.再次运行服务器应用程序并确保它拒绝你\r 再次使用 `curl` 来查看是否针对终结点提供了 OAuth2 保护。 应该在针对此终结点运行任何客户端 SDK 之前执行此操作。 返回的标头足以说明一切正常运作。\r \r 首先，请确保 monogoDB 实例正在运行：\r \r ```\r $sudo mongod\r ```\r \r 然后，切换到目录并开始运行。\r \r ```\r $ cd azuread\r $ node server.js\r ```\r \r 试用基本 POST：\r \r ```\r $ curl -isS -X POST http://127.0.0.1:8080/tasks/brandon/Hello \r ```\r \r ```Shell\r     HTTP/1.1 401 Unauthorized\r     Connection: close\r     WWW-Authenticate: Bearer realm=\"Users\"\r     Date: Tue, 14 Jul 2015 05:45:03 GMT\r     Transfer-Encoding: chunked\r ```\r \r 401 在这里是正常的响应，表明 Passport 层正在尝试重定向到授权终结点，这正是你所希望的。\r \r ## <a name=\"congratulations-you-have-a-rest-api-service-using-oauth2\"></a>祝贺！ 已经创建了一个使用 OAuth2 的 REST API 服务！\r \r 这就是在不使用 OAuth2 兼容客户端的情况下，此服务器能够带来的最大优势。 需要学习其他演练。\r \r 如果只要想要了解如何使用 Restify 和 OAuth2 实现 REST API，此示例中的代码足以帮助你学习开发和生成服务。\r \r 如果对 ADAL 学习历程中的后续步骤感兴趣，我们建议了解下面这些支持的 ADAL 客户端：\r \r 只需将这些代码克隆到开发人员计算机，并根据演练中所述进行配置。\r \r [ADAL for iOS](https://github.com/MSOpenTech/azure-activedirectory-library-for-ios)\r \r [ADAL for Android](https://github.com/MSOpenTech/azure-activedirectory-library-for-android)\r \r [!INCLUDE [active-directory-devquickstarts-additional-resources](../../../includes/active-directory-devquickstarts-additional-resources.md)]\r \r <!--Update_Description: update meta properties --> \r "}