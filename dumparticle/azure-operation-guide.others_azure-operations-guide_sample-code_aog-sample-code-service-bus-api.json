{"Title":"Azure 服务总线 API 调用示例","Description":"Azure 服务总线 API 调用示例","Content":"\r # Azure 服务总线 API 调用示例\r \r 编程调用 Azure 服务总线的相关服务，微软有提供基于 .NET 的 dll（[Nuget](https://www.nuget.org/packages/WindowsAzure.ServiceBus/)），也有基于 Java 的 Jar 包（[Mvnrepository](https://mvnrepository.com/artifact/com.microsoft.azure/azure-servicebus)），另外也可以直接调用服务总线 API。这片文章就提供 Azure 服务总线 API 调用示例，以供参考。主要包含以下内容：\r \r 1. 如何从策略生成共享访问令牌。\r 2. 调用 API 发送消息到服务总线队列。\r 3. 调用 API 从服务总线队列接收消息，包括 ReceiveAndDelete 模式和 PeekLock 模式。\r \r ## 如何从策略生成共享访问令牌\r \r 当调用服务总线 API 时，必须要提供共享访问令牌（SAS Token）作为 Authorization 头部，以作认证。那么如何生成这个 SAS Token 呢？\r \r SAS Token 的具体构成是这样的：`SharedAccessSignature sr={资源地址}&sig={签名}&se={过期时间}&skn={策略名称}`。\r \r - 资源地址：要访问资源的 URL 地址，比如 demo 命名空间下的 q1 队列 `https://demo.servicebus.chinacloudapi.cn/q1`\r \r - 签名：对由资源地址，换行符和过期时间组成的字符串用策略秘钥通过 SHA-256 哈希后生成的 Base64String。\r \r - 过期时间：自纪元算起，以秒为单位。\r \r - 策略名称：相应策略的名称。\r \r <br>\r \r ```\r static string createToken(string resourceUri, string keyName, string key)\r {\r     TimeSpan sinceEpoch = DateTime.UtcNow - new DateTime(1970, 1, 1);\r     var week = 60 * 60 * 24 * 7;\r     var expiry = Convert.ToString((int)sinceEpoch.TotalSeconds + week);\r     string stringToSign = HttpUtility.UrlEncode(resourceUri) + \"\\n\" + expiry;\r     HMACSHA256 hmac = new HMACSHA256(Encoding.UTF8.GetBytes(key));\r     var signature = Convert.ToBase64String(hmac.ComputeHash(Encoding.UTF8.GetBytes(stringToSign)));\r     var sasToken = String.Format(CultureInfo.InvariantCulture, \r                 \"SharedAccessSignature sr={0}&sig={1}&se={2}&skn={3}\", \r                 HttpUtility.UrlEncode(resourceUri), \r                 HttpUtility.UrlEncode(signature), \r                 expiry, \r                 keyName);\r     return sasToken;\r }\r ```\r \r ## 调用 API 发送消息到服务总线队列\r \r 发送消息的 API 具体描述可参照官方文档：[Send Message](https://docs.microsoft.com/en-us/rest/api/servicebus/send-message-to-queue)。\r \r 最关键的就是将 HTTP 请求的 Authorization 头部的值设置为根据拥有发送权限策略生成的 SAS Token。\r \r ```\r static async Task SendMessageAsync(ServiceBusHttpMessage message, string token)\r {\r     var address = $\"https://{serviceBusNamespace}.servicebus.chinacloudapi.cn/{queueName}/messages\";\r \r     HttpContent postContent = new ByteArrayContent(message.Body);\r \r     // Serialize BrokerProperties. \r     var brokerProps = JsonConvert.SerializeObject(message.SystemProperties,\r         Formatting.None,\r         new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore, \r             DefaultValueHandling = DefaultValueHandling.Ignore });\r \r     postContent.Headers.Add(\"BrokerProperties\", brokerProps);\r \r     // Add custom properties. \r     foreach (string key in message.CustomProperties)\r     {\r         postContent.Headers.Add(key, message.CustomProperties.GetValues(key));\r     }\r \r     var httpClient = new HttpClient();\r     httpClient.DefaultRequestHeaders.Add(\"Authorization\", token);\r     httpClient.DefaultRequestHeaders.Add(\"ContentType\", \"application/atom+xml;type=entry;charset=utf-8\");\r \r     // Send message. \r     HttpResponseMessage response = null;\r     try\r     {\r         response = await httpClient.PostAsync($\"{address}?timeout=60\", postContent);\r         response.EnsureSuccessStatusCode();\r         Console.WriteLine(\"SendMessage successfully!\");\r     }\r     catch (HttpRequestException ex)\r     {\r         Console.WriteLine($\"SendMessage failed: {ex.Message}\");\r     }\r     response.Dispose();\r }\r ```\r \r ## 调用 API 从服务总线队列接收消息\r \r ReceiveAndDelete 模式 API：[Receive and Delete Message](https://docs.microsoft.com/en-us/rest/api/servicebus/receive-and-delete-message-destructive-read) 。\r \r PeekLock 模式 API：[Peek-Lock Message](https://docs.microsoft.com/en-us/rest/api/servicebus/peek-lock-message-non-destructive-read) 。\r \r 两者的区别在于，ReceiveAndDelete 模式消息被接收后就自动从队列中删除了，而 PeekLock 模式只是把消息锁住，然后由客户端来删除。所以两种模式的 API URI 是一致的，只是 HTTP 方法不一样，前者是 DELETE，后者是 POST。\r \r ```\r static async Task<ServiceBusHttpMessage> ReceiveMessageAsync(string token, bool deleteMessage = true)\r {\r     var address = $\"https://{serviceBusNamespace}.servicebus.chinacloudapi.cn/{queueName}/messages/head\";\r \r     var httpClient = new HttpClient();\r     httpClient.DefaultRequestHeaders.Add(\"Authorization\", token);\r \r     HttpResponseMessage response = null;\r \r     try\r     {\r         if (deleteMessage)\r         {\r             // receive and delete\r             response = await httpClient.DeleteAsync($\"{address}?timeout=60\");\r         }\r         else\r         {\r             // peek lock\r             response = await httpClient.PostAsync($\"{address}?timeout=60\", new ByteArrayContent(new Byte[0]));\r         }\r \r         response.EnsureSuccessStatusCode();\r         Console.WriteLine($\"ReceiveMessage successfully!\");\r     }\r     catch (HttpRequestException ex)\r     {\r         Console.WriteLine($\"ReceiveMessage failed: {ex.Message}\");\r         return null;\r     }\r \r     var message = await ResolveMessageFromResponse(response);\r     response.Dispose();\r     return message;\r }\r ```\r \r 完整代码：[SBRestApiDemo](https://github.com/wacn/AOG-CodeSample/tree/master/ServiceBus/CSharp/SBRestApiDemo/)。\r \r ## 更多资源\r \r - [服务总线REST API](https://docs.microsoft.com/en-us/rest/api/servicebus/service-bus-runtime-rest/)"}