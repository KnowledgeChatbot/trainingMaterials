{"Title":"如何使用 PowerShell 创建 X.509 证书","Description":"如何使用 PowerShell 在本地创建 X.509 证书，以及在模拟环境下在 Azure IoT 中心启用基于 X.509 的安全性。","Content":"# <a name=\"powershell-scripts-to-manage-ca-signed-x509-certificates\"></a>用于管理 CA 签名的 X.509 证书的 PowerShell 脚本\r \r IoT 中心基于 X.509 证书的安全性需从 [X.509 证书链](https://en.wikipedia.org/wiki/X.509#Certificate_chains_and_cross-certification)开始，其中包括根证书、任何中间证书，及至叶证书。 此操作说明指南演示使用 [OpenSSL](https://www.openssl.org/) 创建 X.509 证书并对其进行签名的示例 PowerShell 脚本。 建议仅将本指南用于试验环境，因为其中很多步骤将发生于现实生活中的生产过程。 可以使用这些证书通过 X.509 证书身份验证在 Azure IoT 中心模拟安全性。 本指南中的步骤在 Windows 计算机上本地创建证书。 \r \r ## <a name=\"prerequisites\"></a>先决条件\r 本教程假定你已获取 OpenSSL 二进制文件。 你还可\r     - 下载 OpenSSL 源代码并在计算机上生成二进制文件，或者 \r     - 下载并安装任何[第三方 OpenSSL 二进制文件](https://wiki.openssl.org/index.php/Binaries)，例如从 [SourceForge 上的此项目](https://sourceforge.net/projects/openssl/)下载并安装。\r \r <a id=\"createcerts\"></a>\r \r ## <a name=\"create-x509-certificates\"></a>创建 X.509 证书\r 以下步骤显示如何在本地创建 X.509 根证书的示例。 \r \r 1. 以管理员身份打开 PowerShell 窗口。 \r 2. 导航到工作目录。 运行以下脚本以设置全局变量。 \r \r     ```PowerShell\r     $openSSLBinSource = \"<full_path_to_the_binaries>\\OpenSSL\\bin\"\r     $errorActionPreference    = \"stop\"\r \r     # Note that these values are for test purpose only\r     $_rootCertSubject         = \"CN=Azure IoT Root CA\"\r     $_intermediateCertSubject = \"CN=Azure IoT Intermediate {0} CA\"\r     $_privateKeyPassword      = \"123\"\r \r     $rootCACerFileName          = \"./RootCA.cer\"\r     $rootCAPemFileName          = \"./RootCA.pem\"\r     $intermediate1CAPemFileName = \"./Intermediate1.pem\"\r     $intermediate2CAPemFileName = \"./Intermediate2.pem\"\r     $intermediate3CAPemFileName = \"./Intermediate3.pem\"\r \r     $openSSLBinDir              = Join-Path $ENV:TEMP \"openssl-bin\"\r \r     # Whether to use ECC or RSA.\r     $useEcc                     = $true\r     ```\r     \r 3. 运行以下脚本，将 OpenSSL 二进制文件复制到工作目录并设置环境变量：\r \r     ```PowerShell\r     function Initialize-CAOpenSSL()\r     {\r         Write-Host (\"Beginning copy of openssl binaries to {0} (and setting up env variables...)\" -f $openSSLBinDir)\r         if (-not (Test-Path $openSSLBinDir))\r         {\r             mkdir $openSSLBinDir | Out-Null\r         }\r \r         robocopy $openSSLBinSource $openSSLBinDir * /s \r         robocopy $openSSLBinSource . * /s \r \r         Write-Host \"Setting up PATH and other environment variables.\"\r         $ENV:PATH += \"; $openSSLBinDir\"\r         $ENV:OPENSSL_CONF = Join-Path $openSSLBinDir \"openssl.cnf\"\r \r         Write-Host \"Success\"\r     }\r     Initialize-CAOpenSSL\r     ```\r     \r 4. 接下来运行以下脚本，搜索是否已安装指定的使用者名称的证书，以及是否在计算机上正确配置 OpenSSL：\r \r     ```PowerShell\r     function Get-CACertBySubjectName([string]$subjectName)\r     {\r         $certificates = gci -Recurse Cert:\\LocalMachine\\ |? { $_.gettype().name -eq \"X509Certificate2\" }\r         $cert = $certificates |? { $_.subject -eq $subjectName -and $_.PSParentPath -eq \"Microsoft.PowerShell.Security\\Certificate::LocalMachine\\My\" }\r         if ($NULL -eq $cert)\r         {\r             throw (\"Unable to find certificate with subjectName {0}\" -f $subjectName)\r         }\r     \r         write $cert\r     }\r     function Test-CAPrerequisites()\r     {\r         $certInstalled = $null\r         try\r         {\r             $certInstalled = Get-CACertBySubjectName $_rootCertSubject\r         }\r         catch {}\r \r         if ($NULL -ne $certInstalled)\r         {\r             throw (\"Certificate {0} already installed.  Cleanup CA certs 1st\" -f $_rootCertSubject)\r         }\r \r         if ($NULL -eq $ENV:OPENSSL_CONF)\r         {\r             throw (\"OpenSSL not configured on this system.  Run 'Initialize-CAOpenSSL' (even if you've already done so) to set everything up.\")\r         }\r         Write-Host \"Success\"\r     }\r     Test-CAPrerequisites\r     ```\r     \r     正确配置所有内容后，将显示“成功”消息。 \r \r <a id=\"createcertchain\"></a>\r \r ## <a name=\"create-x509-certificate-chain\"></a>创建 X.509 证书链\r 通过运行以下 PowerShell 脚本创建包含根 CA 的证书链，例如此示例使用的“CN=Azure IoT Root CA”。 此脚本还更新 Windows 操作系统证书存储，并在工作目录中创建证书文件。 \r     1. 以下脚本创建 PowerShell 函数，为给定使用者名称和签名机构创建自签名证书。 \r     \r     ```PowerShell\r     function New-CASelfsignedCertificate([string]$subjectName, [object]$signingCert, [bool]$isASigner=$true)\r     {\r         # Build up argument list\r         $selfSignedArgs =@{\"-DnsName\"=$subjectName; \r                            \"-CertStoreLocation\"=\"cert:\\LocalMachine\\My\";\r                            \"-NotAfter\"=(get-date).AddDays(30); \r                           }\r \r         if ($isASigner -eq $true)\r         {\r             $selfSignedArgs += @{\"-KeyUsage\"=\"CertSign\"; }\r             $selfSignedArgs += @{\"-TextExtension\"= @((\"2.5.29.19={text}ca=TRUE&pathlength=12\")); }\r         }\r         else\r         {\r             $selfSignedArgs += @{\"-TextExtension\"= @(\"2.5.29.37={text}1.3.6.1.5.5.7.3.2,1.3.6.1.5.5.7.3.1\", \"2.5.29.19={text}ca=FALSE&pathlength=0\")  }\r         }\r \r         if ($signingCert -ne $null)\r         {\r             $selfSignedArgs += @{\"-Signer\"=$signingCert }\r         }\r \r         if ($useEcc -eq $true)\r         {\r             $selfSignedArgs += @{\"-KeyAlgorithm\"=\"ECDSA_nistP256\";\r                              \"-CurveExport\"=\"CurveName\" }\r         }\r \r         # Now use splatting to process this\r         Write-Host (\"Generating certificate {0} which is for prototyping, NOT PRODUCTION.  It will expire in 30 days.\" -f $subjectName)\r         write (New-SelfSignedCertificate @selfSignedArgs)\r     }\r     ``` \r     \r     2. 以下 PowerShell 函数使用前面的函数以及 OpenSSL 二进制文件创建 X.509 中间证书。\r      \r     ```PowerShell\r     function New-CAIntermediateCert([string]$subjectName, [Microsoft.CertificateServices.Commands.Certificate]$signingCert, [string]$pemFileName)\r     {\r         $certFileName = ($subjectName + \".cer\")\r         $newCert = New-CASelfsignedCertificate $subjectName $signingCert\r         Export-Certificate -Cert $newCert -FilePath $certFileName -Type CERT | Out-Null\r         Import-Certificate -CertStoreLocation \"cert:\\LocalMachine\\CA\" -FilePath $certFileName | Out-Null\r \r         # Store public PEM for later chaining\r         openssl x509 -inform deer -in $certFileName -out $pemFileName\r \r         del $certFileName\r    \r         write $newCert\r     }  \r     ```\r     \r     3. 以下 PowerShell 函数创建 X.509 证书链。 阅读[证书链](https://en.wikipedia.org/wiki/X.509#Certificate_chains_and_cross-certification)，了解详细信息。\r     \r     ```PowerShell\r     function New-CACertChain()\r     {\r         Write-Host \"Beginning to install certificate chain to your LocalMachine\\My store\"\r         $rootCACert =  New-CASelfsignedCertificate $_rootCertSubject $null\r     \r         Export-Certificate -Cert $rootCACert -FilePath $rootCACerFileName  -Type CERT\r         Import-Certificate -CertStoreLocation \"cert:\\LocalMachine\\Root\" -FilePath $rootCACerFileName\r \r         openssl x509 -inform der -in $rootCACerFileName -out $rootCAPemFileName\r \r         $intermediateCert1 = New-CAIntermediateCert ($_intermediateCertSubject -f \"1\") $rootCACert $intermediate1CAPemFileName\r         $intermediateCert2 = New-CAIntermediateCert ($_intermediateCertSubject -f \"2\") $intermediateCert1 $intermediate2CAPemFileName\r         $intermediateCert3 = New-CAIntermediateCert ($_intermediateCertSubject -f \"3\") $intermediateCert2 $intermediate3CAPemFileName\r         Write-Host \"Success\"\r     }    \r     ```\r     \r     此脚本在工作目录创建名为 RootCA.cer 的文件。 \r     \r     4. 最后，通过在 PowerShell 窗口中运行命令 `New-CACertChain`，使用上述 PowerShell 函数创建 X.509 证书链。 \r \r \r <a id=\"signverificationcode\"></a>\r \r ## <a name=\"proof-of-possession-of-your-x509-ca-certificate\"></a>X.509 CA 证书的所有权证明\r \r 此脚本执行 X.509 证书的所有权证明流程。 \r \r 在桌面上的 PowerShell 窗口中运行以下代码：\r \r     ```PowerShell\r     function New-CAVerificationCert([string]$requestedSubjectName)\r     {\r         $cnRequestedSubjectName = (\"CN={0}\" -f $requestedSubjectName)\r         $verifyRequestedFileName = \".\\verifyCert4.cer\"\r         $rootCACert = Get-CACertBySubjectName $_rootCertSubject\r         Write-Host \"Using Signing Cert:::\" \r         Write-Host $rootCACert\r     \r         $verifyCert = New-CASelfsignedCertificate $cnRequestedSubjectName $rootCACert $false\r \r         Export-Certificate -cert $verifyCert -filePath $verifyRequestedFileName -Type Cert\r         if (-not (Test-Path $verifyRequestedFileName))\r         {\r             throw (\"Error: CERT file {0} doesn't exist\" -f $verifyRequestedFileName)\r         }\r     \r         Write-Host (\"Certificate with subject {0} has been output to {1}\" -f $cnRequestedSubjectName, (Join-Path (get-location).path $verifyRequestedFileName)) \r     }\r     New-CAVerificationCert \"<your verification code>\"\r     ```\r     \r    这将以名为 VerifyCert4.cer 的文件在工作目录中创建具有给定使用者名称且由 CA 签名的证书。 此证书文件有助于向 IoT 中心验证你是否具有此 CA 的签名权限（即私钥）。\r \r \r <a id=\"createx509device\"></a>\r \r ## <a name=\"create-leaf-x509-certificate-for-your-device\"></a>创建设备的 X.509 叶证书\r \r 本部分介绍可以使用 PowerShell 脚本创建叶设备证书及相应证书链。 \r \r 在本地计算机上的 PowerShell 窗口中，运行以下脚本创建此设备的 CA 签名的 X.509 证书：\r \r     ```PowerShell\r     function New-CADevice([string]$deviceName, [string]$signingCertSubject=$_rootCertSubject)\r     {\r         $cnNewDeviceSubjectName = (\"CN={0}\" -f $deviceName)\r         $newDevicePfxFileName = (\"./{0}.pfx\" -f $deviceName)\r         $newDevicePemAllFileName      = (\"./{0}-all.pem\" -f $deviceName)\r         $newDevicePemPrivateFileName  = (\"./{0}-private.pem\" -f $deviceName)\r         $newDevicePemPublicFileName   = (\"./{0}-public.pem\" -f $deviceName)\r     \r         $signingCert = Get-CACertBySubjectName $signingCertSubject ## \"CN=Azure IoT CA Intermediate 1 CA\"\r \r         $newDeviceCertPfx = New-CASelfSignedCertificate $cnNewDeviceSubjectName $signingCert $false\r     \r         $certSecureStringPwd = ConvertTo-SecureString -String $_privateKeyPassword -Force -AsPlainText\r \r         # Export the PFX of the cert we've just created.  The PFX is a format that contains both public and private keys.\r         Export-PFXCertificate -cert $newDeviceCertPfx -filePath $newDevicePfxFileName -password $certSecureStringPwd\r         if (-not (Test-Path $newDevicePfxFileName))\r         {\r             throw (\"Error: CERT file {0} doesn't exist\" -f $newDevicePfxFileName)\r         }\r \r         # Begin the massaging.  First, turn the PFX into a PEM file which contains public key, private key, and other attributes.\r         Write-Host (\"When prompted for password by openssl, enter the password as {0}\" -f $_privateKeyPassword)\r         openssl pkcs12 -in $newDevicePfxFileName -out $newDevicePemAllFileName -nodes\r \r         # Convert the PEM to get formats we can process\r         if ($useEcc -eq $true)\r         {\r             openssl ec -in $newDevicePemAllFileName -out $newDevicePemPrivateFileName\r         }\r         else\r         {\r             openssl rsa -in $newDevicePemAllFileName -out $newDevicePemPrivateFileName\r         }\r         openssl x509 -in $newDevicePemAllFileName -out $newDevicePemPublicFileName\r  \r         Write-Host (\"Certificate with subject {0} has been output to {1}\" -f $cnNewDeviceSubjectName, (Join-Path (get-location).path $newDevicePemPublicFileName)) \r     }\r     ```\r     \r    然后使用用于创建设备的友好名称在 PowerShell 窗口中运行 `New-CADevice \"<yourTestDevice>\"`。 当系统提示输入 CA 私钥的密码时，请输入“123”。 这将在工作目录中创建 <yourTestDevice>.pfx 文件。\r \r "}