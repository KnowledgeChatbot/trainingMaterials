{"Title":"使用 IDENTITY 创建代理键","Description":"了解如何使用 IDENTITY 在表上创建代理键。","Content":"# <a name=\"create-surrogate-keys-by-using-identity\"></a>使用 IDENTITY 创建代理键\r > [!div class=\"op_single_selector\"]\r > * [概述][Overview]\r > * [数据类型][Data Types]\r > * [分布][Distribute]\r > * [索引][Index]\r > * [分区][Partition]\r > * [统计信息][Statistics]\r > * [临时][Temporary]\r > * [标识][Identity]\r > \r > \r \r 许多数据建模者想要在设计数据仓库模型时在其表上创建代理键。 可以使用 IDENTITY 属性轻松高效地实现此目标，而不会影响负载性能。 \r \r ## <a name=\"get-started-with-identity\"></a>IDENTITY 入门\r 在首次使用类似以下语句的语法创建表时，可以将表定义为具有 IDENTITY 属性：\r \r ```sql\r CREATE TABLE dbo.T1\r (   C1 INT IDENTITY(1,1) NOT NULL\r ,   C2 INT NULL\r )\r WITH\r (   DISTRIBUTION = HASH(C2)\r ,   CLUSTERED COLUMNSTORE INDEX\r )\r ;\r ```\r \r 然后，可以使用 `INSERT..SELECT` 来填充表。\r \r ## <a name=\"behavior\"></a>行为\r IDENTITY 属性设计为能够在数据仓库的所有分布区中扩展，不会影响负载性能。 因此，IDENTITY 的实现旨在实现这些目标。 本部分重点介绍了实现的微妙之处，以帮助你更全面地了解它们。  \r \r ### <a name=\"allocation-of-values\"></a>值的分配\r IDENTITY 属性不保证分配代理值的顺序，这反映了 SQL Server 和 Azure SQL 数据库的行为。 但是，在 Azure SQL 数据仓库中，保证的缺乏更为明显。 \r \r 以下示例对此做了演示：\r \r ```sql\r CREATE TABLE dbo.T1\r (   C1 INT IDENTITY(1,1)    NOT NULL\r ,   C2 VARCHAR(30)              NULL\r )\r WITH\r (   DISTRIBUTION = HASH(C2)\r ,   CLUSTERED COLUMNSTORE INDEX\r )\r ;\r \r INSERT INTO dbo.T1\r VALUES (NULL);\r \r INSERT INTO dbo.T1\r VALUES (NULL);\r \r SELECT *\r FROM dbo.T1;\r \r DBCC PDW_SHOWSPACEUSED('dbo.T1');\r ```\r \r 在前面的示例中，两行位于分布 1 中。 第一行在列 `C1` 中包含代理值 1，且第二行包含代理值 61。 这两个值均由 IDENTITY 属性生成。 但是，值的分配不是连续的。 此行为是设计使然。\r \r ### <a name=\"skewed-data\"></a>倾斜的数据 \r 数据类型的值范围在各个分布区之间是均匀分配的。 如果分布式表受偏斜数据的影响，则可用于数据类型的值范围可能会过早耗尽。 例如，如果所有数据最终都会处于单个分发中，则表实际上只能访问六十分之一的数据类型值。 出于此原因，IDENTITY 属性仅限用于 `INT` 和 `BIGINT` 数据类型。\r \r ### <a name=\"selectinto\"></a>SELECT..INTO\r 在将现有的 IDENTITY 列选入新表时，新列将继承该 IDENTITY 属性，除非下列条件之一为 true：\r - SELECT 语句包含联接。\r - 使用 UNION 联接多个 SELECT 语句。\r - IDENTITY 列在 SELECT 列表中多次列出。\r - IDENTITY 列是表达式的一部分。\r \r 如果其中的任一条件为 true，则创建属性为 NOT NULL 的列，而不继承 IDENTITY 属性。\r \r ### <a name=\"create-table-as-select\"></a>CREATE TABLE AS SELECT\r CREATE TABLE AS SELECT (CTAS) 遵循 SELECT..INTO 中记录的相同 SQL Server 行为。 但是，不能指定语句的 `CREATE TABLE` 部分的列定义中的 IDENTITY 属性。 同样，也不能在 CTAS 的 `SELECT` 部分中使用 IDENTITY 函数。 若要填充表，需要使用 `CREATE TABLE` 来定义后跟 `INSERT..SELECT` 的表来进行填充。\r \r ## <a name=\"explicitly-insert-values-into-an-identity-column\"></a>将值显式插入到 IDENTITY 列 \r SQL 数据仓库支持 `SET IDENTITY_INSERT <your table> ON|OFF` 语法。 可以使用此语法显式将值插入到 IDENTITY 列中。\r \r 许多数据建模者喜欢在其维度中为某些行使用预定义的负值。 例如，-1 或“未知成员”行。 \r \r 下一个脚本演示如何使用 SET IDENTITY_INSERT 显式添加此行：\r \r ```sql\r SET IDENTITY_INSERT dbo.T1 ON;\r \r INSERT INTO dbo.T1\r (   C1\r ,   C2\r )\r VALUES (-1,'UNKNOWN')\r ;\r \r SET IDENTITY_INSERT dbo.T1 OFF;\r \r SELECT  *\r FROM    dbo.T1\r ;\r ```    \r \r ## <a name=\"load-data-into-a-table-with-identity\"></a>将数据加载到具有 IDENTITY 的表\r \r IDENTITY 属性的存在对数据加载代码有一定影响。 本节重点介绍使用 IDENTITY 将数据加载到表中的一些基本模式。 \r \r ### <a name=\"load-data-with-polybase\"></a>使用 PolyBase 加载数据\r 若要使用 IDENTITY 将数据加载到表中并生成代理键，请创建表，然后使用 INSERT..SELECT 或 INSERT..VALUES 执行加载。\r \r 下面的示例重点介绍了基本模式：\r \r ```sql\r --CREATE TABLE with IDENTITY\r CREATE TABLE dbo.T1\r (   C1 INT IDENTITY(1,1)\r ,   C2 VARCHAR(30)\r )\r WITH\r (   DISTRIBUTION = HASH(C2)\r ,   CLUSTERED COLUMNSTORE INDEX\r )\r ;\r \r --Use INSERT..SELECT to populate the table from an external table\r INSERT INTO dbo.T1\r (C2)\r SELECT  C2\r FROM    ext.T1\r ;\r \r SELECT  *\r FROM    dbo.T1\r ;\r \r DBCC PDW_SHOWSPACEUSED('dbo.T1');\r ```\r \r > [!NOTE] \r > 在将数据加载到包含 IDENTITY 列的表时，当前无法使用 `CREATE TABLE AS SELECT`。\r > \r \r 有关使用大容量复制程序 (BCP) 工具加载数据的详细信息，请参阅以下文章：\r \r - [使用 PolyBase 加载数据][]\r - [PolyBase 最佳做法][]\r \r ### <a name=\"load-data-with-bcp\"></a>使用 BCP 加载数据\r BCP 是一个命令行工具，可用于将数据加载到 SQL 数据仓库。 在将数据加载到包含 IDENTITY 列的表中时，其中一个参数 (-E) 控制 BCP 的行为。 \r \r 在指定 -E 后，会保留输入文件中为 IDENTITY 列保留的值。 如果未指定 -E，则会忽略此列中的值。 如果未包括标识列，则会照常加载数据。 将根据属性的增量和种子策略来生成值。\r \r 有关使用 BCP 加载数据的详细信息，请参阅以下文章：\r \r - [使用 BCP 加载][]\r - [MSDN 中的 BCP][]\r \r ## <a name=\"catalog-views\"></a>目录视图\r SQL 数据仓库支持 `sys.identity_columns` 目录视图。 此视图可用于标识具有 IDENTITY 属性的列。\r \r 为了帮助更好地了解数据库架构，本示例演示如何将 `sys.identity_columns` 与其他系统目录视图集成：\r \r ```sql\r SELECT  sm.name\r ,       tb.name\r ,       co.name\r ,       CASE WHEN ic.column_id IS NOT NULL\r              THEN 1\r         ELSE 0\r         END AS is_identity \r FROM        sys.schemas AS sm\r JOIN        sys.tables  AS tb           ON  sm.schema_id = tb.schema_id\r JOIN        sys.columns AS co           ON  tb.object_id = co.object_id\r LEFT JOIN   sys.identity_columns AS ic  ON  co.object_id = ic.object_id\r                                         AND co.column_id = ic.column_id\r WHERE   sm.name = 'dbo'\r AND     tb.name = 'T1'\r ;\r ```\r \r ## <a name=\"limitations\"></a>限制\r 不能在以下方案中使用 IDENTITY 属性：\r - 其中的列数据类型不是 INT 或 BIGINT\r - 其中的列也同样是分发键\r - 其中的表是外部表 \r \r SQL 数据仓库中不支持以下相关函数：\r \r - [IDENTITY()][]\r - [@@IDENTITY][]\r - [SCOPE_IDENTITY][]\r - [IDENT_CURRENT][]\r - [IDENT_INCR][]\r - [IDENT_SEED][]\r - [DBCC CHECK_IDENT()][]\r \r ## <a name=\"tasks\"></a>任务\r \r 本部分提供在使用 IDENTITY 列时可用于执行常见任务的一些示例代码。\r \r > [!NOTE] \r > 在下列所有任务中，C1 列都是 IDENTITY。\r > \r \r ### <a name=\"find-the-highest-allocated-value-for-a-table\"></a>查找表的最高已分配值\r 可以使用 `MAX()` 函数来确定为分布式表分配的最高值：\r \r ```sql\r SELECT  MAX(C1)\r FROM    dbo.T1\r ``` \r \r ### <a name=\"find-the-seed-and-increment-for-the-identity-property\"></a>查找 IDENTITY 属性的种子和增量\r 目录视图可用于通过使用以下查询来发现表的标识增量和种子配置值： \r \r ```sql\r SELECT  sm.name\r ,       tb.name\r ,       co.name\r ,       ic.seed_value\r ,       ic.increment_value \r FROM        sys.schemas AS sm\r JOIN        sys.tables  AS tb           ON  sm.schema_id = tb.schema_id\r JOIN        sys.columns AS co           ON  tb.object_id = co.object_id\r JOIN        sys.identity_columns AS ic  ON  co.object_id = ic.object_id\r                                         AND co.column_id = ic.column_id\r WHERE   sm.name = 'dbo'\r AND     tb.name = 'T1'\r ;\r ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r \r * 若要了解有关开发表的详细信息，请参阅[表概述][Overview]、[表数据类型][Data Types]、[分布表][Distribute]、[为表编制索引][Index]、[将表分区][Partition]和[临时表][Temporary]。 \r * 有关最佳做法的详细信息，请参阅 [SQL 数据仓库最佳做法][SQL Data Warehouse Best Practices]。  \r \r <!--Image references-->\r \r <!--Article references-->\r [Overview]: ./sql-data-warehouse-tables-overview.md\r [Data Types]: ./sql-data-warehouse-tables-data-types.md\r [Distribute]: ./sql-data-warehouse-tables-distribute.md\r [Index]: ./sql-data-warehouse-tables-index.md\r [Partition]: ./sql-data-warehouse-tables-partition.md\r [Statistics]: ./sql-data-warehouse-tables-statistics.md\r [Temporary]: ./sql-data-warehouse-tables-temporary.md\r [Identity]: ./sql-data-warehouse-tables-identity.md\r [SQL Data Warehouse Best Practices]: ./sql-data-warehouse-best-practices.md\r \r [使用 bcp 加载数据]: /sql-data-warehouse/sql-data-warehouse-load-with-bcp/\r [使用 PolyBase 加载数据]: /sql-data-warehouse/sql-data-warehouse-load-from-azure-blob-storage-with-polybase/\r [PolyBase 最佳做法]: /sql-data-warehouse/sql-data-warehouse-load-polybase-guide/\r \r <!--MSDN references-->\r [Identity property]: https://msdn.microsoft.com/library/ms186775.aspx\r [sys.identity_columns]: https://msdn.microsoft.com/library/ms187334.aspx\r [IDENTITY()]: https://msdn.microsoft.com/library/ms189838.aspx\r [@@IDENTITY]: https://msdn.microsoft.com/library/ms187342.aspx\r [SCOPE_IDENTITY]: https://msdn.microsoft.com/library/ms190315.aspx\r [IDENT_CURRENT]: https://msdn.microsoft.com/library/ms175098.aspx\r [IDENT_INCR]: https://msdn.microsoft.com/library/ms189795.aspx\r [IDENT_SEED]: https://msdn.microsoft.com/library/ms189834.aspx\r [DBCC CHECK_IDENT()]: https://msdn.microsoft.com/library/ms176057.aspx\r \r [MSDN 中的 bcp]: https://msdn.microsoft.com/library/ms162802.aspx\r \r <!--Other Web references-->\r \r <!--Update_Description: wording update-->"}