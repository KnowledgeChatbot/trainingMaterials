{"Title":"对 Azure SQL 数据库解决方案进行复制和故障转移","Description":"了解如何配置 Azure SQL 数据库和应用程序以便故障转移到复制的数据库，以及如何测试故障转移。","Content":"# <a name=\"replicate-and-failover-an-azure-sql-database-solution\"></a>对 Azure SQL 数据库解决方案进行复制和故障转移\r \r 在本教程中，将配置 Azure SQL 数据库和应用程序以便故障转移到远程区域中，然后测试故障转移计划。 \r \r 如果没有 Azure 订阅，请在开始前创建一个[试用帐户](https://www.azure.cn/1rmb-trial/)。\r \r 若要完成本教程，请确保做好以下准备：\r \r - 最新版本的 [SQL Server Management Studio](https://docs.microsoft.com/sql/ssms/download-sql-server-management-studio-ssms) (SSMS)。 安装 SSMS 就会安装最新版本的 SQLPackage，这是一个可用于自动执行一系列数据库开发任务的命令行实用工具。 \r - 要迁移的 Azure 数据库。 本教程使用以下任一快速入门中名为 **mySampleDatabase 的 AdventureWorksLT 示例数据库：\r \r    - [创建 DB - 门户](sql-database-get-started-portal.md)\r    - [创建 DB - CLI](sql-database-get-started-cli.md)\r \r ## <a name=\"create-azure-active-directory-users-optional\"></a>创建 Azure Active Directory 用户（可选）\r \r 在此步骤中，创建或标识可作为用户添加到 Azure SQL 数据库逻辑服务器和示例数据库的 Azure Active Directory 用户。\r - 如果订阅属于包含现有用户帐户的 Azure Active Directory 企业环境，则标识 3 个用户帐户，分别用作本教程的 Active Directory 管理用户、应用程序管理用户和应用程序用户，并继续执行步骤 3：创建 SQL 数据库登录名和用户。 \r - 如果订阅不属于 Azure Active Directory 企业环境，或者属于不含任何现有用户帐户的 Azure Active Directory 企业环境（并且你有权创建新的 Azure Active Directory 用户帐户。\r \r 1. 登录到 [Azure 门户](http://portal.azure.cn)。\r 2. 在左侧菜单中，单击“更多服务”。\r 3. 在筛选器文本框中，键入 Azure，然后选择“Azure Active Directory”。\r 4. 在“Azure Active Directory”页的“快速任务”窗格中，单击“添加用户”。\r 5. 在“用户”窗体中，创建以下用户。\r    - 名称：ad-admin\r    - 用户名：ad-admin@yourdomain (Yopu4708)\r 6. 选中“显示密码”复选框，然后记录此用户帐户的密码以供将来使用。\r 7. 单击“创建” 。\r 8. 重复上述 3 个步骤，创建以下 2 个新用户。\r    - 名称：app-admin\r    - 用户名：app-admin@yourdomain (Buju4319)\r    - 名称：app-user\r    - 用户名：app-user@yourdomain (Nonu4001)。\r \r 9. 打开新的浏览器窗口，并使用新创建的 ad-admin 帐户登录 Azure 门户。\r 10. 在“更新密码”页的“当前密码”框中，输入系统生成的密码。 \r 11. 在“新密码”和“确认密码”框中，输入自己的密码。\r 12. 单击“更新密码并登录”。\r \r ## <a name=\"configure-sql-database-integration-with-azure-active-directory\"></a>使用 Azure Active Directory 配置 SQL 数据库集成\r \r 1. 在左侧菜单中单击“更多服务”，在筛选器文本框中键入 sql，然后选择“SQL 服务器”。\r 2. 在“SQL 服务器”页上，单击 SQL 数据库服务器。\r 3. 在服务器“概述”页“概要”窗格的“Active Directory 管理员”下，单击“未配置”。\r 4. 在“Active Directory 管理员”页上单击“设置管理员”。\r 5. 选择“ad-admin”Azure Active Directory 帐户（或其他预先存在的帐户，例如自己的帐户），作为 Azure SQL 数据库服务器的服务器管理员。\r 6. 单击“选择”。\r 7. 单击“保存” 。\r \r ## <a name=\"create-users-with-permissions-for-your-database\"></a>创建具有数据库权限的用户\r \r <TO DO: need to change script to grant app-user sufficient permissions to perform operation in java app>\r \r 使用 SQL Server Management Studio 连接到数据库，并创建用户帐户。 这些用户帐户将自动复制到辅助服务器。 如果进行连接的客户端所在的 IP 地址尚未配置防火墙，则需要配置防火墙规则。 有关步骤，请参阅[使用 Azure 门户创建 SQL DB](sql-database-get-started-portal.md)。\r \r 1. 打开 SQL Server Management Studio。\r 2. 将“身份验证”模式更改为“Active Directory 密码验证”。\r 3. 使用新设计的 Azure Active Directory 服务器管理员帐户连接到服务器。 \r 4. 在对象资源管理器中，展开“系统数据库”，右键单击“mySampleDatabase”，然后单击“新建查询”。\r 5. 在查询窗口中执行以下查询，以便在数据库中创建用户帐户，同时向两个管理帐户授予 db_owner 权限。 将域名的占位符替换为你的域。\r \r    ```tsql\r    --Create Azure AD user account\r    CREATE USER [app-admin@<yourdomain>] FROM EXTERNAL PROVIDER;\r    --Add Azure AD user to db_owner role\r    ALTER ROLE db_owner ADD MEMBER [app-admin@<yourdomain>]; \r    --Create additional Azure AD user account\r    CREATE USER [app-user@<yourdomain>] FROM EXTERNAL PROVIDER;\r    --Create SQL user account\r    CREATE USER app_admin WITH PASSWORD = 'MyStrongPassword1';\r    --Add SQL user to db_owner role\r    ALTER ROLE db_owner ADD MEMBER app_admin; \r    --Create additional SQL user\r    CREATE USER app_user WITH PASSWORD = 'MyStrongPassword1';\r    ```\r \r ## <a name=\"create-database-level-firewall\"></a>创建数据库级防火墙\r \r 使用 SQL Server Management Studio 为数据库创建数据库级防火墙规则。 此数据库级防火墙规则将自动复制到辅助服务器。 出于测试目的，可以为所有 IP 地址（包括 0.0.0.0 和 255.255.255.255）创建防火墙规则，可以为已创建有服务器防火墙规则的单个 IP 地址创建防火墙规则，或者可以为要用于本教程测试的计算机 IP 地址配置一个或多个防火墙规则。  \r \r - 在打开的查询窗口中，将之前的查询替换为以下查询，将 IP 地址替换为环境中相应的 IP 地址。 \r \r    ```tsql\r    -- Create database-level firewall setting for your publich IP address\r    EXECUTE sp_set_database_firewall_rule N'mySampleDatabase','0.0.0.1','0.0.0.1';\r    ```  \r \r ## <a name=\"create-a-failover-group\"></a>创建故障转移组 \r \r 选择故障转移区域，在该区域中创建一个空服务器，然后在现有服务器和新的空服务器之间创建故障转移组。\r \r 1. 填充变量。\r \r    ```powershell\r    $secpasswd = ConvertTo-SecureString \"yourstrongpassword\" -AsPlainText -Force\r    $mycreds = New-Object System.Management.Automation.PSCredential (“ServerAdmin”, $secpasswd)\r    $myresourcegroup = \"<your resource group>\"\r    $mylocation = \"<resource group location>\"\r    $myserver = \"<your existing server>\"\r    $mydatabase = \"<your existing database>\"\r    $mydrlocation = \"<your disaster recovery location>\"\r    $mydrserver = \"<your disaster recovery server>\"\r    $myfailovergroup = \"<your failover group\"\r    ```\r \r 2. 在故障转移区域中创建空的备份服务器。\r \r    ```powershell\r    $mydrserver = New-AzureRmSqlServer -ResourceGroupName $myresourcegroup -Location $mydrlocation -ServerName $mydrserver -ServerVersion \"12.0\" -SqlAdministratorCredentials $mycreds\r    ```\r \r 3. 创建故障转移组。\r \r    ```powershell\r    $myfailovergroup = New-AzureRMSqlDatabaseFailoverGroup –ResourceGroupName $myresourcegroup -ServerName \"$myserver\" -PartnerServerName $mydrserver  –FailoverGroupName $myfailovergroupname –FailoverPolicy \"Automatic\" -GracePeriodWithDataLossHours 2\r    ```\r \r 4. 将数据库添加到故障转移组\r \r    ```powershell\r    $mydrserver | Add-AzureRMSqlDatabaseToFailoverGroup –FailoverGroupName $myfailovergroup  -Database $mydatabase\r    ```\r \r ## <a name=\"add-empty-backup-server-to-domain\"></a>将空的备份服务器添加到域\r \r 1. 在 Azure 门户的左侧菜单中单击“更多服务”，在筛选器文本框中键入 sql，然后选择“SQL 服务器”。\r 2. 在“SQL 服务器”页上，单击新的 SQL 数据库灾难恢复服务器。\r 3. 在服务器“概述”页“概要”窗格的“Active Directory 管理员”下，单击“未配置”。\r 4. 在“Active Directory 管理员”页上单击“设置管理员”。\r 5. 选择“ad-admin”Azure Active Directory 帐户（或其他预先存在的帐户，例如自己的帐户），作为新 Azure SQL 数据库灾难恢复服务器的服务器管理员。\r 6. 单击“选择”。\r 7. 单击“保存” 。\r \r ## <a name=\"prepare-client-tier\"></a>准备客户端层\r \r 1. 使用故障转移配置文件 AWProfile 创建 TM 配置文件。\r 2. 配置监视\r \r    ```powershell\r    $profile = New-AzureRmTrafficManagerProfile -Name AWProfile -ResourceGroupName MYRG -TrafficRoutingMethod Failover -RelativeDnsName myapp -Ttl 30 -MonitorProtocol HTTP -MonitorPort 80 -MonitorPath \"/\"\r    $webapp1 = Get-AzureRMWebApp -Name WebappChinaEast\r    Add-AzureRmTrafficManagerEndpointConfig -EndpointName webapp1ep -TrafficManagerProfile $profile -Type AzureEndpoints -TargetResourceId $webapp1.Id -EndpointStatus Enabled\r    $webapp2 = Get-AzureRMWebApp -Name WebappChinaEast\r    Add-AzureRmTrafficManagerEndpointConfig -EndpointName webapp2ep -TrafficManagerProfile $profile -Type AzureEndpoints -TargetResourceId $webapp2.Id -EndpointStatus Enabled\r    Set-AzureRmTrafficManagerProfile -TrafficManagerProfile $profile\r    ```\r \r ## <a name=\"deploy-java-application-and-connect-to-database\"></a>部署 Java 应用程序并连接到数据库\r \r <In progress>请参阅[连接 Java](sql-database-connect-query-java.md)。\r \r <TO DO: change user to app-user>\r \r 1. 安装 Java 8。\r 2. 安装 Maven。\r 3. 创建 Maven 项目。\r 4. 将以下内容添加到 pom.xml \r \r    - 依赖项\r \r       ```java\r       <dependency>\r          <groupId>com.microsoft.sqlserver</groupId>\r          <artifactId>mssql-jdbc</artifactId>\r          <version>6.1.0.jre8</version>\r        </dependency>\r       ```\r    - 语言级别\r \r       ```java\r       <properties>\r          <maven.compiler.source>1.8</maven.compiler.source>\r          <maven.compiler.target>1.8</maven.compiler.target>\r       </properties>\r       ```\r \r    - 支持 JAR 中清单文件的生成选项\r \r       ```java\r       <build>\r         <plugins>\r            <plugin>\r               <groupId>org.apache.maven.plugins</groupId>\r               <artifactId>maven-jar-plugin</artifactId>\r               <version>3.0.0</version>\r               <configuration>\r                  <archive>\r                     <manifest>\r                        <mainClass>com.sqldbsamples.App</mainClass>\r                     </manifest>\r                  </archive>\r               </configuration>\r            </plugin>\r         </plugins>\r       </build>\r       ```\r 5. 将以下内容添加到 App.java 文件：\r \r    ```java\r    package com.sqldbsamples;\r \r    import java.sql.Connection;\r    import java.sql.Statement;\r    import java.sql.PreparedStatement;\r    import java.sql.ResultSet;\r    import java.sql.Timestamp;\r    import java.sql.DriverManager;\r    import java.util.Date;\r    import java.util.concurrent.TimeUnit;\r \r    public class App {\r \r       private static final String PRIMARY_HOST_HAME = \"your_primary_server_name\";\r       private static final String SECONDARY_HOST_NAME = \"your_secondary_server_name\";\r       private static final String PRIMARY_HOST_HAME = \"janengsampleserver\";\r       private static final String SECONDARY_HOST_NAME = PRIMARY_HOST_HAME;\r     \r       private static final String DB_NAME = \"mySampleDatabase\";\r       private static final String USER = \"ServerAdmin\";\r       private static final String PASSWORD = \"ChangeYourAdminPassword1\";\r \r       private static final String PRIMARY_URL = String.format(\"jdbc:sqlserver://%s.database.chinacloudapi.cn:1433;database=%s;user=%s;password=%s;encrypt=true;hostNameInCertificate=*.database.chinacloudapi.cn;loginTimeout=30;\", PRIMARY_HOST_HAME, DB_NAME, USER, PASSWORD);\r       private static final String SECONDARY_URL = String.format(\"jdbc:sqlserver://%s.database.chinacloudapi.cn:1433;database=%s;user=%s;password=%s;encrypt=true;hostNameInCertificate=*.database.chinacloudapi.cn;loginTimeout=30;\", SECONDARY_HOST_NAME, DB_NAME, USER, PASSWORD);\r \r       public static void main(String[] args) {\r          System.out.println(\"#######################################\");\r          System.out.println(\"## GEO DISTRIBUTED DATABASE TUTORIAL ##\");\r          System.out.println(\"#######################################\");\r          System.out.println(\"\"); \r \r          // todo: get the max id from the table and initialize INSERT COUNTER with it so that the code will always run (avoid duplicate keys)  \r          int highWaterMark = getHighWaterMarkId();\r \r          try {\r             for(int i = 1; i < 1000; i++) {\r                 //  loop will run for about 1h\r                 System.out.print(i + \": insert on primary \" + (insertData((highWaterMark + i))?\"successful\":\"failed\"));\r                 TimeUnit.SECONDS.sleep(1);\r                 System.out.print(\", read from secondary \" + (selectData((highWaterMark + i))?\"successful\":\"failed\") + \"\\n\");\r                 TimeUnit.SECONDS.sleep(3);\r             }\r          } catch(Exception e) {\r             e.printStackTrace();\r       }\r    }\r \r    private static boolean insertData(int id) {\r       // Insert data into the product table with a unique product name that we can use to find the product again later\r       String sql = \"INSERT INTO SalesLT.Product (Name, ProductNumber, Color, StandardCost, ListPrice, SellStartDate) VALUES (?,?,?,?,?,?);\";\r \r       try (Connection connection = DriverManager.getConnection(PRIMARY_URL); \r               PreparedStatement pstmt = connection.prepareStatement(sql)) {\r          pstmt.setString(1, \"BrandNewProduct\" + id);\r          pstmt.setInt(2, 200989 + id + 10000);\r          pstmt.setString(3, \"Blue\");\r          pstmt.setDouble(4, 75.00);\r          pstmt.setDouble(5, 89.99);\r          pstmt.setTimestamp(6, new Timestamp(new Date().getTime()));\r          return (1 == pstmt.executeUpdate());\r       } catch (Exception e) {\r          return false;\r       }\r    }\r \r    private static boolean selectData(int id) {\r       // Query the data that was previously inserted into the primary database from the geo replicated database\r       String sql = \"SELECT Name, Color, ListPrice FROM SalesLT.Product WHERE Name = ?\";\r \r       try (Connection connection = DriverManager.getConnection(SECONDARY_URL); \r               PreparedStatement pstmt = connection.prepareStatement(sql)) {\r          pstmt.setString(1, \"BrandNewProduct\" + id);\r          try (ResultSet resultSet = pstmt.executeQuery()) {\r             return resultSet.next();\r          }\r       } catch (Exception e) {\r          return false;\r       }\r    }\r \r    private static int getHighWaterMarkId() {\r       // Query the high water mark id that is stored in the table to be able to make unique inserts \r       String sql = \"SELECT MAX(ProductId) FROM SalesLT.Product\";\r       int result = 1;\r         \r       try (Connection connection = DriverManager.getConnection(SECONDARY_URL); \r               Statement stmt = connection.createStatement();\r               ResultSet resultSet = stmt.executeQuery(sql)) {\r          if (resultSet.next()) {\r              result =  resultSet.getInt(1);\r             }\r          } catch (Exception e) {\r           e.printStackTrace();\r          }\r          return result;\r       }\r    }\r    ```\r 6. 保存文件。\r \r ## <a name=\"compile-and-run\"></a>编译和运行\r \r 1. 转到控制台并执行\r \r    ```java\r    mvn package\r    ```\r 2. 完成后执行，运行应用程序（将运行大约 1 小时，除非手动停止运行）：\r \r    ```\r    mvn -q -e exec:java \"-Dexec.mainClass=com.sqldbsamples.App\"\r    ```\r \r    如果运行成功，输出将如下所示：\r \r    #######################################\r    ## <a name=\"geo-distributed-database-tutorial\"></a>异地分布式数据库教程 ##\r    #######################################\r \r    1. 成功插入在主终结点上，成功从辅助终结点上读取\r    2. 成功插入在主终结点上，成功从辅助终结点上读取\r    3. 成功插入在主终结点上，成功从辅助终结点上读取\r \r ## <a name=\"perform-dr-drill\"></a>执行 DR 演练\r \r 1. 使用强制故障转移调用 FG 的手动故障转移。 如果无法接受演练期间的数据丢失，则应该删除 -AllowDataLoss\r \r    ```powershell\r    $fg | Switch-AzureRMSqlDatabaseFailoverGroup -AllowDataLoss\r    ```\r \r 2.  禁用 TM 配置文件中的主终结点，触发终结点故障转移 \r \r    ```powershell\r    Disable-AzureRmTrafficManagerEndpoint -Name webapp1ep -Type AzureEndpoints -ProfileName $profile.Name -ResourceGroupName MYRG -Force\r    ```\r \r 3.  重新运行应用程序。\r \r \r ## <a name=\"relocate-application-to-primary-region\"></a>重新将应用程序定位到主要区域\r \r 1.  调用 FG 适合手动执行的故障转移。 未指定 -AllowDataLoss\r \r    ```powershell\r    $fg | Switch-AzureRMSqlDatabaseFailoverGroup \r    ```\r \r 2.  禁用 TM 配置文件中的辅助终结点 (webapp2ep)，触发终结点故障转移 \r \r    ```powershell\r    Disable-AzureRmTrafficManagerEndpoint -Name webapp2ep -Type AzureEndpoints -ProfileName $profile.Name -ResourceGroupName MYRG -Force\r    ```\r \r 3.  重新运行应用程序。\r \r ## <a name=\"troubleshoot-failover\"></a>故障转移排查 \r \r 找出现在作为主要区域的区域，确保发生了故障转移。 如果是主要区域，将显示角色。\r \r    ```powershell\r    $fg = Get-AzureRMSqlDatabaseFailoverGroup -ResourceGroupName \"myrg\" -ServerName \"AWserver\" \r    print $fg.role\r    ```\r \r ## <a name=\"next-steps\"></a>后续步骤 \r \r - 尽快进入附近的影院"}