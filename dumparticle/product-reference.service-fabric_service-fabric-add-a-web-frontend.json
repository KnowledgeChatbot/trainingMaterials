{"Title":"使用 ASP.NET Core 创建 Azure Service Fabric 应用的 Web 前端","Description":"使用 ASP.NET Core 项目和服务间通信，通过 Service Remoting 将 Service Fabric 应用程序公开到 Web。","Content":"# <a name=\"build-a-web-service-front-end-for-your-application-using-aspnet-core\"></a>使用 ASP.NET Core 生成应用程序的 Web 服务前端\r 默认情况下，Azure Service Fabric 服务不提供用于访问 Web 的公共接口。 若要向 HTTP 客户端公开应用程序的功能，需要创建一个 Web 项目作为入口点，然后从该处与单个服务进行通信。\r \r 在本教程中，我们将弥补[在 Visual Studio 中创建第一个应用程序](service-fabric-create-your-first-application-in-visual-studio.md)教程中遗留的内容，在有状态计数器服务的前面添加一个 ASP.NET Core Web 服务。 如果尚未学习上述教程，应该返回并逐步完成该教程中的步骤。\r \r ## <a name=\"set-up-your-environment-for-aspnet-core\"></a>为 ASP.NET Core 设置环境\r \r 需要 Visual Studio 2017 来跟随完成本教程。 任何版本都可以。 \r \r  - [安装 Visual Studio 2017](https://www.visualstudio.com/)\r \r 若要开发 ASP.NET Core Service Fabric 应用程序，必须安装以下工作负荷：\r  - **Azure 开发**（位于“Web 和云”下）\r  - **ASP.NET 和 Web 开发**（位于“Web 和云”下）\r  - **.NET Core 跨平台开发**（位于“其他工具集”下）\r \r >[!Note] \r >Visual Studio 2015 的 .NET Core 工具不再进行更新，但若仍使用 Visual Studio 2015，需要安装 [.NET Core VS 2015 Tooling Preview 2](https://www.microsoft.com/net/download/core)。\r \r ## <a name=\"add-an-aspnet-core-service-to-your-application\"></a>将 ASP.NET Core 服务添加到应用程序\r ASP.NET Core 是轻量跨平台的 Web 开发框架，可用于创建现代 Web UI 和 Web API。 \r \r 让我们将 ASP.NET Web API 项目添加到现有的应用程序。\r \r 1. 在解决方案资源管理器中，右键单击应用程序项目中的“服务”，并选择“添加 > 新建 Service Fabric 服务”。\r \r     ![将一个新服务添加到现有应用程序][vs-add-new-service]\r 2. 在“**创建服务**”页上，选择 **ASP.NET Core** 并将它命名。\r \r     ![在新建服务对话框中选择 ASP.NET Web 服务][vs-new-service-dialog]\r \r 3. 下一页将提供一组 ASP.NET Core 项目模板。 请注意，如果 ASP.NET Core 项目是在 Service Fabric 应用程序外部创建的，则在显示这些选项的同时，还会提供少量附加代码，用于向 Service Fabric 运行时注册该服务。 本教程中，选择“Web API”。 不过，也可运用相同的思路来构建完整的 Web 应用程序。\r \r     ![选择 ASP.NET 项目类型][vs-new-aspnet-project-dialog]\r \r     创建 Web API 项目后，应用程序中会有两个服务。 随着继续生成应用程序，可采用完全相同的方式添加更多服务。 每个服务都可以单独进行版本控制和升级。\r \r ## <a name=\"run-the-application\"></a>运行应用程序\r 为了感受一下我们的成果，让我们部署新的应用程序并看看 ASP.NET Core Web API 模板提供的默认行为。\r \r 1. 在 Visual Studio 中，按 F5 调试应用。\r 2. 部署完成后，Visual Studio 将启动浏览器并打开 ASP.NET Web API 服务的根路径。 ASP.NET Core Web API 模板不提供根路径的默认行为，因此将在浏览器中看到 404 错误。\r 3. 将 `/api/values` 添加到浏览器中的位置。 这将对 Web API 模板中的 ValuesController 调用 `Get` 方法。 它会返回模板提供的默认响应，即包含两个字符串的 JSON 数组：\r \r     ![从 ASP.NET Core Web API 模板返回的默认值][browser-aspnet-template-values]\r \r     在本教程结束后，本页将显示有状态服务的最新计数器值而非默认字符串。\r \r ## <a name=\"connect-the-services\"></a>连接服务\r 在如何与 Reliable Services 通信方面，Service Fabric 提供十足的弹性。 在单个应用程序中，可能拥有可通过 TCP 访问的服务、可通过 HTTP REST API 访问的其他服务，并且还有其他可通过 Web 套接字访问的服务。 有关可用选项和相关权衡取舍的背景信息，请参阅[与服务通信](service-fabric-connect-and-communicate-with-services.md)。 本教程使用 SDK 中提供的 [Service Fabric Service Remoting](service-fabric-reliable-services-communication-remoting.md)。\r \r 在 Service Remoting 方法（模仿远程过程调用或 RPC）中，定义一个接口以用作服务的公共协定。 然后使用该接口生成代理类，以便与服务交互。\r \r ### <a name=\"create-the-remoting-interface\"></a>创建远程处理接口\r 首先创建接口以充当有状态服务与其他服务之间的协定，在此情况下是 ASP.NET Core Web 项目。 此接口必须由使用它来进行 RPC 调用的所有服务共享，因此我们将在其自身的类库项目中创建。\r \r 1. 在解决方案资源管理器中，右键单击解决方案并选择“**添加**” > “**新建项目**”。\r \r 2. 在左侧导航窗格中选择 **Visual C#** 条目，并选择“**类库**”模板。 确保 .NET Framework 版本已设置为 **4.5.2**。\r \r     ![为有状态服务创建接口项目][vs-add-class-library-project]\r \r 3. 安装 **Microsoft.ServiceFabric.Services.Remoting** NuGet 包。 在 NuGet 包管理器中搜索 **Microsoft.ServiceFabric.Services.Remoting**，并为解决方案中所有使用 Services.Remoting 的项目安装它，包括：\r     - 包含服务接口的类库项目\r     - 有状态服务项目\r     - ASP.NET Core Web 服务项目\r \r     ![添加服务 NuGet 包][vs-services-nuget-package]\r \r 4. 在类库中，使用单个方法 `GetCountAsync` 创建接口，并从 `Microsoft.ServiceFabric.Services.Remoting.IService` 扩展接口。 远程接口必须派生自此接口，表明它是 Service Remoting 接口。\r \r     ```c#\r     using Microsoft.ServiceFabric.Services.Remoting;\r     using System.Threading.Tasks;\r \r     ...\r \r     namespace MyStatefulService.Interface\r     {\r         public interface ICounter: IService\r         {\r             Task<long> GetCountAsync();\r         }\r     }\r     ```\r \r ### <a name=\"implement-the-interface-in-your-stateful-service\"></a>在有状态服务中实现接口\r 现在我们已定义了接口，接下来需要在有状态服务中实现该接口。\r \r 1. 在有状态服务中，添加对包含此接口的类库项目的引用。\r \r     ![在有状态服务中添加对类库项目的引用][vs-add-class-library-reference]\r 2. 找到继承自 `StatefulService` 的类（例如 `MyStatefulService`），并扩展它以实现 `ICounter` 接口。\r \r     ```c#\r     using MyStatefulService.Interface;\r \r     ...\r \r     public class MyStatefulService : StatefulService, ICounter\r     {        \r          ...\r     }\r     ```\r 3. 现在实现 `ICounter` 接口中定义的单个方法，即 `GetCountAsync`。\r \r     ```c#\r     public async Task<long> GetCountAsync()\r     {\r         var myDictionary = \r             await this.StateManager.GetOrAddAsync<IReliableDictionary<string, long>>(\"myDictionary\");\r \r         using (var tx = this.StateManager.CreateTransaction())\r         {          \r             var result = await myDictionary.TryGetValueAsync(tx, \"Counter\");\r             return result.HasValue ? result.Value : 0;\r         }\r     }\r     ```\r \r ### <a name=\"expose-the-stateful-service-using-a-service-remoting-listener\"></a>使用服务远程侦听器公开有状态服务\r `ICounter` 接口实现后，最后一步是打开 Service Remoting 信道。 对于有状态服务，Service Fabric 提供了名为 `CreateServiceReplicaListeners`的可重写方法。 通过此方法，可以根据想要为服务启用的通信类型指定一个或多个通信侦听器。\r \r > [!NOTE]\r > 用于打开无状态服务的通信通道的等效方法名为 `CreateServiceInstanceListeners`。\r \r 在本例中，我们将替换现有的 `CreateServiceReplicaListeners` 方法，并提供 `ServiceRemotingListener` 的实例，该实例通过 `ServiceProxy` 创建可从客户端调用的 RPC 终结点。  \r \r 通过 `IService` 接口上的 `CreateServiceRemotingListener` 扩展方法，可以创建具有所有默认设置的 `ServiceRemotingListener`。 若要使用此扩展方法，确保导入了 `Microsoft.ServiceFabric.Services.Remoting.Runtime` 命名空间。 \r \r ```c#\r using Microsoft.ServiceFabric.Services.Remoting.Runtime;\r \r ...\r \r protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()\r {\r     return new List<ServiceReplicaListener>()\r     {\r         new ServiceReplicaListener(\r             (context) =>\r                 this.CreateServiceRemotingListener(context))\r     };\r }\r ```\r \r ### <a name=\"use-the-serviceproxy-class-to-interact-with-the-service\"></a>使用 ServiceProxy 类来与服务交互\r 现在，有状态服务已准备好通过 RPC 接收来自其他服务的流量。 因此，剩下的操作便是从 ASP.NET Web 服务添加代码来与其通信。\r \r 1. 在 ASP.NET 项目中，添加对包含 `ICounter` 接口的类库的引用。\r \r 2. 前面已将 **Microsoft.ServiceFabric.Services.Remoting** NuGet 包添加到 ASP.NET 项目。 此包提供用于对有状态服务进行 RPC 调用的 `ServiceProxy` 类。 请确保 ASP.NET Core Web 服务项目中已安装有此 NuGet 包。\r \r 3. 在 **Controllers** 文件夹中，打开 `ValuesController` 类。 请注意，`Get` 方法目前只返回“value1”和“value2”的硬编码字符串数组，这符合前面在浏览器中看到的内容。 使用以下代码替换此实现：\r    \r     ```c#\r     using MyStatefulService.Interface;\r     using Microsoft.ServiceFabric.Services.Client;\r     using Microsoft.ServiceFabric.Services.Remoting.Client;\r \r     ...\r \r     [HttpGet]\r     public async Task<IEnumerable<string>> Get()\r     {\r         ICounter counter =\r             ServiceProxy.Create<ICounter>(new Uri(\"fabric:/MyApplication/MyStatefulService\"), new ServicePartitionKey(0));\r \r         long count = await counter.GetCountAsync();\r \r         return new string[] { count.ToString() };\r     }\r     ```\r \r     第一行代码是关键代码。 若要创建有状态服务的 ICounter Proxy，必须提供两项信息：分区 ID 和服务名称。\r \r     可以使用分区根据定义的键（例如客户 ID 或邮政编码）将有状态服务的状态划分为不同的桶，以此调整有状态服务。 在我们的简单应用程序中，有状态服务只有一个分区，所以键并不重要。 提供的任何键将导致分区相同。 若要深入了解分区服务，请参阅[如何为 Service Fabric Reliable Services 分区](service-fabric-concepts-partitioning.md)。\r \r     服务名称是 fabric:/&lt;application_name&gt;/&lt;service_name&gt; 格式的 URI。\r \r     使用这两项信息，Service Fabric 可唯一标识请求应发送到的计算机。 `ServiceProxy` 类还能顺利处理托管有状态服务分区的计算机发生故障的情况，另一台计算机必须进行升级才能取而代之。 这种抽象使得编写客户端代码来处理其他服务变得简单许多。\r \r     拥有代理后，我们只需调用 `GetCountAsync` 方法并返回其结果。\r \r 4. 再次按 F5 运行修改后的应用程序。 像前面一样，Visual Studio 将自动启动浏览器并打开 Web 项目的根路径。 添加“api/values”路径，应会看到返回的当前计数器值。\r \r     ![浏览器中显示的有状态计数器值][browser-aspnet-counter-value]\r \r     定期刷新浏览器，以查看计数器更新值。\r \r ## <a name=\"connecting-to-a-reliable-actor-service\"></a>连接到 Reliable Actors 服务\r 本教程着重介绍添加与有状态服务通信的 Web 前端。 但是可以遵循十分类似的模型来与执行组件交流。 创建 Reliable Actor 项目时，Visual Studio 自动生成接口项目。 可以使用该接口在 Web 项目中生成执行组件代理来与执行组件通信。 系统自动提供通信通道。 因此，无需像本教程中所述的处理有状态服务一样创建 `ServiceRemotingListener`。\r \r ## <a name=\"how-web-services-work-on-your-local-cluster\"></a>Web 服务在本地群集上的工作方式\r 一般而言，可以将完全相同的 Service Fabric 应用程序部署到多计算机群集，该群集在本地群集上部署，并且可以确信它能按预期运行。 这是因为，本地群集只是折叠成单个计算机的五节点配置。\r \r 但是，提到 Web 服务，有一个重要的微妙之处。 当群集位于负载均衡器后面时，如同在 Azure 中一样，必须确保 Web 服务已部署到每台计算机上，因为负载均衡器只将流量循环分配到各台计算机。 可以通过将服务的 `InstanceCount` 设置为特殊值“-1”来达到此目的。\r \r 相比之下，在本地运行 Web 服务时，必须确保服务只有一个实例正在运行。 否则，正在同一路径和端口上侦听的多个进程将发生冲突。 因此，本地部署的 Web 服务实例计数应设置为“1”。\r \r 若要了解如何针对不同环境配置不同的值，请参阅[管理多个环境的应用程序参数](service-fabric-manage-multiple-environment-app-configuration.md)。\r \r ## <a name=\"next-steps\"></a>后续步骤\r 现在，已使用 ASP.NET Core 为应用程序设置 Web 前端，详细了解 [Service Fabric Reliable Services 中的 ASP.NET Core](service-fabric-reliable-services-communication-aspnetcore.md)，以便深入了解 ASP.NET Core 如何与 Service Fabric 一起工作。\r \r 接下来，通常[详细了解如何与服务通信](service-fabric-connect-and-communicate-with-services.md)可全面了解 Service Fabric 中服务通信的工作原理。\r \r 很好地了解服务通信的工作原理后，请[在 Azure 中创建群集并将应用程序部署到云](service-fabric-cluster-creation-via-portal.md)。\r \r <!-- Image References -->\r \r [vs-add-new-service]: ./media/service-fabric-add-a-web-frontend/vs-add-new-service.png\r [vs-new-service-dialog]: ./media/service-fabric-add-a-web-frontend/vs-new-service-dialog.png\r [vs-new-aspnet-project-dialog]: ./media/service-fabric-add-a-web-frontend/vs-new-aspnet-project-dialog.png\r [browser-aspnet-template-values]: ./media/service-fabric-add-a-web-frontend/browser-aspnet-template-values.png\r [vs-add-class-library-project]: ./media/service-fabric-add-a-web-frontend/vs-add-class-library-project.png\r [vs-add-class-library-reference]: ./media/service-fabric-add-a-web-frontend/vs-add-class-library-reference.png\r [vs-services-nuget-package]: ./media/service-fabric-add-a-web-frontend/vs-services-nuget-package.png\r [browser-aspnet-counter-value]: ./media/service-fabric-add-a-web-frontend/browser-aspnet-counter-value.png\r [vs-create-platform]: ./media/service-fabric-add-a-web-frontend/vs-create-platform.png\r \r \r <!-- external links -->\r [dotnetcore-install]: https://www.microsoft.com/net/core#windows\r \r <!-- Update_Description: update meta properties, wording update -->"}