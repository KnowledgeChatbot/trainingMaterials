{"Title":"Azure Cosmos DB 中的分区和缩放","Description":"了解分区在 Azure Cosmos DB 中的工作原理，分区和分区键的配置方式以及应用程序分区键的选取方法。","Content":"# <a name=\"partitioning-in-azure-cosmos-db-using-the-documentdb-api\"></a>使用 DocumentDB API 在 Azure Cosmos DB 中分区\r \r [Azure Cosmos DB](../cosmos-db/introduction.md) 是一个全局分布式多模型数据库服务，旨在帮助实现快速、可预测的性能并且随着应用程序的增长无缝扩展。 \r \r 本文概述如何使用 DocumentDB API 处理对 Cosmos DB 容器的分区。 请参阅[分区和水平缩放](../cosmos-db/partition-data.md)，大致了解使用任何 Azure Cosmos DB API 进行分区的概念和最佳做法。 \r \r 若要开始使用代码，请从 [Github](https://github.com/Azure/azure-documentdb-dotnet/tree/a2d61ddb53f8ab2a23d3ce323c77afcf5a608f52/samples/documentdb-benchmark) 下载项目。 \r \r 阅读本文后，你能够回答以下问题：   \r \r * Azure Cosmos DB 中的分区原理是什么？\r * 如何配置 Azure Cosmos DB 中的分区\r * 什么是分区键，以及如何为应用程序选取适当的分区键？\r \r 若要开始使用代码，请从 [Azure Cosmos DB 性能测试驱动程序示例](https://github.com/Azure/azure-documentdb-dotnet/tree/a2d61ddb53f8ab2a23d3ce323c77afcf5a608f52/samples/documentdb-benchmark)下载项目。 \r \r <!-- placeholder until we have a permanent solution-->\r <a name=\"partition-keys\"></a>\r <a name=\"single-partition-and-partitioned-collections\"></a>\r <a name=\"migrating-from-single-partition\"></a>\r \r ## <a name=\"partition-keys\"></a>分区键\r \r 在 DocumentDB API 中，可以通过 JSON 路径形式指定分区键定义。 下表显示分区键定义以及与每个定义相对应的值的示例。 分区键指定为路径，例如，`/department` 表示物业部门。 \r \r <table border=\"0\" cellspacing=\"0\" cellpadding=\"0\">\r     <tbody>\r         <tr>\r             <td valign=\"top\"><p>分区键<strong></strong></p></td>\r             <td valign=\"top\"><p><strong>说明</strong></p></td>\r         </tr>\r         <tr>\r             <td valign=\"top\"><p>/department</p></td>\r             <td valign=\"top\"><p>对应于 doc.department 的值，其中 doc 指的是项。</p></td>\r         </tr>\r         <tr>\r             <td valign=\"top\"><p>/properties/name</p></td>\r             <td valign=\"top\"><p>对应于 doc.properties.name 的值，其中 doc 指的是项（嵌套属性）。</p></td>\r         </tr>\r         <tr>\r             <td valign=\"top\"><p>/id</p></td>\r             <td valign=\"top\"><p>对应于 doc.id 的值（ID 和分区键是相同属性）。</p></td>\r         </tr>\r         <tr>\r             <td valign=\"top\"><p>/\"department name\"</p></td>\r             <td valign=\"top\"><p>对应于 doc[\"部门名称\"] 的值，其中 doc 指的是项。</p></td>\r         </tr>\r     </tbody>\r </table>\r \r > [!NOTE]\r > 分区键的语法类似于索引策略路径的路径规范，关键差别在于路径对应于属性而不是值，即末尾没有通配符。 例如，会指定 /department /? 以在部门下为值编制索引，但指定 /department 作为分区键定义。 分区键以隐式的方式进行索引编制，而且不能使用索引策略覆盖从索引中排除它。\r > \r > \r \r 让我们看看所选的分区键如何影响应用程序的性能。\r \r ## <a name=\"working-with-the-azure-cosmos-db-sdks\"></a>使用 Azure Cosmos DB SDK\r Azure Cosmos DB 通过 [REST API 版本 2015-12-16](https://docs.microsoft.com/rest/api/documentdb/) 增加了对自动分区的支持。 为了创建已分区容器，必须在支持的 SDK 平台（.NET、Node.js、Java、Python、MongoDB）之一下载 SDK 1.6.0 或更高版本。 \r \r ### <a name=\"creating-containers\"></a>创建容器\r 下面的示例演示的 .NET 代码片段用于创建容器，以存储吞吐量为 20,000 个请求单位/秒的设备遥测数据。 SDK 将设置 OfferThroughput 值（从而设置 REST API 中的 `x-ms-offer-throughput` 请求标头）。 这里，我们将 `/deviceId` 设为分区键。 所选分区键随容器元数据（如名称和索引策略）的其余部分一起保存。\r \r 对于此示例，我们选取了 `deviceId`，因为我们知道：(a) 由于存在大量的设备，写入可以跨分区均匀地分步并且我们可以扩展数据库以引入海量数据，(b) 许多请求（如提取设备最近读取内容）仅限于单个 deviceId，并且可以从单个分区进行检索。\r \r ```csharp\r DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);\r await client.CreateDatabaseAsync(new Database { Id = \"db\" });\r \r // Container for device telemetry. Here the property deviceId will be used as the partition key to \r // spread across partitions. Configured for 10K RU/s throughput and an indexing policy that supports \r // sorting against any number or string property.\r DocumentCollection myCollection = new DocumentCollection();\r myCollection.Id = \"coll\";\r myCollection.PartitionKey.Paths.Add(\"/deviceId\");\r \r await client.CreateDocumentCollectionAsync(\r     UriFactory.CreateDatabaseUri(\"db\"),\r     myCollection,\r     new RequestOptions { OfferThroughput = 20000 });\r ```\r \r 此方法可对 Cosmos DB 进行 REST API 调用，且该服务基于所请求的吞吐量预配分区数。 随着性能需求的变化，可以更改容器的吞吐量。 \r \r ### <a name=\"reading-and-writing-items\"></a>读取和写入项\r 现在，请将数据插入 Cosmos DB。 以下示例类包含设备读取和对 CreateDocumentAsync 的调用，目的是将新设备读数插入到容器中。 这是一个利用 DocumentDB API 的示例：\r \r ```csharp\r public class DeviceReading\r {\r     [JsonProperty(\"id\")]\r     public string Id;\r \r     [JsonProperty(\"deviceId\")]\r     public string DeviceId;\r \r     [JsonConverter(typeof(IsoDateTimeConverter))]\r     [JsonProperty(\"readingTime\")]\r     public DateTime ReadingTime;\r \r     [JsonProperty(\"metricType\")]\r     public string MetricType;\r \r     [JsonProperty(\"unit\")]\r     public string Unit;\r \r     [JsonProperty(\"metricValue\")]\r     public double MetricValue;\r   }\r \r // Create a document. Here the partition key is extracted as \"XMS-0001\" based on the collection definition\r await client.CreateDocumentAsync(\r     UriFactory.CreateDocumentCollectionUri(\"db\", \"coll\"),\r     new DeviceReading\r     {\r         Id = \"XMS-001-FE24C\",\r         DeviceId = \"XMS-0001\",\r         MetricType = \"Temperature\",\r         MetricValue = 105.00,\r         Unit = \"Fahrenheit\",\r         ReadingTime = DateTime.UtcNow\r     });\r ```\r \r 请按分区键和 ID 读取项，对其进行更新，最后通过分区键和 ID 将其删除。请注意，读取包括 PartitionKey 值（对应 REST API 中的 `x-ms-documentdb-partitionkey` 请求标头）。\r \r ```csharp\r // Read document. Needs the partition key and the ID to be specified\r Document result = await client.ReadDocumentAsync(\r   UriFactory.CreateDocumentUri(\"db\", \"coll\", \"XMS-001-FE24C\"), \r   new RequestOptions { PartitionKey = new PartitionKey(\"XMS-0001\") });\r \r DeviceReading reading = (DeviceReading)(dynamic)result;\r \r // Update the document. Partition key is not required, again extracted from the document\r reading.MetricValue = 104;\r reading.ReadingTime = DateTime.UtcNow;\r \r await client.ReplaceDocumentAsync(\r   UriFactory.CreateDocumentUri(\"db\", \"coll\", \"XMS-001-FE24C\"), \r   reading);\r \r // Delete document. Needs partition key\r await client.DeleteDocumentAsync(\r   UriFactory.CreateDocumentUri(\"db\", \"coll\", \"XMS-001-FE24C\"), \r   new RequestOptions { PartitionKey = new PartitionKey(\"XMS-0001\") });\r ```\r \r ### <a name=\"querying-partitioned-containers\"></a>查询已分区容器\r 在已分区容器中查询数据时，Cosmos DB 会自动将查询路由到筛选器（如果有）中所指定分区键值对应的分区。 例如，此查询将只路由到包含分区键“XMS-0001”的分区。\r \r ```csharp\r // Query using partition key\r IQueryable<DeviceReading> query = client.CreateDocumentQuery<DeviceReading>(\r     UriFactory.CreateDocumentCollectionUri(\"db\", \"coll\"))\r     .Where(m => m.MetricType == \"Temperature\" && m.DeviceId == \"XMS-0001\");\r ```\r \r 下面的查询在分区键 (DeviceId) 上没有筛选器，并且以扇形展开到针对分区索引执行该查询的所有分区。 请注意，必须指定 EnableCrossPartitionQuery（REST API 中的 `x-ms-documentdb-query-enablecrosspartition`）以使 SDK 跨分区执行查询。\r \r ```csharp\r // Query across partition keys\r IQueryable<DeviceReading> crossPartitionQuery = client.CreateDocumentQuery<DeviceReading>(\r     UriFactory.CreateDocumentCollectionUri(\"db\", \"coll\"), \r     new FeedOptions { EnableCrossPartitionQuery = true })\r     .Where(m => m.MetricType == \"Temperature\" && m.MetricValue > 100);\r ```\r \r 从 SDK 1.12.0 及更高版本开始，Cosmos DB 支持使用 SQL 对已分区的容器执行[聚合函数](documentdb-sql-query.md#Aggregates) `COUNT`、`MIN`、`MAX`、`SUM` 和 `AVG`。 查询必须包括单个聚合运算符，并且必须在投影中包括单个值。\r \r ### <a name=\"parallel-query-execution\"></a>并行查询执行\r Cosmos DB SDK 1.9.0 及更高版本支持并行查询执行选项，这些选项可用于对已分区集合执行低延迟查询，即使在这些查询需要处理大量分区时，也是如此。 例如，以下查询配置为跨分区并行运行。\r \r ```csharp\r // Cross-partition Order By Queries\r IQueryable<DeviceReading> crossPartitionQuery = client.CreateDocumentQuery<DeviceReading>(\r     UriFactory.CreateDocumentCollectionUri(\"db\", \"coll\"), \r     new FeedOptions { EnableCrossPartitionQuery = true, MaxDegreeOfParallelism = 10, MaxBufferedItemCount = 100})\r     .Where(m => m.MetricType == \"Temperature\" && m.MetricValue > 100)\r     .OrderBy(m => m.MetricValue);\r ```\r \r 可以通过调整以下参数来管理并行查询执行：\r \r * 通过设置 `MaxDegreeOfParallelism`，可以控制并行度，即，与容器的分区同时进行的网络连接的最大数量。 如果将此参数设置为 -1，则由 SDK 管理并行度。 如果 `MaxDegreeOfParallelism` 未指定或设置为 0（默认值），则与容器的分区的网络连接只有一个。\r * 通过设置 `MaxBufferedItemCount`，可以权衡查询延迟和客户端内存使用率。 如果省略此参数或将此参数设置为 -1，则由 SDK 管理并行查询执行过程中缓冲的项目数。\r \r 如果给定相同状态的集合，并行查询会以与串行执行相同的顺序返回结果。 执行包含排序（ORDER BY 和/或 TOP）的跨分区查询时，Azure Cosmos DB SDK 跨分区发出并行查询，并合并客户端中的部分排序结果，以生成全局范围内有序的结果。\r \r ### <a name=\"executing-stored-procedures\"></a>执行存储过程\r 还可以对具有相同设备 ID 的文档执行原子事务，例如，如果要在单个项中维护聚合或设备的最新状态，则可以执行该操作。 \r \r ```csharp\r await client.ExecuteStoredProcedureAsync<DeviceReading>(\r     UriFactory.CreateStoredProcedureUri(\"db\", \"coll\", \"SetLatestStateAcrossReadings\"),\r     new RequestOptions { PartitionKey = new PartitionKey(\"XMS-001\") }, \r     \"XMS-001-FE24C\");\r ```\r \r 在下一部分，介绍如何从单分区容器移动到已分区容器。\r \r ## <a name=\"next-steps\"></a>后续步骤\r 本文概述了如何使用 DocumentDB API 对 Azure Cosmos DB 容器进行分区。 有关使用任何 Azure Cosmos DB API 进行分区的概念和最佳做法概述，另请参阅[分区和水平缩放](../cosmos-db/partition-data.md)。 \r \r * 使用 Azure Cosmos DB 执行规模和性能测试。 有关示例，请参阅[执行 Azure Cosmos DB 缩放和性能测试](performance-testing.md)。\r * 使用 [SDK](documentdb-sdk-dotnet.md) 或 [REST API](https://docs.microsoft.com/rest/api/documentdb/) 的编码入门\r * 了解 [Azure Cosmos DB 中的预配吞吐量](request-units.md)\r \r <!--Update_Description: update meta properties, wording update-->"}