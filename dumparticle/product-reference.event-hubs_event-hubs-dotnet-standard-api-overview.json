{"Title":"Azure 事件中心 .NET Standard API 概述","Description":".NET Standard API 概述","Content":"# <a name=\"event-hubs-net-standard-api-overview\"></a>事件中心 .NET Standard API 概述\r 本文汇总了一些重要的事件中心 .NET Standard 客户端 API。 目前，有两个 .NET Standard 客户端库：\r * [Microsoft.Azure.EventHubs](https://docs.microsoft.com/dotnet/api/microsoft.azure.eventhubs)\r   *  此库提供所有基本运行时操作。\r * [Microsoft.Azure.EventHubs.Processor](https://docs.microsoft.com/dotnet/api/microsoft.azure.eventhubs.processor)\r   * 此库添加了一项附加功能，该功能可用于跟踪已处理的事件，是从事件中心读取事件的最简单方法。\r \r ## <a name=\"event-hubs-client\"></a>事件中心客户端\r [EventHubClient](https://docs.microsoft.com/dotnet/api/microsoft.azure.eventhubs.eventhubclient) 是发送事件、创建接收器，以及获取运行时信息时使用的主对象。 此客户端链接到特定事件中心，并创建与事件中心终结点的新连接。\r \r ### <a name=\"create-an-event-hubs-client\"></a>创建事件中心客户端\r [EventHubClient](https://docs.microsoft.com/dotnet/api/microsoft.azure.eventhubs.eventhubclient) 对象从连接字符串创建。 以下示例演示实例化新客户端的最简单方法：\r \r ```csharp\r var eventHubClient = EventHubClient.CreateFromConnectionString(\"{Event Hubs connection string}\");\r ```\r \r 若要以编程方式编辑连接字符串，可以使用 [EventHubsConnectionStringBuilder](https://docs.microsoft.com/dotnet/api/microsoft.azure.eventhubs.eventhubsconnectionstringbuilder) 类，并将连接字符串作为参数传递给 [EventHubClient.CreateFromConnectionString](https://docs.microsoft.com/dotnet/api/microsoft.azure.eventhubs.eventhubclient#Microsoft_Azure_EventHubs_EventHubClient_CreateFromConnectionString_System_String_)。\r \r ```csharp\r var connectionStringBuilder = new EventHubsConnectionStringBuilder(\"{Event Hubs connection string}\")\r {\r     EntityPath = EhEntityPath\r };\r \r var eventHubClient = EventHubClient.CreateFromConnectionString(connectionStringBuilder.ToString());\r ```\r \r ### <a name=\"send-events\"></a>发送事件\r 若要将事件发送到事件中心，请使用 [EventData](https://docs.microsoft.com/dotnet/api/microsoft.azure.eventhubs.eventdata) 类。 主体必须是 `byte` 数组，或 `byte` 数组段。\r \r ```csharp\r // Create a new EventData object by encoding a string as a byte array\r var data = new EventData(Encoding.UTF8.GetBytes(\"This is my message...\"));\r // Set user properties if needed\r data.Properties.Add(\"Type\", \"Informational\");\r // Send single message async\r await eventHubClient.SendAsync(data);\r ```\r \r ### <a name=\"receive-events\"></a>接收事件\r 从事件中心接收事件的建议方法是使用 [Event Processor Host](#event-processor-host-apis)，它提供相关功能来自动跟踪偏移量和分区信息。 但是，在某些情况下，可能需要利用核心事件中心库的灵活性来接收事件。\r \r #### <a name=\"create-a-receiver\"></a>创建接收器\r 接收器将绑定到特定分区，因此为了接收事件中心内的所有事件，将需要创建多个实例。 一般来说，好的做法是以编程方式获取分区信息，而不是对分区 ID 进行硬编码。 为此，可以使用 [GetRuntimeInformationAsync](https://docs.microsoft.com/dotnet/api/microsoft.azure.eventhubs.eventhubclient#Microsoft_Azure_EventHubs_EventHubClient_GetRuntimeInformationAsync) 方法。\r \r ```csharp\r // Create a list to keep track of the receivers\r var receivers = new List<PartitionReceiver>();\r // Use the eventHubClient created above to get the runtime information\r var runTimeInformation = await eventHubClient.GetRuntimeInformationAsync();\r // Loop over the resulting partition ids\r foreach (var partitionId in runTimeInformation.PartitionIds)\r {\r     // Create the receiver\r     var receiver = eventHubClient.CreateReceiver(PartitionReceiver.DefaultConsumerGroupName, partitionId, PartitionReceiver.EndOfStream);\r     // Add the receiver to the list\r     receivers.Add(receiver);\r }\r ```\r \r 由于事件永远不会从事件中心删除（而只会过期），因此需要指定正确的起始点。 以下示例介绍可能的组合。\r \r ```csharp\r // partitionId is assumed to come from GetRuntimeInformationAsync()\r \r // Using the constant PartitionReceiver.EndOfStream only receives all messages from this point forward.\r var receiver = eventHubClient.CreateReceiver(PartitionReceiver.DefaultConsumerGroupName, partitionId, PartitionReceiver.EndOfStream);\r \r // All messages available\r var receiver = eventHubClient.CreateReceiver(PartitionReceiver.DefaultConsumerGroupName, partitionId, \"-1\");\r \r // From one day ago\r var receiver = eventHubClient.CreateReceiver(PartitionReceiver.DefaultConsumerGroupName, partitionId, DateTime.Now.AddDays(-1));\r ```\r \r #### <a name=\"consume-an-event\"></a>使用事件\r ```csharp\r // Receive a maximum of 100 messages in this call to ReceiveAsync\r var ehEvents = await receiver.ReceiveAsync(100);\r // ReceiveAsync can return null if there are no messages\r if (ehEvents != null)\r {\r     // Since ReceiveAsync can return more than a single event you will need a loop to process\r     foreach (var ehEvent in ehEvents)\r     {\r         // Decode the byte array segment\r         var message = UnicodeEncoding.UTF8.GetString(ehEvent.Body.Array);\r         // Load the custom property that we set in the send example\r         var customType = ehEvent.Properties[\"Type\"];\r         // Implement processing logic here\r     }\r }       \r ```\r \r ## <a name=\"event-processor-host-apis\"></a>事件处理程序主机 API\r 这些 API 通过在可用工作进程之间分布分区，为可能变为不可用的工作进程提供复原能力。\r \r ```csharp\r // Checkpointing is done within the SimpleEventProcessor and on a per-consumerGroup per-partition basis, workers resume from where they last left off.\r \r // Read these connection strings from a secure location\r var ehConnectionString = \"{Event Hubs connection string}\";\r var ehEntityPath = \"{event hub path/name}\";\r var storageConnectionString = \"{Storage connection string}\";\r var storageContainerName = \"{Storage account container name}\";\r \r var eventProcessorHost = new EventProcessorHost(\r     ehEntityPath,\r     PartitionReceiver.DefaultConsumerGroupName,\r     ehConnectionString,\r     storageConnectionString,\r     storageContainerName);\r \r // Start/register an EventProcessorHost\r await eventProcessorHost.RegisterEventProcessorAsync<SimpleEventProcessor>();\r \r // Disposes of the Event Processor Host\r await eventProcessorHost.UnregisterEventProcessorAsync();\r ```\r \r 以下是 [IEventProcessor](https://docs.microsoft.com/dotnet/api/microsoft.azure.eventhubs.processor.ieventprocessor) 的示例实现。\r \r ```csharp\r public class SimpleEventProcessor : IEventProcessor\r {\r     public Task CloseAsync(PartitionContext context, CloseReason reason)\r     {\r         Console.WriteLine($\"Processor Shutting Down. Partition '{context.PartitionId}', Reason: '{reason}'.\");\r         return Task.CompletedTask;\r     }\r \r     public Task OpenAsync(PartitionContext context)\r     {\r         Console.WriteLine($\"SimpleEventProcessor initialized. Partition: '{context.PartitionId}'\");\r         return Task.CompletedTask;\r     }\r \r     public Task ProcessErrorAsync(PartitionContext context, Exception error)\r     {\r         Console.WriteLine($\"Error on Partition: {context.PartitionId}, Error: {error.Message}\");\r         return Task.CompletedTask;\r     }\r \r     public Task ProcessEventsAsync(PartitionContext context, IEnumerable<EventData> messages)\r     {\r         foreach (var eventData in messages)\r         {\r             var data = Encoding.UTF8.GetString(eventData.Body.Array, eventData.Body.Offset, eventData.Body.Count);\r             Console.WriteLine($\"Message received. Partition: '{context.PartitionId}', Data: '{data}'\");\r         }\r \r         return context.CheckpointAsync();\r     }\r }\r ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r 若要了解有关事件中心方案的详细信息，请访问以下链接：\r \r * [什么是 Azure 事件中心？](event-hubs-what-is-event-hubs.md)\r * [可用的事件中心 API](event-hubs-api-overview.md)\r \r 下面提供了 .NET API 参考：\r \r * [Microsoft.Azure.EventHubs](https://docs.microsoft.com/dotnet/api/microsoft.azure.eventhubs)\r * [Microsoft.Azure.EventHubs.Processor](https://docs.microsoft.com/dotnet/api/microsoft.azure.eventhubs.processor)\r \r <!--Update_Description: update meta properties, wording update-->"}