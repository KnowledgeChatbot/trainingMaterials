{"Title":"SQL 数据仓库中的 Group By 选项","Description":"有关在开发解决方案时实现 Azure SQL 数据仓库中的 Group By 选项的技巧。","Content":"\r # SQL 数据仓库中的 Group By 选项\r [GROUP BY][GROUP BY] 子句可用于将数据聚合成摘要行集。它还具有一些扩展其功能的选项，但这些选项需要经过处理，因为 Azure SQL 数据仓库不直接支持这些选项。\r \r 这些选项包括：\r \r * 带 ROLLUP 的 GROUP BY\r * GROUPING SETS\r * 带 CUBE 的 GROUP BY\r \r ## Rollup 和 grouping sets 选项\r 此处最简单的选项是改为使用 `UNION ALL` 来执行汇总，而不是依赖显式语法。结果应完全相同\r \r 以下是使用 `ROLLUP` 选项的 Group By 语句示例：\r \r ```sql\r SELECT [SalesTerritoryCountry]\r ,      [SalesTerritoryRegion]\r ,      SUM(SalesAmount)             AS TotalSalesAmount\r FROM  dbo.factInternetSales s\r JOIN  dbo.DimSalesTerritory t       ON s.SalesTerritoryKey       = t.SalesTerritoryKey\r GROUP BY ROLLUP (\r                         [SalesTerritoryCountry]\r                 ,       [SalesTerritoryRegion]\r                 )\r ;\r ```\r \r 我们已通过使用 ROLLUP 请求以下聚合：\r \r * 国家/地区和区域\r * 国家/地区\r * 总计\r \r 若要替换此语句，需要使用 `UNION ALL`；显式指定所需的聚合以返回相同的结果：\r \r ```sql\r SELECT [SalesTerritoryCountry]\r ,      [SalesTerritoryRegion]\r ,      SUM(SalesAmount) AS TotalSalesAmount\r FROM  dbo.factInternetSales s\r JOIN  dbo.DimSalesTerritory t     ON s.SalesTerritoryKey       = t.SalesTerritoryKey\r GROUP BY \r        [SalesTerritoryCountry]\r ,      [SalesTerritoryRegion]\r UNION ALL\r SELECT [SalesTerritoryCountry]\r ,      NULL\r ,      SUM(SalesAmount) AS TotalSalesAmount\r FROM  dbo.factInternetSales s\r JOIN  dbo.DimSalesTerritory t     ON s.SalesTerritoryKey       = t.SalesTerritoryKey\r GROUP BY \r        [SalesTerritoryCountry]\r UNION ALL\r SELECT NULL\r ,      NULL\r ,      SUM(SalesAmount) AS TotalSalesAmount\r FROM  dbo.factInternetSales s\r JOIN  dbo.DimSalesTerritory t     ON s.SalesTerritoryKey       = t.SalesTerritoryKey;\r ```\r \r 对于 GROUPING SETS，我们需要采用相同的主体，但只创建想要查看的聚合级别的 UNION ALL 部分\r \r ## Cube 选项\r 可以使用 UNION ALL 方法创建 GROUP BY WITH CUBE。问题在于，代码可能很快就会变得庞大且失控。若要避免此情况，可以使用这种更高级的方法。\r \r 使用上述示例。\r \r 第一步是定义“cube”，它定义我们想要创建的所有聚合级别。请务必记下两个派生表的 CROSS JOIN。这样就会生成所有级别。剩余代码确实可以设置格式。\r \r ```sql\r CREATE TABLE #Cube\r WITH \r (   DISTRIBUTION = ROUND_ROBIN\r ,   LOCATION = USER_DB\r )\r AS\r WITH GrpCube AS\r (SELECT    CAST(ISNULL(Country,'NULL')+','+ISNULL(Region,'NULL') AS NVARCHAR(50)) as 'Cols'\r ,          CAST(ISNULL(Country+',','')+ISNULL(Region,'') AS NVARCHAR(50))  as 'GroupBy'\r ,          ROW_NUMBER() OVER (ORDER BY Country) as 'Seq'\r FROM       ( SELECT 'SalesTerritoryCountry' as Country\r              UNION ALL\r              SELECT NULL\r            ) c\r CROSS JOIN ( SELECT 'SalesTerritoryRegion' as Region\r              UNION ALL\r              SELECT NULL\r            ) r\r )\r SELECT Cols\r ,      CASE WHEN SUBSTRING(GroupBy,LEN(GroupBy),1) = ',' \r             THEN SUBSTRING(GroupBy,1,LEN(GroupBy)-1) \r             ELSE GroupBy \r        END AS GroupBy  --Remove Trailing Comma\r ,Seq\r FROM GrpCube;\r ```\r \r CTAS 的结果如下所示：\r \r ![][1]\r \r 第二步是指定目标表用于存储临时结果：\r \r ```sql\r DECLARE\r  @SQL NVARCHAR(4000)\r ,@Columns NVARCHAR(4000)\r ,@GroupBy NVARCHAR(4000)\r ,@i INT = 1\r ,@nbr INT = 0\r ;\r CREATE TABLE #Results\r (\r  [SalesTerritoryCountry] NVARCHAR(50)\r ,[SalesTerritoryRegion]  NVARCHAR(50)\r ,[TotalSalesAmount]      MONEY\r )\r WITH\r (   DISTRIBUTION = ROUND_ROBIN\r ,   LOCATION = USER_DB\r )\r ;\r ```\r \r 第三步是是循环访问执行聚合的列 cube。查询将为 #Cube 临时表中的每个行运行一次，并将结果存储在 #Results 临时表中\r \r ```sql\r SET @nbr =(SELECT MAX(Seq) FROM #Cube);\r \r WHILE @i<=@nbr\r BEGIN\r     SET @Columns = (SELECT Cols    FROM #Cube where seq = @i);\r     SET @GroupBy = (SELECT GroupBy FROM #Cube where seq = @i);\r \r     SET @SQL ='INSERT INTO #Results\r               SELECT '+@Columns+'\r               ,      SUM(SalesAmount) AS TotalSalesAmount\r               FROM  dbo.factInternetSales s\r               JOIN  dbo.DimSalesTerritory t  \r               ON s.SalesTerritoryKey = t.SalesTerritoryKey\r               '+CASE WHEN @GroupBy <>''\r                      THEN 'GROUP BY '+@GroupBy ELSE '' END\r \r     EXEC sp_executesql @SQL;\r     SET @i +=1;\r END\r ```\r \r 最后，我们只需读取 #Results 临时表即可返回结果\r \r ```sql\r SELECT *\r FROM #Results\r ORDER BY 1,2,3\r ;\r ```\r \r 通过将代码拆分成不同的部分并生成循环构造，代码将更好管理和维护。\r \r ## 后续步骤\r 有关更多开发技巧，请参阅[开发概述][development overview]。\r \r <!--Image references-->\r [1]: ./media/sql-data-warehouse-develop-group-by-options/sql-data-warehouse-develop-group-by-cube.png\r \r <!--Article references-->\r [development overview]: ./sql-data-warehouse-overview-develop.md\r \r <!--MSDN references-->\r [GROUP BY]: https://msdn.microsoft.com/zh-cn/library/ms177673.aspx\r \r <!--Other Web references-->\r \r <!---HONumber=Mooncake_Quality_Review_0104_2017-->"}