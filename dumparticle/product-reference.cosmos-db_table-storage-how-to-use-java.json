{"Title":"如何通过 Java 使用 Azure 表存储","Description":"使用 Azure 表存储（一种 NoSQL 数据存储）将结构化数据存储在云中。","Content":"# <a name=\"how-to-use-azure-table-storage-from-java\"></a>如何通过 Java 使用 Azure 表存储\r [!INCLUDE [storage-selector-table-include](../../includes/storage-selector-table-include.md)]\r [!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]\r \r ## <a name=\"overview\"></a>概述\r 本指南将演示如何使用 Azure 表存储服务执行常见方案。 这些示例用 Java 编写并使用[用于 Java 的 Microsoft Azure 存储 SDK][Microsoft Azure Storage SDK for Java]。 涉及的方案包括创建、列出和删除表，以及在表中插入、查询、修改和删除实体。 有关表的详细信息，请参阅 [后续步骤](#Next-Steps) 部分。\r \r > [!NOTE]\r > SDK 提供给在 Android 设备上使用 Azure 存储的开发人员。 有关详细信息，请参阅[用于 Android 的 Microsoft Azure 存储 SDK][Microsoft Azure Storage SDK for Android]。\r >\r \r [!INCLUDE [storage-table-concepts-include](../../includes/storage-table-concepts-include.md)]\r \r [!INCLUDE [storage-create-account-include](../../includes/storage-create-account-include.md)]\r \r ## <a name=\"create-a-java-application\"></a>创建 Java 应用程序\r 本指南会使用存储功能，这些功能可在本地 Java 应用程序中运行，或在 Azure 的 Web 角色或辅助角色中通过运行的代码来运行。\r \r 为此，需要安装 Java 开发工具包 (JDK)，并在 Azure 订阅中创建一个 Azure 存储帐户。 完成此操作后，需要验证开发系统是否满足最低要求和 GitHub 上的[用于 Java 的 Microsoft Azure 存储 SDK][Microsoft Azure Storage SDK for Java] 存储库中列出的依赖项。 如果系统满足这些要求，可以按照说明下载和安装系统中该存储库的 Azure Storage Libraries for Java。 完成这些任务后，便能够创建一个 Java 应用程序，以使用本文中的示例。\r \r ## <a name=\"configure-your-application-to-access-table-storage\"></a>配置应用程序以访问表存储\r 将下列 import 语句添加到需要在其中使用 Azure 存储 API 访问表的 Java 文件的顶部：\r \r ```java\r // Include the following imports to use table APIs\r import com.microsoft.azure.storage.*;\r import com.microsoft.azure.storage.table.*;\r import com.microsoft.azure.storage.table.TableQuery.*;\r ```\r \r ## <a name=\"set-up-an-azure-storage-connection-string\"></a>设置 Azure 存储连接字符串\r Azure 存储客户端使用存储连接字符串来存储用于访问数据管理服务的终结点和凭据。 在客户端应用程序中运行时，必须提供以下格式的存储连接字符串，并对 AccountName 和 AccountKey 值使用 [Azure 门户](https://portal.azure.cn)中列出的存储帐户的名称和存储帐户的主访问密钥。 此示例演示如何声明一个静态字段以保存连接字符串：\r \r ```java\r // Define the connection-string with your values.\r public static final String storageConnectionString =\r     \"DefaultEndpointsProtocol=http;\" +\r     \"AccountName=your_storage_account;\" +\r     \"AccountKey=your_storage_account_key;\" +\r     \"EndpointSuffix=core.chinacloudapi.cn\";\r ```\r \r 在 Azure 的角色中运行的应用程序中，此字符串可存储在服务配置文件 *ServiceConfiguration.cscfg*中，并可通过调用 **RoleEnvironment.getConfigurationSettings** 方法进行访问。 下面是从服务配置文件中名为 **StorageConnectionString** 的 *Setting* 元素中获取连接字符串的示例：\r \r ```java\r // Retrieve storage account from connection-string.\r String storageConnectionString =\r     RoleEnvironment.getConfigurationSettings().get(\"StorageConnectionString\");\r ```\r \r 下面的示例假定使用了这两个方法之一来获取存储连接字符串。\r \r ## <a name=\"how-to-create-a-table\"></a>如何：创建表\r 利用 **CloudTableClient** 对象，可以获得表和实体的引用对象。 以下代码可创建 CloudTableClient 对象并使用它创建新的 CloudTable 对象，用于表示名为“people”的表。 \r \r > [!NOTE]\r > 还有其他方式来创建 CloudStorageAccount 对象；有关详细信息，请参阅 [Azure 存储客户端 SDK 参考]中的 CloudStorageAccount。\r >\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Create the table if it doesn't exist.\r     String tableName = \"people\";\r     CloudTable cloudTable = tableClient.getTableReference(tableName);\r     cloudTable.createIfNotExists();\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-list-the-tables\"></a>如何：列出表\r 若要获取表的列表，请调用 CloudTableClient.listTables() 方法来检索表名称的迭代列表。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Loop through the collection of table names.\r     for (String table : tableClient.listTables())\r     {\r         // Output each table name.\r         System.out.println(table);\r     }\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-add-an-entity-to-a-table\"></a>如何：向表中添加实体\r 实体映射到 Java 对象，该对象使用可实现 **TableEntity** 的自定义类。 为方便起见，TableServiceEntity 类实现 TableEntity，并使用反射将属性映射到以属性本身命名的 getter 和 setter 方法。 要将实体添加到表，首先要创建用于定义实体的属性的类。 以下代码定义了将客户的名字和姓氏分别用作行键和分区键的实体类。 实体的分区键和行键共同唯一地标识表中的实体。 查询分区键相同的实体的速度可以快于查询分区键不同的实体的速度。\r \r ```java\r public class CustomerEntity extends TableServiceEntity {\r     public CustomerEntity(String lastName, String firstName) {\r         this.partitionKey = lastName;\r         this.rowKey = firstName;\r     }\r \r     public CustomerEntity() { }\r \r     String email;\r     String phoneNumber;\r \r     public String getEmail() {\r         return this.email;\r     }\r \r     public void setEmail(String email) {\r         this.email = email;\r     }\r \r     public String getPhoneNumber() {\r         return this.phoneNumber;\r     }\r \r     public void setPhoneNumber(String phoneNumber) {\r         this.phoneNumber = phoneNumber;\r     }\r }\r ```\r \r 涉及实体的表操作需要 **TableOperation** 对象。 此对象用于定义要对实体执行的操作，该操作可使用 **CloudTable** 对象执行。 以下代码创建了包含要存储的某些客户数据的 **CustomerEntity** 类的新实例。 接下来，该代码调用 TableOperation.insertOrReplace 来创建 TableOperation 对象，以便将实体插入表中，并将新的 CustomerEntity 与之关联。 最后，该代码对 CloudTable 对象调用 execute 方法，并指定“people”表和新的 TableOperation，后者随后向存储服务发送新请求，以便将新客户实体插入“people”表，或在实体已存在的情况下替换实体。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Create a cloud table object for the table.\r     CloudTable cloudTable = tableClient.getTableReference(\"people\");\r \r     // Create a new customer entity.\r     CustomerEntity customer1 = new CustomerEntity(\"Harp\", \"Walter\");\r     customer1.setEmail(\"Walter@contoso.com\");\r     customer1.setPhoneNumber(\"425-555-0101\");\r \r     // Create an operation to add the new customer to the people table.\r     TableOperation insertCustomer1 = TableOperation.insertOrReplace(customer1);\r \r     // Submit the operation to the table service.\r     cloudTable.execute(insertCustomer1);\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-insert-a-batch-of-entities\"></a>如何：插入一批实体\r 可以通过一次写入操作将一批实体插入到表服务。 以下代码创建一个 **TableBatchOperation** 对象，并向其中添加三个插入操作。 每个插入操作的添加方法如下：创建一个新的实体对象，设置它的值，然后对 TableBatchOperation 对象调用 insert 方法，将实体与新插入操作相关联。 然后，该代码对 CloudTable 对象调用 execute，并指定“people”表和 TableBatchOperation 对象，后者会在单个请求中向存储服务发送一批表操作。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Define a batch operation.\r     TableBatchOperation batchOperation = new TableBatchOperation();\r \r     // Create a cloud table object for the table.\r     CloudTable cloudTable = tableClient.getTableReference(\"people\");\r \r     // Create a customer entity to add to the table.\r     CustomerEntity customer = new CustomerEntity(\"Smith\", \"Jeff\");\r     customer.setEmail(\"Jeff@contoso.com\");\r     customer.setPhoneNumber(\"425-555-0104\");\r     batchOperation.insertOrReplace(customer);\r \r     // Create another customer entity to add to the table.\r     CustomerEntity customer2 = new CustomerEntity(\"Smith\", \"Ben\");\r     customer2.setEmail(\"Ben@contoso.com\");\r     customer2.setPhoneNumber(\"425-555-0102\");\r     batchOperation.insertOrReplace(customer2);\r \r     // Create a third customer entity to add to the table.\r     CustomerEntity customer3 = new CustomerEntity(\"Smith\", \"Denise\");\r     customer3.setEmail(\"Denise@contoso.com\");\r     customer3.setPhoneNumber(\"425-555-0103\");\r     batchOperation.insertOrReplace(customer3);\r \r     // Execute the batch of operations on the \"people\" table.\r     cloudTable.execute(batchOperation);\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r 批处理操作的注意事项如下：\r \r * 在单次批处理操作中最多可以执行 100 个插入、删除、合并、替换、插入或合并以及插入或替换操作（可以是这些操作的任意组合）。\r * 批处理操作也可以包含检索操作，但前提是检索操作是批处理中仅有的操作。\r * 单次批处理操作中的所有实体都必须具有相同的分区键。\r * 批处理操作的数据负载限制为 4MB。\r \r ## <a name=\"how-to-retrieve-all-entities-in-a-partition\"></a>如何：检索分区中的所有实体\r 若要从表中查询分区中的实体，可以使用 **TableQuery**。 调用 **TableQuery.from** 可创建一个针对特定表的查询，该查询返回指定的结果类型。 以下代码指定了一个筛选器，用于筛选其中的分区键是“Smith”的实体。 **TableQuery.generateFilterCondition** 是一个用于创建查询筛选器的帮助器方法。 对 TableQuery.from 方法返回的引用调用 where 可对查询应用筛选器。 对 CloudTable 对象调用 execute 来执行查询时，该查询将返回指定了 CustomerEntity 结果类型的 Iterator。 然后，可以利用在 for each 循环中返回的 **Iterator** 来使用结果。 此代码会将查询结果中每个实体的字段打印到控制台。\r \r ```java\r try\r {\r     // Define constants for filters.\r     final String PARTITION_KEY = \"PartitionKey\";\r     final String ROW_KEY = \"RowKey\";\r     final String TIMESTAMP = \"Timestamp\";\r \r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Create a cloud table object for the table.\r     CloudTable cloudTable = tableClient.getTableReference(\"people\");\r \r     // Create a filter condition where the partition key is \"Smith\".\r     String partitionFilter = TableQuery.generateFilterCondition(\r         PARTITION_KEY,\r         QueryComparisons.EQUAL,\r         \"Smith\");\r \r     // Specify a partition query, using \"Smith\" as the partition key filter.\r     TableQuery<CustomerEntity> partitionQuery =\r         TableQuery.from(CustomerEntity.class)\r         .where(partitionFilter);\r \r     // Loop through the results, displaying information about the entity.\r     for (CustomerEntity entity : cloudTable.execute(partitionQuery)) {\r         System.out.println(entity.getPartitionKey() +\r             \" \" + entity.getRowKey() +\r             \"\\t\" + entity.getEmail() +\r             \"\\t\" + entity.getPhoneNumber());\r     }\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-retrieve-a-range-of-entities-in-a-partition\"></a>如何：检索分区中的一部分实体\r 如果不想查询分区中的所有实体，则可以在筛选器中使用比较运算符来指定一个范围。 以下代码组合了两个筛选器，用于获取分区“Smith”中行键（名字）以字母“E”及字母“E”前面的字母开头的所有实体。 然后，该代码打印了查询结果。 如果使用添加到本指南批量插入部分的表的实体，则此次只返回两个实体（Ben 和 Denise Smith），而不会包括 Jeff Smith。\r \r ```java\r try\r {\r     // Define constants for filters.\r     final String PARTITION_KEY = \"PartitionKey\";\r     final String ROW_KEY = \"RowKey\";\r     final String TIMESTAMP = \"Timestamp\";\r \r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Create a cloud table object for the table.\r     CloudTable cloudTable = tableClient.getTableReference(\"people\");\r \r     // Create a filter condition where the partition key is \"Smith\".\r     String partitionFilter = TableQuery.generateFilterCondition(\r         PARTITION_KEY,\r         QueryComparisons.EQUAL,\r         \"Smith\");\r \r     // Create a filter condition where the row key is less than the letter \"E\".\r     String rowFilter = TableQuery.generateFilterCondition(\r         ROW_KEY,\r         QueryComparisons.LESS_THAN,\r         \"E\");\r \r     // Combine the two conditions into a filter expression.\r     String combinedFilter = TableQuery.combineFilters(partitionFilter,\r         Operators.AND, rowFilter);\r \r     // Specify a range query, using \"Smith\" as the partition key,\r     // with the row key being up to the letter \"E\".\r     TableQuery<CustomerEntity> rangeQuery =\r         TableQuery.from(CustomerEntity.class)\r         .where(combinedFilter);\r \r     // Loop through the results, displaying information about the entity\r     for (CustomerEntity entity : cloudTable.execute(rangeQuery)) {\r         System.out.println(entity.getPartitionKey() +\r             \" \" + entity.getRowKey() +\r             \"\\t\" + entity.getEmail() +\r             \"\\t\" + entity.getPhoneNumber());\r     }\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-retrieve-a-single-entity\"></a>如何：检索单个实体\r 可以编写查询以检索单个特定实体。 以下代码使用分区键和行键参数调用 TableOperation.retrieve 来指定客户“Jeff Smith”，而不是创建 TableQuery 并使用筛选器来执行同一操作。 执行的检索操作将只返回一个实体，而不会返回一个集合。 getResultAsType 方法会将结果转换为分配目标的类型 - CustomerEntity 对象。 如果此类型与为查询指定的类型不兼容，则会引发异常。 如果没有实体具有完全匹配的分区键和行键，则会返回 null 值。 在查询中指定分区键和行键是从表服务中检索单个实体的最快方法。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Create a cloud table object for the table.\r     CloudTable cloudTable = tableClient.getTableReference(\"people\");\r \r     // Retrieve the entity with partition key of \"Smith\" and row key of \"Jeff\"\r     TableOperation retrieveSmithJeff =\r         TableOperation.retrieve(\"Smith\", \"Jeff\", CustomerEntity.class);\r \r     // Submit the operation to the table service and get the specific entity.\r     CustomerEntity specificEntity =\r         cloudTable.execute(retrieveSmithJeff).getResultAsType();\r \r     // Output the entity.\r     if (specificEntity != null)\r     {\r         System.out.println(specificEntity.getPartitionKey() +\r             \" \" + specificEntity.getRowKey() +\r             \"\\t\" + specificEntity.getEmail() +\r             \"\\t\" + specificEntity.getPhoneNumber());\r     }\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-modify-an-entity\"></a>如何：修改实体\r 要修改实体，请从表服务中检索它，对实体对象进行更改，然后通过替换或合并操作将更改保存回表服务。 以下代码更改现有客户的电话号码。 此代码将调用 TableOperation.replace，而不是像执行插入时那样调用 TableOperation.insert。 \r             **CloudTable.execute** 方法调用表服务，并替换该实体，除非在此应用程序检索到该实体之后另一个应用程序对它进行了更改。 如果出现这种情况，则会引发异常，必须再次检索、修改并保存该实体。 此乐观并发重试模式在分布式存储系统中很常见。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Create a cloud table object for the table.\r     CloudTable cloudTable = tableClient.getTableReference(\"people\");\r \r     // Retrieve the entity with partition key of \"Smith\" and row key of \"Jeff\".\r     TableOperation retrieveSmithJeff =\r         TableOperation.retrieve(\"Smith\", \"Jeff\", CustomerEntity.class);\r \r     // Submit the operation to the table service and get the specific entity.\r     CustomerEntity specificEntity =\r         cloudTable.execute(retrieveSmithJeff).getResultAsType();\r \r     // Specify a new phone number.\r     specificEntity.setPhoneNumber(\"425-555-0105\");\r \r     // Create an operation to replace the entity.\r     TableOperation replaceEntity = TableOperation.replace(specificEntity);\r \r     // Submit the operation to the table service.\r     cloudTable.execute(replaceEntity);\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-query-a-subset-of-entity-properties\"></a>如何：查询实体属性子集\r 对表的查询可以只检索实体中的少数几个属性。 此方法称为“投影”，可减少带宽并提高查询性能，尤其适用于大型实体。 以下代码中的查询使用 **select** 方法，仅返回表中实体的电子邮件地址。 返回结果在 EntityResolver（用于对从服务器返回的实体执行类型转换）的帮助下投影到 String 集合中。 可以在 [Azure Tables: Introducing Upsert and Query Projection][Azure Tables: Introducing Upsert and Query Projection]（Azure 表：Upsert 和查询投影简介）中更加详细地了解投影。 请注意，本地存储模拟器不支持投影，因此，此代码仅在使用表服务中的帐户时才能运行。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Create a cloud table object for the table.\r     CloudTable cloudTable = tableClient.getTableReference(\"people\");\r \r     // Define a projection query that retrieves only the Email property\r     TableQuery<CustomerEntity> projectionQuery =\r         TableQuery.from(CustomerEntity.class)\r         .select(new String[] {\"Email\"});\r \r     // Define a Entity resolver to project the entity to the Email value.\r     EntityResolver<String> emailResolver = new EntityResolver<String>() {\r         @Override\r         public String resolve(String PartitionKey, String RowKey, Date timeStamp, HashMap<String, EntityProperty> properties, String etag) {\r             return properties.get(\"Email\").getValueAsString();\r         }\r     };\r \r     // Loop through the results, displaying the Email values.\r     for (String projectedString :\r         cloudTable.execute(projectionQuery, emailResolver)) {\r             System.out.println(projectedString);\r     }\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-insert-or-replace-an-entity\"></a>如何：插入或替换实体\r 经常需要将某个实体添加到表中，但又不知道该实体是否已存在于表中。 利用插入或替换操作，可以提出一个以下形式的请求：如果实体不存在，则插入一个实体；如果实体存在，则将其替换为现有实体。 以下代码基于前面的示例针对“Walter Harp”插入或替换实体。 创建新实体后，此代码调用 **TableOperation.insertOrReplace** 方法。 此代码随后使用表和插入或将表操作替换为参数对 CloudTable 对象调用 execute。 若要只更新实体的一部分，则可以改用 **TableOperation.insertOrMerge** 方法。 请注意，本地存储模拟器不支持插入或替换，因此，此代码仅在使用表服务中的帐户时才能运行。 可以在此 [Azure Tables: Introducing Upsert and Query Projection][Azure Tables: Introducing Upsert and Query Projection]（Azure 表：Upsert 和查询投影简介）中更加详细地了插入或替换和插入或合并。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Create a cloud table object for the table.\r     CloudTable cloudTable = tableClient.getTableReference(\"people\");\r \r     // Create a new customer entity.\r     CustomerEntity customer5 = new CustomerEntity(\"Harp\", \"Walter\");\r     customer5.setEmail(\"Walter@contoso.com\");\r     customer5.setPhoneNumber(\"425-555-0106\");\r \r     // Create an operation to add the new customer to the people table.\r     TableOperation insertCustomer5 = TableOperation.insertOrReplace(customer5);\r \r     // Submit the operation to the table service.\r     cloudTable.execute(insertCustomer5);\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-delete-an-entity\"></a>如何：删除实体\r 可以在检索到实体后轻松将其删除。 检索到实体后，对要删除的实体调用 **TableOperation.delete** 。 然后对 CloudTable 对象调用 execute。 以下代码检索并删除一个客户实体。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Create a cloud table object for the table.\r     CloudTable cloudTable = tableClient.getTableReference(\"people\");\r \r     // Create an operation to retrieve the entity with partition key of \"Smith\" and row key of \"Jeff\".\r     TableOperation retrieveSmithJeff = TableOperation.retrieve(\"Smith\", \"Jeff\", CustomerEntity.class);\r \r     // Retrieve the entity with partition key of \"Smith\" and row key of \"Jeff\".\r     CustomerEntity entitySmithJeff =\r         cloudTable.execute(retrieveSmithJeff).getResultAsType();\r \r     // Create an operation to delete the entity.\r     TableOperation deleteSmithJeff = TableOperation.delete(entitySmithJeff);\r \r     // Submit the delete operation to the table service.\r     cloudTable.execute(deleteSmithJeff);\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-delete-a-table\"></a>如何：删除表\r 最后，以下代码从存储帐户中删除一个表。 表在删除之后的一小段时间（通常小于四十秒）内无法重新创建。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the table client.\r     CloudTableClient tableClient = storageAccount.createCloudTableClient();\r \r     // Delete the table and all its data if it exists.\r     CloudTable cloudTable = tableClient.getTableReference(\"people\");\r     cloudTable.deleteIfExists();\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r [!INCLUDE [storage-check-out-samples-java](../../includes/storage-check-out-samples-java.md)]\r \r ## <a name=\"next-steps\"></a>后续步骤\r \r * [Azure 存储资源管理器](../vs-azure-tools-storage-manage-with-storage-explorer.md)是 Microsoft 免费提供的独立应用，适用于在 Windows、macOS 和 Linux 上以可视方式处理 Azure 存储数据。\r * [用于 Java 的 Microsoft Azure 存储 SDK][Microsoft Azure Storage SDK for Java]\r * [Azure 存储客户端 SDK 参考][Azure 存储客户端 SDK 参考]\r * [Azure Storage REST API（Azure 存储 REST API）][Azure Storage REST API]\r * [Azure 存储团队博客][Azure Storage Team Blog]\r \r 有关详细信息，请访问[面向 Java 开发人员的 Azure](https://docs.azure.cn/java/azure)。\r \r [Azure SDK for Java]: /develop/java/\r [Microsoft Azure Storage SDK for Java]: https://github.com/azure/azure-storage-java\r [Microsoft Azure Storage SDK for Android]: https://github.com/azure/azure-storage-android\r [Azure 存储客户端 SDK 参考]: http://azure.github.io/azure-storage-java/\r [Azure Storage REST API]: https://msdn.microsoft.com/library/azure/dd179355.aspx\r [Azure Storage Team Blog]: http://blogs.msdn.com/b/windowsazurestorage/\r [Azure Tables: Introducing Upsert and Query Projection]: http://blogs.msdn.com/b/windowsazurestorage/archive/2011/09/15/windows-azure-tables-introducing-upsert-and-query-projection.aspx\r \r <!-- Update_Description: update meta properties, update link -->"}