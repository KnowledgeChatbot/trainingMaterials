{"Title":"Azure 通知中心 - 使用 .NET 后端通知 iOS 用户","Description":"了解如何向 Azure 中的用户发送推送通知。使用 Objective-C 和 .NET API 为后端编写的代码示例。","Content":"\r #Azure 通知中心 - 使用 .NET 后端通知 iOS 用户\r \r [!INCLUDE [notification-hubs-selector-aspnet-backend-notify-users](../../includes/notification-hubs-selector-aspnet-backend-notify-users.md)]\r \r ##概述\r \r 利用 Azure 中的推送通知支持，你可以访问易于使用且向外扩展的多平台推送基础结构，这大大简化了为移动平台的使用者应用程序和企业应用程序实现推送通知的过程。本教程说明如何使用 Azure 通知中心将推送通知发送到特定设备上的特定应用程序用户。ASP.NET WebAPI 后端用于对客户端进行身份验证并生成通知，如指南主题[从应用后端注册](./notification-hubs-push-notification-registration-management.md#registration-management-from-a-backend)中所述。\r \r > [!NOTE]\r > 本教程假设您已根据[通知中心入门 (iOS)](./notification-hubs-ios-apple-push-notification-apns-get-started.md) 中所述创建并配置了通知中心。此外，只有在学习本教程后，才可以学习[安全推送 (iOS)](./notification-hubs-aspnet-backend-ios-push-apple-apns-secure-notification.md) 教程。\r \r \r [!INCLUDE [notification-hubs-aspnet-backend-notifyusers](../../includes/notification-hubs-aspnet-backend-notifyusers.md)]\r \r ## 修改 iOS 应用\r \r 1. 打开你在[通知中心入门 (iOS)](./notification-hubs-ios-apple-push-notification-apns-get-started.md) 教程中创建的“单页视图”应用。\r \r     > [!NOTE]\r     > 在本节中我们假定你的项目已配置了空的组织名称。如果未配置，你将需要在所有类名前面追加组织名称。\r \r 2. 在 Main.storyboard 中添加对象库中的组件，如下面的屏幕截图中所示。\r \r     ![][1]\r \r     + **用户名**：包含占位符文本“输入用户名”的 UITextField，直接位于发送结果标签的下面并受左边距和右边距约束。\r     + **密码**：包含占位符文本“输入密码”的 UITextField，直接位于用户名文本字段的下面并受左边距和右边距约束。选中属性检查器中“返回密钥”下的“安全文本输入”选项。\r     + **登录**：在密码文本字段的直接下方标记的 UIButton 并取消选中属性检查器中“控件内容”下的“已启用”选项\r     + **WNS**：标签和开关，用于已在中心设置 Windows 通知服务时，启用将通知发送到 Windows 通知服务。请参阅 [Windows 入门](./notification-hubs-windows-store-dotnet-get-started-wns-push-notification.md)教程。\r     + **GCM**：标签和开关，用于已在中心设置 Google Cloud Messaging 时，启用将通知发送到 Google Cloud Messaging。\r     + **APNS**：标签和开关，用于启用将通知发送到 Apple 平台通知服务。\r     + **收件人用户名**：包含占位符文本“收件人用户名标记”的 UITextField，直接位于 GCM 标签的下面并受左边距和右边距约束。\r \r     某些组件已在[通知中心入 (iOS)](./notification-hubs-ios-apple-push-notification-apns-get-started.md) 教程中添加。\r \r 3. 按 **Ctrl** 的同时从视图中的组件拖至 ViewController.h 并添加这些新插座。\r \r     ```\r     @property (weak, nonatomic) IBOutlet UITextField *UsernameField;\r     @property (weak, nonatomic) IBOutlet UITextField *PasswordField;\r     @property (weak, nonatomic) IBOutlet UITextField *RecipientField;\r     @property (weak, nonatomic) IBOutlet UITextField *NotificationField;\r \r     // Used to enable the buttons on the UI\r     @property (weak, nonatomic) IBOutlet UIButton *LogInButton;\r     @property (weak, nonatomic) IBOutlet UIButton *SendNotificationButton;\r \r     // Used to enabled sending notifications across platforms\r     @property (weak, nonatomic) IBOutlet UISwitch *WNSSwitch;\r     @property (weak, nonatomic) IBOutlet UISwitch *GCMSwitch;\r     @property (weak, nonatomic) IBOutlet UISwitch *APNSSwitch;\r \r     - (IBAction)LogInAction:(id)sender;\r     ```\r \r 4. 在 ViewController.h 中，在 import 语句的正下方添加以下 `#define`。将 *< 输入你的后端终结点>* 占位符替换为在上一节中用于部署应用后端的目标 URL。例如，*http://you_backend.chinacloudsites.cn* 。\r \r     ```\r     #define BACKEND_ENDPOINT @\"<Enter Your Backend Endpoint>\"\r     ```\r \r 4. 在你的项目中，创建一个名为 **RegisterClient** 的新 **Cocoa Touch 类**，以便与你创建的 ASP.NET 后端交互。创建继承自 `NSObject` 的类。然后在 RegisterClient.h 中添加以下代码。\r \r     ```\r     @interface RegisterClient : NSObject\r \r     @property (strong, nonatomic) NSString* authenticationHeader;\r \r     -(void) registerWithDeviceToken:(NSData*)token tags:(NSSet*)tags\r         andCompletion:(void(^)(NSError*))completion;\r \r     -(instancetype) initWithEndpoint:(NSString*)Endpoint;\r \r     @end\r     ```\r \r 5. 在 RegisterClient.m 中，更新 `@interface` 节：\r \r     ```\r     @interface RegisterClient ()\r \r     @property (strong, nonatomic) NSURLSession* session;\r     @property (strong, nonatomic) NSURLSession* endpoint;\r \r     -(void) tryToRegisterWithDeviceToken:(NSData*)token tags:(NSSet*)tags retry:(BOOL)retry\r                 andCompletion:(void(^)(NSError*))completion;\r     -(void) retrieveOrRequestRegistrationIdWithDeviceToken:(NSString*)token\r                 completion:(void(^)(NSString*, NSError*))completion;\r     -(void) upsertRegistrationWithRegistrationId:(NSString*)registrationId deviceToken:(NSString*)token\r                 tags:(NSSet*)tags andCompletion:(void(^)(NSURLResponse*, NSError*))completion;\r \r     @end\r     ```\r \r 6. 将 RegisterClient.m 中的 `@implementation` 节替换为以下代码。\r \r     ```\r     @implementation RegisterClient\r \r     // Globals used by RegisterClient\r     NSString *const RegistrationIdLocalStorageKey = @\"RegistrationId\";\r \r     -(instancetype) initWithEndpoint:(NSString*)Endpoint\r     {\r         self = [super init];\r         if (self) {\r             NSURLSessionConfiguration* config = [NSURLSessionConfiguration defaultSessionConfiguration];\r             _session = [NSURLSession sessionWithConfiguration:config delegate:nil delegateQueue:nil];\r             _endpoint = Endpoint;\r         }\r         return self;\r     }\r \r     -(void) registerWithDeviceToken:(NSData*)token tags:(NSSet*)tags\r                 andCompletion:(void(^)(NSError*))completion\r     {\r         [self tryToRegisterWithDeviceToken:token tags:tags retry:YES andCompletion:completion];\r     }\r \r     -(void) tryToRegisterWithDeviceToken:(NSData*)token tags:(NSSet*)tags retry:(BOOL)retry\r                 andCompletion:(void(^)(NSError*))completion\r     {\r         NSSet* tagsSet = tags?tags:[[NSSet alloc] init];\r \r         NSString *deviceTokenString = [[token description]\r             stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@\"<>\"]];\r         deviceTokenString = [[deviceTokenString stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"]\r                                 uppercaseString];\r \r         [self retrieveOrRequestRegistrationIdWithDeviceToken: deviceTokenString\r             completion:^(NSString* registrationId, NSError *error) {\r             NSLog(@\"regId: %@\", registrationId);\r             if (error) {\r                 completion(error);\r                 return;\r             }\r \r             [self upsertRegistrationWithRegistrationId:registrationId deviceToken:deviceTokenString\r                 tags:tagsSet andCompletion:^(NSURLResponse * response, NSError *error) {\r                 if (error) {\r                     completion(error);\r                     return;\r                 }\r \r                 NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*)response;\r                 if (httpResponse.statusCode == 200) {\r                     completion(nil);\r                 } else if (httpResponse.statusCode == 410 && retry) {\r                     [self tryToRegisterWithDeviceToken:token tags:tags retry:NO andCompletion:completion];\r                 } else {\r                     NSLog(@\"Registration error with response status: %ld\", (long)httpResponse.statusCode);\r \r                     completion([NSError errorWithDomain:@\"Registration\" code:httpResponse.statusCode\r                                 userInfo:nil]);\r                 }\r \r             }];\r         }];\r     }\r \r     -(void) upsertRegistrationWithRegistrationId:(NSString*)registrationId deviceToken:(NSData*)token\r                 tags:(NSSet*)tags andCompletion:(void(^)(NSURLResponse*, NSError*))completion\r     {\r         NSDictionary* deviceRegistration = @{@\"Platform\" : @\"apns\", @\"Handle\": token,\r                                                 @\"Tags\": [tags allObjects]};\r         NSData* jsonData = [NSJSONSerialization dataWithJSONObject:deviceRegistration\r                             options:NSJSONWritingPrettyPrinted error:nil];\r \r         NSLog(@\"JSON registration: %@\", [[NSString alloc] initWithData:jsonData\r                                             encoding:NSUTF8StringEncoding]);\r \r         NSString* endpoint = [NSString stringWithFormat:@\"%@/api/register/%@\", _endpoint,\r                                 registrationId];\r         NSURL* requestURL = [NSURL URLWithString:endpoint];\r         NSMutableURLRequest* request = [NSMutableURLRequest requestWithURL:requestURL];\r         [request setHTTPMethod:@\"PUT\"];\r         [request setHTTPBody:jsonData];\r         NSString* authorizationHeaderValue = [NSString stringWithFormat:@\"Basic %@\",\r                                                 self.authenticationHeader];\r         [request setValue:authorizationHeaderValue forHTTPHeaderField:@\"Authorization\"];\r         [request setValue:@\"application/json\" forHTTPHeaderField:@\"Content-Type\"];\r \r         NSURLSessionDataTask* dataTask = [self.session dataTaskWithRequest:request\r             completionHandler:^(NSData *data, NSURLResponse *response, NSError *error)\r         {\r             if (!error)\r             {\r                 completion(response, error);\r             }\r             else\r             {\r                 NSLog(@\"Error request: %@\", error);\r                 completion(nil, error);\r             }\r         }];\r         [dataTask resume];\r     }\r \r     -(void) retrieveOrRequestRegistrationIdWithDeviceToken:(NSString*)token\r                 completion:(void(^)(NSString*, NSError*))completion\r     {\r         NSString* registrationId = [[NSUserDefaults standardUserDefaults]\r                                     objectForKey:RegistrationIdLocalStorageKey];\r \r         if (registrationId)\r         {\r             completion(registrationId, nil);\r             return;\r         }\r \r         // request new one & save\r         NSURL* requestURL = [NSURL URLWithString:[NSString stringWithFormat:@\"%@/api/register?handle=%@\",\r                                 _endpoint, token]];\r         NSMutableURLRequest* request = [NSMutableURLRequest requestWithURL:requestURL];\r         [request setHTTPMethod:@\"POST\"];\r         NSString* authorizationHeaderValue = [NSString stringWithFormat:@\"Basic %@\",\r                                                 self.authenticationHeader];\r         [request setValue:authorizationHeaderValue forHTTPHeaderField:@\"Authorization\"];\r \r         NSURLSessionDataTask* dataTask = [self.session dataTaskWithRequest:request\r             completionHandler:^(NSData *data, NSURLResponse *response, NSError *error)\r         {\r             NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*) response;\r             if (!error && httpResponse.statusCode == 200)\r             {\r                 NSString* registrationId = [[NSString alloc] initWithData:data\r                     encoding:NSUTF8StringEncoding];\r \r                 // remove quotes\r                 registrationId = [registrationId substringWithRange:NSMakeRange(1,\r                                     [registrationId length]-2)];\r \r                 [[NSUserDefaults standardUserDefaults] setObject:registrationId\r                     forKey:RegistrationIdLocalStorageKey];\r                 [[NSUserDefaults standardUserDefaults] synchronize];\r \r                 completion(registrationId, nil);\r             }\r             else\r             {\r                 NSLog(@\"Error status: %ld, request: %@\", (long)httpResponse.statusCode, error);\r                 if (error)\r                     completion(nil, error);\r                 else {\r                     completion(nil, [NSError errorWithDomain:@\"Registration\" code:httpResponse.statusCode\r                                 userInfo:nil]);\r                 }\r             }\r         }];\r         [dataTask resume];\r     }\r \r     @end\r     ```\r \r     上面的代码使用 NSURLSession 对应用后端执行 REST 调用并使用 NSUserDefaults 在本地存储通知中心返回的 registrationId，实现了指南文章[从应用后端注册](./notification-hubs-push-notification-registration-management.md#registration-management-from-a-backend)中所述的逻辑。\r \r     请注意，此类需要设置其属性 **authorizationHeader**，才能正常工作。登录后，由 **ViewController** 类设置此属性。\r \r 7. 在 ViewController.h 中，为 RegisterClient.h 添加 `#import` 语句。然后，在 `@interface` 中添加设备令牌的声明和对 `RegisterClient` 实例的引用：\r \r     ```\r     #import \"RegisterClient.h\"\r \r     @property (strong, nonatomic) NSData* deviceToken;\r     @property (strong, nonatomic) RegisterClient* registerClient;\r     ```\r \r 8. 在 ViewController.m 的 `@interface` 中添加私有方法声明：\r \r     ```\r     @interface ViewController () <UITextFieldDelegate, NSURLConnectionDataDelegate, NSXMLParserDelegate>\r \r     // create the Authorization header to perform Basic authentication with your app back-end\r     -(void) createAndSetAuthenticationHeaderWithUsername:(NSString*)username\r                     AndPassword:(NSString*)password;\r \r     @end\r     ```\r \r     > [!NOTE]\r     > 下面的代码段不是安全的身份验证方案，你应将 **createAndSetAuthenticationHeaderWithUsername:AndPassword:** 的实现替换为你的特定身份验证机制，该机制将生成要供注册客户端类（例如，OAuth、Active Directory）使用的身份验证令牌。\r \r 9. 然后在 ViewController.m 的 `@implementation` 节中添加以下代码，以添加用于设置设备令牌的实现和身份验证标头。\r \r     ```\r     -(void) setDeviceToken: (NSData*) deviceToken\r     {\r         _deviceToken = deviceToken;\r         self.LogInButton.enabled = YES;\r     }\r \r     -(void) createAndSetAuthenticationHeaderWithUsername:(NSString*)username\r                     AndPassword:(NSString*)password;\r     {\r         NSString* headerValue = [NSString stringWithFormat:@\"%@:%@\", username, password];\r \r         NSData* encodedData = [[headerValue dataUsingEncoding:NSUTF8StringEncoding] base64EncodedDataWithOptions:NSDataBase64EncodingEndLineWithCarriageReturn];\r \r         self.registerClient.authenticationHeader = [[NSString alloc] initWithData:encodedData\r                                                     encoding:NSUTF8StringEncoding];\r     }\r \r     -(BOOL)textFieldShouldReturn:(UITextField *)textField\r     {\r         [textField resignFirstResponder];\r         return YES;\r     }\r     ```\r \r     请注意设置设备令牌时如何启用登录按钮。这是因为在登录操作过程中，视图控制器将使用应用后端注册推送通知。因此，我们不希望在正确设置设备令牌前可以访问登录操作。可以只要登录在推送注册之前发生，就将前者与后者解耦。\r \r 10. 在 ViewController.m 中，使用以下代码段实现“登录”按钮的操作方法以及使用 ASP.NET 后端发送通知消息的方法。\r \r     ```\r     - (IBAction)LogInAction:(id)sender {\r         // create authentication header and set it in register client\r         NSString* username = self.UsernameField.text;\r         NSString* password = self.PasswordField.text;\r \r         [self createAndSetAuthenticationHeaderWithUsername:username AndPassword:password];\r \r         __weak ViewController* selfie = self;\r         [self.registerClient registerWithDeviceToken:self.deviceToken tags:nil\r             andCompletion:^(NSError* error) {\r             if (!error) {\r                 dispatch_async(dispatch_get_main_queue(),\r                 ^{\r                     selfie.SendNotificationButton.enabled = YES;\r                     [self MessageBox:@\"Success\" message:@\"Registered successfully!\"];\r                 });\r             }\r         }];\r     }\r \r     - (void)SendNotificationASPNETBackend:(NSString*)pns UsernameTag:(NSString*)usernameTag\r                 Message:(NSString*)message\r     {\r         NSURLSession* session = [NSURLSession\r             sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:nil\r             delegateQueue:nil];\r \r         // Pass the pns and username tag as parameters with the REST URL to the ASP.NET backend\r         NSURL* requestURL = [NSURL URLWithString:[NSString\r             stringWithFormat:@\"%@/api/notifications?pns=%@&to_tag=%@\", BACKEND_ENDPOINT, pns,\r             usernameTag]];\r \r         NSMutableURLRequest* request = [NSMutableURLRequest requestWithURL:requestURL];\r         [request setHTTPMethod:@\"POST\"];\r \r         // Get the mock authenticationheader from the register client\r         NSString* authorizationHeaderValue = [NSString stringWithFormat:@\"Basic %@\",\r             self.registerClient.authenticationHeader];\r         [request setValue:authorizationHeaderValue forHTTPHeaderField:@\"Authorization\"];\r \r         //Add the notification message body\r         [request setValue:@\"application/json;charset=utf-8\" forHTTPHeaderField:@\"Content-Type\"];\r         [request setHTTPBody:[message dataUsingEncoding:NSUTF8StringEncoding]];\r \r         // Execute the send notification REST API on the ASP.NET Backend\r         NSURLSessionDataTask* dataTask = [session dataTaskWithRequest:request\r             completionHandler:^(NSData *data, NSURLResponse *response, NSError *error)\r         {\r             NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*) response;\r             if (error || httpResponse.statusCode != 200)\r             {\r                 NSString* status = [NSString stringWithFormat:@\"Error Status for %@: %d\\nError: %@\\n\",\r                                     pns, httpResponse.statusCode, error];\r                 dispatch_async(dispatch_get_main_queue(),\r                 ^{\r                     // Append text because all 3 PNS calls may also have information to view\r                     [self.sendResults setText:[self.sendResults.text stringByAppendingString:status]];\r                 });\r                 NSLog(status);\r             }\r \r             if (data != NULL)\r             {\r                 xmlParser = [[NSXMLParser alloc] initWithData:data];\r                 [xmlParser setDelegate:self];\r                 [xmlParser parse];\r             }\r         }];\r         [dataTask resume];\r     }\r     ```\r \r 11. 更新“发送通知”按钮的操作以使用 ASP.NET 后端，发送开关启用的任何 PNS。\r \r     ```\r     - (IBAction)SendNotificationMessage:(id)sender\r     {\r         //[self SendNotificationRESTAPI];\r         [self SendToEnabledPlatforms];\r     }\r \r     -(void)SendToEnabledPlatforms\r     {\r         NSString* json = [NSString stringWithFormat:@\"\"%@\"\",self.notificationMessage.text];\r \r         [self.sendResults setText:@\"\"];\r \r         if ([self.WNSSwitch isOn])\r             [self SendNotificationASPNETBackend:@\"wns\" UsernameTag:self.RecipientField.text Message:json];\r \r         if ([self.GCMSwitch isOn])\r             [self SendNotificationASPNETBackend:@\"gcm\" UsernameTag:self.RecipientField.text Message:json];\r \r         if ([self.APNSSwitch isOn])\r             [self SendNotificationASPNETBackend:@\"apns\" UsernameTag:self.RecipientField.text Message:json];\r     }\r     ```\r \r 11. 在函数 **ViewDidLoad** 中，添加以下内容来实例化 RegisterClient 实例并设置文本字段的委托。\r \r     ```\r     self.UsernameField.delegate = self;\r     self.PasswordField.delegate = self;\r     self.RecipientField.delegate = self;\r     self.registerClient = [[RegisterClient alloc] initWithEndpoint:BACKEND_ENDPOINT];\r     ```\r \r 12. 现在，在 **AppDelegate.m** 中，删除方法 **application:didRegisterForPushNotificationWithDeviceToken:** 的所有内容并将其替换为以下内容，以确保视图控制器包含从 APN 中检索到的最新设备令牌：\r \r     ```\r     // Add import to the top of the file\r     #import \"ViewController.h\"\r \r     - (void)application:(UIApplication *)application\r                 didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken\r     {\r         ViewController* rvc = (ViewController*) self.window.rootViewController;\r         rvc.deviceToken = deviceToken;\r     }\r     ```\r \r 13. 最后，在 **AppDelegate.m** 中，确保你使用了以下方法：\r \r     ```\r     - (void)application:(UIApplication *)application didReceiveRemoteNotification: (NSDictionary *)userInfo {\r         NSLog(@\"%@\", userInfo);\r         [self MessageBox:@\"Notification\" message:[[userInfo objectForKey:@\"aps\"] valueForKey:@\"alert\"]];\r     }\r     ```\r \r ## 测试应用程序\r \r 1. 在 XCode 中，在物理 iOS 设备上运行此应用（推送通知将无法在模拟器中正常工作）。\r \r 2. 在 iOS 应用 UI 中，输入用户名和密码。这些信息可以是任意字符串，但必须是相同的字符串值。然后，单击“登录”。\r \r     ![][2]\r \r 3. 你应看到弹出窗口通知你注册成功。单击**“确定”**。\r \r     ![][3]  \r \r 4. 在*“收件人用户名标记”文本字段中，输入用于从另一台设备注册的用户名标记。\r 5. 输入通知消息，然后单击“发送通知”。只有使用该用户名标记注册的设备才会收到通知消息。该消息将只发送给那些用户。\r \r     ![][4]\r \r [1]: ./media/notification-hubs-aspnet-backend-ios-notify-users/notification-hubs-ios-notify-users-interface.png\r [2]: ./media/notification-hubs-aspnet-backend-ios-notify-users/notification-hubs-ios-notify-users-enter-user-pwd.png\r [3]: ./media/notification-hubs-aspnet-backend-ios-notify-users/notification-hubs-ios-notify-users-registered.png\r [4]: ./media/notification-hubs-aspnet-backend-ios-notify-users/notification-hubs-ios-notify-users-enter-msg.png\r \r <!---HONumber=Mooncake_1114_2016-->"}