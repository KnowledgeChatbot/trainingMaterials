{"Title":"使用 Microsoft PlayReady 或 Apple FairPlay 保护 HLS 内容 - Azure","Description":"本主题概括介绍并演示了如何使用 Azure 媒体服务通过 Apple FairPlay 动态加密 HTTP Live Streaming (HLS) 内容。 它还演示了如何使用媒体服务许可证传送服务将 FairPlay 许可证传送到客户端。","Content":"# <a name=\"protect-your-hls-content-with-apple-fairplay-or-microsoft-playready\"></a>使用 Apple FairPlay 或 Microsoft PlayReady 保护 HLS 内容\r 使用 Azure 媒体服务，可使用以下格式动态加密 HTTP Live Streaming (HLS) 内容：  \r \r * **AES-128 信封明文密钥**\r \r     整个区块使用 AES-128 CBC 模式进行加密。 iOS 和 OS X 播放器本身支持解密流。 有关详细信息，请参阅[使用 AES-128 动态加密和密钥传递服务](media-services-protect-with-aes128.md)。\r * **Apple FairPlay**\r \r     各视频和音频示例都使用 AES-128 CBC 模式进行加密。 FairPlay 流式处理 (FPS) 集成到设备操作系统，iOS 和 Apple TV 本身支持这项功能。 OS X 上的 Safari 通过加密媒体扩展 (EME) 接口支持来启用 FPS。\r * **Microsoft PlayReady**\r \r 下图显示了 HLS + FairPlay 或 PlayReady 动态加密工作流。\r \r ![动态加密工作流的图示](./media/media-services-content-protection-overview/media-services-content-protection-with-fairplay.png)\r \r 本主题演示如何使用媒体服务通过 Apple FairPlay 动态加密 HLS 内容。 它还演示了如何使用媒体服务许可证传送服务将 FairPlay 许可证传送到客户端。\r \r > [!NOTE]\r > 如果还想要使用 PlayReady 加密 HLS 内容，则需要创建一个通用的内容密钥并将其与资产相关联。 还需要配置内容密钥的授权策略，如[使用 PlayReady 动态通用加密](media-services-protect-with-drm.md)中所述。\r >\r >\r \r ## <a name=\"requirements-and-considerations\"></a>要求和注意事项\r \r 在使用媒体服务传送通过 FairPlay 加密的 HLS 和传送 FairPlay 许可证时，需要以下各项：\r \r     - 一个 Azure 帐户。 有关详细信息，请参阅 [Azure 试用](https://www.azure.cn/pricing/1rmb-trial/?WT.mc_id=A261C142F)。\r     - 一个媒体服务帐户。若要创建媒体服务帐户，请参阅[使用 Azure 门户创建 Azure 媒体服务帐户](media-services-portal-create-account.md)。\r     - 注册 [Apple 开发计划](https://developer.apple.com/)。\r     - Apple 要求内容所有者获取 [部署包](https://developer.apple.com/contact/fps/)。 说明已使用媒体服务实现密钥安全模块 (KSM)，以及正在请求最终 FPS 包。 最终 FPS 包中有如何生成证书和获取应用程序密钥 (ASK) 的说明。 可使用 ASK 配置 FairPlay。 \r     - Azure 媒体服务 .NET SDK **3.6.0** 版本或更高版本。\r \r 必须在媒体服务密钥传送端上设置以下各项：\r \r   * 应用证书 (AC)：这是一个包含私钥的 .pfx 文件。 创建此文件，并使用密码对其进行加密。\r \r        配置密钥传送策略时，必须提供该密码和 Base64 格式的 .pfx 文件。\r \r       以下步骤介绍如何为 FairPlay 生成 .pfx 证书文件：\r \r     1. 从 https://slproweb.com/products/Win32OpenSSL.html 安装 OpenSSL。\r \r         转到 Apple 提供的 FairPlay 证书和其他文件所在的文件夹。\r     2. 从命令行运行以下命令。 这会将 .cer 文件转换为 .pem 文件。\r \r         \"C:\\OpenSSL-Win32\\bin\\openssl.exe\" x509 -inform der -in fairplay.cer -out fairplay-out.pem\r     3. 从命令行运行以下命令。 这会将 .pem 文件转换为包含私钥的 .pfx 文件。 然后， OpenSSL 会要求提供 .pfx 文件的密码。\r \r         \"C:\\OpenSSL-Win32\\bin\\openssl.exe\" pkcs12 -export -out fairplay-out.pfx -inkey privatekey.pem -in fairplay-out.pem -passin file:privatekey-pem-pass.txt\r   * 应用证书密码：用于创建 .pfx 文件的密码。\r   * 应用证书密码 ID：必须上传密码，其方式与上传其他媒体服务密钥类似。 使用 ContentKeyType.FairPlayPfxPassword 枚举值获取媒体服务 ID。 需要在密钥传送策略选项中使用此 ID。\r   * iv：这是 16 字节的随机值。 该值必须与资产传送策略中的 iv 相匹配。 生成 iv 并将其放入以下两个位置：资产传送策略和密钥传送策略选项。\r   * ASK：使用 Apple 开发人员门户生成证书时会收到此密钥。 每个开发团队会收到唯一的 ASK。 请保存一份 ASK 副本，并将其存储在安全位置。 稍后需要将 ASK 作为 FairPlayAsk 配置到媒体服务。\r   * ASK ID：将 ASK 上传到媒体服务中时，将获取此 ID。 必须使用 ContentKeyType.FairPlayAsk 枚举值上传 ASK。 因此，将返回媒体服务 ID，在设置密钥传送策略选项时应使用此 ID。\r \r 以下事项必须通过 FPS 客户端来设置：\r \r   * 应用证书 (AC)：这是一个包含公钥的 .cer/.der 文件，操作系统使用它来加密某些负载。 媒体服务需要了解它，因为播放器需要它。 密钥传送服务使用相应的私钥对其进行解密。\r \r 若要播放 FairPlay 加密的流，需要先获取实际 ASK，然后生成实际证书。 该过程将创建所有三个部分：\r \r   * .der 文件\r   * .pfx 文件\r   * .pfx 的密码\r \r 以下客户端支持使用 AES-128 CBC 加密的 HLS：OS X 上的 Safari、Apple TV、iOS。\r \r ## <a name=\"configure-fairplay-dynamic-encryption-and-license-delivery-services\"></a>配置 FairPlay 动态加密和许可证传送服务\r 下面是使用 FairPlay 保护资产的常规步骤，这些步骤使用媒体服务许可证传送服务，也使用动态加密。\r \r 1. 创建资产并将文件上传到资产。\r 2. 将包含文件的资产编码为自适应比特率 MP4 集。\r 3. 创建内容密钥并将其与编码资产相关联。  \r 4. 配置内容密钥授权策略。 指定以下项：\r \r    * 传送方法（在本例中为 FairPlay）。\r    * FairPlay 策略选项配置。 有关如何配置 FairPlay 的详细信息，请参阅以下示例中的 ConfigureFairPlayPolicyOptions() 方法。\r \r      > [!NOTE]\r      > 通常，可能只需配置一次 FairPlay 策略选项，因为仅有一套证书和 ASK。\r      >\r      >\r    * 限制（开放或令牌）。\r    * 特定于密钥传送类型的信息，用于定义将密钥传送到客户端的方式。\r 5. 配置资产传送策略。 传送策略配置包括：\r \r    * 传送协议 (HLS)。\r    * 动态加密类型（常用的 CBC 加密）。\r    * 许可证获取 URL。\r \r      > [!NOTE]\r      > 如果要传送使用 FairPlay 和其他数字版权管理 (DRM) 系统加密的流，则必须配置单独的传送策略：\r      >\r      > * 一个 IAssetDeliveryPolicy，用于使用通用加密 (CENC) (PlayReady + Widevine) 和 Smooth with PlayReady 配置 HTTP 上的动态自适应流式处理 (DASH)\r      > * 另一个 IAssetDeliveryPolicy 用来配置 HLS 的 FairPlay\r      >\r      >\r 6. 创建 OnDemand 定位符以获取流式处理 URL。\r \r ## <a name=\"use-fairplay-key-delivery-by-player-apps\"></a>使用播放器应用执行的 FairPlay 密钥传送\r 可以通过使用 iOS SDK 开发播放器应用。 若要能够播放 FairPlay 内容，必须实现许可证交换协议。 此协议不由 Apple 指定。 而是取决于每个应用发送密钥传送请求的方式。 媒体服务 FairPlay 密钥传送服务需要 SPC 为采用以下形式的 www-form-url 编码后消息：\r \r     spc=<Base64 encoded SPC>\r \r > [!NOTE]\r > Azure Media Player 不支持现成的 FairPlay 播放。 若要获得 MAC OS X 上的 FairPlay 播放，需要通过 Apple 开发人员帐户获得示例播放器。\r >\r >\r \r ## <a name=\"streaming-urls\"></a>流 URL\r 如果使用了多个 DRM 加密资产，则应在流式处理 URL 中使用加密标记：（format='m3u8-aapl'， encryption='xxx'）。\r \r 请注意以下事项：\r \r * 仅可指定零个或一个加密类型。\r * 如果资产仅应用了一种加密，则无需在 URL 中指定加密类型。\r * 加密类型不区分大小写。\r * 可以指定以下加密类型：  \r   * cenc：通用加密 (PlayReady)\r   * cbcs-aapl：Fairplay\r   * cbc：AES 信封加密\r \r ## <a name=\"create-and-configure-a-visual-studio-project\"></a>创建和配置 Visual Studio 项目\r \r 1. 设置开发环境，并在 app.config 文件中填充连接信息，如[使用 .NET 进行媒体服务开发](media-services-dotnet-how-to-use.md)中所述。 \r 2. 将以下元素添加到 app.config 文件中定义的 appSettings：\r \r         <add key=\"Issuer\" value=\"http://testacs.com\"/>\r         <add key=\"Audience\" value=\"urn:test\"/>\r \r ## <a name=\"example\"></a>示例\r \r 以下示例演示使用媒体服务传送使用 FairPlay 加密的内容的能力。 适用于 .NET 的 Azure 媒体服务 SDK 版本 3.6.0 中引入了此功能。 \r \r 使用本部分中所示的代码覆盖 Program.cs 文件中的代码。\r \r >[!NOTE]\r >不同 AMS 策略的策略限制为 1,000,000 个（例如，对于定位器策略或 ContentKeyAuthorizationPolicy）。 如果始终使用相同的日期/访问权限，则应使用相同的策略 ID，例如，用于要长期就地保留的定位符的策略（非上传策略）。 有关详细信息，请参阅[此](media-services-dotnet-manage-entities.md#limit-access-policies)主题。\r \r 请务必将变量更新为指向输入文件所在的文件夹。\r \r     using System;\r     using System.Collections.Generic;\r     using System.Configuration;\r     using System.IO;\r     using System.Linq;\r     using System.Threading;\r     using Microsoft.WindowsAzure.MediaServices.Client;\r     using Microsoft.WindowsAzure.MediaServices.Client.ContentKeyAuthorization;\r     using Microsoft.WindowsAzure.MediaServices.Client.DynamicEncryption;\r     using Microsoft.WindowsAzure.MediaServices.Client.FairPlay;\r     using Newtonsoft.Json;\r     using System.Security.Cryptography.X509Certificates;\r \r     namespace DynamicEncryptionWithFairPlay\r     {\r         class Program\r         {\r         // Read values from the App.config file.\r         private static readonly string _AADTenantDomain =\r         ConfigurationManager.AppSettings[\"AADTenantDomain\"];\r         private static readonly string _RESTAPIEndpoint =\r         ConfigurationManager.AppSettings[\"MediaServiceRESTAPIEndpoint\"];\r \r         private static readonly Uri _sampleIssuer =\r             new Uri(ConfigurationManager.AppSettings[\"Issuer\"]);\r         private static readonly Uri _sampleAudience =\r             new Uri(ConfigurationManager.AppSettings[\"Audience\"]);\r \r         // Field for service context.\r         private static CloudMediaContext _context = null;\r \r         private static readonly string _mediaFiles =\r             Path.GetFullPath(@\"../..\\Media\");\r \r         private static readonly string _singleMP4File =\r             Path.Combine(_mediaFiles, @\"BigBuckBunny.mp4\");\r \r         static void Main(string[] args)\r         {\r             var tokenCredentials = new AzureAdTokenCredentials(_AADTenantDomain, AzureEnvironments.AzureChinaCloudEnvironment);\r             var tokenProvider = new AzureAdTokenProvider(tokenCredentials);\r \r             _context = new CloudMediaContext(new Uri(_RESTAPIEndpoint), tokenProvider);\r \r             bool tokenRestriction = false;\r             string tokenTemplateString = null;\r \r             IAsset asset = UploadFileAndCreateAsset(_singleMP4File);\r             Console.WriteLine(\"Uploaded asset: {0}\", asset.Id);\r \r             IAsset encodedAsset = EncodeToAdaptiveBitrateMP4Set(asset);\r             Console.WriteLine(\"Encoded asset: {0}\", encodedAsset.Id);\r \r             IContentKey key = CreateCommonCBCTypeContentKey(encodedAsset);\r             Console.WriteLine(\"Created key {0} for the asset {1} \", key.Id, encodedAsset.Id);\r             Console.WriteLine(\"FairPlay License Key delivery URL: {0}\", key.GetKeyDeliveryUrl(ContentKeyDeliveryType.FairPlay));\r             Console.WriteLine();\r \r             if (tokenRestriction)\r             tokenTemplateString = AddTokenRestrictedAuthorizationPolicy(key);\r             else\r             AddOpenAuthorizationPolicy(key);\r \r             Console.WriteLine(\"Added authorization policy: {0}\", key.AuthorizationPolicyId);\r             Console.WriteLine();\r \r             CreateAssetDeliveryPolicy(encodedAsset, key);\r             Console.WriteLine(\"Created asset delivery policy. \\n\");\r             Console.WriteLine();\r \r             if (tokenRestriction && !String.IsNullOrEmpty(tokenTemplateString))\r             {\r             // Deserializes a string containing an Xml representation of a TokenRestrictionTemplate\r             // back into a TokenRestrictionTemplate class instance.\r             TokenRestrictionTemplate tokenTemplate =\r                 TokenRestrictionTemplateSerializer.Deserialize(tokenTemplateString);\r \r             // Generate a test token based on the the data in the given TokenRestrictionTemplate.\r             // Note, you need to pass the key id Guid because we specified\r             // TokenClaim.ContentKeyIdentifierClaim in during the creation of TokenRestrictionTemplate.\r             Guid rawkey = EncryptionUtils.GetKeyIdAsGuid(key.Id);\r             string testToken = TokenRestrictionTemplateSerializer.GenerateTestToken(tokenTemplate, null, rawkey,\r                                         DateTime.UtcNow.AddDays(365));\r             Console.WriteLine(\"The authorization token is:\\nBearer {0}\", testToken);\r             Console.WriteLine();\r             }\r \r             string url = GetStreamingOriginLocator(encodedAsset);\r             Console.WriteLine(\"Encrypted HLS URL: {0}/manifest(format=m3u8-aapl)\", url);\r \r             Console.ReadLine();\r         }\r \r         static public IAsset UploadFileAndCreateAsset(string singleFilePath)\r         {\r             if (!File.Exists(singleFilePath))\r             {\r             Console.WriteLine(\"File does not exist.\");\r             return null;\r             }\r \r             var assetName = Path.GetFileNameWithoutExtension(singleFilePath);\r             IAsset inputAsset = _context.Assets.Create(assetName, AssetCreationOptions.None);\r \r             var assetFile = inputAsset.AssetFiles.Create(Path.GetFileName(singleFilePath));\r \r             Console.WriteLine(\"Created assetFile {0}\", assetFile.Name);\r \r             Console.WriteLine(\"Upload {0}\", assetFile.Name);\r \r             assetFile.Upload(singleFilePath);\r             Console.WriteLine(\"Done uploading {0}\", assetFile.Name);\r \r             return inputAsset;\r         }\r \r         static public IAsset EncodeToAdaptiveBitrateMP4Set(IAsset inputAsset)\r         {\r             var encodingPreset = \"Adaptive Streaming\";\r \r             IJob job = _context.Jobs.Create(String.Format(\"Encoding {0}\", inputAsset.Name));\r \r             var mediaProcessors =\r             _context.MediaProcessors.Where(p => p.Name.Contains(\"Media Encoder Standard\")).ToList();\r \r             var latestMediaProcessor =\r             mediaProcessors.OrderBy(mp => new Version(mp.Version)).LastOrDefault();\r \r             ITask encodeTask = job.Tasks.AddNew(\"Encoding\", latestMediaProcessor, encodingPreset, TaskOptions.None);\r             encodeTask.InputAssets.Add(inputAsset);\r             encodeTask.OutputAssets.AddNew(String.Format(\"{0} as {1}\", inputAsset.Name, encodingPreset), AssetCreationOptions.StorageEncrypted);\r \r             job.StateChanged += new EventHandler<JobStateChangedEventArgs>(JobStateChanged);\r             job.Submit();\r             job.GetExecutionProgressTask(CancellationToken.None).Wait();\r \r             return job.OutputMediaAssets[0];\r         }\r \r         static public IContentKey CreateCommonCBCTypeContentKey(IAsset asset)\r         {\r             // Create HLS SAMPLE AES encryption content key\r             Guid keyId = Guid.NewGuid();\r             byte[] contentKey = GetRandomBuffer(16);\r \r             IContentKey key = _context.ContentKeys.Create(\r                         keyId,\r                         contentKey,\r                         \"ContentKey\",\r                         ContentKeyType.CommonEncryptionCbcs);\r \r             // Associate the key with the asset.\r             asset.ContentKeys.Add(key);\r \r             return key;\r         }\r \r \r         static public void AddOpenAuthorizationPolicy(IContentKey contentKey)\r         {\r             // Create ContentKeyAuthorizationPolicy with Open restrictions\r             // and create authorization policy          \r \r             List<ContentKeyAuthorizationPolicyRestriction> restrictions = new List<ContentKeyAuthorizationPolicyRestriction>\r                     {\r                     new ContentKeyAuthorizationPolicyRestriction\r                     {\r                         Name = \"Open\",\r                         KeyRestrictionType = (int)ContentKeyRestrictionType.Open,\r                         Requirements = null\r                     }\r                     };\r \r \r             // Configure FairPlay policy option.\r             string FairPlayConfiguration = ConfigureFairPlayPolicyOptions();\r \r             IContentKeyAuthorizationPolicyOption FairPlayPolicy =\r             _context.ContentKeyAuthorizationPolicyOptions.Create(\"\",\r             ContentKeyDeliveryType.FairPlay,\r             restrictions,\r             FairPlayConfiguration);\r \r \r             IContentKeyAuthorizationPolicy contentKeyAuthorizationPolicy = _context.\r                 ContentKeyAuthorizationPolicies.\r                 CreateAsync(\"Deliver Common CBC Content Key with no restrictions\").\r                 Result;\r \r             contentKeyAuthorizationPolicy.Options.Add(FairPlayPolicy);\r \r             // Associate the content key authorization policy with the content key.\r             contentKey.AuthorizationPolicyId = contentKeyAuthorizationPolicy.Id;\r             contentKey = contentKey.UpdateAsync().Result;\r         }\r \r         public static string AddTokenRestrictedAuthorizationPolicy(IContentKey contentKey)\r         {\r             string tokenTemplateString = GenerateTokenRequirements();\r \r             List<ContentKeyAuthorizationPolicyRestriction> restrictions = new List<ContentKeyAuthorizationPolicyRestriction>\r                     {\r                     new ContentKeyAuthorizationPolicyRestriction\r                     {\r                         Name = \"Token Authorization Policy\",\r                         KeyRestrictionType = (int)ContentKeyRestrictionType.TokenRestricted,\r                         Requirements = tokenTemplateString,\r                     }\r                     };\r \r             // Configure FairPlay policy option.\r             string FairPlayConfiguration = ConfigureFairPlayPolicyOptions();\r \r \r             IContentKeyAuthorizationPolicyOption FairPlayPolicy =\r             _context.ContentKeyAuthorizationPolicyOptions.Create(\"Token option\",\r                    ContentKeyDeliveryType.FairPlay,\r                    restrictions,\r                    FairPlayConfiguration);\r \r             IContentKeyAuthorizationPolicy contentKeyAuthorizationPolicy = _context.\r                 ContentKeyAuthorizationPolicies.\r                 CreateAsync(\"Deliver Common CBC Content Key with token restrictions\").\r                 Result;\r \r             contentKeyAuthorizationPolicy.Options.Add(FairPlayPolicy);\r \r             // Associate the content key authorization policy with the content key\r             contentKey.AuthorizationPolicyId = contentKeyAuthorizationPolicy.Id;\r             contentKey = contentKey.UpdateAsync().Result;\r \r             return tokenTemplateString;\r         }\r \r         private static string ConfigureFairPlayPolicyOptions()\r         {\r             // For testing you can provide all zeroes for ASK bytes together with the cert from Apple FPS SDK.\r             // However, for production you must use a real ASK from Apple bound to a real prod certificate.\r             byte[] askBytes = Guid.NewGuid().ToByteArray();\r             var askId = Guid.NewGuid();\r             // Key delivery retrieves askKey by askId and uses this key to generate the response.\r             IContentKey askKey = _context.ContentKeys.Create(\r                         askId,\r                         askBytes,\r                         \"askKey\",\r                         ContentKeyType.FairPlayASk);\r \r             //Customer password for creating the .pfx file.\r             string pfxPassword = \"<customer password for creating the .pfx file>\";\r             // Key delivery retrieves pfxPasswordKey by pfxPasswordId and uses this key to generate the response.\r             var pfxPasswordId = Guid.NewGuid();\r             byte[] pfxPasswordBytes = System.Text.Encoding.UTF8.GetBytes(pfxPassword);\r             IContentKey pfxPasswordKey = _context.ContentKeys.Create(\r                         pfxPasswordId,\r                         pfxPasswordBytes,\r                         \"pfxPasswordKey\",\r                         ContentKeyType.FairPlayPfxPassword);\r \r             // iv - 16 bytes random value, must match the iv in the asset delivery policy.\r             byte[] iv = Guid.NewGuid().ToByteArray();\r \r             //Specify the .pfx file created by the customer.\r             var appCert = new X509Certificate2(\"path to the .pfx file created by the customer\", pfxPassword, X509KeyStorageFlags.Exportable);\r \r             string FairPlayConfiguration =\r             Microsoft.WindowsAzure.MediaServices.Client.FairPlay.FairPlayConfiguration.CreateSerializedFairPlayOptionConfiguration(\r                 appCert,\r                 pfxPassword,\r                 pfxPasswordId,\r                 askId,\r                 iv);\r \r             return FairPlayConfiguration;\r         }\r \r         static private string GenerateTokenRequirements()\r         {\r             TokenRestrictionTemplate template = new TokenRestrictionTemplate(TokenType.SWT);\r \r             template.PrimaryVerificationKey = new SymmetricVerificationKey();\r             template.AlternateVerificationKeys.Add(new SymmetricVerificationKey());\r             template.Audience = _sampleAudience.ToString();\r             template.Issuer = _sampleIssuer.ToString();\r             template.RequiredClaims.Add(TokenClaim.ContentKeyIdentifierClaim);\r \r             return TokenRestrictionTemplateSerializer.Serialize(template);\r         }\r \r         static public void CreateAssetDeliveryPolicy(IAsset asset, IContentKey key)\r         {\r             var kdPolicy = _context.ContentKeyAuthorizationPolicies.Where(p => p.Id == key.AuthorizationPolicyId).Single();\r \r             var kdOption = kdPolicy.Options.Single(o => o.KeyDeliveryType == ContentKeyDeliveryType.FairPlay);\r \r             FairPlayConfiguration configFP = JsonConvert.DeserializeObject<FairPlayConfiguration>(kdOption.KeyDeliveryConfiguration);\r \r             // Get the FairPlay license service URL.\r             Uri acquisitionUrl = key.GetKeyDeliveryUrl(ContentKeyDeliveryType.FairPlay);\r \r             // The reason the below code replaces \"https://\" with \"skd://\" is because\r             // in the IOS player sample code which you obtained in Apple developer account,\r             // the player only recognizes a Key URL that starts with skd://.\r             // However, if you are using a customized player,\r             // you can choose whatever protocol you want.\r             // For example, \"https\".\r \r             Dictionary<AssetDeliveryPolicyConfigurationKey, string> assetDeliveryPolicyConfiguration =\r             new Dictionary<AssetDeliveryPolicyConfigurationKey, string>\r             {\r                     {AssetDeliveryPolicyConfigurationKey.FairPlayLicenseAcquisitionUrl, acquisitionUrl.ToString().Replace(\"https://\", \"skd://\")},\r                     {AssetDeliveryPolicyConfigurationKey.CommonEncryptionIVForCbcs, configFP.ContentEncryptionIV}\r             };\r \r             var assetDeliveryPolicy = _context.AssetDeliveryPolicies.Create(\r                 \"AssetDeliveryPolicy\",\r             AssetDeliveryPolicyType.DynamicCommonEncryptionCbcs,\r             AssetDeliveryProtocol.HLS,\r             assetDeliveryPolicyConfiguration);\r \r             // Add AssetDelivery Policy to the asset\r             asset.DeliveryPolicies.Add(assetDeliveryPolicy);\r \r         }\r \r         /// <summary>\r         /// Gets the streaming origin locator.\r         /// </summary>\r         /// <param name=\"assets\"></param>\r         /// <returns></returns>\r         static public string GetStreamingOriginLocator(IAsset asset)\r         {\r \r             // Get a reference to the streaming manifest file from the  \r             // collection of files in the asset.\r \r             var assetFile = asset.AssetFiles.Where(f => f.Name.ToLower().\r                          EndsWith(\".ism\")).\r                          FirstOrDefault();\r \r             // Create a 30-day readonly access policy.\r             IAccessPolicy policy = _context.AccessPolicies.Create(\"Streaming policy\",\r             TimeSpan.FromDays(30),\r             AccessPermissions.Read);\r \r             // Create a locator to the streaming content on an origin.\r             ILocator originLocator = _context.Locators.CreateLocator(LocatorType.OnDemandOrigin, asset,\r             policy,\r             DateTime.UtcNow.AddMinutes(-5));\r \r             // Create a URL to the manifest file.\r             return originLocator.Path + assetFile.Name;\r         }\r \r         static private void JobStateChanged(object sender, JobStateChangedEventArgs e)\r         {\r             Console.WriteLine(string.Format(\"{0}\\n  State: {1}\\n  Time: {2}\\n\\n\",\r             ((IJob)sender).Name,\r             e.CurrentState,\r             DateTime.UtcNow.ToString(@\"yyyy_M_d__hh_mm_ss\")));\r         }\r \r         static private byte[] GetRandomBuffer(int length)\r         {\r             var returnValue = new byte[length];\r \r             using (var rng =\r             new System.Security.Cryptography.RNGCryptoServiceProvider())\r             {\r             rng.GetBytes(returnValue);\r             }\r \r             return returnValue;\r         }\r         }\r     }\r \r \r <!--Update_Description: update code to use AAD token instead of ACS-->"}