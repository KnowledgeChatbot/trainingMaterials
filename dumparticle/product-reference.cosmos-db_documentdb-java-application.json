{"Title":"使用 Azure Cosmos DB 开发 Java 应用程序教程","Description":"此 Java Web 应用程序教程展示如何使用 Azure Cosmos DB 和DocumentDB API 从 Azure 网站上托管的 Java 应用程序来存储和访问数据。","Content":"# <a name=\"build-a-java-web-application-using-azure-cosmos-db-and-the-documentdb-api\"></a>使用 Azure Cosmos DB 和 DocumentDB API 构建 Java Web 应用程序\r > [!div class=\"op_single_selector\"]\r > * [.NET](documentdb-dotnet-application.md)\r > * [Node.js](documentdb-nodejs-application.md)\r > * [Java](documentdb-java-application.md)\r > * [Python](documentdb-python-application.md)\r > \r > \r \r 本 Java Web 应用程序教程介绍了如何使用 [Azure Cosmos DB](https://www.azure.cn/home/features/cosmos-db/) 服务通过 Azure 应用服务 Web 应用上托管的 Java 应用程序来存储和访问数据。 本主题介绍以下内容：\r \r * 如何在 Eclipse 中构建基本 JavaServer Pages (JSP) 程序。\r * 如何借助 [Azure Cosmos DB Java SDK](https://github.com/Azure/azure-documentdb-java) 使用 Azure Cosmos DB 服务。\r \r 此 Java 应用程序教程演示了如何创建一个基于 web 的任务管理应用程序，可以使用此应用程序创建、检索任务，以及将任务标记为已完成，如下图所示。 在 Azure Cosmos DB 中，ToDo 列表中的每个任务都存储为 JSON 文档。\r \r ![我的 ToDo 列表 Java 应用程序](./media/documentdb-java-application/image1.png)\r \r > [!TIP]\r > 本应用程序开发教程假设读者之前有使用 Java 的经验。 如果不熟悉 Java 或[必备工具](#Prerequisites)，建议从 GitHub 下载完整的 [todo](https://github.com/Azure-Samples/documentdb-java-todo-app) 项目，并按照[本文末尾的说明](#GetProject)生成该项目。 构建之后，可以回顾本文以深入了解项目上下文中的代码。  \r > \r > \r \r ## <a name=\"Prerequisites\"></a>此 Java Web 应用程序教程的先决条件\r 在开始本应用程序开发教程前，必须具有：\r \r *  如果没有 Azure 订阅，可在开始前创建一个[试用帐户](https://www.azure.cn/pricing/1rmb-trial/)。 \r \r   [!INCLUDE [cosmos-db-emulator-docdb-api](../../includes/cosmos-db-emulator-docdb-api.md)]\r \r * [Java 开发工具包 (JDK) 7+](http://www.oracle.com/technetwork/java/javase/downloads/index.html)。\r * [Eclipse IDE for Java EE Developers。](http://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/lunasr1)\r * [已启用 Java 运行时环境（例如 Tomcat 或 Jetty）的 Azure 网站。](../app-service/app-service-web-get-started-java.md)\r \r 如果你是首次安装这些工具，那么可以参考 coreservlets.com 网站的[教程：安装 TomCat7 并将其与 Eclipse 一起使用](http://www.coreservlets.com/Apache-Tomcat-Tutorial/tomcat-7-with-eclipse.html)文章的 Quick Start 部分提供的安装过程演练。\r \r ## <a name=\"CreateDB\"></a>步骤 1：创建 Azure Cosmos DB 帐户\r 首先创建一个 Azure Cosmos DB 帐户。 如果已有一个帐户，或者要在本教程中使用 Azure Cosmos DB 模拟器，可以跳到[步骤 2：创建 Java JSP 应用程序](#CreateJSP)。\r \r [!INCLUDE [create-dbaccount](../../includes/cosmos-db-create-dbaccount.md)]\r \r [!INCLUDE [keys](../../includes/cosmos-db-keys.md)]\r \r ## <a name=\"CreateJSP\"></a>步骤 2：创建 Java JSP 应用程序\r 若要创建 JSP 应用程序，请执行以下步骤：\r \r 1. 首先，创建一个 Java 项目。 启动 Eclipse，依次单击“文件”、“新建”和“动态 Web 项目”。 如果未看到“动态 Web 项目”作为可用项目列出，请执行下列操作：依次单击“文件”、“新建”和“项目”，展开“Web”，并依次单击“动态 Web 项目”、“下一步”。\r \r     ![JSP Java 应用程序开发](./media/documentdb-java-application/image10.png)\r 2. 在“项目名称”框中输入项目名称，在“目标运行时”下拉菜单中随意选择一个值（例如 Apache Tomcat v7.0），并单击“完成”。 选择目标运行可通过 Eclipse 在本地运行项目。\r 3. 在 Eclipse 的项目资源管理器视图中，展开项目。 右键单击“WebContent”，并依次单击“新建”、“JSP 文件”。\r 4. 在“新建 JSP 文件”对话框中，将文件命名为“index.jsp”。 将父文件夹保留为“WebContent”，如下图所示，并单击“下一步”。\r \r     ![创建新的 JSP 文件 - Java Web 应用程序教程](./media/documentdb-java-application/image11.png)\r 5. 对于本教程，请在“选择 JSP 模板”对话框中选择“新建 JSP 文件(html)”，并单击“完成”。\r 6. 在 Eclipse 中打开 index.jsp 文件后，添加文本以在以下元素中显示“Hello World!”： 现有 <body> 元素中。 更新后的 <body> 内容应类似于以下代码：\r \r         <body>\r             <% out.println(\"Hello World!\"); %>\r         </body>\r 7. 保存 index.jsp 文件。\r 8. 如果在步骤 2 中设置了目标运行时，则可以依次单击“项目”、“运行”，在本地运行 JSP 应用程序：\r \r     ![Hello World — Java 应用程序教程](./media/documentdb-java-application/image12.png)\r \r ## <a name=\"InstallSDK\"></a>第 3 步：安装 DocumentDB Java SDK\r 提取 DocumentDB Java SDK 和其依赖项的最简单方法是使用 [Apache Maven](http://maven.apache.org/)。\r \r 要执行此操作，你需要通过完成以下步骤将项目转换为 maven 项目：\r \r 1. 在项目资源管理器中右键单击项目，并依次单击“配置”、“转换为 Maven 项目”。\r 2. 在“创建新 POM”窗口中，接受默认值，并单击“完成”。\r 3. 在“项目资源管理器” 中，打开 pom.xml 文件。\r 4. 在“依赖项”选项卡上，在“依赖项”窗格中单击“添加”。\r 5. 在“选择依赖项”  窗口中，执行以下操作：\r \r     * 在“组 ID”框中，输入 com.microsoft.azure。\r     * 在“项目 ID”框中输入 azure-documentdb。\r     * 在“版本”框中输入 1.5.1。\r \r     ![安装 DocumentDB Java 应用程序 SDK](./media/documentdb-java-application/image13.png)\r \r     * 或者，通过文本编辑器直接将组 ID 和项目 ID 的依赖项 XML 添加到 pom.xml：\r \r         <dependency> <groupId>com.microsoft.azure</groupId> <artifactId>azure-documentdb</artifactId> <version>1.9.1</version> </dependency>\r 6. 单击“确定”，Maven 将安装 DocumentDB Java SDK。\r 7. 保存 pom.xml 文件。\r \r ## <a name=\"UseService\"></a>步骤 4：在 Java 应用程序中使用 Azure Cosmos DB 服务\r 1. 首先，让我们在 TodoItem.java 中定义 TodoItem 对象：\r \r         @Data\r         @Builder\r         public class TodoItem {\r             private String category;\r             private boolean complete;\r             private String id;\r             private String name;\r         }\r \r     在此项目中，我们使用[项目 Lombok](http://projectlombok.org/)生成构造函数、getter、setter 和一个生成器。 或者，可以手动编写此代码，或使用 IDE 生成此代码。\r 2. 若要调用 Azure Cosmos DB 服务，必须实例化一个新的 DocumentClient。 一般情况下，最好是重用 **DocumentClient** -而不是为每个后续请求构造新的客户端。 我们可以通过在 **DocumentClientFactory**中包装客户端来重用此客户端。 在 DocumentClientFactory.java 中，需要在此处粘贴 [步骤 1](#CreateDB) 中保存到剪贴板中的 URI 和 PRIMARY KEY 值。 将 [YOUR_ENDPOINT_HERE] 替换为自己的 URI，将 [YOUR_KEY_HERE] 替换为自己的主密钥。\r \r         private static final String HOST = \"[YOUR_ENDPOINT_HERE]\";\r         private static final String MASTER_KEY = \"[YOUR_KEY_HERE]\";\r \r         private static DocumentClient documentClient = new DocumentClient(HOST, MASTER_KEY,\r                         ConnectionPolicy.GetDefault(), ConsistencyLevel.Session);\r \r         public static DocumentClient getDocumentClient() {\r             return documentClient;\r         }\r 3. 接下来创建数据访问对象 (DAO)，将 ToDo 项保存到 Azure Cosmos DB 的过程进行抽象。\r \r     要将 ToDo 项保存到集合中，客户端需要了解可用于保存的数据库和集合（通过自链接引用）。 通常，如果可能的话最好缓存数据库和集合，以避免额外的往返访问数据库。\r \r     以下代码演示了存在数据库和集合的情况下如何检索数据库和集合，如果不存在，则创建新的数据库和集合。\r \r         public class DocDbDao implements TodoDao {\r             // The name of our database.\r             private static final String DATABASE_ID = \"TodoDB\";\r \r             // The name of our collection.\r             private static final String COLLECTION_ID = \"TodoCollection\";\r \r             // The Azure Cosmos DB Client\r             private static DocumentClient documentClient = DocumentClientFactory\r                     .getDocumentClient();\r \r             // Cache for the database object, so we don't have to query for it to\r             // retrieve self links.\r             private static Database databaseCache;\r \r             // Cache for the collection object, so we don't have to query for it to\r             // retrieve self links.\r             private static DocumentCollection collectionCache;\r \r             private Database getTodoDatabase() {\r                 if (databaseCache == null) {\r                     // Get the database if it exists\r                     List<Database> databaseList = documentClient\r                             .queryDatabases(\r                                     \"SELECT * FROM root r WHERE r.id='\" + DATABASE_ID\r                                             + \"'\", null).getQueryIterable().toList();\r \r                     if (databaseList.size() > 0) {\r                         // Cache the database object so we won't have to query for it\r                         // later to retrieve the selfLink.\r                         databaseCache = databaseList.get(0);\r                     } else {\r                         // Create the database if it doesn't exist.\r                         try {\r                             Database databaseDefinition = new Database();\r                             databaseDefinition.setId(DATABASE_ID);\r \r                             databaseCache = documentClient.createDatabase(\r                                     databaseDefinition, null).getResource();\r                         } catch (DocumentClientException e) {\r                             // TODO: Something has gone terribly wrong - the app wasn't\r                             // able to query or create the collection.\r                             // Verify your connection, endpoint, and key.\r                             e.printStackTrace();\r                         }\r                     }\r                 }\r \r                 return databaseCache;\r             }\r \r             private DocumentCollection getTodoCollection() {\r                 if (collectionCache == null) {\r                     // Get the collection if it exists.\r                     List<DocumentCollection> collectionList = documentClient\r                             .queryCollections(\r                                     getTodoDatabase().getSelfLink(),\r                                     \"SELECT * FROM root r WHERE r.id='\" + COLLECTION_ID\r                                             + \"'\", null).getQueryIterable().toList();\r \r                     if (collectionList.size() > 0) {\r                         // Cache the collection object so we won't have to query for it\r                         // later to retrieve the selfLink.\r                         collectionCache = collectionList.get(0);\r                     } else {\r                         // Create the collection if it doesn't exist.\r                         try {\r                             DocumentCollection collectionDefinition = new DocumentCollection();\r                             collectionDefinition.setId(COLLECTION_ID);\r \r                             collectionCache = documentClient.createCollection(\r                                     getTodoDatabase().getSelfLink(),\r                                     collectionDefinition, null).getResource();\r                         } catch (DocumentClientException e) {\r                             // TODO: Something has gone terribly wrong - the app wasn't\r                             // able to query or create the collection.\r                             // Verify your connection, endpoint, and key.\r                             e.printStackTrace();\r                         }\r                     }\r                 }\r \r                 return collectionCache;\r             }\r         }\r 4. 下一步是编写一些代码将 TodoItem 保存到集合中。 本示例使用 [Gson](https://code.google.com/p/google-gson/) 将 TodoItem 普通 Java 对象 (POJO) 序列化到 JSON 文档和从中反序列化 POJO。\r \r         // We'll use Gson for POJO <=> JSON serialization for this example.\r         private static Gson gson = new Gson();\r \r         @Override\r         public TodoItem createTodoItem(TodoItem todoItem) {\r             // Serialize the TodoItem as a JSON Document.\r             Document todoItemDocument = new Document(gson.toJson(todoItem));\r \r             // Annotate the document as a TodoItem for retrieval (so that we can\r             // store multiple entity types in the collection).\r             todoItemDocument.set(\"entityType\", \"todoItem\");\r \r             try {\r                 // Persist the document using the DocumentClient.\r                 todoItemDocument = documentClient.createDocument(\r                         getTodoCollection().getSelfLink(), todoItemDocument, null,\r                         false).getResource();\r             } catch (DocumentClientException e) {\r                 e.printStackTrace();\r                 return null;\r             }\r \r             return gson.fromJson(todoItemDocument.toString(), TodoItem.class);\r         }\r 5. 与 Azure Cosmos DB 数据库和集合一样，文档也是通过自链接来引用。 使用以下帮助程序函数可以通过另一个属性（例如“id”）来检索文档，而不是自链接：\r \r         private Document getDocumentById(String id) {\r             // Retrieve the document using the DocumentClient.\r             List<Document> documentList = documentClient\r                     .queryDocuments(getTodoCollection().getSelfLink(),\r                             \"SELECT * FROM root r WHERE r.id='\" + id + \"'\", null)\r                     .getQueryIterable().toList();\r \r             if (documentList.size() > 0) {\r                 return documentList.get(0);\r             } else {\r                 return null;\r             }\r         }\r 6. 我们可使用步骤 5 中的帮助器方法按 ID 检索 TodoItem JSON 文档，并将其反序列化到 POJO：\r \r         @Override\r         public TodoItem readTodoItem(String id) {\r             // Retrieve the document by id using our helper method.\r             Document todoItemDocument = getDocumentById(id);\r \r             if (todoItemDocument != null) {\r                 // De-serialize the document in to a TodoItem.\r                 return gson.fromJson(todoItemDocument.toString(), TodoItem.class);\r             } else {\r                 return null;\r             }\r         }\r 7. 我们还可以通过 DocumentClient 使用 DocumentDB SQL 获取一个集合或 TodoItem 列表：\r \r         @Override\r         public List<TodoItem> readTodoItems() {\r             List<TodoItem> todoItems = new ArrayList<TodoItem>();\r \r             // Retrieve the TodoItem documents\r             List<Document> documentList = documentClient\r                     .queryDocuments(getTodoCollection().getSelfLink(),\r                             \"SELECT * FROM root r WHERE r.entityType = 'todoItem'\",\r                             null).getQueryIterable().toList();\r \r             // De-serialize the documents in to TodoItems.\r             for (Document todoItemDocument : documentList) {\r                 todoItems.add(gson.fromJson(todoItemDocument.toString(),\r                         TodoItem.class));\r             }\r \r             return todoItems;\r         }\r 8. 使用 DocumentClient 更新文档的方法有多种。 在 Todo 列表应用程序中，我们希望能够切换 TodoItem 是否已完成。 这可以通过更新文档中的\"完成\"属性来实现：\r \r         @Override\r         public TodoItem updateTodoItem(String id, boolean isComplete) {\r             // Retrieve the document from the database\r             Document todoItemDocument = getDocumentById(id);\r \r             // You can update the document as a JSON document directly.\r             // For more complex operations - you could de-serialize the document in\r             // to a POJO, update the POJO, and then re-serialize the POJO back in to\r             // a document.\r             todoItemDocument.set(\"complete\", isComplete);\r \r             try {\r                 // Persist/replace the updated document.\r                 todoItemDocument = documentClient.replaceDocument(todoItemDocument,\r                         null).getResource();\r             } catch (DocumentClientException e) {\r                 e.printStackTrace();\r                 return null;\r             }\r \r             return gson.fromJson(todoItemDocument.toString(), TodoItem.class);\r         }\r 9. 最后，我们希望能够从我们的列表中删除 TodoItem。 要执行此操作，我们可以使用之前编写的帮助器方法检索自链接，然后告诉客户端将其删除：\r \r         @Override\r         public boolean deleteTodoItem(String id) {\r             // Azure Cosmos DB refers to documents by self link rather than id.\r \r             // Query for the document to retrieve the self link.\r             Document todoItemDocument = getDocumentById(id);\r \r             try {\r                 // Delete the document by self link.\r                 documentClient.deleteDocument(todoItemDocument.getSelfLink(), null);\r             } catch (DocumentClientException e) {\r                 e.printStackTrace();\r                 return false;\r             }\r \r             return true;\r         }\r \r ## <a name=\"Wire\"></a>步骤 5：将剩余的 Java 应用程序开发项目绑定到一起\r 现在，我们完成了有趣的部分，剩下所有要做的是构建一个快速的用户接口，并将其与我们的 DAO 进行绑定。\r \r 1. 首先，让我们生成控制器以调用 DAO：\r \r         public class TodoItemController {\r             public static TodoItemController getInstance() {\r                 if (todoItemController == null) {\r                     todoItemController = new TodoItemController(TodoDaoFactory.getDao());\r                 }\r                 return todoItemController;\r             }\r \r             private static TodoItemController todoItemController;\r \r             private final TodoDao todoDao;\r \r             TodoItemController(TodoDao todoDao) {\r                 this.todoDao = todoDao;\r             }\r \r             public TodoItem createTodoItem(@NonNull String name,\r                     @NonNull String category, boolean isComplete) {\r                 TodoItem todoItem = TodoItem.builder().name(name).category(category)\r                         .complete(isComplete).build();\r                 return todoDao.createTodoItem(todoItem);\r             }\r \r             public boolean deleteTodoItem(@NonNull String id) {\r                 return todoDao.deleteTodoItem(id);\r             }\r \r             public TodoItem getTodoItemById(@NonNull String id) {\r                 return todoDao.readTodoItem(id);\r             }\r \r             public List<TodoItem> getTodoItems() {\r                 return todoDao.readTodoItems();\r             }\r \r             public TodoItem updateTodoItem(@NonNull String id, boolean isComplete) {\r                 return todoDao.updateTodoItem(id, isComplete);\r             }\r         }\r \r     在更复杂的应用程序中，控制器可以包含基于 DAO 的复杂的业务逻辑。\r 2. 接下来，我们创建 servlet 将 HTTP 请求路由到控制器：\r \r         public class TodoServlet extends HttpServlet {\r             // API Keys\r             public static final String API_METHOD = \"method\";\r \r             // API Methods\r             public static final String CREATE_TODO_ITEM = \"createTodoItem\";\r             public static final String GET_TODO_ITEMS = \"getTodoItems\";\r             public static final String UPDATE_TODO_ITEM = \"updateTodoItem\";\r \r             // API Parameters\r             public static final String TODO_ITEM_ID = \"todoItemId\";\r             public static final String TODO_ITEM_NAME = \"todoItemName\";\r             public static final String TODO_ITEM_CATEGORY = \"todoItemCategory\";\r             public static final String TODO_ITEM_COMPLETE = \"todoItemComplete\";\r \r             public static final String MESSAGE_ERROR_INVALID_METHOD = \"{'error': 'Invalid method'}\";\r \r             private static final long serialVersionUID = 1L;\r             private static final Gson gson = new Gson();\r \r             @Override\r             protected void doGet(HttpServletRequest request,\r                     HttpServletResponse response) throws ServletException, IOException {\r \r                 String apiResponse = MESSAGE_ERROR_INVALID_METHOD;\r \r                 TodoItemController todoItemController = TodoItemController\r                         .getInstance();\r \r                 String id = request.getParameter(TODO_ITEM_ID);\r                 String name = request.getParameter(TODO_ITEM_NAME);\r                 String category = request.getParameter(TODO_ITEM_CATEGORY);\r                 boolean isComplete = StringUtils.equalsIgnoreCase(\"true\",\r                         request.getParameter(TODO_ITEM_COMPLETE)) ? true : false;\r \r                 switch (request.getParameter(API_METHOD)) {\r                 case CREATE_TODO_ITEM:\r                     apiResponse = gson.toJson(todoItemController.createTodoItem(name,\r                             category, isComplete));\r                     break;\r                 case GET_TODO_ITEMS:\r                     apiResponse = gson.toJson(todoItemController.getTodoItems());\r                     break;\r                 case UPDATE_TODO_ITEM:\r                     apiResponse = gson.toJson(todoItemController.updateTodoItem(id,\r                             isComplete));\r                     break;\r                 default:\r                     break;\r                 }\r \r                 response.getWriter().println(apiResponse);\r             }\r \r             @Override\r             protected void doPost(HttpServletRequest request,\r                     HttpServletResponse response) throws ServletException, IOException {\r                 doGet(request, response);\r             }\r         }\r 3. 我们需要一个 Web 用户界面来向用户显示。 让我们重新编写之前创建的 index.jsp：\r     ```html\r         <html>\r         <head>\r           <meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\r           <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge;\" />\r           <title>Azure Cosmos DB Java Sample</title>\r \r           <!-- Bootstrap -->\r           <link href=\"//ajax.aspnetcdn.com/ajax/bootstrap/3.2.0/css/bootstrap.min.css\" rel=\"stylesheet\">\r \r           <style>\r             /* Add padding to body for fixed nav bar */\r             body {\r               padding-top: 50px;\r             }\r           </style>\r         </head>\r         <body>\r           <!-- Nav Bar -->\r           <div class=\"navbar navbar-inverse navbar-fixed-top\" role=\"navigation\">\r             <div class=\"container\">\r               <div class=\"navbar-header\">\r                 <a class=\"navbar-brand\" href=\"#\">My Tasks</a>\r               </div>\r             </div>\r           </div>\r \r           <!-- Body -->\r           <div class=\"container\">\r             <h1>My ToDo List</h1>\r \r             <hr/>\r \r             <!-- The ToDo List -->\r             <div class = \"todoList\">\r               <table class=\"table table-bordered table-striped\" id=\"todoItems\">\r                 <thead>\r                   <tr>\r                     <th>Name</th>\r                     <th>Category</th>\r                     <th>Complete</th>\r                   </tr>\r                 </thead>\r                 <tbody>\r                 </tbody>\r               </table>\r \r               <!-- Update Button -->\r               <div class=\"todoUpdatePanel\">\r                 <form class=\"form-horizontal\" role=\"form\">\r                   <button type=\"button\" class=\"btn btn-primary\">Update Tasks</button>\r                 </form>\r               </div>\r \r             </div>\r \r             <hr/>\r \r             <!-- Item Input Form -->\r             <div class=\"todoForm\">\r               <form class=\"form-horizontal\" role=\"form\">\r                 <div class=\"form-group\">\r                   <label for=\"inputItemName\" class=\"col-sm-2\">Task Name</label>\r                   <div class=\"col-sm-10\">\r                     <input type=\"text\" class=\"form-control\" id=\"inputItemName\" placeholder=\"Enter name\">\r                   </div>\r                 </div>\r \r                 <div class=\"form-group\">\r                   <label for=\"inputItemCategory\" class=\"col-sm-2\">Task Category</label>\r                   <div class=\"col-sm-10\">\r                     <input type=\"text\" class=\"form-control\" id=\"inputItemCategory\" placeholder=\"Enter category\">\r                   </div>\r                 </div>\r \r                 <button type=\"button\" class=\"btn btn-primary\">Add Task</button>\r               </form>\r             </div>\r \r           </div>\r \r           <!-- Placed at the end of the document so the pages load faster -->\r           <script src=\"//ajax.aspnetcdn.com/ajax/jQuery/jquery-2.1.1.min.js\"></script>\r           <script src=\"//ajax.aspnetcdn.com/ajax/bootstrap/3.2.0/bootstrap.min.js\"></script>\r           <script src=\"assets/todo.js\"></script>\r         </body>\r         </html>\r     ```\r 4. 最后，编写一些客户端 Javascript 将 Web 用户界面和 servlet 绑定在一起：\r \r         var todoApp = {\r           /*\r            * API methods to call Java backend.\r            */\r           apiEndpoint: \"api\",\r \r           createTodoItem: function(name, category, isComplete) {\r             $.post(todoApp.apiEndpoint, {\r                 \"method\": \"createTodoItem\",\r                 \"todoItemName\": name,\r                 \"todoItemCategory\": category,\r                 \"todoItemComplete\": isComplete\r               },\r               function(data) {\r                 var todoItem = data;\r                 todoApp.addTodoItemToTable(todoItem.id, todoItem.name, todoItem.category, todoItem.complete);\r               },\r               \"json\");\r           },\r \r           getTodoItems: function() {\r             $.post(todoApp.apiEndpoint, {\r                 \"method\": \"getTodoItems\"\r               },\r               function(data) {\r                 var todoItemArr = data;\r                 $.each(todoItemArr, function(index, value) {\r                   todoApp.addTodoItemToTable(value.id, value.name, value.category, value.complete);\r                 });\r               },\r               \"json\");\r           },\r \r           updateTodoItem: function(id, isComplete) {\r             $.post(todoApp.apiEndpoint, {\r                 \"method\": \"updateTodoItem\",\r                 \"todoItemId\": id,\r                 \"todoItemComplete\": isComplete\r               },\r               function(data) {},\r               \"json\");\r           },\r \r           /*\r            * UI Methods\r            */\r           addTodoItemToTable: function(id, name, category, isComplete) {\r             var rowColor = isComplete ? \"active\" : \"warning\";\r \r             todoApp.ui_table().append($(\"<tr>\")\r               .append($(\"<td>\").text(name))\r               .append($(\"<td>\").text(category))\r               .append($(\"<td>\")\r                 .append($(\"<input>\")\r                   .attr(\"type\", \"checkbox\")\r                   .attr(\"id\", id)\r                   .attr(\"checked\", isComplete)\r                   .attr(\"class\", \"isComplete\")\r                 ))\r               .addClass(rowColor)\r             );\r           },\r \r           /*\r            * UI Bindings\r            */\r           bindCreateButton: function() {\r             todoApp.ui_createButton().click(function() {\r               todoApp.createTodoItem(todoApp.ui_createNameInput().val(), todoApp.ui_createCategoryInput().val(), false);\r               todoApp.ui_createNameInput().val(\"\");\r               todoApp.ui_createCategoryInput().val(\"\");\r             });\r           },\r \r           bindUpdateButton: function() {\r             todoApp.ui_updateButton().click(function() {\r               // Disable button temporarily.\r               var myButton = $(this);\r               var originalText = myButton.text();\r               $(this).text(\"Updating...\");\r               $(this).prop(\"disabled\", true);\r \r               // Call api to update todo items.\r               $.each(todoApp.ui_updateId(), function(index, value) {\r                 todoApp.updateTodoItem(value.name, value.value);\r                 $(value).remove();\r               });\r \r               // Re-enable button.\r               setTimeout(function() {\r                 myButton.prop(\"disabled\", false);\r                 myButton.text(originalText);\r               }, 500);\r             });\r           },\r \r           bindUpdateCheckboxes: function() {\r             todoApp.ui_table().on(\"click\", \".isComplete\", function(event) {\r               var checkboxElement = $(event.currentTarget);\r               var rowElement = $(event.currentTarget).parents('tr');\r               var id = checkboxElement.attr('id');\r               var isComplete = checkboxElement.is(':checked');\r \r               // Toggle table row color\r               if (isComplete) {\r                 rowElement.addClass(\"active\");\r                 rowElement.removeClass(\"warning\");\r               } else {\r                 rowElement.removeClass(\"active\");\r                 rowElement.addClass(\"warning\");\r               }\r \r               // Update hidden inputs for update panel.\r               todoApp.ui_updateForm().children(\"input[name='\" + id + \"']\").remove();\r \r               todoApp.ui_updateForm().append($(\"<input>\")\r                 .attr(\"type\", \"hidden\")\r                 .attr(\"class\", \"updateComplete\")\r                 .attr(\"name\", id)\r                 .attr(\"value\", isComplete));\r \r             });\r           },\r \r           /*\r            * UI Elements\r            */\r           ui_createNameInput: function() {\r             return $(\".todoForm #inputItemName\");\r           },\r \r           ui_createCategoryInput: function() {\r             return $(\".todoForm #inputItemCategory\");\r           },\r \r           ui_createButton: function() {\r             return $(\".todoForm button\");\r           },\r \r           ui_table: function() {\r             return $(\".todoList table tbody\");\r           },\r \r           ui_updateButton: function() {\r             return $(\".todoUpdatePanel button\");\r           },\r \r           ui_updateForm: function() {\r             return $(\".todoUpdatePanel form\");\r           },\r \r           ui_updateId: function() {\r             return $(\".todoUpdatePanel .updateComplete\");\r           },\r \r           /*\r            * Install the TodoApp\r            */\r           install: function() {\r             todoApp.bindCreateButton();\r             todoApp.bindUpdateButton();\r             todoApp.bindUpdateCheckboxes();\r \r             todoApp.getTodoItems();\r           }\r         };\r \r         $(document).ready(function() {\r           todoApp.install();\r         });\r 5. 非常好！ 现在剩下的就是测试此应用程序。 在本地运行此应用程序，并添加一些 Todo 项，方法是填充项名称和类别，并单击“添加任务” 。\r 6. 显示项之后，用户可以通过切换复选框，并单击“更新任务” 来更新项是否已完成。\r \r ## <a name=\"Deploy\"></a>步骤 6：将 Java 应用程序部署到 Azure 网站\r 要在 Azure 网站上部署 Java 应用程序，只需将应用程序导出为 WAR 文件，然后通过源控件（例如 Git）或 FTP 上传此文件。\r \r 1. 要将应用程序导出为 WAR 文件，请在“项目资源管理器”中右键单击项目，然后依次单击“导出”和“WAR 文件”。\r 2. 在“WAR 导出”  窗口中，执行以下操作：\r \r    * 在“Web 项目”框中，输入 azure-documentdb-java-sample。\r    * 在“目标”框中，选择一个目标以保存 WAR 文件。\r    * 单击“完成” 。\r 3. 现在已经具有 WAR 文件，只需将它上传到 Azure 网站的 **webapps** 目录。 有关上传此文件的说明，请参阅[将 Java 应用程序添加到 Azure 应用服务 Web 应用](../app-service-web/web-sites-java-add-app.md)。\r \r     将 WAR 文件上传到 webapps 目录之后，运行时环境会检测到你已经添加了此文件，并自动加载它。\r 4. 若要查看完成的作品，请导航到 http://YOUR\\_SITE\\_NAME.chinacloudsites.cn/azure-java-sample/，然后开始添加任务！\r \r ## <a name=\"GetProject\"></a>从 GitHub 获取项目\r GitHub 上的 [todo](https://github.com/Azure-Samples/documentdb-java-todo-app) 项目包含本教程中的所有示例。 如果要将 todo 项目导入 Eclipse，请确保用户具有 [先决条件](#Prerequisites) 部分中所列的软件和资源，并执行以下操作：\r \r 1. 安装 [项目 Lombok](http://projectlombok.org/)。 Lombok 用于生成项目中的构造函数、getter 和 setter。 下载 lombok.jar 文件之后，双击此文件进行安装，或者从命令行安装。\r 2. 如果 Eclipse 处于打开状态，请将其关闭并重启以加载 Lombok。\r 3. 在 Eclipse 中，在“文件”菜单上单击“导入”。\r 4. 在“导入”窗口中，依次单击“Git”、“来自 Git 的项目”和“下一步”。\r 5. 在“选择存储库源”屏幕上，单击“克隆 URI”。\r 6. 在“源 Git 存储库”屏幕上的“URI”框中，输入 https://github.com/Azure-Samples/java-todo-app.git，然后单击“下一步”。\r 7. 在“分支选择”屏幕上，确保已选择“master”，并单击“下一步”。\r 8. 在“本地目标”屏幕上，单击“浏览”选择要将存储库复制到的文件夹，并单击“下一步”。\r 9. 在“选择要用于导入项目的向导”屏幕上，确保已选择“导入现有项目”，并单击“下一步”。\r 10. 在“导入项目”屏幕上，取消选择“DocumentDB”项目，然后单击“完成”。 DocumentDB 项目包含 Azure Cosmos DB Java SDK，我们会将其添加为依赖项。\r 11. 在“项目资源管理器”中，导航到 azure-documentdb-java-sample\\src\\com.microsoft.azure.documentdb.sample.dao\\DocumentClientFactory.java，并将 HOST 和 MASTER_KEY 值替换为 Azure Cosmos DB 帐户的 URI 和主密钥，然后保存该文件。 有关详细信息，请参阅[步骤 1.创建 Azure Cosmos DB 数据库帐户](#CreateDB)。\r 12. 在“项目资源管理器”中，右键单击“azure-documentdb-java-sample”，并依次单击“生成路径”、“配置生成路径”。\r 13. 在“Java 生成路径”屏幕上，在右侧窗格中，选择“库”选项卡，并单击“添加外部 JAR”。 导航到 lombok.jar 文件的位置，并依次单击“打开”、“确定”。\r 14. 使用步骤 12 再次打开“属性”窗口，并在左窗格中单击“目标运行时”。\r 15. 在“目标运行时”屏幕上，单击“新建”，选择“Apache Tomcat v7.0”，并单击“确定”。\r 16. 使用步骤 12 再次打开“属性”窗口，并在左窗格中单击“项目方面”。\r 17. 在“项目方面”屏幕上，选择“动态 Web 模块”和“Java”，并单击“确定”。\r 18. 在此屏幕下面的“服务器”选项卡上，右键单击“localhost 上的 Tomcat v7.0 服务器”，并单击“添加和删除”。\r 19. 在“添加和删除”窗口中，将 azure-documentdb-java-sample 移到“配置”框，并单击“完成”。\r 20. 在“服务器”选项卡上，右键单击“localhost 上的 Tomcat v7.0 服务器”，并单击“重新启动”。\r 21. 在浏览器中，导航到 http://localhost:8080/azure-documentdb-java-sample/ 并开始在任务列表中添加条目。 请注意，如果更改了默认端口值，请将 8080 更改成选择的值。\r 22. 要将项目部署到 Azure 网站，请参阅[步骤 6.将应用程序部署到 Azure 网站](#Deploy)。\r \r [1]: media/documentdb-java-application/keys.png\r \r <!--Update_Description: update meta properties, wording update-->"}