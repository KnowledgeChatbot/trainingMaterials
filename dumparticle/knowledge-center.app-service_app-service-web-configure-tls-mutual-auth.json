{"Title":"如何为 Web 应用配置 TLS 相互身份验证","Description":"了解如何将 Web 应用配置为使用 TLS 客户端证书身份验证。","Content":"# <a name=\"how-to-configure-tls-mutual-authentication-for-web-app\"></a>如何为 Web 应用配置 TLS 相互身份验证\r \r [!INCLUDE [azure-sdk-developer-differences](../../includes/azure-sdk-developer-differences.md)]\r \r ## <a name=\"overview\"></a>概述\r 通过为 Azure Web 应用启用不同类型的身份验证可以限制对网站的访问。 执行此操作的方法之一是在通过 TLS/SSL 发送请求时使用客户端证书进行身份验证。 此机制称为 TLS 相互身份验证或客户端证书身份验证，本文将详细说明如何将 Web 应用设置为使用客户端证书身份验证。\r \r > \r > **注意：** 如果你通过 HTTP 而不是 HTTPS 访问你的站点，你不会收到任何客户端证书。 因此，如果应用程序需要客户端证书，则你不应允许通过 HTTP 对应用程序发出请求。\r > \r > \r \r [!INCLUDE [app-service-web-to-api-and-mobile](../../includes/app-service-web-to-api-and-mobile.md)]\r \r ## <a name=\"configure-web-app-for-client-certificate-authentication\"></a>将 Web 应用配置为使用客户端证书身份验证\r 要将 Web 应用设置为要求使用客户端证书，你需要为 Web 应用添加 clientCertEnabled 站点设置并将该设置指定为 true。 目前无法通过门户中的管理体验进行此设置，需要使用 REST API 来实现此目的。\r \r 可以使用 [ARMClient 工具](https://github.com/projectkudu/ARMClient) 轻松创建 REST API 调用。 使用该工具登录之后，需要发出以下命令：\r \r >[!NOTE]\r > 使用 `ARMClient.exe login [environment name]` 登录时，`[environment name]` 应该是 `MOONCAKE`。 换而言之，用于登录 Azure 中国区的命令为 `ARMClient.exe login MOONCAKE`。\r >\r >\r \r     ARMClient PUT subscriptions/{Subscription Id}/resourcegroups/{Resource Group Name}/providers/Microsoft.Web/sites/{Website Name}?api-version=2015-04-01 @enableclientcert.json -verbose\r \r 将 {} 中的所有内容替换为 Web 应用的信息，并创建包含以下 JSON 内容的 enableclientcert.json 文件：\r \r     {\r         \"location\": \"My Web App Location\",\r         \"properties\": {\r             \"clientCertEnabled\": true\r         }\r     }\r \r 确保将“location”的值更改为 Web 应用所在的位置，例如中国北部。\r \r > 注意：如果在 Powershell 中运行 ARMClient，必须使用重音符 ` 为 JSON 文件转义 @ 符号。\r > \r > \r \r ## <a name=\"accessing-the-client-certificate-from-your-web-app\"></a>从 Web 应用访问客户端证书\r 如果要使用 ASP.NET 并将应用配置为使用客户端证书身份验证，可通过 **HttpRequest.ClientCertificate** 属性使用证书。 对于其他应用程序堆栈，可以通过“X-ARR-ClientCert”请求标头中的 base64 编码值在应用中使用客户端证书。 应用程序可以基于此值创建证书，并将它用于应用程序中的身份验证和授权。\r \r ## <a name=\"special-considerations-for-certificate-validation\"></a>有关证书验证的特殊注意事项\r Azure Web 应用平台不会针对发送到应用程序的客户端证书进行任何验证。 验证此证书是 Web 应用的责任。 下面是为了进行身份验证而验证证书属性的示例 ASP.NET 代码。\r \r     using System;\r     using System.Collections.Specialized;\r     using System.Security.Cryptography.X509Certificates;\r     using System.Web;\r \r     namespace ClientCertificateUsageSample\r     {\r         public partial class cert : System.Web.UI.Page\r         {\r             public string certHeader = \"\";\r             public string errorString = \"\";\r             private X509Certificate2 certificate = null;\r             public string certThumbprint = \"\";\r             public string certSubject = \"\";\r             public string certIssuer = \"\";\r             public string certSignatureAlg = \"\";\r             public string certIssueDate = \"\";\r             public string certExpiryDate = \"\";\r             public bool isValidCert = false;\r \r             //\r             // Read the certificate from the header into an X509Certificate2 object\r             // Display properties of the certificate on the page\r             //\r             protected void Page_Load(object sender, EventArgs e)\r             {\r                 NameValueCollection headers = base.Request.Headers;\r                 certHeader = headers[\"X-ARR-ClientCert\"];\r                 if (!String.IsNullOrEmpty(certHeader))\r                 {\r                     try\r                     {\r                         byte[] clientCertBytes = Convert.FromBase64String(certHeader);\r                         certificate = new X509Certificate2(clientCertBytes);\r                         certSubject = certificate.Subject;\r                         certIssuer = certificate.Issuer;\r                         certThumbprint = certificate.Thumbprint;\r                         certSignatureAlg = certificate.SignatureAlgorithm.FriendlyName;\r                         certIssueDate = certificate.NotBefore.ToShortDateString() + \" \" + certificate.NotBefore.ToShortTimeString();\r                         certExpiryDate = certificate.NotAfter.ToShortDateString() + \" \" + certificate.NotAfter.ToShortTimeString();\r                     }\r                     catch (Exception ex)\r                     {\r                         errorString = ex.ToString();\r                     }\r                     finally \r                     {\r                         isValidCert = IsValidClientCertificate();\r                         if (!isValidCert) Response.StatusCode = 403;\r                         else Response.StatusCode = 200;\r                     }\r                 }\r                 else\r                 {\r                     certHeader = \"\";\r                 }\r             }\r \r             //\r             // This is a SAMPLE verification routine. Depending on your application logic and security requirements, \r             // you should modify this method\r             //\r             private bool IsValidClientCertificate()\r             {\r                 // In this example we will only accept the certificate as a valid certificate if all the conditions below are met:\r                 // 1. The certificate is not expired and is active for the current time on server.\r                 // 2. The subject name of the certificate has the common name nildevecc\r                 // 3. The issuer name of the certificate has the common name nildevecc and organization name Microsoft Corp\r                 // 4. The thumbprint of the certificate is 30757A2E831977D8BD9C8496E4C99AB26CB9622B\r                 //\r                 // This example does NOT test that this certificate is chained to a Trusted Root Authority (or revoked) on the server \r                 // and it allows for self signed certificates\r                 //\r \r                 if (certificate == null || !String.IsNullOrEmpty(errorString)) return false;\r \r                 // 1. Check time validity of certificate\r                 if (DateTime.Compare(DateTime.Now, certificate.NotBefore) < 0 || DateTime.Compare(DateTime.Now, certificate.NotAfter) > 0) return false;\r \r                 // 2. Check subject name of certificate\r                 bool foundSubject = false;\r                 string[] certSubjectData = certificate.Subject.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\r                 foreach (string s in certSubjectData)\r                 {\r                     if (String.Compare(s.Trim(), \"CN=nildevecc\") == 0)\r                     {\r                         foundSubject = true;\r                         break;\r                     }\r                 }\r                 if (!foundSubject) return false;\r \r                 // 3. Check issuer name of certificate\r                 bool foundIssuerCN = false, foundIssuerO = false;\r                 string[] certIssuerData = certificate.Issuer.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\r                 foreach (string s in certIssuerData)\r                 {\r                     if (String.Compare(s.Trim(), \"CN=nildevecc\") == 0)\r                     {\r                         foundIssuerCN = true;\r                         if (foundIssuerO) break;\r                     }\r \r                     if (String.Compare(s.Trim(), \"O=Microsoft Corp\") == 0)\r                     {\r                         foundIssuerO = true;\r                         if (foundIssuerCN) break;\r                     }\r                 }\r \r                 if (!foundIssuerCN || !foundIssuerO) return false;\r \r                 // 4. Check thumprint of certificate\r                 if (String.Compare(certificate.Thumbprint.Trim().ToUpper(), \"30757A2E831977D8BD9C8496E4C99AB26CB9622B\") != 0) return false;\r \r                 // If you also want to test if the certificate chains to a Trusted Root Authority you can uncomment the code below\r                 //\r                 //X509Chain certChain = new X509Chain();\r                 //certChain.Build(certificate);\r                 //bool isValidCertChain = true;\r                 //foreach (X509ChainElement chElement in certChain.ChainElements)\r                 //{\r                 //    if (!chElement.Certificate.Verify())\r                 //    {\r                 //        isValidCertChain = false;\r                 //        break;\r                 //    }\r                 //}\r                 //if (!isValidCertChain) return false;\r \r                 return true;\r             }\r         }\r     }"}