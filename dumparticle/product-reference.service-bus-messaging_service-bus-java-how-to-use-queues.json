{"Title":"如何通过 Java 使用服务总线队列","Description":"了解如何在 Azure 中使用服务总线队列。 用 Java 编写的代码示例。","Content":"# <a name=\"how-to-use-service-bus-queues-with-java\"></a>如何通过 Java 使用服务总线队列\r [!INCLUDE [service-bus-selector-queues](../../includes/service-bus-selector-queues.md)]\r \r 本文介绍了如何使用服务总线队列。 这些示例用 Java 编写并使用 [用于 Java 的 Azure SDK][用于 Java 的 Azure SDK]。 涉及的任务包括**创建队列**、**发送和接收消息**以及**删除队列**。\r \r [!INCLUDE [howto-service-bus-queues](../../includes/howto-service-bus-queues.md)]\r \r [!INCLUDE [service-bus-create-namespace-portal](../../includes/service-bus-create-namespace-portal.md)]\r \r ## <a name=\"configure-your-application-to-use-service-bus\"></a>配置应用程序以使用服务总线\r 在生成本示例之前，请确保已安装 [用于 Java 的 Azure SDK][用于 Java 的 Azure SDK]。 如果使用的是 Eclipse，则可以安装包含用于 Java 的 Azure SDK 的[用于 Eclipse 的 Azure 工具包][用于 Eclipse 的 Azure 工具包]。 然后，用户可以将 **Microsoft Azure Libraries for Java** 添加到项目：\r \r ![](./media/service-bus-java-how-to-use-queues/eclipselibs.png)\r \r 将以下 `import` 语句添加到 Java 文件顶部：\r \r ```java\r // Include the following imports to use Service Bus APIs\r import com.microsoft.windowsazure.services.servicebus.*;\r import com.microsoft.windowsazure.services.servicebus.models.*;\r import com.microsoft.windowsazure.core.*;\r import javax.xml.datatype.*;\r ```\r \r ## <a name=\"create-a-queue\"></a>创建队列\r \r 服务总线队列的管理操作可通过 **ServiceBusContract** 类执行。 **ServiceBusContract** 对象是使用封装了 SAS 令牌及用于管理其权限的适当配置构造的，而 **ServiceBusContract** 类是与 Azure 进行通信的单一点。\r \r **ServiceBusService** 类提供了创建、枚举和删除队列的方法。 以下示例演示了如何通过名为“HowToSample”的命名空间，使用 **ServiceBusService** 对象创建名为“TestQueue”的队列：\r \r ```java\r     Configuration config =\r         ServiceBusConfiguration.configureWithSASAuthentication(\r                 \"HowToSample\",\r                 \"RootManageSharedAccessKey\",\r                 \"SAS_key_value\",\r                 \".servicebus.chinacloudapi.cn\"\r                 );\r \r ServiceBusContract service = ServiceBusService.create(config);\r QueueInfo queueInfo = new QueueInfo(\"TestQueue\");\r try\r {\r     CreateQueueResult result = service.createQueue(queueInfo);\r }\r catch (ServiceException e)\r {\r     System.out.print(\"ServiceException encountered: \");\r     System.out.println(e.getMessage());\r     System.exit(-1);\r }\r ```\r \r 可对 **QueueInfo** 执行某些方法，以调整队列的属性（例如，将默认的生存时间 (TTL) 值设置为应用于发送到队列的消息）。 以下示例演示了如何创建最大大小为 5GB 且名为 `TestQueue` 的队列：\r \r ```java\r long maxSizeInMegabytes = 5120;\r QueueInfo queueInfo = new QueueInfo(\"TestQueue\");\r queueInfo.setMaxSizeInMegabytes(maxSizeInMegabytes);\r CreateQueueResult result = service.createQueue(queueInfo);\r ```\r \r 注意：可对 **ServiceBusContract** 对象使用 **listQueues** 方法来检查具有指定名称的队列在某个服务命名空间中是否已存在。\r \r ## <a name=\"send-messages-to-a-queue\"></a>向队列发送消息\r \r 要将消息发送到服务总线队列，应用程序将获得 **ServiceBusContract** 对象。 以下代码演示了如何将消息发送到先前在 `HowToSample` 命名空间中创建的 `TestQueue` 队列。\r \r ```java\r try\r {\r     BrokeredMessage message = new BrokeredMessage(\"MyMessage\");\r     service.sendQueueMessage(\"TestQueue\", message);\r }\r catch (ServiceException e) \r {\r     System.out.print(\"ServiceException encountered: \");\r     System.out.println(e.getMessage());\r     System.exit(-1);\r }\r ```\r \r 发送到服务总线队列以及从服务总线队列接收的消息是 [BrokeredMessage][BrokeredMessage] 类的实例。 [BrokeredMessage][BrokeredMessage] 对象包含一组标准属性（如 [Label](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.label#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) 和 [TimeToLive](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.timetolive#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)）、一个用来保存自定义应用程序特定属性的字典以及大量随机应用程序数据。 应用程序可通过将任何可序列化对象传入到 [BrokeredMessage][BrokeredMessage] 的构造函数中来设置消息的正文，然后将使用适当的序列化程序来序列化对象。 或者，可提供 **java.IO.InputStream** 对象。\r \r 以下示例演示了如何将五条测试消息发送到在前面的代码片段中获取的 `TestQueue` **MessageSender**：\r \r ```java\r for (int i=0; i<5; i++)\r {\r      // Create message, passing a string message for the body.\r      BrokeredMessage message = new BrokeredMessage(\"Test message \" + i);\r      // Set an additional app-specific property.\r      message.setProperty(\"MyProperty\", i); \r      // Send message to the queue\r      service.sendQueueMessage(\"TestQueue\", message);\r }\r ```\r \r 服务总线队列在标准层中支持的最大消息大小为 256 KB。 标头最大为 64 KB，其中包括标准和自定义应用程序属性。 一个队列可包含的消息数不受限制，但消息的总大小受限。 此队列大小是在创建时定义的，上限为 5 GB。\r \r ## <a name=\"receive-messages-from-a-queue\"></a>从队列接收消息\r \r 从队列接收消息的主要方法是使用 **ServiceBusContract** 对象。 收到的消息可在两种不同模式下工作：**ReceiveAndDelete** 和 **PeekLock**。\r \r 当使用 **ReceiveAndDelete** 模式时，接收是一项单次操作，即，服务总线接收到队列中某条消息的读取请求时，会将该消息标记为“已使用”并将其返回给应用程序。 **ReceiveAndDelete** 模式（默认模式）是最简单的模式，最适合应用程序可容忍出现故障时不处理消息的情景。 为了理解这一点，可以考虑这样一种情形：使用方发出接收请求，但在处理该请求前发生了崩溃。\r 由于服务总线会将消息标记为“已使用”，因此当应用程序重启并重新开始使用消息时，它会遗漏在发生崩溃前使用的消息。\r \r 在 **PeekLock** 模式下，接收变成了一个两阶段操作，从而有可能支持无法允许遗漏消息的应用程序。 当 Service Bus 收到请求时，它会查找下一条要使用的消息，锁定该消息以防其他使用者接收，并将该消息返回到应用程序。 应用程序完成消息处理（或可靠地存储消息以供将来处理）后，会通过对收到的消息调用 **Delete** 完成接收过程的第二个阶段。 服务总线发现 **Delete** 调用时，会将消息标记为“已使用”并将其从队列中删除。\r \r 以下示例演示如何使用 **PeekLock** 模式（非默认模式）接收和处理消息。 下面的示例执行无限循环并在消息到达我们的“TestQueue”后进行处理：\r \r ```java\r     try\r {\r     ReceiveMessageOptions opts = ReceiveMessageOptions.DEFAULT;\r     opts.setReceiveMode(ReceiveMode.PEEK_LOCK);\r \r     while(true)  { \r          ReceiveQueueMessageResult resultQM = \r                  service.receiveQueueMessage(\"TestQueue\", opts);\r         BrokeredMessage message = resultQM.getValue();\r         if (message != null && message.getMessageId() != null)\r         {\r             System.out.println(\"MessageID: \" + message.getMessageId());    \r             // Display the queue message.\r             System.out.print(\"From queue: \");\r             byte[] b = new byte[200];\r             String s = null;\r             int numRead = message.getBody().read(b);\r             while (-1 != numRead)\r             {\r                 s = new String(b);\r                 s = s.trim();\r                 System.out.print(s);\r                 numRead = message.getBody().read(b);\r             }\r             System.out.println();\r             System.out.println(\"Custom Property: \" + \r                 message.getProperty(\"MyProperty\"));\r             // Remove message from queue.\r             System.out.println(\"Deleting this message.\");\r             //service.deleteMessage(message);\r         }  \r         else  \r         {        \r             System.out.println(\"Finishing up - no more messages.\");        \r             break; \r             // Added to handle no more messages.\r             // Could instead wait for more messages to be added.\r         }\r     }\r }\r catch (ServiceException e) {\r     System.out.print(\"ServiceException encountered: \");\r     System.out.println(e.getMessage());\r     System.exit(-1);\r }\r catch (Exception e) {\r     System.out.print(\"Generic exception encountered: \");\r     System.out.println(e.getMessage());\r     System.exit(-1);\r }     \r ```\r \r ## <a name=\"how-to-handle-application-crashes-and-unreadable-messages\"></a>如何处理应用程序崩溃和不可读消息\r \r Service Bus 提供了相关功能来帮助你轻松地从应用程序错误或消息处理问题中恢复。 如果接收方应用程序出于某种原因无法处理消息，则其可以对收到的消息调用 **unlockMessage** 方法（而不是 **deleteMessage** 方法）。 这会导致服务总线解锁队列中的消息并使其能够重新被同一个正在使用的应用程序或其他正在使用的应用程序接收。\r \r 还存在与队列中已锁定消息关联的超时，并且如果应用程序无法在锁定超时到期之前处理消息（例如，如果应用程序崩溃），则服务总线将自动解锁该消息并使它可再次被接收。\r \r 如果在处理消息之后，发出 **deleteMessage** 请求之前，应用程序发生崩溃，则在应用程序重启时会将该消息重新传送给它。 此情况通常称作*至少处理一次*，即每条消息至少被处理一次，但在某些情况下，同一消息可能会被重新传送。 如果方案无法容忍重复处理，则应用程序开发人员应向其应用程序添加更多逻辑以处理重复消息传送。 通常可使用消息的 **getMessageId** 方法实现此操作，这在多个传送尝试中保持不变。\r \r ## <a name=\"next-steps\"></a>后续步骤\r 现在，已了解服务总线队列的基础知识，请参阅[队列、主题和订阅][Queues, topics, and subscriptions] 以获取更多信息。\r \r 有关详细信息，请参阅 [Java 开发人员中心](/develop/java/)。\r   [用于 Java 的 Azure SDK]: /develop/java/\r   [用于 Eclipse 的 Azure 工具包]: https://msdn.microsoft.com/zh-cn/library/azure/hh694271.aspx\r \r   [Queues, topics, and subscriptions]: ./service-bus-queues-topics-subscriptions.md\r   [BrokeredMessage]: https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.brokeredmessage\r \r <!--Update_Description:update meta properties and wording-->"}