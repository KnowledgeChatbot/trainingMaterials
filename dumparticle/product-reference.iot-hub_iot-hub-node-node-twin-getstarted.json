{"Title":"Azure IoT 中心设备孪生入门 (Node)","Description":"如何使用 Azure IoT 中心设备孪生添加标记，并使用 IoT 中心查询。 使用 Azure IoT SDK for Node.js 实现模拟设备应用，并实现可添加标记和运行 IoT 中心查询的服务应用。","Content":"# <a name=\"get-started-with-device-twins-node\"></a>设备孪生入门 (Node)\r \r [!INCLUDE [iot-hub-selector-twin-get-started](../../includes/iot-hub-selector-twin-get-started.md)]\r \r 在本教程结束时，将拥有两个 Node.js 控制台应用：\r \r * **AddTagsAndQuery.js**（Node.js 后端应用），用于添加标记和查询设备孪生。\r * TwinSimulatedDevice.js（Node.js 应用），用于模拟使用早先创建的设备标识连接到 IoT 中心的设备，并报告其连接状况。\r \r > [!NOTE]\r > [Azure IoT SDK][lnk-hub-sdks] 文章介绍了可用于构建设备和后端应用的 Azure IoT SDK。\r > \r > \r \r 若要完成本教程，需要满足以下条件：\r \r * Node.js 版本 4.0.x 或更高版本。\r \r + 有效的 Azure 帐户。（如果没有帐户，只需花费几分钟就能创建一个[帐户][lnk-free-trial]。）\r \r [!INCLUDE [iot-hub-get-started-create-hub](../../includes/iot-hub-get-started-create-hub.md)]\r \r [!INCLUDE [iot-hub-get-started-create-device-identity](../../includes/iot-hub-get-started-create-device-identity.md)]\r \r ## <a name=\"create-the-service-app\"></a>创建服务应用\r 在本部分中，将创建一个 Node.js 控制台应用，该应用将位置元数据添加到与 **myDeviceId** 关联的设备孪生。 然后，该应用将选择位于中国的设备来查询存储在 IoT 中心的设备孪生，然后查询报告移动电话网络连接的设备孪生。\r \r 1. 新建名为 **addtagsandqueryapp** 的空文件夹。在命令提示符下的 **addtagsandqueryapp** 文件夹中，使用以下命令创建新的 package.json 文件。接受所有默认值：\r \r     ```\r     npm init\r     ```\r 2. 在 **addtagsandqueryapp** 文件夹的命令提示符下，运行以下命令以安装 **azure-iothub** 包：\r    \r     ```\r     npm install azure-iothub --save\r     ```\r 3. 使用文本编辑器，在 **addtagsandqueryapp** 文件夹中创建一个新的 **AddTagsAndQuery.js** 文件。\r 4. 将以下代码添加到 **AddTagsAndQuery.js** 文件，并将 **{iot hub connection string}** 占位符替换为创建中心时复制的 IoT 中心连接字符串：\r \r     ```\r     'use strict';\r     var iothub = require('azure-iothub');\r     var connectionString = '{iot hub connection string}';\r     var registry = iothub.Registry.fromConnectionString(connectionString);\r \r     registry.getTwin('myDeviceId', function(err, twin){\r         if (err) {\r             console.error(err.constructor.name + ': ' + err.message);\r         } else {\r             var patch = {\r                 tags: {\r                     location: {\r                         region: 'CN',\r                         plant: 'Redmond43'\r                   }\r                 }\r             };\r \r             twin.update(patch, function(err) {\r               if (err) {\r                 console.error('Could not update twin: ' + err.constructor.name + ': ' + err.message);\r               } else {\r                 console.log(twin.deviceId + ' twin updated successfully');\r                 queryTwins();\r               }\r             });\r         }\r     });\r     ```\r \r     **Registry** 对象公开从服务与设备孪生进行交互所需的所有方法。 前面的代码首先初始化 **Registry** 对象，然后检索 **myDeviceId** 的设备孪生，最后使用所需位置信息更新其标记。\r    \r     更新标记后，它将调用 queryTwins 函数。\r 5. 在 **AddTagsAndQuery.js** 末尾添加以下代码以实现 **queryTwins** 函数：\r \r     ```\r     var queryTwins = function() {\r         var query = registry.createQuery(\"SELECT * FROM devices WHERE tags.location.plant = 'Redmond43'\", 100);\r         query.nextAsTwin(function(err, results) {\r             if (err) {\r                 console.error('Failed to fetch the results: ' + err.message);\r             } else {\r                 console.log(\"Devices in Redmond43: \" + results.map(function(twin) {return twin.deviceId}).join(','));\r             }\r         });\r \r         query = registry.createQuery(\"SELECT * FROM devices WHERE tags.location.plant = 'Redmond43' AND properties.reported.connectivity.type = 'cellular'\", 100);\r         query.nextAsTwin(function(err, results) {\r             if (err) {\r                 console.error('Failed to fetch the results: ' + err.message);\r             } else {\r                 console.log(\"Devices in Redmond43 using cellular network: \" + results.map(function(twin) {return twin.deviceId}).join(','));\r             }\r         });\r     };\r     ```\r \r     前面的代码执行两个查询：第一个只选择位于 **Redmond43** 工厂中的设备的设备孪生，第二个会优化查询以只选择还通过手机网络连接的设备。\r    \r     上面的代码创建 query 对象时，会指定返回的最大文档数。 **query** 对象包含 **hasMoreResults** 布尔值属性，可以使用它多次调用 **nextAsTwin** 方法来检索所有结果。 名为 next 的方法可用于非设备孪生的结果（例如聚合查询的结果）。\r 6. 使用以下内容运行应用程序：\r \r     ```\r     node AddTagsAndQuery.js\r     ```\r \r     在查询位于 **Redmond43** 的所有设备的查询结果中，应该会看到一个设备，而在将结果限制为使用蜂窝网络的设备的查询结果中没有任何设备。\r \r     ![][1]  \r \r 在下一部分中，创建的设备应用会报告连接信息，并更改上一部分中查询的结果。\r \r ## <a name=\"create-the-device-app\"></a>创建设备应用\r 在此部分，会创建一个 Node.js 控制台应用作为 **myDeviceId**连接到中心，并更新其设备孪生的报告属性，说明它是使用手机网络进行连接的。\r \r \r 1. 新建名为 **reportconnectivity** 的空文件夹。在 **reportconnectivity** 文件夹的命令提示符处，使用以下命令创建新的 package.json 文件。接受所有默认值：\r \r     ```\r     npm init\r     ```\r 2. 在 **reportconnectivity** 文件夹中，在命令提示符下运行以下命令以安装 **azure-iot-device** 包和 **azure-iot-device-mqtt** 包：\r \r     ```\r     npm install azure-iot-device azure-iot-device-mqtt --save\r     ```\r 3. 使用文本编辑器，在 **reportconnectivity** 文件夹中创建一个新的 **ReportConnectivity.js** 文件。\r 4. 将以下代码添加到 **ReportConnectivity.js** 文件，并将 **{device connection string}** 占位符替换为创建 **myDeviceId** 设备标识时复制的设备连接字符串：\r \r     ```\r     'use strict';\r     var Client = require('azure-iot-device').Client;\r     var Protocol = require('azure-iot-device-mqtt').Mqtt;\r \r     var connectionString = '{device connection string}';\r     var client = Client.fromConnectionString(connectionString, Protocol);\r \r     client.open(function(err) {\r     if (err) {\r         console.error('could not open IotHub client');\r     }  else {\r         console.log('client opened');\r \r         client.getTwin(function(err, twin) {\r         if (err) {\r             console.error('could not get twin');\r         } else {\r             var patch = {\r                 connectivity: {\r                     type: 'cellular'\r                 }\r             };\r \r             twin.properties.reported.update(patch, function(err) {\r                 if (err) {\r                     console.error('could not update twin');\r                 } else {\r                     console.log('twin state reported');\r                     process.exit();\r                 }\r             });\r         }\r         });\r     }\r     });\r     ```\r \r     **Client** 对象公开从该设备与设备孪生交互所需的所有方法。 上面的代码在初始化 **Client** 对象后会检索 **myDeviceId** 的设备孪生，并使用连接信息更新其报告属性。\r 5. 运行设备应用\r \r     ```\r     node ReportConnectivity.js\r     ```\r \r     此时会显示消息`twin state reported`。\r 6. 现在设备报告了其连接信息，应出现在两个查询中。 返回到 **addtagsandqueryapp** 文件夹，再次运行查询：\r \r     ```\r     node AddTagsAndQuery.js\r     ```\r \r     这次 **myDeviceId** 应出现在两个查询结果中。\r \r     ![][3]  \r \r ## <a name=\"next-steps\"></a>后续步骤\r 本教程中，在 Azure 门户中配置了新的 IoT 中心，并在 IoT 中心的标识注册表中创建了设备标识。 已从后端应用以标记形式添加了设备元数据，并编写了模拟的设备应用，用于报告设备孪生中的设备连接信息。 还学习了如何使用类似 SQL 的 IoT 中心查询语言来查询此信息。\r \r 充分利用以下资源：\r \r - 通过 [Get started with IoT Hub][lnk-iothub-getstarted]（IoT 中心入门）教程学习如何从设备发送遥测；\r - 通过[使用所需属性配置设备][lnk-twin-how-to-configure]教程学习如何使用设备孪生的所需属性配置设备；\r - 通过[使用直接方法][lnk-methods-tutorial]教程学习如何以交互方式控制设备（例如从用户控制的应用打开风扇）。\r \r <!-- images -->\r \r [1]: ./media/iot-hub-node-node-twin-getstarted/service1.png\r [3]: ./media/iot-hub-node-node-twin-getstarted/service2.png\r \r <!-- links -->\r \r [lnk-hub-sdks]: ./iot-hub-devguide-sdks.md\r [lnk-free-trial]: https://www.azure.cn/pricing/1rmb-trial/\r \r [lnk-d2c]: ./iot-hub-devguide-messaging.md#device-to-cloud-messages\r [lnk-methods]: ./iot-hub-devguide-direct-methods.md\r [lnk-twins]: ./iot-hub-devguide-device-twins.md\r [lnk-query]: ./iot-hub-devguide-query-language.md\r [lnk-identity]: ./iot-hub-devguide-identity-registry.md\r \r [lnk-iothub-getstarted]: ./iot-hub-node-node-getstarted.md\r [lnk-device-management]: ./iot-hub-node-node-device-management-get-started.md\r [lnk-iot-edge]: ./iot-hub-linux-iot-edge-get-started.md\r [lnk-connect-device]: /develop/iot/\r \r [lnk-twin-how-to-configure]: ./iot-hub-node-node-twin-how-to-configure.md\r [lnk-dev-setup]: https://github.com/Azure/azure-iot-sdk-node/tree/master/doc/node-devbox-setup.md\r \r [lnk-methods-tutorial]: ./iot-hub-node-node-direct-methods.md\r [lnk-devguide-mqtt]: ./iot-hub-mqtt-support.md\r \r <!--Update_Description:update wording and link references-->"}