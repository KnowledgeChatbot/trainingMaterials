{"Title":"通过使用 Web API 注册推送通知的当前用户","Description":"了解在 ASP.NET Web API 执行注册时如何在 iOS 应用程序中请求向 Azure 通知中心注册推送通知。","Content":"\r # 通过使用 ASP.NET 注册推送通知的当前用户\r \r > [!div class=\"op_single_selector\"]\r >- [iOS](./notification-hubs-ios-aspnet-register-user-from-backend-to-push-notification.md)\r \r ## 概述\r \r 本主题演示在 ASP.NET Web API 执行注册时如何请求向 Azure 通知中心注册推送通知。本主题是对教程[使用通知中心通知用户]的扩展。你必须在该教程中已完成创建经过身份验证的移动服务所需的步骤。有关通知用户方案的详细信息，请参阅[使用通知中心通知用户]。\r \r ## 更新应用程序  \r \r 1. 在 MainStoryboard\\_iPhone.storyboard 中，从对象库添加以下组件：\r \r     + **标签**：“使用通知中心推送到用户”\r     + **标签**：\"InstallationId\"\r     + **标签**：“用户”\r     + **文本字段**：“用户”\r     + **标签**：“密码”\r     + **文本字段**：“密码”\r     + **按钮**：“登录”\r \r     此时，你的 Storyboard 应与下图类似：\r \r     ![][0]\r \r 2. 在助手编辑器中，创建所有带开关的控件的容器并调用它们，连接文本字段与视图控制器（委派），并创建“登录”按钮的“操作”。\r \r     ![][1]\r \r     BreakingNewsViewController.h 文件现在应包含以下代码：\r \r     ```\r     @property (weak, nonatomic) IBOutlet UILabel *installationId;\r     @property (weak, nonatomic) IBOutlet UITextField *User;\r     @property (weak, nonatomic) IBOutlet UITextField *Password;\r \r     - (IBAction)login:(id)sender;\r     ```\r 5. 创建名为 **DeviceInfo** 的类，将以下代码复制到 DeviceInfo.h 文件的接口部分：\r \r     ```\r     @property (readonly, nonatomic) NSString* installationId;\r     @property (nonatomic) NSData* deviceToken;\r     ```\r \r 6. 在文件 DeviceInfo.m 的实现部分中复制以下代码：\r \r     ```\r         @synthesize installationId = _installationId;\r \r         - (id)init {\r             if (!(self = [super init]))\r                 return nil;\r \r             NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];\r             _installationId = [defaults stringForKey:@\"PushToUserInstallationId\"];\r             if(!_installationId) {\r                 CFUUIDRef newUUID = CFUUIDCreate(kCFAllocatorDefault);\r                 _installationId = (__bridge_transfer NSString *)CFUUIDCreateString(kCFAllocatorDefault, newUUID);\r                 CFRelease(newUUID);\r \r                 //store the install ID so we don't generate a new one next time\r                 [defaults setObject:_installationId forKey:@\"PushToUserInstallationId\"];\r                 [defaults synchronize];\r             }\r \r             return self;\r         }\r \r         - (NSString*)getDeviceTokenInHex {\r             const unsigned *tokenBytes = [[self deviceToken] bytes];\r             NSString *hexToken = [NSString stringWithFormat:@\"%08X%08X%08X%08X%08X%08X%08X%08X\",\r                                   ntohl(tokenBytes[0]), ntohl(tokenBytes[1]), ntohl(tokenBytes[2]),\r                                   ntohl(tokenBytes[3]), ntohl(tokenBytes[4]), ntohl(tokenBytes[5]),\r                                   ntohl(tokenBytes[6]), ntohl(tokenBytes[7])];\r             return hexToken;\r         }\r     ```\r \r 7. 在 PushToUserAppDelegate.h 中，添加以下单一属性：\r \r     ```\r     @property (strong, nonatomic) DeviceInfo* deviceInfo;\r     ```\r \r 8. 在 PushToUserAppDelegate.m 的 **didFinishLaunchingWithOptions** 方法中，添加以下代码：\r \r     ```\r     self.deviceInfo = [[DeviceInfo alloc] init];\r \r     [[UIApplication sharedApplication] registerForRemoteNotificationTypes: UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound];\r     ```\r \r     第一行初始化 **DeviceInfo** 单一实例。第二行启动推送通知的注册，前提是你已完成[通知中心入门]教程的学习。\r \r 9. 在 PushToUserAppDelegate.m 的 AppDelegate 中实现 **didRegisterForRemoteNotificationsWithDeviceToken** 方法并添加以下代码：\r \r     ```\r     self.deviceInfo.deviceToken = deviceToken;\r     ```\r \r     这为请求设置设备标记。\r \r     > [!NOTE]\r     > 此时，此方法中不应有任何其他代码。如果你已调用在完成[通知中心入门](./notification-hubs-ios-apple-push-notification-apns-get-started.md)教程的学习时添加的 **registerNativeWithDeviceToken** 方法，必须注释掉或删除该调用。\r \r 10. 在 PushToUserAppDelegate.m 文件中，添加以下处理程序方法：\r \r     ```\r     - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo {\r         NSLog(@\"%@\", userInfo);\r         UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@\"Notification\" message:\r                               [userInfo objectForKey:@\"inAppMessage\"] delegate:nil cancelButtonTitle:\r                               @\"OK\" otherButtonTitles:nil, nil];\r         [alert show];\r     }\r     ```\r \r      当你的应用程序接收到它正在运行的通知时，此方法将在 UI 中显示一个警报。\r \r 9. 打开 PushToUserViewController.m 文件，并在以下实现中返回键盘：\r \r     ```\r     - (BOOL)textFieldShouldReturn:(UITextField *)theTextField {\r         if (theTextField == self.User || theTextField == self.Password) {\r             [theTextField resignFirstResponder];\r         }\r         return YES;\r     }\r     ```\r \r 9. 在 PushToUserViewController.m 文件的 **viewDidLoad** 方法中，按以下方式初始化 installationId 标签：\r \r     ```\r     DeviceInfo* deviceInfo = [(PushToUserAppDelegate*)[[UIApplication sharedApplication]delegate] deviceInfo];\r     Self.installationId.text = deviceInfo.installationId;\r     ```\r \r 10. 在 PushToUserViewController.m 的接口部分中添加以下属性：\r \r     ```\r     @property (readonly) NSOperationQueue* downloadQueue;\r     - (NSString*)base64forData:(NSData*)theData;\r     ```\r \r 11. 然后，添加以下实现：\r \r     ```\r         - (NSOperationQueue *)downloadQueue {\r             if (!_downloadQueue) {\r                 _downloadQueue = [[NSOperationQueue alloc] init];\r                 _downloadQueue.name = @\"Download Queue\";\r                 _downloadQueue.maxConcurrentOperationCount = 1;\r             }\r             return _downloadQueue;\r         }\r \r         // base64 encoding\r         - (NSString*)base64forData:(NSData*)theData\r         {\r             const uint8_t* input = (const uint8_t*)[theData bytes];\r             NSInteger length = [theData length];\r \r             static char table[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r \r             NSMutableData* data = [NSMutableData dataWithLength:((length + 2) / 3) * 4];\r             uint8_t* output = (uint8_t*)data.mutableBytes;\r \r             NSInteger i;\r             for (i=0; i < length; i += 3) {\r                 NSInteger value = 0;\r                 NSInteger j;\r                 for (j = i; j < (i + 3); j++) {\r                     value <<= 8;\r \r                     if (j < length) {\r                         value |= (0xFF & input[j]);\r                     }\r                 }\r \r                 NSInteger theIndex = (i / 3) * 4;\r                 output[theIndex + 0] =                    table[(value >> 18) & 0x3F];\r                 output[theIndex + 1] =                    table[(value >> 12) & 0x3F];\r                 output[theIndex + 2] = (i + 1) < length ? table[(value >> 6)  & 0x3F] : '=';\r                 output[theIndex + 3] = (i + 2) < length ? table[(value >> 0)  & 0x3F] : '=';\r             }\r \r             return [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding];\r         }\r     ```\r \r 12. 将以下代码复制到由 XCode 创建的 **login** 处理程序方法：\r \r     ```\r         DeviceInfo* deviceInfo = [(PushToUserAppDelegate*)[[UIApplication sharedApplication]delegate] deviceInfo];\r \r         // build JSON\r         NSString* json = [NSString stringWithFormat:@\"{\"platform\":\"ios\", \"instId\":\"%@\", \"deviceToken\":\"%@\"}\", deviceInfo.installationId, [deviceInfo getDeviceTokenInHex]];\r \r         // build auth string\r         NSString* authString = [NSString stringWithFormat:@\"%@:%@\", self.User.text, self.Password.text];\r \r         NSMutableURLRequest* request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://nhnotifyuser.azurewebsites.net/api/register\"]];\r         [request setHTTPMethod:@\"POST\"];\r         [request setHTTPBody:[json dataUsingEncoding:NSUTF8StringEncoding]];\r         [request addValue:[@([json lengthOfBytesUsingEncoding:NSUTF8StringEncoding]) description] forHTTPHeaderField:@\"Content-Length\"];\r         [request addValue:@\"application/json\" forHTTPHeaderField:@\"Content-Type\"];\r         [request addValue:[NSString stringWithFormat:@\"Basic %@\",[self base64forData:[authString dataUsingEncoding:NSUTF8StringEncoding]]] forHTTPHeaderField:@\"Authorization\"];\r \r         // connect with POST\r         [NSURLConnection sendAsynchronousRequest:request queue:[self downloadQueue] completionHandler:^(NSURLResponse* response, NSData* data, NSError* error) {\r             // add UIAlert depending on response.\r             if (error != nil) {\r                 NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*)response;\r                 if ([httpResponse statusCode] == 200) {\r                     UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@\"Back-end registration\" message:@\"Registration successful\" delegate:nil cancelButtonTitle: @\"OK\" otherButtonTitles:nil, nil];\r                     [alert show];\r                 } else {\r                     NSLog(@\"status: %ld\", (long)[httpResponse statusCode]);\r                 }\r             } else {\r                 NSLog(@\"error: %@\", error);\r             }\r         }];\r     ```\r \r     此方法获取一个安装 ID 和用于推送通知的通道并将它与设备类型一起发送到在通知中心创建注册的已经身份验证的 Web API 方法。此 Web API 已在[使用通知中心通知用户]中定义。\r \r 现在客户端应用程序已更新，请返回到[使用通知中心通知用户]并更新移动服务以使用通知中心发送通知。\r \r <!-- Anchors. -->\r \r <!-- Images. -->\r [0]: ./media/notification-hubs-ios-aspnet-register-user-push-notifications/notification-hub-user-aspnet-ios1.png\r [1]: ./media/notification-hubs-ios-aspnet-register-user-push-notifications/notification-hub-user-aspnet-ios2.png\r \r <!-- URLs. -->\r [使用通知中心通知用户]: ./notification-hubs-aspnet-backend-windows-dotnet-wns-notification.md\r \r [通知中心入门]: ./notification-hubs-ios-apple-push-notification-apns-get-started.md\r \r <!---HONumber=Mooncake_Quality_Review_0125_2017-->"}