{"Title":"为 Azure 微服务创建混沌和故障转移测试","Description":"使用 Service Fabric 混沌测试和故障转移测试方案来引入故障，然后验证服务的可靠性。","Content":"\r # 可测试性方案\r 大型分布式系统，例如云基础结构，在本质上都是不可靠的。Azure Service Fabric 使开发人员能够编写出可以在不可靠基础结构上运行的服务。若要编写高质量的服务，开发人员需要能够引入这种不可靠的基础结构来测试其服务的稳定性。\r \r 故障分析服务使开发人员能够引入故障操作，在存在故障的情况下测试服务。然而，定向模拟故障只能做到这种程度。若要进一步测试，可以使用 Service Fabric 中的测试方案：混沌测试和故障转移测试。这些方案在整个群集模拟连续交叉出现的故障，包括常规故障和非常规故障，时间跨度很长。为测试配置故障率和故障类型后，就可以通过 C# API 或 PowerShell 启动该测试，以在群集和服务中生成故障。\r \r > [!WARNING]\r ChaosTestScenario 将被更具弹性的、基于服务的混沌测试取代。有关更多详细信息，请参阅新文章：[受控的混沌测试](./service-fabric-controlled-chaos.md)。\r > \r > \r \r ## 混沌测试\r 混沌方案跨整个 Service Fabric 群集生成故障。一般而言，该方案将几个月或几年经历的故障压缩到几小时。各种交叉故障的组合并具有高故障率，能够找出很有可能被忽视的极端状况。这会使服务的代码质量得到显著提高。\r \r ### 在混沌测试中模拟的故障\r  - 重新启动节点\r  - 重新启动已部署的代码包\r  - 删除副本\r  - 重新启动副本\r  - 移动主副本（可选）\r  - 移动辅助副本（可选）\r \r 混沌测试在指定时间段内运行故障和群集验证的多次循环。让群集达到稳定状态以及验证成功所用的时间也是可配置的。若在群集验证中遇到故障，则方案失败。\r \r 例如，考虑一个设置为运行一小时且最多三个并发故障的测试。该测试将引入三个故障，然后验证群集运行状况。该测试将重复进行以上步骤，直到群集变得不正常或一小时的时间已过。如果在任何一次迭代中群集变得不正常，即在配置的时间内不稳定，则测试将引发异常而失败。此异常指出系统出现问题，并且需要进一步调查。\r \r 当前，混沌测试故障生成引擎只引入安全故障。这意味着在没有外部故障的情况下，绝对不会出现仲裁丢失或数据丢失。\r \r ### 重要的配置选项\r  - **TimeToRun**：测试在成功完成之前将要运行的总时间。测试也可以提前完成来代替验证失败。\r  - **MaxClusterStabilizationTimeout**：在测试失败之前，等待群集变得正常的最长时间。执行的检查包括群集运行状况是否正常、服务运行状况是否正常、对于服务分区而言目标副本集是否达到设定的大小以及是否不存在 InBuild 副本。\r  - **MaxConcurrentFaults**：每次循环中并发故障的最大数量。数字越大，测试越激进，从而导致更复杂的故障转移和转换组合。在没有外部故障的情况下，测试保证不管此配置有多高，都不会出现仲裁丢失或数据丢失。\r  - **EnableMoveReplicaFaults**：启用或禁用导致主副本或辅助副本移动的故障。默认情况下，这些故障处于禁用状态。\r  - **WaitTimeBetweenIterations**：循环之间（即在一轮故障和对应的验证之后）等待的时间量。\r \r ### 如何运行混沌测试\r C# 示例\r \r ```csharp\r using System;\r using System.Fabric;\r using System.Fabric.Testability.Scenario;\r using System.Threading;\r using System.Threading.Tasks;\r \r class Test\r {\r     public static int Main(string[] args)\r     {\r         string clusterConnection = \"localhost:19000\";\r \r         Console.WriteLine(\"Starting Chaos Test Scenario...\");\r         try\r         {\r             RunChaosTestScenarioAsync(clusterConnection).Wait();\r         }\r         catch (AggregateException ae)\r         {\r             Console.WriteLine(\"Chaos Test Scenario did not complete: \");\r             foreach (Exception ex in ae.InnerExceptions)\r             {\r                 if (ex is FabricException)\r                 {\r                     Console.WriteLine(\"HResult: {0} Message: {1}\", ex.HResult, ex.Message);\r                 }\r             }\r             return -1;\r         }\r \r         Console.WriteLine(\"Chaos Test Scenario completed.\");\r         return 0;\r     }\r \r     static async Task RunChaosTestScenarioAsync(string clusterConnection)\r     {\r         TimeSpan maxClusterStabilizationTimeout = TimeSpan.FromSeconds(180);\r         uint maxConcurrentFaults = 3;\r         bool enableMoveReplicaFaults = true;\r \r         // Create FabricClient with connection and security information here.\r         FabricClient fabricClient = new FabricClient(clusterConnection);\r \r         // The chaos test scenario should run at least 60 minutes or until it fails.\r         TimeSpan timeToRun = TimeSpan.FromMinutes(60);\r         ChaosTestScenarioParameters scenarioParameters = new ChaosTestScenarioParameters(\r           maxClusterStabilizationTimeout,\r           maxConcurrentFaults,\r           enableMoveReplicaFaults,\r           timeToRun);\r \r         // Other related parameters:\r         // Pause between two iterations for a random duration bound by this value.\r         // scenarioParameters.WaitTimeBetweenIterations = TimeSpan.FromSeconds(30);\r         // Pause between concurrent actions for a random duration bound by this value.\r         // scenarioParameters.WaitTimeBetweenFaults = TimeSpan.FromSeconds(10);\r \r         // Create the scenario class and execute it asynchronously.\r         ChaosTestScenario chaosScenario = new ChaosTestScenario(fabricClient, scenarioParameters);\r \r         try\r         {\r             await chaosScenario.ExecuteAsync(CancellationToken.None);\r         }\r         catch (AggregateException ae)\r         {\r             throw ae.InnerException;\r         }\r     }\r }\r ```\r \r PowerShell\r \r ```powershell\r $connection = \"localhost:19000\"\r $timeToRun = 60\r $maxStabilizationTimeSecs = 180\r $concurrentFaults = 3\r $waitTimeBetweenIterationsSec = 60\r \r Connect-ServiceFabricCluster $connection\r \r Invoke-ServiceFabricChaosTestScenario -TimeToRunMinute $timeToRun -MaxClusterStabilizationTimeoutSec $maxStabilizationTimeSecs -MaxConcurrentFaults $concurrentFaults -EnableMoveReplicaFaults -WaitTimeBetweenIterationsSec $waitTimeBetweenIterationsSec\r ```\r \r ##<a name=\"failover-test\"></a> 故障转移测试\r \r 故障转移测试方案是混沌测试方案针对特定服务分区的一个版本。它在特定服务分区上测试故障转移的效果，同时不影响其他服务。配置好目标分区信息和其他参数后，它就可以作为一个客户端工具运行，使用 C# API 或 PowerShell 生成针对一个服务分区的故障。该方案重复一系列的模块故障和服务验证，同时业务逻辑在一边继续运行以提供工作负荷。服务验证失败指出存在需要进一步调查的问题。\r \r ### 在故障转移测试中模拟的故障\r - 重新启动分区所在的已部署代码包\r - 删除主/辅助副本或无状态实例\r - 重新启动主/辅助副本（如果是持久化服务）\r - 移动主副本\r - 移动辅助副本\r - 重新启动分区\r \r 故障转移测试工作引入所选的故障，然后在服务上运行验证以确保其稳定性。与混沌测试中可能出现多个故障相比，故障转移测试一次仅引入一个故障。如果每次故障之后，服务分区在配置的等待时间内没有达到稳定，则测试失败。测试只引入安全的故障。这意味着在没有外部故障的情况下，将不会出现仲裁丢失或数据丢失。\r \r ### 重要的配置选项\r  - **PartitionSelector**：选择器对象，指定需要作为目标的分区。\r  - **TimeToRun**：测试在完成之前将要运行的总时间。\r  - **MaxServiceStabilizationTimeout**：在测试失败之前，等待群集变得正常的最长时间。执行的检查包括服务运行状况是否正常、对于所有分区而言目标副本集是否达到设定的大小以及是否不存在 InBuild 副本。\r  - **WaitTimeBetweenFaults**：每次故障和验证循环之间等待的时间量。\r \r ### 如何运行故障转移测试\r \r **C#**\r \r ```csharp\r using System;\r using System.Fabric;\r using System.Fabric.Testability.Scenario;\r using System.Threading;\r using System.Threading.Tasks;\r \r class Test\r {\r     public static int Main(string[] args)\r     {\r         string clusterConnection = \"localhost:19000\";\r         Uri serviceName = new Uri(\"fabric:/samples/PersistentToDoListApp/PersistentToDoListService\");\r \r         Console.WriteLine(\"Starting Chaos Test Scenario...\");\r         try\r         {\r             RunFailoverTestScenarioAsync(clusterConnection, serviceName).Wait();\r         }\r         catch (AggregateException ae)\r         {\r             Console.WriteLine(\"Chaos Test Scenario did not complete: \");\r             foreach (Exception ex in ae.InnerExceptions)\r             {\r                 if (ex is FabricException)\r                 {\r                     Console.WriteLine(\"HResult: {0} Message: {1}\", ex.HResult, ex.Message);\r                 }\r             }\r             return -1;\r         }\r \r         Console.WriteLine(\"Chaos Test Scenario completed.\");\r         return 0;\r     }\r \r     static async Task RunFailoverTestScenarioAsync(string clusterConnection, Uri serviceName)\r     {\r         TimeSpan maxServiceStabilizationTimeout = TimeSpan.FromSeconds(180);\r         PartitionSelector randomPartitionSelector = PartitionSelector.RandomOf(serviceName);\r \r         // Create FabricClient with connection and security information here.\r         FabricClient fabricClient = new FabricClient(clusterConnection);\r \r         // The chaos test scenario should run at least 60 minutes or until it fails.\r         TimeSpan timeToRun = TimeSpan.FromMinutes(60);\r         FailoverTestScenarioParameters scenarioParameters = new FailoverTestScenarioParameters(\r           randomPartitionSelector,\r           timeToRun,\r           maxServiceStabilizationTimeout);\r \r         // Other related parameters:\r         // Pause between two iterations for a random duration bound by this value.\r         // scenarioParameters.WaitTimeBetweenIterations = TimeSpan.FromSeconds(30);\r         // Pause between concurrent actions for a random duration bound by this value.\r         // scenarioParameters.WaitTimeBetweenFaults = TimeSpan.FromSeconds(10);\r \r         // Create the scenario class and execute it asynchronously.\r         FailoverTestScenario failoverScenario = new FailoverTestScenario(fabricClient, scenarioParameters);\r \r         try\r         {\r             await failoverScenario.ExecuteAsync(CancellationToken.None);\r         }\r         catch (AggregateException ae)\r         {\r             throw ae.InnerException;\r         }\r     }\r }\r ```\r \r **PowerShell**\r \r ```powershell\r $connection = \"localhost:19000\"\r $timeToRun = 60\r $maxStabilizationTimeSecs = 180\r $waitTimeBetweenFaultsSec = 10\r $serviceName = \"fabric:/SampleApp/SampleService\"\r \r Connect-ServiceFabricCluster $connection\r \r Invoke-ServiceFabricFailoverTestScenario -TimeToRunMinute $timeToRun -MaxServiceStabilizationTimeoutSec $maxStabilizationTimeSecs -WaitTimeBetweenFaultsSec $waitTimeBetweenFaultsSec -ServiceName $serviceName -PartitionKindSingleton\r ```\r \r <!---HONumber=Mooncake_0227_2017-->\r <!--Update_Description: add warning to chaos test-->"}