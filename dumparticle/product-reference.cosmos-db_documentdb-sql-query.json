{"Title":"Azure Cosmos DB DocumentDB API 的 SQL 查询","Description":"了解 Azure Cosmos DB 的 SQL 语法、数据库概念和 SQL 查询。 SQL 可在 Azure Cosmos DB 中作为 JSON 查询语言使用。","Content":"# <a name=\"sql-queries-for-azure-cosmos-db-documentdb-api\"></a>Azure Cosmos DB DocumentDB API 的 SQL 查询\r Azure Cosmos DB 通过将 SQL（结构化查询语言）用作 JSON 查询语言来支持查询文档。 Cosmos DB 是真正无架构的。 凭借其对数据库引擎内 JSON 数据模型的直接承诺，它可以提供 JSON 文档的自动索引，而无需显式架构或创建辅助索引。 \r \r 在设计 Cosmos DB 的查询语言时，我们有两个目标：\r \r * 我们希望支持 SQL，而不是发明一种新的 JSON 查询语言。 SQL 是最常见和最常用的查询语言之一。 Cosmos DB SQL 提供一种正式的编程模型，用于对 JSON 文档进行丰富的查询。\r * 由于 JSON 文档数据库能够在数据库引擎中直接执行 JavaScript，我们希望将 JavaScript 的编程模型用作查询语言的基础。 DocumentDB API SQL 植根于 JavaScript 的类型系统、表达式计算和函数调用中。 而这反过来为关系投影、跨 JSON 文档的分层导航、自联接、空间查询以及调用完全采用 JavaScript 编写的用户定义的函数 (UDF) 和其他功能提供了自然编程模型。 \r \r 我们相信这些功能是减少应用程序和数据库之间冲突的关键，并且对于开发人员的工作效率来说是至关重要的。\r \r <!-- Not Available [!VIDEO https://channel9.msdn.com/Shows/Data-Exposed/DataExposedQueryingDocumentDB/player] -->\r \r 然后，返回到本文中，我们将从 SQL 查询教程开始，指导完成一些简单的 JSON 文档和 SQL 命令。\r \r ## <a name=\"GettingStarted\"></a>Cosmos DB 中的 SQL 命令入门\r 为了解 Cosmos DB SQL 在工作时的情况，让我们以一些简单的 JSON 文档开始，并对它完成一些简单的查询。 考虑以下两个关于两个家庭的 JSON 文档。 使用 Cosmos DB 时不需要显式创建任何架构或辅助索引。 只需将 JSON 文档插入 Cosmos DB 集合中并随后进行查询。 这里，我们有一个包含 Andersen 家庭、父母、子女（以及他们的宠物）、地址和注册信息的简单 JSON 文档。 该文档拥有字符串、数字、布尔、数组和嵌套属性。 \r \r **文档**  \r \r ```JSON\r {\r   \"id\": \"AndersenFamily\",\r   \"lastName\": \"Andersen\",\r   \"parents\": [\r      { \"firstName\": \"Thomas\" },\r      { \"firstName\": \"Mary Kay\"}\r   ],\r   \"children\": [\r      {\r          \"firstName\": \"Henriette Thaulow\", \r          \"gender\": \"female\", \r          \"grade\": 5,\r          \"pets\": [{ \"givenName\": \"Fluffy\" }]\r      }\r   ],\r   \"address\": { \"state\": \"WA\", \"county\": \"King\", \"city\": \"seattle\" },\r   \"creationDate\": 1431620472,\r   \"isRegistered\": true\r }\r ```\r \r 下面是另一个有着细微差异的文档 — 使用了 `givenName` 和 `familyName`，而不是 `firstName` 和 `lastName`。\r \r **文档**  \r \r ```json\r {\r   \"id\": \"WakefieldFamily\",\r   \"parents\": [\r       { \"familyName\": \"Wakefield\", \"givenName\": \"Robin\" },\r       { \"familyName\": \"Miller\", \"givenName\": \"Ben\" }\r   ],\r   \"children\": [\r       {\r         \"familyName\": \"Merriam\", \r         \"givenName\": \"Jesse\", \r         \"gender\": \"female\", \"grade\": 1,\r         \"pets\": [\r             { \"givenName\": \"Goofy\" },\r             { \"givenName\": \"Shadow\" }\r         ]\r       },\r       { \r         \"familyName\": \"Miller\", \r          \"givenName\": \"Lisa\", \r          \"gender\": \"female\", \r          \"grade\": 8 }\r   ],\r   \"address\": { \"state\": \"NY\", \"county\": \"Manhattan\", \"city\": \"NY\" },\r   \"creationDate\": 1431620462,\r   \"isRegistered\": false\r }\r ```\r \r 现在尝试对此数据执行一些查询，了解 DocumentDB API SQL 的一些主要方面。 例如，以下查询返回其中的 ID 字段与 `AndersenFamily` 匹配的文档。 由于它是 `SELECT *`，因此该查询的输出为完整的 JSON 文档：\r \r **查询**\r \r     SELECT * \r     FROM Families f \r     WHERE f.id = \"AndersenFamily\"\r \r **结果**\r \r     [{\r         \"id\": \"AndersenFamily\",\r         \"lastName\": \"Andersen\",\r         \"parents\": [\r            { \"firstName\": \"Thomas\" },\r            { \"firstName\": \"Mary Kay\"}\r         ],\r         \"children\": [\r            {\r                \"firstName\": \"Henriette Thaulow\", \"gender\": \"female\", \"grade\": 5,\r                \"pets\": [{ \"givenName\": \"Fluffy\" }]\r            }\r         ],\r         \"address\": { \"state\": \"WA\", \"county\": \"King\", \"city\": \"seattle\" },\r         \"creationDate\": 1431620472,\r         \"isRegistered\": true\r     }]\r \r 现在，考虑我们需要将 JSON 输出的格式重新设置为另一种不同的形式。 地址的城市名称与省/自治区/直辖市名称相同时，此查询使用两个选定的字段 Name 和 City 表示新的 JSON 对象。 在这种情况下，“NY, NY”匹配。\r \r **查询**    \r \r     SELECT {\"Name\":f.id, \"City\":f.address.city} AS Family \r     FROM Families f \r     WHERE f.address.city = f.address.state\r \r **结果**\r \r     [{\r         \"Family\": {\r             \"Name\": \"WakefieldFamily\", \r             \"City\": \"NY\"\r         }\r     }]\r \r 下一个查询返回 ID与按居住城市排序的 `WakefieldFamily` 匹配的家庭中所有子女的给定名称。\r \r **查询**\r \r     SELECT c.givenName \r     FROM Families f \r     JOIN c IN f.children \r     WHERE f.id = 'WakefieldFamily'\r     ORDER BY f.address.city ASC\r \r **结果**\r \r     [\r       { \"givenName\": \"Jesse\" }, \r       { \"givenName\": \"Lisa\"}\r     ]\r \r 我们希望通过我们目前已看到的示例来突出 Cosmos DB 查询语言一些值得注意的方面：  \r \r * 由于 DocumentDB API SQL 适用于 JSON 值，因此它可以处理三种形式的实体，而不是行和列。 因此，使用该语言可在任意深度引用树的节点，如 `Node1.Node2.Node3…..Nodem`，这类似于引用 `<table>.<column>` 的两个部分引用的关系型 SQL。   \r * 结构化查询语言适用于无架构的数据。 因此，需要动态绑定类型系统。 相同的表达式在不同文档上可能会产生不同的类型。 查询的结果是一个有效的 JSON 值，但不保证它为固定的架构。  \r * Cosmos DB 仅支持严格的 JSON 文档。 这意味着类型系统和表达式仅限于处理 JSON 类型。 有关更多详细信息，请参阅 [JSON 规范](http://www.json.org/)。  \r * Cosmos DB 集合是 JSON 文档的一个无架构容器。 集合中，文档内和跨文档的数据实体的关系是按包含关系隐式捕获的，而不是按主键和外键关系。 考虑到稍后会在本文中讨论文档内联接，因此这是一个值得注意的重要方面。\r \r ## <a name=\"Indexing\"></a> Cosmos DB 索引\r 了解 DocumentDB API SQL 语法前，有必要先了解 Cosmos DB 中的索引设计。 \r \r 数据库索引的目的是在提供良好的吞吐量和低延迟的同时，以最小的资源消耗（如 CPU 和输入/输出）提供各种形式的查询。 通常，为查询数据库选择正确的索引需要大量的计划和试验。 此方法对数据不符合严格的架构并且快速发展的无架构数据库来说是一个挑战。 \r \r 因此，设计 Cosmos DB 索引子系统时，我们设定了以下目标：\r \r * 在无需架构的情况下索引文档：索引子系统不需要任何架构信息或对文档的架构做出任何假设。 \r * 支持高效、层次丰富的关系查询：索引高效地支持 Cosmos DB 查询语言，包括支持分层和关系投影。\r * 持续大量写入时支持一致的查询：对于使用一致的查询的高写入吞吐量工作负荷，在持续大量写入时可逐步、高效地联机更新索引。 一致的索引更新对在用户配置文档服务的一致性级别进行查询来说是至关重要的。\r * 支持多租户：在为跨租户的资源调控给定基于保留的模型的情况下，可以在为每个副本分配的系统资源（CPU、内存和每秒的输入/输出操作）的预算内执行索引更新。 \r * 存储效率：就成本效益而言，在磁盘上存储索引的开销是有限的，并且是可预测的。 这一点非常重要，因为 Cosmos DB 允许开发人员在索引开销与查询性能之间做出基于成本的权衡。  \r \r 有关演示如何为集合配置索引策略的示例，请参阅 MSDN 上的 [Azure Cosmos DB 示例](https://github.com/Azure/azure-documentdb-net)。 现在，让我们开始详细了解 Azure Cosmos DB SQL 语法。\r \r ## <a name=\"Basics\"></a>Azure Cosmos DB SQL 查询基础知识\r 每个查询按 ANSI-SQL 标准由 SELECT 子句和可选的 FROM 和 WHERE 子句组成。 通常，对于每个查询，已枚举 FROM 子句中的源。 然后将 WHERE 子句中的筛选器应用到源以检索 JSON 文档的子集。 最后，使用 SELECT 子句以投影选择列表中请求的 JSON 值。\r \r     SELECT <select_list> \r     [FROM <from_specification>] \r     [WHERE <filter_condition>]\r     [ORDER BY <sort_specification]    \r \r ## <a name=\"FromClause\"></a>FROM 子句\r `FROM <from_specification>` 子句是可选的，除非稍后在查询中对源进行筛选或投影。 此子句的目的在于指定必须对其执行查询的数据源。 通常情况下，整个集合作为源，但可以将集合的子集指定为源。 \r \r 一个类似 `SELECT * FROM Families` 的查询指示整个家庭集合是要枚举的源。 特殊标识符 ROOT 可以用来表示集合，而不使用集合名称来表示。 以下列表包含每个查询需要强制执行的规则：\r \r * 集合可以使用别名，如 `SELECT f.id FROM Families AS f` 或只需为 `SELECT f.id FROM Families f`。 此处，`f` 等效于 `Families`。 `AS` 是可选的关键字，用于为标识符取别名。\r * 一旦有了别名，则无法绑定原始的源。 例如，由于再也无法解析标识符“Families”，因此 `SELECT Families.id FROM Families f` 在语法上无效。\r * 所有需要引用的属性都必须是完全限定的。 在没有遵循严格架构的情况下，会强制性地执行这一点以避免任何不确定的绑定。 因此，由于未绑定 `id` 属性，因此 `SELECT id FROM Families f` 在语法上无效。\r \r ### <a name=\"sub-documents\"></a>子文档\r 也可以将源缩小为更小的子集。 例如，要在每个文档中仅枚举子树，则子根可能变成源，如下例所示。\r \r **查询**\r \r     SELECT * \r     FROM Families.children\r \r **结果**  \r \r     [\r       [\r         {\r             \"firstName\": \"Henriette Thaulow\",\r             \"gender\": \"female\",\r             \"grade\": 5,\r             \"pets\": [\r               {\r                   \"givenName\": \"Fluffy\"\r               }\r             ]\r         }\r       ],\r       [\r         {\r             \"familyName\": \"Merriam\",\r             \"givenName\": \"Jesse\",\r             \"gender\": \"female\",\r             \"grade\": 1\r         },\r         {\r             \"familyName\": \"Miller\",\r             \"givenName\": \"Lisa\",\r             \"gender\": \"female\",\r             \"grade\": 8\r         }\r       ]\r     ]\r \r 虽然上面的示例中使用数组作为源，但也可以使用对象作为源，如下例所示：在源中可以找到的任何有效 JSON 值（非未定义）都被视为包含在查询的结果中。 如果一些家庭没有 `address.state` 值，则会将他们排除在查询结果之外。\r \r **查询**\r \r     SELECT * \r     FROM Families.address.state\r \r **结果**\r \r     [\r       \"WA\", \r       \"NY\"\r     ]\r \r ## <a name=\"WhereClause\"></a>WHERE 子句\r WHERE 子句（**`WHERE <filter_condition>`**）可选。 它指定由源提供的 JSON 文档必须满足的条件，以便作为结果的一部分包含在内。 任何 JSON 文档必须将指定的条件评估为“true”以作为结果。 WHERE 子句由索引层使用，以确定可以作为结果的一部分的源文档的绝对最小子集。 \r \r 以下查询请求包含值为 `AndersenFamily`的名称属性的文档。 任何其他不具有名称属性或值与 `AndersenFamily` 不匹配的文档则被排除在外。 \r \r **查询**\r \r     SELECT f.address\r     FROM Families f \r     WHERE f.id = \"AndersenFamily\"\r \r **结果**\r \r     [{\r       \"address\": {\r         \"state\": \"WA\", \r         \"county\": \"King\", \r         \"city\": \"seattle\"\r       }\r     }]\r \r 上面的示例演示了一个简单的等式查询。 DocumentDB API SQL 还支持各种标量表达式。 最常使用的是二进制和一元表达式。 来自源 JSON 对象的属性引用也是有效的表达式。 \r \r 当前支持以下二进制运算符，它们可在查询中使用，如下例所示：  \r \r <table>\r <tr>\r <td>算术</td>    \r <td>+,-,*,/,%</td>\r </tr>\r <tr>\r <td>位</td>    \r <td>|、&、^、<<、>>、>>>（补零右移）</td>\r </tr>\r <tr>\r <td>逻辑</td>\r <td>AND、OR、NOT</td>\r </tr>\r <tr>\r <td>比较</td>    \r <td>=、!=、&lt;、&gt;、&lt;=、&gt;=、<></td>\r </tr>\r <tr>\r <td>String</td>    \r <td>||（连接）</td>\r </tr>\r </table>  \r \r 让我们查看一些使用二进制运算符的查询。\r \r     SELECT * \r     FROM Families.children[0] c\r     WHERE c.grade % 2 = 1     -- matching grades == 5, 1\r \r     SELECT * \r     FROM Families.children[0] c\r     WHERE c.grade ^ 4 = 1    -- matching grades == 5\r \r     SELECT *\r     FROM Families.children[0] c\r     WHERE c.grade >= 5     -- matching grades == 5\r \r 也支持一元运算符 +、-、~ 和 NOT，它们可在查询中使用，如下例所示：\r \r     SELECT *\r     FROM Families.children[0] c\r     WHERE NOT(c.grade = 5)  -- matching grades == 1\r \r     SELECT *\r     FROM Families.children[0] c\r     WHERE (-c.grade = -5)  -- matching grades == 5\r \r 除了二进制和一元运算符以外，还允许使用属性引用。 例如，`SELECT * FROM Families f WHERE f.isRegistered` 返回包含 `isRegistered` 属性的文档，其中的属性值等于 JSON `true` 值。 任何其他值（false、null、Undefined、`<number>`、`<string>`、`<object>`、`<array>` 等等）都会导致源文档被排除在结果之外。 \r \r ### <a name=\"equality-and-comparison-operators\"></a>等式和比较运算符\r 下表显示了 DocumentDB API SQL 中任意两个 JSON 类型之间等式比较的结果。\r \r <table style = \"width:300px\">\r    <tbody>\r       <tr>\r          <td valign=\"top\">\r             <strong>Op</strong>\r          </td>\r          <td valign=\"top\">\r             <strong>Undefined</strong>\r          </td>\r          <td valign=\"top\">\r             <strong>Null</strong>\r          </td>\r          <td valign=\"top\">\r             <strong>Boolean</strong>\r          </td>\r          <td valign=\"top\">\r             <strong>Number</strong>\r          </td>\r          <td valign=\"top\">\r             <strong>String</strong>\r          </td>\r          <td valign=\"top\">\r             <strong>Object</strong>\r          </td>\r          <td valign=\"top\">\r             <strong>Array</strong>\r          </td>\r       </tr>\r       <tr>\r          <td valign=\"top\">\r             <strong>Undefined<strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r       </tr>\r       <tr>\r          <td valign=\"top\">\r             <strong>Null<strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r             <strong>OK</strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r       </tr>\r       <tr>\r          <td valign=\"top\">\r             <strong>Boolean<strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r             <strong>OK</strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r       </tr>\r       <tr>\r          <td valign=\"top\">\r             <strong>Number<strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r             <strong>OK</strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r       </tr>\r       <tr>\r          <td valign=\"top\">\r             <strong>String<strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r             <strong>OK</strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r       </tr>\r       <tr>\r          <td valign=\"top\">\r             <strong>Object<strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r             <strong>OK</strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r       </tr>\r       <tr>\r          <td valign=\"top\">\r             <strong>Array<strong>\r          </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r Undefined </td>\r          <td valign=\"top\">\r             <strong>OK</strong>\r          </td>\r       </tr>\r    </tbody>\r </table>\r \r 对于其他比较运算符（如 >、>=、!=、< 和 <=），以下规则适用：   \r \r * 跨类型比较结果为 Undefined。\r * 两个对象或两个数组之间比较结果为 Undefined。   \r \r 如果筛选器中标量表达式的结果为 Undefined，则相应的文档不会包含在结果中，因为 Undefined 在逻辑上不等于“True”。\r \r ### <a name=\"between-keyword\"></a>BETWEEN 关键字\r 还可以使用 BETWEEN 关键字来对一定范围内的值（如在 ANSI SQL 中）进行快速查询。 可对字符串或数字使用 BETWEEN。\r \r 例如，此查询返回在其中第一个子女的年级为 1-5 之间（包括 1 和 5）的所有家庭文档。 \r \r     SELECT *\r     FROM Families.children[0] c\r     WHERE c.grade BETWEEN 1 AND 5\r \r 与在 ANSI-SQL 中不同，也可以使用 FROM 子句中的 BETWEEN 子句，如以下示例所示。\r \r     SELECT (c.grade BETWEEN 0 AND 10)\r     FROM Families.children[0] c\r \r 了更快地执行查询，请记得创建索引策略，该策略对在 BETWEEN 子句中筛选的任何数值属性/路径使用范围索引类型。 \r \r 在 DocumentDB API 与 ANSI SQL 中使用 BETWEEN 的主要不同之处在于是否可以对混合类型的属性执行快速的范围查询 — 例如，在某些文档中将“grade”设置为数字 (5)，而在其他文档中将其设置为字符串（“grade4”）。 在这些情况下（如在 JavaScript 中），在两种不同类型之间进行比较的结果为“undefined”，会跳过文档。\r \r ### <a name=\"logical-and-or-and-not-operators\"></a>逻辑（AND、OR 和 NOT）运算符\r 逻辑运算符对布尔值进行运算。 下表显示了这些运算符的逻辑真值表。\r \r | OR | True | False | Undefined |\r | --- | --- | --- | --- |\r | True |True |True |True |\r | False |True |False |Undefined |\r | Undefined |True |Undefined |Undefined |\r \r | AND | True | False | Undefined |\r | --- | --- | --- | --- |\r | True |True |False |Undefined |\r | False |False |False |False |\r | Undefined |Undefined |False |Undefined |\r \r | NOT |  |\r | --- | --- |\r | True |False |\r | False |True |\r | Undefined |Undefined |\r \r ### <a name=\"in-keyword\"></a>IN 关键字\r IN 关键字可用于检查指定的值是否与列表中的任意值匹配。 例如，此查询返回 ID 为“WakefieldFamily”或“AndersenFamily”的所有家庭文档。 \r \r     SELECT *\r     FROM Families \r     WHERE Families.id IN ('AndersenFamily', 'WakefieldFamily')\r \r 此示例返回状态为任何指定值的所有文档。\r \r     SELECT *\r     FROM Families \r     WHERE Families.address.state IN (\"NY\", \"WA\", \"CA\", \"PA\", \"OH\", \"OR\", \"MI\", \"WI\", \"MN\", \"FL\")\r \r ### <a name=\"ternary--and-coalesce--operators\"></a>三元 (?) 和联合 (??) 运算符\r 三元和联合运算符可以用于生成条件表达式，类似于常用的编程语言（如 C# 和 JavaScript）。 \r \r 当动态构建新的 JSON 属性时，使用三元 (?) 运算符会非常方便。 例如，现在可以写入查询以将类级别（初学者/中级/高级）分类到用户可读的表单中，如下面所示。\r \r      SELECT (c.grade < 5)? \"elementary\": \"other\" AS gradeLevel \r      FROM Families.children[0] c\r \r 也可以将调用嵌套到运算符，如以下查询中所示。\r \r     SELECT (c.grade < 5)? \"elementary\": ((c.grade < 9)? \"junior\": \"high\")  AS gradeLevel \r     FROM Families.children[0] c\r \r 如同使用其他查询运算符一样，如果任何文档中缺少条件表达式的引用属性，或者如果正在进行比较的类型不同，那么这些文档会被排除在查询结果之外。\r \r 联合 (??) 运算符可用于有效地检查文档中是否存在属性（也称为 已定义）。 这在对半结构化数据或混合类型的数据执行查询时很有用。 例如，此查询返回“lastName”（如果存在）或“surname”（如果不存在）。\r \r     SELECT f.lastName ?? f.surname AS familyName\r     FROM Families f\r \r ### <a name=\"EscapingReservedKeywords\"></a>带引号的属性访问器\r 也可以使用带引号的属性运算符 `[]` 访问属性。 例如，由于再也无法解析标识符“Families”，因此 `SELECT c.grade` and `SELECT c[\"grade\"]` 是等效的。 此语法在需要转义包含空格和特殊字符的属性或正好将相同的名称作为 SQL 关键字或保留字共享的属性时很有用。\r \r     SELECT f[\"lastName\"]\r     FROM Families f\r     WHERE f[\"id\"] = \"AndersenFamily\"\r \r ## <a name=\"SelectClause\"></a>SELECT 子句\r SELECT 子句 (**`SELECT <select_list>`**) 是强制性的，用于指定要从查询中检索的值，就如在 ANSI-SQL 中一样。 将在源文档顶端上筛选出来的子集传递给投影阶段，在其中检索指定的 JSON 值并为每个传递给它的输出构造新的 JSON 对象。 \r \r 下面的示例演示了典型的 SELECT 查询。 \r \r **查询**\r \r     SELECT f.address\r     FROM Families f \r     WHERE f.id = \"AndersenFamily\"\r \r **结果**\r \r     [{\r       \"address\": {\r         \"state\": \"WA\", \r         \"county\": \"King\", \r         \"city\": \"seattle\"\r       }\r     }]\r \r ### <a name=\"nested-properties\"></a>嵌套属性\r 在下面的示例中，我们投影两个嵌套的属性 `f.address.state` and `f.address.city`。\r \r **查询**\r \r     SELECT f.address.state, f.address.city\r     FROM Families f \r     WHERE f.id = \"AndersenFamily\"\r \r **结果**\r \r     [{\r       \"state\": \"WA\", \r       \"city\": \"seattle\"\r     }]\r \r 投影也支持 JSON 表达式，如下例所示：\r \r **查询**\r \r     SELECT { \"state\": f.address.state, \"city\": f.address.city, \"name\": f.id }\r     FROM Families f \r     WHERE f.id = \"AndersenFamily\"\r \r **结果**\r \r     [{\r       \"$1\": {\r         \"state\": \"WA\", \r         \"city\": \"seattle\", \r         \"name\": \"AndersenFamily\"\r       }\r     }]\r \r 让我们看看此处的 `$1` 角色。 `SELECT` 子句需要创建 JSON 对象，并且由于没有提供任何密钥，因此我们使用以 `$1` 开头的隐式参数变量名。 例如，此查询返回了两个隐式参数变量，标为 `$1` 和 `$2`。\r \r **查询**\r \r     SELECT { \"state\": f.address.state, \"city\": f.address.city }, \r            { \"name\": f.id }\r     FROM Families f \r     WHERE f.id = \"AndersenFamily\"\r \r **结果**\r \r     [{\r       \"$1\": {\r         \"state\": \"WA\", \r         \"city\": \"seattle\"\r       }, \r       \"$2\": {\r         \"name\": \"AndersenFamily\"\r       }\r     }]\r \r ### <a name=\"aliasing\"></a>别名\r 现在让我们使用值的显示别名对上面的示例进行扩展。 AS 是用于别名的关键字。 在将第二个值投影为 `NameInfo` 时，它如显示的那样是可选的。 \r \r 如果查询包含两个具有相同名称的属性，则必须使用别名以重命名其中一个属性或两个属性，以便可以在投影的结果中消除它们的歧义。\r \r **查询**\r \r     SELECT \r            { \"state\": f.address.state, \"city\": f.address.city } AS AddressInfo, \r            { \"name\": f.id } NameInfo\r     FROM Families f \r     WHERE f.id = \"AndersenFamily\"\r \r **结果**\r \r     [{\r       \"AddressInfo\": {\r         \"state\": \"WA\", \r         \"city\": \"seattle\"\r       }, \r       \"NameInfo\": {\r         \"name\": \"AndersenFamily\"\r       }\r     }]\r \r ### <a name=\"scalar-expressions\"></a>标量表达式\r 除了属性引用之外，SELECT 子句还支持标量表达式，如常量、算术表达式和逻辑表达式等。例如，下面是一个简单的“Hello World”查询。\r \r **查询**\r \r     SELECT \"Hello World\"\r \r **结果**\r \r     [{\r       \"$1\": \"Hello World\"\r     }]\r \r 下面是一个使用标量表达式的更复杂的示例。\r \r **查询**\r \r     SELECT ((2 + 11 % 7)-2)/3    \r \r **结果**\r \r     [{\r       \"$1\": 1.33333\r     }]\r \r 在下面的示例中，标量表达式的结果是布尔。\r \r **查询**\r \r     SELECT f.address.city = f.address.state AS AreFromSameCityState\r     FROM Families f    \r \r **结果**\r \r     [\r       {\r         \"AreFromSameCityState\": false\r       }, \r       {\r         \"AreFromSameCityState\": true\r       }\r     ]\r \r ### <a name=\"object-and-array-creation\"></a>对象和数组创建\r DocumentDB API SQL 的另一个重要功能是数组/对象创建。 请注意，在上一个示例中，我们已创建了一个新的 JSON 对象。 同样，也可以构造数组，如下例所示：\r \r **查询**\r \r     SELECT [f.address.city, f.address.state] AS CityState \r     FROM Families f    \r \r **结果**  \r \r     [\r       {\r         \"CityState\": [\r           \"seattle\", \r           \"WA\"\r         ]\r       }, \r       {\r         \"CityState\": [\r           \"NY\", \r           \"NY\"\r         ]\r       }\r     ]\r \r ### <a name=\"ValueKeyword\"></a>VALUE 关键字\r **VALUE** 关键字提供一种返回 JSON 值的方法。 例如，下面所示的查询返回标量 `\"Hello World\"`，而不是 `{$1: \"Hello World\"}`。\r \r **查询**\r \r     SELECT VALUE \"Hello World\"\r \r **结果**\r \r     [\r       \"Hello World\"\r     ]\r \r 下面的查询在结果中返回不带 `\"address\"` 标签的 JSON 值。\r \r **查询**\r \r     SELECT VALUE f.address\r     FROM Families f    \r \r **结果**  \r \r     [\r       {\r         \"state\": \"WA\", \r         \"county\": \"King\", \r         \"city\": \"seattle\"\r       }, \r       {\r         \"state\": \"NY\", \r         \"county\": \"Manhattan\", \r         \"city\": \"NY\"\r       }\r     ]\r \r 下面的示例对此进行了扩展，以演示如何返回 JSON 基元值（JSON 树的叶级别）。 \r \r **查询**\r \r     SELECT VALUE f.address.state\r     FROM Families f    \r \r **结果**\r \r     [\r       \"WA\",\r       \"NY\"\r     ]\r \r ### <a name=\"-operator\"></a>* 运算符\r 支持使用特殊运算符 (*) 按原样投影文档。 在使用时，它必须仅为投影的字段。 当类似 `SELECT * FROM Families f` 的查询有效时，`SELECT VALUE * FROM Families f ` 和 `SELECT *, f.id FROM Families f ` 无效。\r \r **查询**\r \r     SELECT * \r     FROM Families f \r     WHERE f.id = \"AndersenFamily\"\r \r **结果**\r \r     [{\r         \"id\": \"AndersenFamily\",\r         \"lastName\": \"Andersen\",\r         \"parents\": [\r            { \"firstName\": \"Thomas\" },\r            { \"firstName\": \"Mary Kay\"}\r         ],\r         \"children\": [\r            {\r                \"firstName\": \"Henriette Thaulow\", \"gender\": \"female\", \"grade\": 5,\r                \"pets\": [{ \"givenName\": \"Fluffy\" }]\r            }\r         ],\r         \"address\": { \"state\": \"WA\", \"county\": \"King\", \"city\": \"seattle\" },\r         \"creationDate\": 1431620472,\r         \"isRegistered\": true\r     }]\r \r ### <a name=\"TopKeyword\"></a>TOP 运算符\r TOP 关键字可用于限制来自查询中的值的数量。 将 TOP 与 ORDER BY 子句配合使用时，结果集被限制为有序值的前 N 个数；否则，它会返回未定义排序的结果中的前 N 个数。 在 SELECT 语句中，最佳做法是始终使用带有 TOP 子句的 ORDER BY 子句。 这是可预测指示受 TOP 影响的行的唯一方法。 \r \r **查询**\r \r     SELECT TOP 1 * \r     FROM Families f \r \r **结果**\r \r     [{\r         \"id\": \"AndersenFamily\",\r         \"lastName\": \"Andersen\",\r         \"parents\": [\r            { \"firstName\": \"Thomas\" },\r            { \"firstName\": \"Mary Kay\"}\r         ],\r         \"children\": [\r            {\r                \"firstName\": \"Henriette Thaulow\", \"gender\": \"female\", \"grade\": 5,\r                \"pets\": [{ \"givenName\": \"Fluffy\" }]\r            }\r         ],\r         \"address\": { \"state\": \"WA\", \"county\": \"King\", \"city\": \"seattle\" },\r         \"creationDate\": 1431620472,\r         \"isRegistered\": true\r     }]\r \r 可将 TOP 与常量值（如以上所示）或使用参数化查询的变量值配合使用。 有关更多详细信息，请参阅下面的参数化查询。\r \r ### <a name=\"Aggregates\"></a>聚合函数\r 也可在 `SELECT` 子句中执行聚合操作。 聚合函数对一组值进行计算，返回单个值。 例如，以下查询返回集合中系列文档的计数。\r \r **查询**\r \r     SELECT COUNT(1) \r     FROM Families f \r \r **结果**\r \r     [{\r         \"$1\": 2\r     }]\r \r 也可使用 `VALUE` 关键字返回聚合的标量值。 例如，以下查询将值的计数作为单个值返回：\r \r **查询**\r \r     SELECT VALUE COUNT(1) \r     FROM Families f \r \r **结果**\r \r     [ 2 ]\r \r 也可组合使用筛选器来执行聚合。 例如，以下查询返回地址在华盛顿州的文档的计数。\r \r **查询**\r \r     SELECT VALUE COUNT(1) \r     FROM Families f\r     WHERE f.address.state = \"WA\" \r \r **结果**\r \r     [ 1 ]\r \r 下表显示了 DocumentDB API 中受支持的聚合函数的列表。 `SUM` 和 `AVG` 基于数字值执行，而 `COUNT`、`MIN`、`MAX` 则可基于数字、字符串、布尔值和 null 值执行。 \r \r | 使用情况 | 说明 |\r |-------|-------------|\r | COUNT | 在表达式中返回项的数目。 |\r | SUM   | 在表达式中返回所有值的总和。 |\r | 最小值   | 在表达式中返回最小值。 |\r | MAX   | 在表达式中返回最大值。 |\r | 平均值   | 在表达式中返回多个值的平均值。 |\r \r 也可基于数组迭代的结果进行聚合。 有关详细信息，请参阅[查询中的数组迭代](#Iteration)。\r \r > [!NOTE]\r > 请注意，使用 Azure 门户的查询浏览器时，聚合查询可能会通过查询页返回部分聚合的结果。 SDK 跨所有页面生成单个累计值。 \r > \r > 若要使用代码执行聚合查询，用户需要 .NET SDK 1.12.0、.NET Core SDK 1.1.0，或者 Java SDK 1.9.5 或更高版本。    \r >\r \r ## <a name=\"OrderByClause\"></a>ORDER BY 子句\r 如同在 ANSI-SQL 中一样，在查询时可以包含可选的 Order By 子句。 该子句可以包括可选的 ASC/DESC 参数以指定检索结果必须遵守的顺序。\r \r 例如，下面是按居住城市的名称检索家庭的查询。\r \r **查询**\r \r     SELECT f.id, f.address.city\r     FROM Families f \r     ORDER BY f.address.city\r \r **结果**\r \r     [\r       {\r         \"id\": \"WakefieldFamily\",\r         \"city\": \"NY\"\r       },\r       {\r         \"id\": \"AndersenFamily\",\r         \"city\": \"Seattle\"    \r       }\r     ]\r \r 下面的查询按创建日期检索家庭，该创建日期存储为表示纪元时间的数字，即，自 1970 年 1 月 1 日起经过的时间（以秒为单位）。\r \r **查询**\r \r     SELECT f.id, f.creationDate\r     FROM Families f \r     ORDER BY f.creationDate DESC\r \r **结果**\r \r     [\r       {\r         \"id\": \"WakefieldFamily\",\r         \"creationDate\": 1431620462\r       },\r       {\r         \"id\": \"AndersenFamily\",\r         \"creationDate\": 1431620472    \r       }\r     ]\r \r ## <a name=\"Advanced\"></a>高级数据库概念和 SQL 查询\r \r ### <a name=\"Iteration\"></a>迭代\r 在 DocumentDB API SQL 中通过 **IN** 关键字添加了一个新构造，以为遍历 JSON 数组提供支持。 FROM 源为迭代提供支持。 让我们从下面的示例开始：\r \r **查询**\r \r     SELECT * \r     FROM Families.children\r \r **结果**  \r \r     [\r       [\r         {\r           \"firstName\": \"Henriette Thaulow\", \r           \"gender\": \"female\", \r           \"grade\": 5, \r           \"pets\": [{ \"givenName\": \"Fluffy\"}]\r         }\r       ], \r       [\r         {\r             \"familyName\": \"Merriam\", \r             \"givenName\": \"Jesse\", \r             \"gender\": \"female\", \r             \"grade\": 1\r         }, \r         {\r             \"familyName\": \"Miller\", \r             \"givenName\": \"Lisa\", \r             \"gender\": \"female\", \r             \"grade\": 8\r         }\r       ]\r     ]\r \r 现在，让我们来看看对集合中的子女执行遍历的另一个查询。 请注意输出数组中的差异。 此示例拆分 `children` 并将结果合并为单个数组。  \r \r **查询**\r \r     SELECT * \r     FROM c IN Families.children\r \r **结果**  \r \r     [\r       {\r           \"firstName\": \"Henriette Thaulow\",\r           \"gender\": \"female\",\r           \"grade\": 5,\r           \"pets\": [{ \"givenName\": \"Fluffy\" }]\r       },\r       {\r           \"familyName\": \"Merriam\",\r           \"givenName\": \"Jesse\",\r           \"gender\": \"female\",\r           \"grade\": 1\r       },\r       {\r           \"familyName\": \"Miller\",\r           \"givenName\": \"Lisa\",\r           \"gender\": \"female\",\r           \"grade\": 8\r       }\r     ]\r \r 这可用于对数组的单个实体执行进一步筛选，如下例所示：\r \r **查询**\r \r     SELECT c.givenName\r     FROM c IN Families.children\r     WHERE c.grade = 8\r \r **结果**  \r \r     [{\r       \"givenName\": \"Lisa\"\r     }]\r \r 也可基于数组迭代的结果进行聚合。 例如，以下查询对所有家庭的孩子计数。\r \r **查询**\r \r     SELECT COUNT(child) \r     FROM child IN Families.children\r \r **结果**  \r \r     [\r       { \r         \"$1\": 3\r       }\r     ]\r \r ### <a name=\"Joins\"></a>联接\r 在关系型数据库中，跨表联接的要求是非常重要的。 设计规范化的架构是一项逻辑要求。 与此相反，DocumentDB API 处理无架构文档的非规范化数据模型。 这在逻辑上等效于“自联接”。\r \r 语言支持的语法为 <from_source1> JOIN <from_source2> JOIN ...JOIN <from_sourceN>。 总体而言，此语法返回一组 **N** 元组（带有 **N** 个值的元组）。 每个元组拥有通过对它们相应的集遍历所有集合别名所产生的值。 换言之，这是加入联接的集的完整叉积。\r \r 下面的示例演示了 JOIN 子句的工作原理。 下面的示例中，由于源中每个文档和空集的叉积为空，因此结果为空。\r \r **查询**\r \r     SELECT f.id\r     FROM Families f\r     JOIN f.NonExistent\r \r **结果**  \r \r     [{\r     }]\r \r 在下面的示例中，联接位于文档根和 `children` 子根之间。 这是两个 JSON 对象之间的叉积。 子女是一个数组的事实在 JOIN 中无效，因为我们正在处理的是子女数组的单一根。 因此，由于每个带有数组的文档的叉积仅生成一个文档，因此结果仅包含两个结果。\r \r **查询**\r \r     SELECT f.id\r     FROM Families f\r     JOIN f.children\r \r **结果**\r \r     [\r       {\r         \"id\": \"AndersenFamily\"\r       }, \r       {\r         \"id\": \"WakefieldFamily\"\r       }\r     ]\r \r 下面的示例演示了更传统的联接：\r \r **查询**\r \r     SELECT f.id\r     FROM Families f\r     JOIN c IN f.children \r \r **结果**\r \r     [\r       {\r         \"id\": \"AndersenFamily\"\r       }, \r       {\r         \"id\": \"WakefieldFamily\"\r       }, \r       {\r         \"id\": \"WakefieldFamily\"\r       }\r     ]\r \r 首先要注意的是 **JOIN** 子句的 `from_source` 是迭代器。 因此，在此示例中的流程如下：  \r \r * 在数组中扩展每个子元素 **c**。\r * 应用具有文档 **f** 的根的叉积，这些文档具有已在第一步中合并的每个子元素 **c**。\r * 最后，单独投影根对象 **f** 名称属性。 \r \r 第一个文档 (`AndersenFamily`) 仅包含一个子元素，因此结果集仅包含与此文档对应的单个对象。 第二个文档 (`WakefieldFamily`) 包含两个子元素。 因此，叉积会为每个子女生成单独的对象，从而产生两个对象，每个对象分别与此文档对应。 这两个文档中的根字段会是相同的，正如在叉积中所预期的一样。\r \r JOIN 真正实用的地方通过以其他方式难以投影的形式基于叉积生成元组。 此外，就如我们会在下面的示例中看见的那样，可以对元组组合进行筛选，总体上由用户选择元组满足的条件。\r \r **查询**\r \r     SELECT \r         f.id AS familyName,\r         c.givenName AS childGivenName,\r         c.firstName AS childFirstName,\r         p.givenName AS petName \r     FROM Families f \r     JOIN c IN f.children \r     JOIN p IN c.pets\r \r **结果**\r \r     [\r       {\r         \"familyName\": \"AndersenFamily\", \r         \"childFirstName\": \"Henriette Thaulow\", \r         \"petName\": \"Fluffy\"\r       }, \r       {\r         \"familyName\": \"WakefieldFamily\", \r         \"childGivenName\": \"Jesse\", \r         \"petName\": \"Goofy\"\r       }, \r       {\r        \"familyName\": \"WakefieldFamily\", \r        \"childGivenName\": \"Jesse\", \r        \"petName\": \"Shadow\"\r       }\r     ]\r \r 此示例是前面示例的自然扩展，且执行双联接。 因此，可将叉积视为下面的伪代码：\r \r     for-each(Family f in Families)\r     {    \r         for-each(Child c in f.children)\r         {\r             for-each(Pet p in c.pets)\r             {\r                 return (Tuple(f.id AS familyName, \r                   c.givenName AS childGivenName, \r                   c.firstName AS childFirstName,\r                   p.givenName AS petName));\r             }\r         }\r     }\r \r `AndersenFamily` 有一个拥有一只宠物的孩子。 因此，叉积从此家庭中生成一行 (1\\*1\\*1)。 尽管 WakefieldFamily 有两个孩子，但只有一个孩子“Jesse”拥有宠物。 不过，Jesse 有 2 只宠物。 因此叉积从此家庭中生成 1\\*1\\*2 = 2 行。\r \r 在接下来的示例中，可以根据 `pet`进行额外的筛选。 这排除了宠物名称不是“Shadow”的所有元组。 请注意，我们能够从数组中生成元组，根据元组的任意元素进行筛选以及投影元素的任何组合。 \r \r **查询**\r \r     SELECT \r         f.id AS familyName,\r         c.givenName AS childGivenName,\r         c.firstName AS childFirstName,\r         p.givenName AS petName \r     FROM Families f \r     JOIN c IN f.children \r     JOIN p IN c.pets\r     WHERE p.givenName = \"Shadow\"\r \r **结果**\r \r     [\r       {\r        \"familyName\": \"WakefieldFamily\", \r        \"childGivenName\": \"Jesse\", \r        \"petName\": \"Shadow\"\r       }\r     ]\r \r ## <a name=\"JavaScriptIntegration\"></a>JavaScript 集成\r Azure Cosmos DB 根据存储过程和触发器，为对集合直接执行基于 JavaScript 的应用程序逻辑提供编程模型。 这允许以下两种情况：\r \r * 借助直接在数据库引擎内深度集成 JavaScript 运行时，能够对集合中的文档执行高性能事务性 CRUD 操作和查询。 \r * 控制流、变量范围和分配的自然建模和将异常处理基元与数据库事务集成。 有关 Azure Cosmos DB 对 JavaScript 集成的支持的更多详细信息，请参阅“JavaScript 服务器端可编程性”文档。\r \r ### <a name=\"UserDefinedFunctions\"></a>用户定义的函数 (UDF)\r 除了本文中已定义的类型外，DocumentDB API SQL 也对用户定义的函数 (UDF) 提供支持。 具体而言，支持标量 UDF，开发人员可在其中传入零个或许多参数并返回单个参数结果。 检查每个参数是否是合法的 JSON 值。  \r \r 扩展 DocumentDB API SQL 语法，以支持使用这些用户定义的函数的自定义应用程序逻辑。 可使用 DocumentDB API 注册 UDF，并作为 SQL 查询的一部分引用这些函数。 事实上，UDF 经过精心设计，可由查询调用。 作为此选择的必然结果，UDF 不能访问其他 JavaScript 类型（存储过程和触发器）所拥有的上下文对象。 由于查询以只读方式执行，因此它们可以在主要或次要副本上运行。 因此，UDF 设计为在次要副本上运行，这与其他 JavaScript 类型不同。\r \r 以下是如何在 Cosmos DB 数据库中（特别是在文档集合下）注册 UDF 的示例。\r \r        UserDefinedFunction regexMatchUdf = new UserDefinedFunction\r        {\r            Id = \"REGEX_MATCH\",\r            Body = @\"function (input, pattern) { \r                        return input.match(pattern) !== null;\r                    };\",\r        };\r \r        UserDefinedFunction createdUdf = client.CreateUserDefinedFunctionAsync(\r            UriFactory.CreateDocumentCollectionUri(\"testdb\", \"families\"), \r            regexMatchUdf).Result;  \r \r 之前的示例创建了名称为 `REGEX_MATCH` 的 UDF。 它接受两个 JSON 字符串值 `input` 和 `pattern`，并且使用 JavaScript 的 string.match() 函数检查第一个值是否与第二个值中指定的模式匹配。\r \r 现在，我们可以在投影中的查询中使用此 UDF。 在从查询内调用时，必须用区分大小写的前缀“udf.”限定 UDF 。 \r \r > [!NOTE]\r > 在 2015/3/17 之前，Cosmos DB 支持无需“udf.”前缀的 UDF 调用， 例如 SELECT REGEX_MATCH()。 已弃用此调用模式。  \r > \r > \r \r **查询**\r \r     SELECT udf.REGEX_MATCH(Families.address.city, \".*eattle\")\r     FROM Families\r \r **结果**\r \r     [\r       {\r         \"$1\": true\r       }, \r       {\r         \"$1\": false\r       }\r     ]\r \r 也可在 UDF 中使用筛选器，这同样要使用“udf.”前缀进行限定， 前缀：\r \r **查询**\r \r     SELECT Families.id, Families.address.city\r     FROM Families\r     WHERE udf.REGEX_MATCH(Families.address.city, \".*eattle\")\r \r **结果**\r \r     [{\r         \"id\": \"AndersenFamily\",\r         \"city\": \"Seattle\"\r     }]\r \r 从本质上来说，UDF 是有效的标量表达式且可在投影和筛选器中使用。 \r \r 要扩展 UDF 的功能，让我们看看使用条件逻辑的另一个示例：\r \r        UserDefinedFunction seaLevelUdf = new UserDefinedFunction()\r        {\r            Id = \"SEALEVEL\",\r            Body = @\"function(city) {\r                    switch (city) {\r                        case 'seattle':\r                            return 520;\r                        case 'NY':\r                            return 410;\r                        case 'Shanghai':\r                            return 673;\r                        default:\r                            return -1;\r                     }\"\r             };\r \r             UserDefinedFunction createdUdf = await client.CreateUserDefinedFunctionAsync(\r                 UriFactory.CreateDocumentCollectionUri(\"testdb\", \"families\"), \r                 seaLevelUdf);\r \r 以下是使用 UDF 的一个示例。\r \r **查询**\r \r     SELECT f.address.city, udf.SEALEVEL(f.address.city) AS seaLevel\r     FROM Families f    \r \r **结果**\r \r      [\r       {\r         \"city\": \"seattle\", \r         \"seaLevel\": 520\r       }, \r       {\r         \"city\": \"NY\", \r         \"seaLevel\": 410\r       }\r     ]\r \r 如前面的示例所示，UDF 使用 DocumentDB API SQL 集成 JavaScript 语言的功能以通过丰富的可编程接口执行复杂的过程，并在内置 JavaScript 运行时功能的帮助下，执行条件逻辑。\r \r DocumentDB API SQL 在处理 UDF 当前阶段（WHERE 子句或 SELECT 子句），为源中每个文档的 UDF 提供参数。 结果无缝地纳入总体执行管道中。 如果由 UDF 参数引用的属性在 JSON 值中不可用，则参数会被视为未定义，因此会完全跳过 UDF 调用。 同样，如果未定义 UDF的结果，则它不会包含在结果中。 \r \r 总而言之，UDF 是作为查询的一部分处理复杂业务逻辑重要的工具。\r \r ### <a name=\"operator-evaluation\"></a>运算符评估\r Cosmos DB 是一个 JSON 数据库，与 JavaScript 运算符以及其评估语义具有许多相似之处。 就 JSON 支持而言，当 Cosmos DB 尝试保留 JavaScript 语义时，操作评估在某些实例中有所偏移。\r \r 在传统 SQL 不同，在 DocumentDB API SQL 中，在从数据库中检索出值之前，值类型经常是未知的。 为了高效执行查询，大多数运算符具有严格的类型要求。 \r \r 不同于 JavaScript，DocumentDB API SQL 不会执行隐式转换。 例如，类似 `SELECT * FROM Person p WHERE p.Age = 21` 的查询与包含值为 21 的 Age 属性的文档相匹配。 任何其他 Age 属性与字符串“21”匹配或包含其他无数可能的变量（“021”、“21.0”、“0021”和“00021”等等）的文档则不匹配。 这与 JavaScript 相反，在 JavaScript 中，字符串会隐式转换为数字（基于运算符 ex: ==）。 此选择对于 DocumentDB API SQL 中的高效索引匹配至关重要。 \r \r ## <a name=\"parameterized-sql-queries\"></a>参数化 SQL 查询\r Cosmos DB 支持使用带有常用的 @ 表示法的参数进行查询。 参数化 SQL 为用户输入提供可靠的处理和转义，可防止通过 SQL 注入发生意外的数据泄露。 \r \r 例如，可以编写一个将姓氏和省/自治区/直辖市地址作为参数的查询，然后基于用户输入针对姓氏和省/自治区/直辖市地址执行此查询。\r \r     SELECT * \r     FROM Families f\r     WHERE f.lastName = @lastName AND f.address.state = @addressState\r \r 然后，可以将此请求作为参数化 JSON 查询发送到 Cosmos DB，如下所示。\r \r     {      \r         \"query\": \"SELECT * FROM Families f WHERE f.lastName = @lastName AND f.address.state = @addressState\",     \r         \"parameters\": [          \r             {\"name\": \"@lastName\", \"value\": \"Wakefield\"},         \r             {\"name\": \"@addressState\", \"value\": \"NY\"},           \r         ] \r     }\r \r 可以使用参数化查询设置 TOP 的参数，如下所示。\r \r     {      \r         \"query\": \"SELECT TOP @n * FROM Families\",     \r         \"parameters\": [          \r             {\"name\": \"@n\", \"value\": 10},         \r         ] \r     }\r \r 参数值可以为任何有效的 JSON（字符串、数字、布尔、null，甚至是数组或嵌套的 JSON）。 此外，由于 Cosmos DB 是无架构的，因此未针对任何类型对参数进行验证。\r \r ## <a name=\"BuiltinFunctions\"></a>内置函数\r Cosmos DB 还支持使用许多内置函数进行常见操作，这些函数可以在查询（如用户定义的函数 (UDF)）中使用。\r \r | 函数组          | 操作                                                                                                                                          |\r |-------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|\r | 数学函数  | ABS、CEILING、EXP、FLOOR、LOG、LOG10、POWER、ROUND、SIGN、SQRT、SQUARE、TRUNC、ACOS、ASIN、ATAN、ATN2、COS、COT、DEGREES、PI、RADIANS、SIN 和 TAN |\r | 类型检查函数 | IS_ARRAY、IS_BOOL、IS_NULL、IS_NUMBER、IS_OBJECT、IS_STRING、IS_DEFINED 和 IS_PRIMITIVE                                                           |\r | 字符串函数        | CONCAT、CONTAINS、ENDSWITH、INDEX_OF、LEFT、LENGTH、LOWER、LTRIM、REPLACE、REPLICATE、REVERSE、RIGHT、RTRIM、STARTSWITH、SUBSTRING 和 UPPER       |\r | 数组函数         | ARRAY_CONCAT、ARRAY_CONTAINS、ARRAY_LENGTH 和 ARRAY_SLICE                                                                                         |\r | 空间函数       | ST_DISTANCE、ST_WITHIN、ST_INTERSECTS、ST_ISVALID 和 ST_ISVALIDDETAILED                                                                           | \r \r 如果当前正使用内置函数现在可用的用户定义函数 (UDF)，那么应使用相应的内置函数，因为它会更快更有效地运行。 \r \r ### <a name=\"mathematical-functions\"></a>数学函数\r 每个数学函数均执行一个计算，基于作为参数提供的输出值，并返回数值。 以下是支持的内置数学函数表。\r \r | 使用情况 | 说明 |\r |----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r | [[ABS (num_expr)](#bk_abs) | 返回指定数值表达式的绝对（正）值。 |\r | [CEILING (num_expr)](#bk_ceiling) | 返回大于或等于指定数值表达式的最小整数值。 |\r | [FLOOR (num_expr)](#bk_floor) | 返回小于或等于指定数值表达式的最大整数。 |\r | [EXP (num_expr)](#bk_exp) | 返回指定数值表达式的指数。 |\r | [LOG (num_expr [,base])](#bk_log) | 返回指定数值表达式的自然对数，或使用指定底数的对数 |\r | [LOG10 (num_expr)](#bk_log10) | 返回指定数值表达式以 10 为底的对数值。 |\r | [ROUND (num_expr)](#bk_round) | 返回一个数值，四舍五入到最接近的整数值。 |\r | [TRUNC (num_expr)](#bk_trunc) | 返回一个数值，截断到最接近的整数值。 |\r | [SQRT (num_expr)](#bk_sqrt) | 返回指定数值表达式的平方根。 |\r | [SQUARE (num_expr)](#bk_square) | 返回指定数值表达式的平方。 |\r | [POWER (num_expr, num_expr)](#bk_power) | 返回指定数值表达式相对指定值的幂。 |\r | [SIGN (num_expr)](#bk_sign) | 返回指定数值表达式的符号值 (-1, 0, 1)。 |\r | [ACOS (num_expr)](#bk_acos) | 返回角度（弧度），其余弦是指定的数值表达式；也被称为反余弦。 |\r | [ASIN (num_expr)](#bk_asin) | 返回角度（弧度），其正弦是指定的数值表达式。 也被称为反正弦。 |\r | [ATAN (num_expr)](#bk_atan) | 返回角度（弧度），其正切是指定的数值表达式。 这也被称为反正切。 |\r | [ATN2 (num_expr)](#bk_atn2) | 返回正 x 轴与射线（原点到点 (y, x)）之间的角度（弧度），其中 x 和 y 是两个指定的浮点表达式的值。 |\r | [COS (num_expr)](#bk_cos) | 返回指定表达式中指定角度的三角余弦（弧度）。 |\r | [COT (num_expr)](#bk_cot) | 返回指定数值表达式中指定角度的三角余切。 |\r | [DEGREES (num_expr)](#bk_degrees) | 返回指定角度（弧度）的相应角度（度）。 |\r | [PI ()](#bk_pi) | 返回 PI 的常数值。 |\r | [RADIANS (num_expr)](#bk_radians) | 返回输入的数值表达式（度）的弧度。 |\r | [SIN (num_expr)](#bk_sin) | 返回指定表达式中指定角度的三角正弦（弧度）。 |\r | [TAN (num_expr)](#bk_tan) | 返回指定表达式中输入表达式的正切。 |\r \r 例如，现在可以运行以下查询：\r \r **查询**\r \r     SELECT VALUE ABS(-4)\r \r **结果**\r \r     [4]\r \r 与 ANSI SQL 相比，Cosmos DB 的函数的主要差异在于它们设计为可良好地适用于无架构和混合架构数据。 例如，如果拥有一个缺少 Size 属性或有一个非数值的值（如“unknown”）的文档，那么会跳过该文档，而不是返回错误。\r \r ### <a name=\"type-checking-functions\"></a>类型检查函数\r 类型检查函数允许检查 SQL 查询内表达式的类型。 类型是变量或未知时，可使用类型检查函数动态确定文档内属性的类型。 以下是支持的内置类型检查函数表。\r \r <table>\r <tr>\r   <td><strong>使用情况</strong></td>\r   <td><strong>说明</strong></td>\r </tr>\r <tr>\r   <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_array\">IS_ARRAY (expr)</a></td>\r   <td>返回一个布尔值，它指示值的类型是否为数组。</td>\r </tr>\r <tr>\r   <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_bool\">IS_BOOL (expr)</a></td>\r   <td>返回一个布尔值，它指示值的类型是否为布尔。</td>\r </tr>\r <tr>\r   <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_null\">IS_NULL (expr)</a></td>\r   <td>返回一个布尔值，它指示值的类型是否为 null。</td>\r </tr>\r <tr>\r   <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_number\">IS_NUMBER (expr)</a></td>\r   <td>返回一个布尔值，它指示值的类型是否为数字。</td>\r </tr>\r <tr>\r   <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_object\">IS_OBJECT (expr)</a></td>\r   <td>返回一个布尔值，它指示值的类型是否为 JSON 对象。</td>\r </tr>\r <tr>\r   <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_string\">IS_STRING (expr)</a></td>\r   <td>返回一个布尔值，它指示值的类型是否为字符串。</td>\r </tr>\r <tr>\r   <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_defined\">IS_DEFINED (expr)</a></td>\r   <td>返回一个布尔，它指示属性是否已经分配了值。</td>\r </tr>\r <tr>\r   <td><a href=\"https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_primitive\">IS_PRIMITIVE (expr)</a></td>\r   <td>返回一个布尔值，它指示值的类型是否为字符串、数字、布尔或 null。</td>\r </tr>\r \r </table>\r \r 使用这些函数，现在可以运行以下查询：\r \r **查询**\r \r     SELECT VALUE IS_NUMBER(-4)\r \r **结果**\r \r     [true]\r \r ### <a name=\"string-functions\"></a>字符串函数\r 下面的标量函数对字符串输入值执行操作，并返回字符串、数值或布尔值。 以下是内置字符串函数表：\r \r | 使用情况 | 说明 |\r | --- | --- |\r | [LENGTH (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_length) |返回指定字符串的字符数 |\r | [CONCAT (str_expr, str_expr [, str_expr])](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_concat) |返回一个字符串，该字符串是连接两个或多个字符串值的结果。 |\r | [SUBSTRING (str_expr, num_expr, num_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_substring) |返回部分字符串表达式。 |\r | [STARTSWITH (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_startswith) |返回一个布尔值，该值指示第一个字符串表达式是否以第二个字符串表达式结尾 |\r | [ENDSWITH (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_endswith) |返回一个布尔值，该值指示第一个字符串表达式是否以第二个字符串表达式结尾 |\r | [CONTAINS (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_contains) |返回一个布尔值，该值指示第一个字符串表达式是否包含第二个字符串表达式。 |\r | [INDEX_OF (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_index_of) |返回第一个指定的字符串表达式中第一次出现第二个字符串表达式的起始位置，如果未找到字符串，则返回 -1。 |\r | [LEFT (str_expr, num_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_left) |返回具有指定字符数的字符串的左侧部分。 |\r | [RIGHT (str_expr, num_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_right) |返回具有指定字符数的字符串的右侧部分。 |\r | [LTRIM (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_ltrim) |返回删除前导空格后的字符串表达式。 |\r | [RTRIM (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_rtrim) |返回截断所有尾随空格后的字符串表达式。 |\r | [LOWER (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_lower) |返回在将大写字符数据转换为小写后的字符串表达式。 |\r | [UPPER (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_upper) |返回在将小写字符数据转换为大写后的字符串表达式。 |\r | [REPLACE (str_expr, str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_replace) |将出现的所有指定字符串值替换为另一个字符串值。 |\r | [REPLICATE (str_expr, num_expr)](/cosmos-db/documentdb-sql-query-reference#bk_replicate) |将一个字符串值重复指定的次数。 |\r | [REVERSE (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_reverse) |返回字符串值的逆序排序形式。 |\r \r 借助这些函数，现可以运行以下查询。 例如，可以返回大写形式的家庭名称，如下所示：\r \r **查询**\r \r     SELECT VALUE UPPER(Families.id)\r     FROM Families\r \r **结果**\r \r     [\r         \"WAKEFIELDFAMILY\", \r         \"ANDERSENFAMILY\"\r     ]\r \r 或如此示例中一样连接字符串：\r \r **查询**\r \r     SELECT Families.id, CONCAT(Families.address.city, \",\", Families.address.state) AS location\r     FROM Families\r \r **结果**\r \r     [{\r       \"id\": \"WakefieldFamily\",\r       \"location\": \"NY,NY\"\r     },\r     {\r       \"id\": \"AndersenFamily\",\r       \"location\": \"seattle,WA\"\r     }]\r \r 也可在 WHERE 子句中使用字符串函数来筛选结果，如下例所示：\r \r **查询**\r \r     SELECT Families.id, Families.address.city\r     FROM Families\r     WHERE STARTSWITH(Families.id, \"Wakefield\")\r \r **结果**\r \r     [{\r       \"id\": \"WakefieldFamily\",\r       \"city\": \"NY\"\r     }]\r \r ### <a name=\"array-functions\"></a>数组函数\r 下面的标量函数对数组输入值执行操作，并返回数值、布尔值或数组值。 以下是内置数组函数表：\r \r | 使用情况 | 说明 |\r | --- | --- |\r | [ARRAY_LENGTH (arr_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_length) |返回指定数组表达式的元素数。 |\r | [ARRAY_CONCAT (arr_expr, arr_expr [, arr_expr])](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_concat) |返回一个数组，该数组是连接两个或更多数组值的结果。 |\r | [ARRAY_CONTAINS (arr_expr, expr [, bool_expr])](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_contains) |返回一个布尔，它指示数组是否包含指定的值。 可以指定是要执行完全还是部分匹配。 |\r | [ARRAY_SLICE (arr_expr, num_expr [, num_expr])](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_slice) |返回部分数组表达式。 |\r \r 数组函数可用于在 JSON 内操纵数组。 例如，下面的查询返回其中一位父母是“Robin Wakefield”的所有文档。 \r \r **查询**\r \r     SELECT Families.id \r     FROM Families \r     WHERE ARRAY_CONTAINS(Families.parents, { givenName: \"Robin\", familyName: \"Wakefield\" })\r \r **结果**\r \r     [{\r       \"id\": \"WakefieldFamily\"\r     }]\r \r 可以指定一个部分片段来匹配数组中的元素。 以下查询查找 `givenName` 为 `Robin` 的所有父母。\r \r **查询**\r \r     SELECT Families.id \r     FROM Families \r     WHERE ARRAY_CONTAINS(Families.parents, { givenName: \"Robin\" }, true)\r \r **结果**\r \r     [{\r       \"id\": \"WakefieldFamily\"\r     }]\r \r 以下是使用 ARRAY_LENGTH 获取每个家庭的子女数的另一个示例。\r \r **查询**\r \r     SELECT Families.id, ARRAY_LENGTH(Families.children) AS numberOfChildren\r     FROM Families \r \r **结果**\r \r     [{\r       \"id\": \"WakefieldFamily\",\r       \"numberOfChildren\": 2\r     },\r     {\r       \"id\": \"AndersenFamily\",\r       \"numberOfChildren\": 1\r     }]\r \r ### <a name=\"spatial-functions\"></a>空间函数\r Cosmos DB 支持以下用于查询地理空间的开放地理空间信息联盟 (OGC) 内置函数。 \r \r <table>\r <tr>\r   <td><strong>使用情况</strong></td>\r   <td><strong>说明</strong></td>\r </tr>\r <tr>\r   <td>ST_DISTANCE (point_expr、point_expr)</td>\r   <td>返回两个 GeoJSON 点、多边形或 LineString 表达式之间的距离。</td>\r </tr>\r <tr>\r   <td>ST_WITHIN (point_expr、polygon_expr)</td>\r   <td>返回一个布尔表达式，该表达式指示第一个 GeoJSON 对象（点、多边形或 LineString）是否在第二个 GeoJSON 对象（点、多边形或 LineString）里面。</td>\r </tr>\r <tr>\r   <td>ST_INTERSECTS (spatial_expr, spatial_expr)</td>\r   <td>返回一个布尔表达式，该表达式指示两个指定的 GeoJSON 对象（点、多边形或 LineString）是否相交。</td>\r </tr>\r <tr>\r   <td>ST_ISVALID</td>\r   <td>返回一个布尔值，该值指示指定的 GeoJSON 点、多边形或 LineString 表达式是否有效。</td>\r </tr>\r <tr>\r   <td>ST_ISVALIDDETAILED</td>\r   <td>如果指定的 GeoJSON 点、多边形或 LineString 表达式有效，则返回包含布尔值的 JSON 值；如果无效，则额外加上作为字符串值的原因。</td>\r </tr>\r </table>\r \r 空间函数可用于对空间数据执行邻近查询。 例如，以下查询使用 ST_DISTANCE 内置函数返回所有家族文档，且这些文档在指定位置的 30 公里内。 \r \r **查询**\r \r     SELECT f.id \r     FROM Families f \r     WHERE ST_DISTANCE(f.location, {'type': 'Point', 'coordinates':[31.9, -4.8]}) < 30000\r \r **结果**\r \r     [{\r       \"id\": \"WakefieldFamily\"\r     }]\r \r 有关 Cosmos DB 中地理支持的更多详细信息，请参阅[在 Azure Cosmos DB 中使用地理数据](geospatial.md)。 这会完成空间函数和 Cosmos DB 的 SQL 语法。 现在，让我们来看看 LINQ 查询的工作方式，以及它如何与我们目前为止所看到的语法进行交互。\r \r ## <a name=\"Linq\"></a>LINQ 到 DocumentDB API SQL\r LINQ 是一个 .NET 编程模型，它将计算表示为对对象流的查询。 Cosmos DB 提供一个客户端库，通过促进 JSON 与 .NET 对象之间的转换，以及从 LINQ 查询的子集到 Cosmos DB 查询的映射，来与 LINQ 进行交互。 \r \r 下面的图片显示了支持使用 Cosmos DB 的 LINQ 查询的体系结构。  使用 Cosmos DB 客户端，开发人员可以创建直接查询 Cosmos DB 查询提供程序的 **IQueryable** 对象，该提供程序随后会将 LINQ 查询转换为 Cosmos DB 查询。 随后会将该查询传递到 Cosmos DB 服务器以检索一组 JSON 格式的结果。 在客户端上，返回的结果会反序列化为 .NET 对象的流。\r \r ![支持使用 DocumentDB API 的 LINQ 查询的体系结构 - SQL语法、JSON 查询语言、数据库概念和 SQL 查询][1]\r \r ### <a name=\"net-and-json-mapping\"></a>.NET 和 JSON 映射\r .NET 对象与 JSON 文档之间的映射是自然的 - 每个数据成员字段映射到 JSON 对象，其中字段名称映射到对象的“key”部分，并且\"value\"部分以递归方式映射到该对象的值部分。 考虑以下示例：创建的 Family 对象会映射到 JSON 文档，如下所示。 反之亦然，JSON 文档会映射回 .NET 对象。\r \r **C# 类**\r \r     public class Family\r     {\r         [JsonProperty(PropertyName=\"id\")]\r         public string Id;\r         public Parent[] parents;\r         public Child[] children;\r         public bool isRegistered;\r     };\r \r     public struct Parent\r     {\r         public string familyName;\r         public string givenName;\r     };\r \r     public class Child\r     {\r         public string familyName;\r         public string givenName;\r         public string gender;\r         public int grade;\r         public List<Pet> pets;\r     };\r \r     public class Pet\r     {\r         public string givenName;\r     };\r \r     public class Address\r     {\r         public string state;\r         public string county;\r         public string city;\r     };\r \r     // Create a Family object.\r     Parent mother = new Parent { familyName= \"Wakefield\", givenName=\"Robin\" };\r     Parent father = new Parent { familyName = \"Miller\", givenName = \"Ben\" };\r     Child child = new Child { familyName=\"Merriam\", givenName=\"Jesse\", gender=\"female\", grade=1 };\r     Pet pet = new Pet { givenName = \"Fluffy\" };\r     Address address = new Address { state = \"NY\", county = \"Manhattan\", city = \"NY\" };\r     Family family = new Family { Id = \"WakefieldFamily\", parents = new Parent [] { mother, father}, children = new Child[] { child }, isRegistered = false };\r \r **JSON**  \r \r     {\r         \"id\": \"WakefieldFamily\",\r         \"parents\": [\r             { \"familyName\": \"Wakefield\", \"givenName\": \"Robin\" },\r             { \"familyName\": \"Miller\", \"givenName\": \"Ben\" }\r         ],\r         \"children\": [\r             {\r                 \"familyName\": \"Merriam\", \r                 \"givenName\": \"Jesse\", \r                 \"gender\": \"female\", \r                 \"grade\": 1,\r                 \"pets\": [\r                     { \"givenName\": \"Goofy\" },\r                     { \"givenName\": \"Shadow\" }\r                 ]\r             },\r             { \r               \"familyName\": \"Miller\", \r               \"givenName\": \"Lisa\", \r               \"gender\": \"female\", \r               \"grade\": 8 \r             }\r         ],\r         \"address\": { \"state\": \"NY\", \"county\": \"Manhattan\", \"city\": \"NY\" },\r         \"isRegistered\": false\r     };\r \r ### <a name=\"linq-to-sql-translation\"></a>LINQ 到 SQL 转换\r Cosmos DB 查询提供程序执行从 LINQ 查询到 Cosmos DB SQL 查询的最有效映射。 在以下描述中，我们假设读者对 LINQ 已经有了一个基本的了解。\r \r 首先，对于类型系统，我们支持所有 JSON 基元类型 — 数值类型、布尔、字符串和 null。 仅支持这些 JSON 类型。 支持以下的标量表达式。\r \r * 常量值 - 这些包含评估查询时基元数据类型的常量值。\r * 属性/数组索引表达式 — 这些表达式引用对象或数组元素的属性。\r \r      family.Id;    family.children[0].familyName;    family.children[0].grade;    family.children[n].grade; //n is an int variable\r * 算术表达式 - 这些表达式包含数值和布尔值上的常用算术表达式。 有关完整列表，请参阅 SQL 规范。\r \r      2 * family.children[0].grade;    x + y;\r * 字符串比较表达式 - 这些表达式包含字符串值与某些常量字符串值的比较。  \r \r      mother.familyName == \"Smith\";    child.givenName == s; //s is a string variable\r * 对象/数组创建表达式 - 这些表达式返回复合值类型或匿名类型的对象，或此类对象组成的数组。 可以嵌套这些值。\r \r      new Parent { familyName = \"Smith\", givenName = \"Joe\" }; new { first = 1, second = 2 }; //an anonymous type with two fields              \r      new int[] { 3, child.grade, 5 };\r \r ### <a name=\"SupportedLinqOperators\"></a>支持的 LINQ 运算符列表\r 以下是 DocumentDB .NET SDK 中包含的 LINQ 提供程序支持的 LINQ 运算符列表。\r \r * **Select**：投影转换为 SQL SELECT（包括对象构造）\r * **Where**：筛选器转换为 SQL WHERE，且支持 &&、|| 和 ! 与 SQL 运算符之间的转换\r * **SelectMany**：允许将数组展开到 SQL JOIN 子句。 可以用于链/嵌套表达式以对数组元素进行筛选\r * **OrderBy 和 OrderByDescending**：转换为 ORDER BY 升序/降序\r * 用于聚合的 **Count**、**Sum**、**Min**、**Max** 和 **Average** 运算符及其异步等效项 **CountAsync**、**SumAsync**、**MinAsync**、**MaxAsync** 和 **AverageAsync**。\r * **CompareTo**：转换为范围比较。 通常用于字符串，因为它们在 .NET 中不可进行比较\r * **Take**：转换为 SQL TOP，用于限制查询中的结果\r * **数学函数**：支持从 .NET 的 Abs、Acos、Asin、Atan、Ceiling、Cos、Exp、Floor、Log、Log10、Pow、Round、Sign、Sin、Sqrt、Tan、Truncate 转换为等效的 SQL 内置函数。\r * **字符串函数**：支持从 .NET 的 Concat、Contains、EndsWith、IndexOf、Count、ToLower、TrimStart、Replace、Reverse、TrimEnd、StartsWith、SubString、ToUpper 转换为等效的 SQL 内置函数。\r * **数组函数**：支持从 .NET 的 Concat、Contains 和 Count 转换为等效的 SQL 内置函数。\r * **地理空间扩展函数**：支持从 stub 方法 Distance、Within、IsValid 和 IsValidDetailed 转换为等效的 SQL 内置函数。\r * **用户定义的函数扩展函数**：支持从 stub 方法 UserDefinedFunctionProvider.Invoke 转换为相应的用户的定义函数。\r * **其他**：支持联合与条件运算符的转换。 可以根据上下文将 Contains 转换为字符串 CONTAINS、ARRAY_CONTAINS 或 SQL IN。\r \r ### <a name=\"sql-query-operators\"></a>SQL 查询运算符\r 以下示例演示了一些标准 LINQ 查询运算符是如何转换为 Cosmos DB 查询的。\r \r #### <a name=\"select-operator\"></a>Select 运算符\r 语法为 `input.Select(x => f(x))`，其中 `f` 是一个标量表达式。\r \r **LINQ Lambda 表达式**\r \r     input.Select(family => family.parents[0].familyName);\r \r **SQL** \r \r     SELECT VALUE f.parents[0].familyName\r     FROM Families f\r \r **LINQ Lambda 表达式**\r \r     input.Select(family => family.children[0].grade + c); // c is an int variable\r \r **SQL** \r \r     SELECT VALUE f.children[0].grade + c\r     FROM Families f \r \r **LINQ Lambda 表达式**\r \r     input.Select(family => new\r     {\r         name = family.children[0].familyName,\r         grade = family.children[0].grade + 3\r     });\r \r **SQL** \r \r     SELECT VALUE {\"name\":f.children[0].familyName, \r                   \"grade\": f.children[0].grade + 3 }\r     FROM Families f\r \r #### <a name=\"selectmany-operator\"></a>SelectMany 运算符\r 语法为 `input.SelectMany(x => f(x))`，其中 `f` 是返回集合类型的标量表达式。\r \r **LINQ Lambda 表达式**\r \r     input.SelectMany(family => family.children);\r \r **SQL** \r \r     SELECT VALUE child\r     FROM child IN Families.children\r \r #### <a name=\"where-operator\"></a>Where 运算符\r 语法为 `input.Where(x => f(x))`，其中 `f` 是返回布尔值的标量表达式。\r \r **LINQ Lambda 表达式**\r \r     input.Where(family=> family.parents[0].familyName == \"Smith\");\r \r **SQL** \r \r     SELECT *\r     FROM Families f\r     WHERE f.parents[0].familyName = \"Smith\" \r \r **LINQ Lambda 表达式**\r \r     input.Where(\r         family => family.parents[0].familyName == \"Smith\" && \r         family.children[0].grade < 3);\r \r **SQL** \r \r     SELECT *\r     FROM Families f\r     WHERE f.parents[0].familyName = \"Smith\"\r     AND f.children[0].grade < 3\r \r ### <a name=\"composite-sql-queries\"></a>复合 SQL 查询\r 可以将以上运算符组合在一起，形成功能更强大的查询。 由于 Cosmos DB 支持嵌套的集合，因此可以连接或嵌套运算符组合。\r \r #### <a name=\"concatenation\"></a>串联\r 语法为 `input(.|.SelectMany())(.Select()|.Where())*`。 串联的查询可以可选的 `SelectMany` 查询开始，后接多个 `Select` 或 `Where` 运算符。\r \r **LINQ Lambda 表达式**\r \r     input.Select(family=>family.parents[0])\r         .Where(familyName == \"Smith\");\r \r **SQL**\r \r     SELECT *\r     FROM Families f\r     WHERE f.parents[0].familyName = \"Smith\"\r \r **LINQ Lambda 表达式**\r \r     input.Where(family => family.children[0].grade > 3)\r         .Select(family => family.parents[0].familyName);\r \r **SQL** \r \r     SELECT VALUE f.parents[0].familyName\r     FROM Families f\r     WHERE f.children[0].grade > 3\r \r **LINQ Lambda 表达式**\r \r     input.Select(family => new { grade=family.children[0].grade}).\r         Where(anon=> anon.grade < 3);\r \r **SQL** \r \r     SELECT *\r     FROM Families f\r     WHERE ({grade: f.children[0].grade}.grade > 3)\r \r **LINQ Lambda 表达式**\r \r     input.SelectMany(family => family.parents)\r         .Where(parent => parents.familyName == \"Smith\");\r \r **SQL** \r \r     SELECT *\r     FROM p IN Families.parents\r     WHERE p.familyName = \"Smith\"\r \r #### <a name=\"nesting\"></a>嵌套\r 语法为 `input.SelectMany(x=>x.Q())`，其中 Q 是 `Select`、`SelectMany` 或 `Where` 运算符。\r \r 在嵌套查询中，内部查询应用到外部集合的每个元素。 一项重要的功能是内部查询可以引用外部集合（如自联接）中元素的字段。\r \r **LINQ Lambda 表达式**\r \r     input.SelectMany(family=> \r         family.parents.Select(p => p.familyName));\r \r **SQL** \r \r     SELECT VALUE p.familyName\r     FROM Families f\r     JOIN p IN f.parents\r \r **LINQ Lambda 表达式**\r \r     input.SelectMany(family => \r         family.children.Where(child => child.familyName == \"Jeff\"));\r \r **SQL** \r \r     SELECT *\r     FROM Families f\r     JOIN c IN f.children\r     WHERE c.familyName = \"Jeff\"\r \r **LINQ Lambda 表达式**\r \r     input.SelectMany(family => family.children.Where(\r         child => child.familyName == family.parents[0].familyName));\r \r **SQL** \r \r     SELECT *\r     FROM Families f\r     JOIN c IN f.children\r     WHERE c.familyName = f.parents[0].familyName\r \r ## <a name=\"ExecutingSqlQueries\"></a>执行 SQL 查询\r Cosmos DB 通过一个 REST API 公开资源，任何可以发出 HTTP/HTTPS 请求的语言都可以调用该 REST API。 此外，Cosmos DB 还提供多种常用语言（如 .NET、Node.js、JavaScript 和 Python）的编程库。 REST API 和各种库均支持通过 SQL 进行查询。 除了 SQL 之外，.NET SDK 还支持 LINQ 查询。\r \r 以下示例演示了如何对 Cosmos DB 数据库帐户创建和提交该查询。\r \r ### <a name=\"RestAPI\"></a>REST API\r Cosmos DB 通过 HTTP 提供开放的 RESTful 编程模型。 可以使用 Azure 订阅预配数据库帐户。 Cosmos DB 资源模型由数据库帐户下的一组资源组成，可使用一个稳定的逻辑 URI 对每个资源进行寻址。 本文档中将一组资源称为一个源。 数据库帐户由一组数据库组成，每个数据库包含多个集合，而每个集合又包含文档、UDF 和其他资源类型。\r \r 这些资源的基本交互模型借助采用其标准解释的 HTTP 谓词 GET、PUT、POST 和 DELETE。 POST 谓词用于创建新资源、执行存储过程或发出 Cosmos DB 查询。 查询始终为只读操作，且无任何副作用。\r \r 以下示例说明如何针对包含我们目前查看的两个示例文档的集合，使用 POST 进行 DocumentDB API 查询。 查询对 JSON 名称属性进行简单的筛选。 请注意，使用 `x-ms-documentdb-isquery` 和 Content-Type: `application/query+json` 标头表示该操作是一个查询。\r \r **请求**\r \r     POST https://<REST URI>/docs HTTP/1.1\r     ...\r     x-ms-documentdb-isquery: True\r     Content-Type: application/query+json\r \r     {      \r         \"query\": \"SELECT * FROM Families f WHERE f.id = @familyId\",     \r         \"parameters\": [          \r             {\"name\": \"@familyId\", \"value\": \"AndersenFamily\"}         \r         ] \r     }\r \r **结果**\r \r     HTTP/1.1 200 Ok\r     x-ms-activity-id: 8b4678fa-a947-47d3-8dd3-549a40da6eed\r     x-ms-item-count: 1\r     x-ms-request-charge: 0.32\r \r     <indented for readability, results highlighted>\r \r     {  \r        \"_rid\":\"u1NXANcKogE=\",\r        \"Documents\":[  \r           {  \r              \"id\":\"AndersenFamily\",\r              \"lastName\":\"Andersen\",\r              \"parents\":[  \r                 {  \r                    \"firstName\":\"Thomas\"\r                 },\r                 {  \r                    \"firstName\":\"Mary Kay\"\r                 }\r              ],\r              \"children\":[  \r                 {  \r                    \"firstName\":\"Henriette Thaulow\",\r                    \"gender\":\"female\",\r                    \"grade\":5,\r                    \"pets\":[  \r                       {  \r                          \"givenName\":\"Fluffy\"\r                       }\r                    ]\r                 }\r              ],\r              \"address\":{  \r                 \"state\":\"WA\",\r                 \"county\":\"King\",\r                 \"city\":\"seattle\"\r              },\r              \"_rid\":\"u1NXANcKogEcAAAAAAAAAA==\",\r              \"_ts\":1407691744,\r              \"_self\":\"dbs\\/u1NXAA==\\/colls\\/u1NXANcKogE=\\/docs\\/u1NXANcKogEcAAAAAAAAAA==\\/\",\r              \"_etag\":\"00002b00-0000-0000-0000-53e7abe00000\",\r              \"_attachments\":\"_attachments\\/\"\r           }\r        ],\r        \"count\":1\r     }\r \r 第二个示例演示了从联接中返回多个结果的更复杂的查询。\r \r **请求**\r \r     POST https://<REST URI>/docs HTTP/1.1\r     ...\r     x-ms-documentdb-isquery: True\r     Content-Type: application/query+json\r \r     {      \r         \"query\": \"SELECT \r                      f.id AS familyName, \r                      c.givenName AS childGivenName, \r                      c.firstName AS childFirstName, \r                      p.givenName AS petName \r                   FROM Families f \r                   JOIN c IN f.children \r                   JOIN p in c.pets\",     \r         \"parameters\": [] \r     }\r \r **结果**\r \r     HTTP/1.1 200 Ok\r     x-ms-activity-id: 568f34e3-5695-44d3-9b7d-62f8b83e509d\r     x-ms-item-count: 1\r     x-ms-request-charge: 7.84\r \r     <indented for readability, results highlighted>\r \r     {  \r        \"_rid\":\"u1NXANcKogE=\",\r        \"Documents\":[  \r           {  \r              \"familyName\":\"AndersenFamily\",\r              \"childFirstName\":\"Henriette Thaulow\",\r              \"petName\":\"Fluffy\"\r           },\r           {  \r              \"familyName\":\"WakefieldFamily\",\r              \"childGivenName\":\"Jesse\",\r              \"petName\":\"Goofy\"\r           },\r           {  \r              \"familyName\":\"WakefieldFamily\",\r              \"childGivenName\":\"Jesse\",\r              \"petName\":\"Shadow\"\r           }\r        ],\r        \"count\":3\r     }\r \r 如果查询的结果无法包含在一页内，那么 REST API 通过 `x-ms-continuation-token` 响应标头返回继续标记。 客户端可以通过在后续结果中包含该标头对结果进行分页。 可以通过 `x-ms-max-item-count` 数量标头控制每页的结果数。 如果指定的查询有一个聚合函数（例如 `COUNT`），则查询页可能会通过结果页返回部分聚合的值。 若要生成最终结果，客户端必须对这些结果执行二级聚合，例如，对各个页面中返回的计数进行总计，以便返回总的计数。\r \r 若要管理查询的数据一致性策略，请使用 `x-ms-consistency-level` 标头（如所有的 REST API 请求）。 对于会话一致性，还需要回显查询请求中最新的 `x-ms-session-token` Cookie 标头。 查询集合的索引策略也可以影响查询结果的一致性。 使用默认的索引策略设置，集合的索引始终与文档内容保持同步，且查询结果将与为数据选择的一致性匹配。 如果索引策略太放松而具有延迟，那么查询会返回过时的结果。 有关详细信息，请参阅 [Azure Cosmos DB 一致性级别][consistency-levels]。\r \r 如果集合上配置的索引策略不能支持指定的查询，Azure Cosmos DB 服务器会返回 400“错误请求”。 在对为哈希（等式）查找配置的路径，以及从索引中显式排除的路径进行范围查询时，返回此内容。 当索引不可用时，可通过指定 `x-ms-documentdb-query-enable-scan` 标头以允许查询执行扫描。\r \r 可通过将 `x-ms-documentdb-populatequerymetrics` 标头设置为 `True` 获取有关查询执行的详细指标。 有关详细信息，请参阅 [Azure Cosmos DB DocumentDB API 的 SQL 查询指标](documentdb-sql-query-metrics.md)。\r ### <a name=\"DotNetSdk\"></a>C# (.NET) SDK\r .NET SDK 支持 LINQ 和 SQL 查询。 以下示例演示了如何执行本文档之前介绍的简单筛选查询。\r \r     foreach (var family in client.CreateDocumentQuery(collectionLink, \r         \"SELECT * FROM Families f WHERE f.id = \\\"AndersenFamily\\\"\"))\r     {\r         Console.WriteLine(\"\\tRead {0} from SQL\", family);\r     }\r \r     SqlQuerySpec query = new SqlQuerySpec(\"SELECT * FROM Families f WHERE f.id = @familyId\");\r     query.Parameters = new SqlParameterCollection();\r     query.Parameters.Add(new SqlParameter(\"@familyId\", \"AndersenFamily\"));\r \r     foreach (var family in client.CreateDocumentQuery(collectionLink, query))\r     {\r         Console.WriteLine(\"\\tRead {0} from parameterized SQL\", family);\r     }\r \r     foreach (var family in (\r         from f in client.CreateDocumentQuery(collectionLink)\r         where f.Id == \"AndersenFamily\"\r         select f))\r     {\r         Console.WriteLine(\"\\tRead {0} from LINQ query\", family);\r     }\r \r     foreach (var family in client.CreateDocumentQuery(collectionLink)\r         .Where(f => f.Id == \"AndersenFamily\")\r         .Select(f => f))\r     {\r         Console.WriteLine(\"\\tRead {0} from LINQ lambda\", family);\r     }\r \r 此示例比较了每个文档内等式的两个属性，并使用匿名投影。 \r \r     foreach (var family in client.CreateDocumentQuery(collectionLink,\r         @\"SELECT {\"\"Name\"\": f.id, \"\"City\"\":f.address.city} AS Family \r         FROM Families f \r         WHERE f.address.city = f.address.state\"))\r     {\r         Console.WriteLine(\"\\tRead {0} from SQL\", family);\r     }\r \r     foreach (var family in (\r         from f in client.CreateDocumentQuery<Family>(collectionLink)\r         where f.address.city == f.address.state\r         select new { Name = f.Id, City = f.address.city }))\r     {\r         Console.WriteLine(\"\\tRead {0} from LINQ query\", family);\r     }\r \r     foreach (var family in\r         client.CreateDocumentQuery<Family>(collectionLink)\r         .Where(f => f.address.city == f.address.state)\r         .Select(f => new { Name = f.Id, City = f.address.city }))\r     {\r         Console.WriteLine(\"\\tRead {0} from LINQ lambda\", family);\r     }\r \r 下面的示例中演示了通过 LINQ SelectMany 表示的联接。\r \r     foreach (var pet in client.CreateDocumentQuery(collectionLink,\r           @\"SELECT p\r             FROM Families f \r                  JOIN c IN f.children \r                  JOIN p in c.pets \r             WHERE p.givenName = \"\"Shadow\"\"\"))\r     {\r         Console.WriteLine(\"\\tRead {0} from SQL\", pet);\r     }\r \r     // Equivalent in Lambda expressions\r     foreach (var pet in\r         client.CreateDocumentQuery<Family>(collectionLink)\r         .SelectMany(f => f.children)\r         .SelectMany(c => c.pets)\r         .Where(p => p.givenName == \"Shadow\"))\r     {\r         Console.WriteLine(\"\\tRead {0} from LINQ lambda\", pet);\r     }\r \r .NET 客户端自动遍历 foreach 块中所有的查询结果页，如上所示。 REST API 部分介绍的查询选项也适用于 CreateDocumentQuery 方法中使用 `FeedOptions` and `FeedResponse` 的 .NET SDK。 可使用 `MaxItemCount` 设置控制页面的数量。 \r \r 还可以通过使用 `IQueryable` 对象创建 `IDocumentQueryable`，并读取 ` ResponseContinuationToken` 值并将它们作为 `FeedOptions` 中的 `RequestContinuationToken` 向回传递，从而显式控制分页。 `EnableScanInQuery` 以启用扫描。 对于分区集合，可以使用 `PartitionKey` 来针对单个分区运行查询（尽管 Cosmos DB 可以自动从查询文本中提取此内容），并使用 `EnableCrossPartitionQuery` 来运行需要针对多个分区运行的查询。 \r \r 有关包含查询的更多示例，请参阅 [Azure Cosmos DB .NET 示例](https://github.com/Azure/azure-documentdb-net)。 \r \r ### <a name=\"JavaScriptServerSideApi\"></a>JavaScript 服务器端 API\r Cosmos DB 使用存储过程和触发器，为对集合直接执行基于 JavaScript 的应用程序逻辑提供编程模型。 集合级别上注册的 JavaScript 逻辑稍后可以对针对给定集合的文档的操作发出数据库操作。 这些操作包装在环境 ACID 事务中。\r \r 以下示例演示了如何在 JavaScript 服务器 API 中使用 queryDocuments 来从存储过程和触发器内部进行查询。\r \r     function businessLogic(name, author) {\r         var context = getContext();\r         var collectionManager = context.getCollection();\r         var collectionLink = collectionManager.getSelfLink()\r \r         // create a new document.\r         collectionManager.createDocument(collectionLink,\r             { name: name, author: author },\r             function (err, documentCreated) {\r                 if (err) throw new Error(err.message);\r \r                 // filter documents by author\r                 var filterQuery = \"SELECT * from root r WHERE r.author = 'George R.'\";\r                 collectionManager.queryDocuments(collectionLink,\r                     filterQuery,\r                     function (err, matchingDocuments) {\r                         if (err) throw new Error(err.message);\r     context.getResponse().setBody(matchingDocuments.length);\r \r                         // Replace the author name for all documents that satisfied the query.\r                         for (var i = 0; i < matchingDocuments.length; i++) {\r                             matchingDocuments[i].author = \"George R. R. Martin\";\r                             // we don't need to execute a callback because they are in parallel\r                             collectionManager.replaceDocument(matchingDocuments[i]._self,\r                                 matchingDocuments[i]);\r                         }\r                     })\r             });\r     }\r \r ## <a name=\"References\"></a>参考\r 1. [Azure Cosmos DB 简介][introduction]\r 2. [Azure Cosmos DB SQL 规范](http://go.microsoft.com/fwlink/p/?LinkID=510612)\r 3. [Azure Cosmos DB .NET 示例](https://github.com/Azure/azure-documentdb-net)\r 4. [Azure Cosmos DB 一致性级别][consistency-levels]\r 5. ANSI SQL 2011 [http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681](http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681)\r 6. JSON [http://json.org/](http://json.org/)\r 7. Javascript 规范 [http://www.ecma-international.org/publications/standards/Ecma-262.htm](http://www.ecma-international.org/publications/standards/Ecma-262.htm) \r 8. LINQ [http://msdn.microsoft.com/library/bb308959.aspx](http://msdn.microsoft.com/library/bb308959.aspx) \r 9. 针对大型数据库的查询评估技术 [http://dl.acm.org/citation.cfm?id=152611](http://dl.acm.org/citation.cfm?id=152611)\r 10. Query Processing in Parallel Relational Database Systems, IEEE Computer Society Press, 1994\r 11. Lu, Ooi, Tan, Query Processing in Parallel Relational Database Systems, IEEE Computer Society Press, 1994.\r 12. Christopher Olston, Benjamin Reed, Utkarsh Srivastava, Ravi Kumar, Andrew Tomkins: Pig Latin: A Not-So-Foreign Language for Data Processing, SIGMOD 2008.\r 13. G. Graefe. The Cascades framework for query optimization. IEEE Data Eng. Bull., 18(3): 1995.\r \r [1]: ./media/documentdb-sql-query/sql-query1.png\r [introduction]: introduction.md\r [consistency-levels]: consistency-levels.md\r \r <!--Update_Description: wording update-->"}