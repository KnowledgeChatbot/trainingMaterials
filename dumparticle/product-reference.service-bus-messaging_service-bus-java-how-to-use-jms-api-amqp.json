{"Title":"如何配合使用 AMQP 1.0 与 Java 服务总线 API","Description":"了解如何将 Java 消息服务 (JMS) 用于 Azure 服务总线和高级消息队列协议 (AMQP) 1.0。","Content":"\r # 如何将 Java 消息服务 (JMS) API 用于服务总线和 AMQP 1.0\r \r 高级消息队列协议 (AMQP) 1.0 是一个高效、可靠的线级消息传送协议，可用于构建可靠的跨平台消息传送应用程序。\r \r 在 Service Bus 中支持 AMQP 1.0 意味着可以通过一系列使用有效的二进制协议的平台利用队列和发布/订阅中转消息传送功能。此外，你还可以生成由结合使用多个语言、框架和操作系统构建的组件组成的应用程序。\r \r 本文说明如何从使用常用 Java 消息服务 (JMS) API 标准的 Java 应用程序使用服务总线消息传送功能（队列和发布/订阅主题）。有一个[配套文章](./service-bus-amqp-dotnet.md)，该文说明如何使用服务总线 .NET API 执行相同的操作。使用 AMQP 1.0，可以同时使用以下两个指南来了解跨平台消息。\r \r ## 服务总线入门\r \r 此指南假定你已有包含名为“queue1”的队列的服务总线命名空间。如果没有，则可以使用 [Azure 经典管理门户](http://manage.windowsazure.cn)创建命名空间和队列。有关如何创建服务总线命名空间和队列的详细信息，请参阅[如何使用服务总线队列](./service-bus-dotnet-get-started-with-queues.md)。\r > [!NOTE]\r >分区队列和主题也支持 AMQP。有关详细信息，请参阅[分区消息实体](./service-bus-partitioning.md)和[针对服务总线分区队列和主题的 AMQP 1.0 支持](./service-bus-amqp-protocol-guide.md)。\r \r ## 下载 AMQP 1.0 JMS 客户端库\r \r 有关从哪里下载 Apache Qpid JMS AMQP 1.0 客户端库的最新版本的信息，请访问 [https://qpid.apache.org/download.html](https://qpid.apache.org/download.html)。\r \r 使用 Service Bus 构建和运行 JMS 应用程序时必须将以下 4 个 JAR 文件从 Apache Qpid JMS AMQP 1.0 分发存档添加到 Java CLASSPATH：\r \r - geronimo-jms\\_1.1\\_spec-1.0.jar\r - qpid-amqp-1-0-client-[version].jar\r - qpid-amqp-1-0-client-jms-[version].jar\r - qpid-amqp-1-0-common-[version].jar\r \r ## 为 Java 应用程序编码\r \r ### Java 命名和目录接口 (JNDI)\r \r JMS 使用 Java 命名和目录接口 (JNDI) 创建逻辑名称和物理名称之间的分隔。将使用 JNDI 解析以下两种类型的 JMS 对象：ConnectionFactory 和 Destination。JNDI 使用一个提供程序模型，你可以在其中插入不同目录服务来处理名称解析任务。Apache Qpid JMS AMQP 1.0 库附带一个使用以下格式的属性文件配置的、基于属性文件的简单 JNDI 提供程序。\r \r ```\r     # servicebus.properties - sample JNDI configuration\r \r     # Register a ConnectionFactory in JNDI using the form:\r     # connectionfactory.[jndi_name] = [ConnectionURL]\r connectionfactory.SBCF = amqps://[SASPolicyName]:[SASPolicyKey]@[namespace].servicebus.chinacloudapi.cn\r \r     # Register some queues in JNDI using the form\r     # queue.[jndi_name] = [physical_name]\r     # topic.[jndi_name] = [physical_name]\r     queue.QUEUE = queue1\r ```\r \r #### 配置 ConnectionFactory\r \r 用于在 Qpid 属性文件 JNDI 提供程序中定义 **ConnectionFactory** 的条目的格式如下：\r \r ```\r     connectionfactory.[jndi_name] = [ConnectionURL]\r ```\r \r 其中，**[jndi\\_name]** 和 **[ConnectionURL]** 具有以下含义：\r \r - **[jndi\\_name]**：ConnectionFactory 的逻辑名称。这是将使用 JNDI IntialContext.lookup() 方法在 Java 应用程序中解析的名称。\r - **[ConnectionURL]**：向 AMQP 中转站提供包含所需信息的 JMS 库的 URL。\r \r **ConnectionURL** 的格式如下：\r \r ```\r     amqps://[SASPolicyName]:[SASPolicyKey]@[namespace].servicebus.chinacloudapi.cn\r ```\r \r 其中 **[namespace]**、**[SASPolicyName]** 和 **[SASPolicyKey]** 具有以下含义：\r \r - **[namespace]**：服务总线命名空间。\r - **[SASPolicyName]**：队列共享访问签名策略名称。\r - **[SASPolicyKey]**：队列共享访问签名策略密钥。\r \r > [!NOTE]\r > 必须手动为密码进行 URL 编码。在 [http://www.w3schools.com/tags/ref_urlencode.asp](http://www.w3schools.com/tags/ref_urlencode.asp) 上提供了一个有用的 URL 编码实用工具。\r \r #### 配置目标\r \r 用于在 Qpid 属性文件 JNDI 提供程序中定义目标的项的格式如下：\r \r ```\r     queue.[jndi_name] = [physical_name]\r ```\r \r 或\r \r ```\r     topic.[jndi_name] = [physical_name]\r ```\r \r 其中，**[jndi\\_name]** 和 **[physical\\_name]** 的含义如下：\r \r - **[jndi\\_name]**：目标的逻辑名称。这是将使用 JNDI IntialContext.lookup() 方法在 Java 应用程序中解析的名称。\r - **[physical\\_name]**：应用程序向其发送或从该处接收消息的服务总线实体的名称。\r \r > [!NOTE]\r >在从 Service Bus 主题订阅中接收时，在 JNDI 中指定的物理名称应该是该主题的名称。在 JMS 应用程序代码中创建可持久订阅时提供该订阅名称。[服务总线 AMQP 1.0 开发人员指南](./service-bus-amqp-dotnet.md)提供了有关从 JMS 使用服务总线主题订阅的更多详细信息。\r \r ### 编写 JMS 应用程序\r \r 将 JMS 用于服务总线时不需要特殊的 API 或选项。但是，有一些限制，我们将在后面说明。与使用任何 JMS 应用程序一样，若要解析 **ConnectionFactory** 和目标，首先要做的事情是配置 JNDI 环境。\r \r #### 配置 JNDI InitialContext\r \r JNDI 环境是通过将配置信息的哈希表传入到 javax.naming.InitialContext 类的构造函数中来配置的。哈希表中的两个必需元素是初始上下文工厂的类名称和提供程序 URL。以下代码演示了如何配置 JNDI 环境以将基于 Qpid 属性文件的 JNDI 提供程序用于名为 **servicebus.properties** 的属性文件。\r \r ```java\r     Hashtable<String, String> env = new Hashtable<String, String>(); \r     env.put(Context.INITIAL_CONTEXT_FACTORY, \"org.apache.qpid.amqp_1_0.jms.jndi.PropertiesFileInitialContextFactory\"); \r     env.put(Context.PROVIDER_URL, \"servicebus.properties\"); \r     InitialContext context = new InitialContext(env);\r ```\r \r ### 使用 Service Bus 队列的简单 JMS 应用程序\r \r 以下示例程序将 JMS TextMessages 发送到 JNDI 逻辑名称为 QUEUE 的 Service Bus 队列，然后接收返回的消息。\r \r ```java\r     // SimpleSenderReceiver.java\r \r     import javax.jms.*;\r     import javax.naming.Context;\r     import javax.naming.InitialContext;\r     import java.io.BufferedReader;\r     import java.io.InputStreamReader;\r     import java.util.Hashtable;\r     import java.util.Random;\r \r     public class SimpleSenderReceiver implements MessageListener {\r         private static boolean runReceiver = true;\r         private Connection connection;\r         private Session sendSession;\r         private Session receiveSession;\r         private MessageProducer sender;\r         private MessageConsumer receiver;\r         private static Random randomGenerator = new Random();\r \r         public SimpleSenderReceiver() throws Exception {\r             // Configure JNDI environment\r             Hashtable<String, String> env = new Hashtable<String, String>();\r             env.put(Context.INITIAL_CONTEXT_FACTORY, \r                     \"org.apache.qpid.amqp_1_0.jms.jndi.PropertiesFileInitialContextFactory\");\r             env.put(Context.PROVIDER_URL, \"servicebus.properties\");\r             Context context = new InitialContext(env);\r \r             // Lookup ConnectionFactory and Queue\r             ConnectionFactory cf = (ConnectionFactory) context.lookup(\"SBCF\");\r             Destination queue = (Destination) context.lookup(\"QUEUE\");\r \r             // Create Connection\r             connection = cf.createConnection();\r \r             // Create sender-side Session and MessageProducer\r             sendSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\r             sender = sendSession.createProducer(queue);\r \r             if (runReceiver) {\r                 // Create receiver-side Session, MessageConsumer,and MessageListener\r                 receiveSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\r                 receiver = receiveSession.createConsumer(queue);\r                 receiver.setMessageListener(this);\r                 connection.start();\r             }\r         }\r \r         public static void main(String[] args) {\r             try {\r \r                 if ((args.length > 0) && args[0].equalsIgnoreCase(\"sendonly\")) {\r                     runReceiver = false;\r                 }\r \r                 SimpleSenderReceiver simpleSenderReceiver = new SimpleSenderReceiver();\r                 System.out.println(\"Press [enter] to send a message. Type 'exit' + [enter] to quit.\");\r                 BufferedReader commandLine = new java.io.BufferedReader(new InputStreamReader(System.in));\r \r                 while (true) {\r                     String s = commandLine.readLine();\r                     if (s.equalsIgnoreCase(\"exit\")) {\r                         simpleSenderReceiver.close();\r                         System.exit(0);\r                     } else {\r                         simpleSenderReceiver.sendMessage();\r                     }\r                 }\r             } catch (Exception e) {\r                 e.printStackTrace();\r             }\r         }\r \r         private void sendMessage() throws JMSException {\r             TextMessage message = sendSession.createTextMessage();\r             message.setText(\"Test AMQP message from JMS\");\r             long randomMessageID = randomGenerator.nextLong() >>>1;\r             message.setJMSMessageID(\"ID:\" + randomMessageID);\r             sender.send(message);\r             System.out.println(\"Sent message with JMSMessageID = \" + message.getJMSMessageID());\r         }\r \r         public void close() throws JMSException {\r             connection.close();\r         }\r \r         public void onMessage(Message message) {\r             try {\r                 System.out.println(\"Received message with JMSMessageID = \" + message.getJMSMessageID());\r                 message.acknowledge();\r             } catch (Exception e) {\r                 e.printStackTrace();\r             }\r         }\r     }\t\r ```\r \r ### 运行应用程序\r \r 运行应用程序将产生以下形式的输出：\r \r ```\r     > java SimpleSenderReceiver\r     Press [enter] to send a message. Type 'exit' + [enter] to quit.\r \r     Sent message with JMSMessageID = ID:2867600614942270318\r     Received message with JMSMessageID = ID:2867600614942270318\r \r     Sent message with JMSMessageID = ID:7578408152750301483\r     Received message with JMSMessageID = ID:7578408152750301483\r \r     Sent message with JMSMessageID = ID:956102171969368961\r     Received message with JMSMessageID = ID:956102171969368961\r     exit\r ```\r \r ##JMS 和 .NET 之间的跨平台消息传送\r \r 本指南说明了如何使用 JMS 向 Service Bus 发送消息以及从 Service Bus 接收消息。但是，AMQP 1.0 的关键优势之一是它支持通过以不同语言编写的组件生成应用程序，从而能够可靠和完全无损地交换消息。\r \r 通过使用前面所述的示例 JMS 应用程序和从随附的指南[如何将 AMQP 1.0 用于 .NET 服务总线 .NET API](./service-bus-amqp-dotnet.md) 中选取的类似 .NET 应用程序，你可以在 .NET 和 Java 之间交换消息。\r \r 有关使用服务总线和 AMQP 1.0 的跨平台消息传送的详细信息，请参阅[服务总线 AMQP 1.0 开发人员指南](./service-bus-amqp-dotnet.md)。\r \r ### JMS 到 .NET\r \r 演示 JMS 到 .NET 消息传送：\r \r * 启动 .NET 示例应用程序而不使用任何命令行参数。\r * 使用“sendonly”命令行参数启动 Java 示例应用程序。在此模式下，应用程序不会从队列接收消息，而只会发送消息。\r * 在 Java 应用程序控制台中按 **Enter** 多次，这将导致消息发送。\r * 这些消息由 .NET 应用程序接收。\r \r #### 从 JMS 应用程序输出\r \r ```\r     > java SimpleSenderReceiver sendonly\r     Press [enter] to send a message. Type 'exit' + [enter] to quit.\r     Sent message with JMSMessageID = ID:4364096528752411591\r     Sent message with JMSMessageID = ID:459252991689389983\r     Sent message with JMSMessageID = ID:1565011046230456854\r     exit\r ```\r \r #### 从 .NET 应用程序输出\r \r ```\r     > SimpleSenderReceiver.exe\t\r     Press [enter] to send a message. Type 'exit' + [enter] to quit.\r     Received message with MessageID = 4364096528752411591\r     Received message with MessageID = 459252991689389983\r     Received message with MessageID = 1565011046230456854\r     exit\r ```\r \r ### .NET 到 JMS\r \r 演示 NET 到 JMS 消息传送：\r \r * 使用“sendonly”命令行参数启动 .NET 示例应用程序。在此模式下，应用程序不会从队列接收消息，而只会发送消息。\r * 启动 Java 示例应用程序而不使用任何命令行参数。\r * 在 .NET 应用程序控制台中按 **Enter** 多次，这将导致消息发送。\r * 这些消息由 Java 应用程序接收。\r \r #### 从 .NET 应用程序输出\r \r ```\r     > SimpleSenderReceiver.exe sendonly\r     Press [enter] to send a message. Type 'exit' + [enter] to quit.\r     Sent message with MessageID = d64e681a310a48a1ae0ce7b017bf1cf3\t\r     Sent message with MessageID = 98a39664995b4f74b32e2a0ecccc46bb\r     Sent message with MessageID = acbca67f03c346de9b7893026f97ddeb\r     exit\r ```\r \r #### 从 JMS 应用程序输出\r \r ```\r     > java SimpleSenderReceiver\t\r     Press [enter] to send a message. Type 'exit' + [enter] to quit.\r     Received message with JMSMessageID = ID:d64e681a310a48a1ae0ce7b017bf1cf3\r     Received message with JMSMessageID = ID:98a39664995b4f74b32e2a0ecccc46bb\r     Received message with JMSMessageID = ID:acbca67f03c346de9b7893026f97ddeb\r     exit\r ```\r \r ## 不受支持的功能和限制\r \r 在将 JMS over AMQP 1.0 用于 Service Bus 时存在以下限制，即：\r \r * 每个**会话**只允许一个 **MessageProducer** 或 **MessageConsumer**。如果你需要在应用程序中创建多个 **MessageProducer** 或 **MessageConsumer**，请分别为它们创建专用**会话**。\r * 当前不支持易失性主题订阅。\r * 当前不支持 **MessageSelectors**。\r * 当前不支持临时目标（即 **TemporaryQueue** 和 **TemporaryTopic**），以及使用这些目标的 **QueueRequestor** 和 **TopicRequestor** API。\r * 不支持事务处理会话和分布式事务。\r \r ## 摘要\r \r 本操作方法指南演示了如何通过使用常用 JMS API 和 AMQP 1.0 通过 Java 使用 Service Bus 中转消息传送功能（队列和发布/订阅主题）。\r \r 也可以通过其他语言（包括 .NET、C、Python 和 PHP）使用 Service Bus AMQP 1.0。使用这些不同语言构建的组件可以使用服务总线中的 AMQP 1.0 支持可靠且完全无损地交换消息。有关详细信息，请参阅[服务总线 AMQP 1.0 开发人员指南](./service-bus-amqp-dotnet.md)。\r \r ## 后续步骤\r \r * [Azure Service Bus 中的 AMQP 1.0 支持](./service-bus-amqp-overview.md)\r * [如何将 AMQP 1.0 与服务总线 .NET API 一起使用](./service-bus-amqp-dotnet.md)\r * [服务总线 AMQP 1.0 开发人员指南](./service-bus-amqp-dotnet.md)\r * [如何使用 Service Bus 队列](./service-bus-dotnet-get-started-with-queues.md)\r * [Java 开发人员中心](https://www.azure.cn/develop/java/)。\r \r <!---HONumber=Mooncake_Quality_Review_0104_2017-->\r <!--Update_Description:update meta properties-->"}