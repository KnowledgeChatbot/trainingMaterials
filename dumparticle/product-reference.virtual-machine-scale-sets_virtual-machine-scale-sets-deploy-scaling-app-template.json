{"Title":"在 Azure 虚拟机规模集上部署应用","Description":"了解如何使用 Azure 资源管理器模板在虚拟机规模集上部署简单的自动缩放应用程序。","Content":"# <a name=\"deploy-an-autoscaling-app-using-a-template\"></a>使用模板部署自动缩放应用\r \r [Azure 资源管理器模板](/azure-resource-manager/resource-group-overview#template-deployment)是部署成组的相关资源的好办法。 本教程基于[部署简单规模集](virtual-machine-scale-sets-mvss-start.md)，介绍如何使用 Azure 资源管理器模板在规模集上部署简单的自动缩放应用程序。  还可以使用 PowerShell、CLI 或门户设置自动缩放。 有关详细信息，请参阅[自动缩放概述](virtual-machine-scale-sets-autoscale-overview.md)。\r \r ## <a name=\"two-quickstart-templates\"></a>两个快速入门模板\r 部署规模集时，可以使用 [VM 扩展](../virtual-machines/virtual-machines-windows-extensions-features.md)在平台映像中安装新软件。 VM 扩展是小型应用程序，可在Azure 虚拟机上提供部署后配置和自动化任务，例如部署应用。 [Azure/azure-quickstart-templates](https://github.com/Azure/azure-quickstart-templates) 中提供两个不同的示例模板，介绍了如何使用 VM 扩展会自动缩放应用程序部署到规模集上。\r \r ### <a name=\"python-http-server-on-linux\"></a>Linux 上的 Python HTTP 服务器\r [Linux 上的 Python HTTP 服务器](https://github.com/Azure/azure-quickstart-templates/tree/master/201-vmss-bottle-autoscale)示例模板部署一个在 Linux 规模集上运行的简单自动缩放应用程序。  使用自定义脚本 VM 扩展在规模集的每个 VM 上部署 Python Web 框架 [Bottle](http://bottlepy.org/docs/dev/) 和一个简单的 HTTP 服务器。 此规模集在所有 VM 的平均 CPU 使用率高于 60% 时增加，在平均 CPU 使用率低于 30% 时减少。\r \r 除规模集资源外，azuredeploy.json 示例模板还声明虚拟网络、公共 IP 地址、负载均衡器和自动缩放设置资源。  \r \r 在 azuredeploy.json 模板中，`Microsoft.Compute/virtualMachineScaleSets` 资源的 `extensionProfile` 属性指定自定义脚本扩展。 `fileUris` 指定脚本位置。 在这种情况下，存在两个文件：workserver.py，用于指定一个简单的 HTTP 服务器；installserver.sh，用于安装 Bottle 并启动 HTTP 服务器。 部署规模集后，`commandToExecute` 指定要运行的命令。\r \r ```json\r           \"extensionProfile\": {\r             \"extensions\": [\r               {\r                 \"name\": \"lapextension\",\r                 \"properties\": {\r                   \"publisher\": \"Microsoft.Azure.Extensions\",\r                   \"type\": \"CustomScript\",\r                   \"typeHandlerVersion\": \"2.0\",\r                   \"autoUpgradeMinorVersion\": true,\r                   \"settings\": {\r                     \"fileUris\": [\r                       \"https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/201-vmss-bottle-autoscale/installserver.sh\",\r                       \"https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/201-vmss-bottle-autoscale/workserver.py\"\r                     ],\r                     \"commandToExecute\": \"bash installserver.sh\"\r                   }\r                 }\r               }\r             ]\r           }\r ```\r \r ### <a name=\"aspnet-mvc-application-on-windows\"></a>Windows 上的 ASP.NET MVC 应用程序\r [Windows 上的 ASP.NET MVC 应用程序](https://github.com/Azure/azure-quickstart-templates/tree/master/201-vmss-windows-webapp-dsc-autoscale)示例模板部署一个在 Windows 规模集的 IIS 中运行的简单 ASP.NET MVC 应用。  使用 [PowerShell 所需状态配置 (DSC)](virtual-machine-scale-sets-dsc.md) VM 扩展部署 IIS 和 MVC 应用。  CPU 使用率高于 50% 持续 5 分钟时，（VM 上的）规模集增加。 \r \r 除规模集资源外，azuredeploy.json 示例模板还声明虚拟网络、公共 IP 地址、负载均衡器和自动缩放设置资源。 此外，该模板还演示了应用程序升级。\r \r 在 azuredeploy.json 模板中，`Microsoft.Compute/virtualMachineScaleSets` 资源的 `extensionProfile` 属性指定[所需状态配置 (DSC)](virtual-machine-scale-sets-dsc.md) 扩展，此扩展从 WebDeploy 包安装 IIS 和默认 Web 应用。  IISInstall.ps1 脚本在虚拟机上安装 IIS，该脚本位于 DSC 文件夹中。  可在 WebDeploy 文件夹中找到 MVC Web 应用。  安装脚本和 Web 应用的路径定义在 azuredeploy.parameters.json 文件的 `powershelldscZip` 和 `webDeployPackage` 中。 \r \r ```json\r           \"extensionProfile\": {\r             \"extensions\": [\r               {\r                 \"name\": \"Microsoft.Powershell.DSC\",\r                 \"properties\": {\r                   \"publisher\": \"Microsoft.Powershell\",\r                   \"type\": \"DSC\",\r                   \"typeHandlerVersion\": \"2.9\",\r                   \"autoUpgradeMinorVersion\": true,\r                   \"forceUpdateTag\": \"[parameters('powershelldscUpdateTagVersion')]\",\r                   \"settings\": {\r                     \"configuration\": {\r                       \"url\": \"[variables('powershelldscZipFullPath')]\",\r                       \"script\": \"IISInstall.ps1\",\r                       \"function\": \"InstallIIS\"\r                     },\r                     \"configurationArguments\": {\r                       \"nodeName\": \"localhost\",\r                       \"WebDeployPackagePath\": \"[variables('webDeployPackageFullPath')]\"\r                     }\r                   }\r                 }\r               }\r             ]\r           }\r ```\r \r ## <a name=\"deploy-the-template\"></a>部署模板\r 部署 [Linux 上的 Python HTTP 服务器](https://github.com/Azure/azure-quickstart-templates/tree/master/201-vmss-bottle-autoscale)或 [Windows 上的 ASP.NET MVC 应用](https://github.com/Azure/azure-quickstart-templates/tree/master/201-vmss-windows-webapp-dsc-autoscale)模板最简单的方式是使用 GitHub 的自述文件中的“部署到 Azure”按钮。  也可使用 PowerShell 或 Azure CLI 部署示例模板。\r \r ### <a name=\"powershell\"></a>PowerShell\r 将 [Linux 上的 Python HTTP 服务器](https://github.com/Azure/azure-quickstart-templates/tree/master/201-vmss-bottle-autoscale)或 [Windows 上的 ASP.NET MVC 应用](https://github.com/Azure/azure-quickstart-templates/tree/master/201-vmss-windows-webapp-dsc-autoscale)文件从 GitHub 存储库复制到本地计算机上的文件夹。  打开 azuredeploy.parameters.json 文件并更新 `vmssName`、`adminUsername` 和 `adminPassword` 参数的默认值。 将以下 PowerShell 脚本保存到 azuredeploy.json 模板所在文件夹中的 deploy.ps1。 若要部署示例模板，请从 PowerShell 命令窗口运行 deploy.ps1 脚本。\r \r ```powershell\r param(\r  [Parameter(Mandatory=$True)]\r  [string]\r  $subscriptionId,\r \r  [Parameter(Mandatory=$True)]\r  [string]\r  $resourceGroupName,\r \r  [string]\r  $resourceGroupLocation,\r \r  [Parameter(Mandatory=$True)]\r  [string]\r  $deploymentName,\r \r  [string]\r  $templateFilePath = \"template.json\",\r \r  [string]\r  $parametersFilePath = \"parameters.json\"\r )\r \r <#\r .SYNOPSIS\r     Registers RPs\r #>\r Function RegisterRP {\r     Param(\r         [string]$ResourceProviderNamespace\r     )\r \r     Write-Host \"Registering resource provider '$ResourceProviderNamespace'\";\r     Register-AzureRmResourceProvider -ProviderNamespace $ResourceProviderNamespace;\r }\r \r #******************************************************************************\r # Script body\r # Execution begins here\r #******************************************************************************\r $ErrorActionPreference = \"Stop\"\r \r # sign in\r Write-Host \"Logging in...\";\r Login-AzureRmAccount -EnvironmentName AzureChinaCloud;\r \r # select subscription\r Write-Host \"Selecting subscription '$subscriptionId'\";\r Select-AzureRmSubscription -SubscriptionID $subscriptionId;\r \r # Register RPs\r $resourceProviders = @(\"microsoft.compute\",\"microsoft.insights\",\"microsoft.network\");\r if($resourceProviders.length) {\r     Write-Host \"Registering resource providers\"\r     foreach($resourceProvider in $resourceProviders) {\r         RegisterRP($resourceProvider);\r     }\r }\r \r #Create or check for existing resource group\r $resourceGroup = Get-AzureRmResourceGroup -Name $resourceGroupName -ErrorAction SilentlyContinue\r if(!$resourceGroup)\r {\r     Write-Host \"Resource group '$resourceGroupName' does not exist. To create a new resource group, please enter a location.\";\r     if(!$resourceGroupLocation) {\r         $resourceGroupLocation = Read-Host \"resourceGroupLocation\";\r     }\r     Write-Host \"Creating resource group '$resourceGroupName' in location '$resourceGroupLocation'\";\r     New-AzureRmResourceGroup -Name $resourceGroupName -Location $resourceGroupLocation\r }\r else{\r     Write-Host \"Using existing resource group '$resourceGroupName'\";\r }\r \r # Start the deployment\r Write-Host \"Starting deployment...\";\r if(Test-Path $parametersFilePath) {\r     New-AzureRmResourceGroupDeployment -ResourceGroupName $resourceGroupName -TemplateFile $templateFilePath -TemplateParameterFile $parametersFilePath;\r } else {\r     New-AzureRmResourceGroupDeployment -ResourceGroupName $resourceGroupName -TemplateFile $templateFilePath;\r }\r ```\r \r ### <a name=\"azure-cli\"></a>Azure CLI\r ```azurecli\r #!/bin/bash\r set -euo pipefail\r IFS=$'\\n\\t'\r \r # -e: immediately exit if any command has a non-zero exit status\r # -o: prevents errors in a pipeline from being masked\r # IFS new value is less likely to cause confusing bugs when looping arrays or arguments (e.g. $@)\r \r usage() { echo \"Usage: $0 -i <subscriptionId> -g <resourceGroupName> -n <deploymentName> -l <resourceGroupLocation>\" 1>&2; exit 1; }\r \r declare subscriptionId=\"\"\r declare resourceGroupName=\"\"\r declare deploymentName=\"\"\r declare resourceGroupLocation=\"\"\r \r # Initialize parameters specified from command line\r while getopts \":i:g:n:l:\" arg; do\r     case \"${arg}\" in\r         i)\r             subscriptionId=${OPTARG}\r             ;;\r         g)\r             resourceGroupName=${OPTARG}\r             ;;\r         n)\r             deploymentName=${OPTARG}\r             ;;\r         l)\r             resourceGroupLocation=${OPTARG}\r             ;;\r         esac\r done\r shift $((OPTIND-1))\r \r #Prompt for parameters is some required parameters are missing\r if [[ -z \"$subscriptionId\" ]]; then\r     echo \"Subscription Id:\"\r     read subscriptionId\r     [[ \"${subscriptionId:?}\" ]]\r fi\r \r if [[ -z \"$resourceGroupName\" ]]; then\r     echo \"ResourceGroupName:\"\r     read resourceGroupName\r     [[ \"${resourceGroupName:?}\" ]]\r fi\r \r if [[ -z \"$deploymentName\" ]]; then\r     echo \"DeploymentName:\"\r     read deploymentName\r fi\r \r if [[ -z \"$resourceGroupLocation\" ]]; then\r     echo \"Enter a location below to create a new resource group else skip this\"\r     echo \"ResourceGroupLocation:\"\r     read resourceGroupLocation\r fi\r \r #templateFile Path - template file to be used\r templateFilePath=\"template.json\"\r \r if [ ! -f \"$templateFilePath\" ]; then\r     echo \"$templateFilePath not found\"\r     exit 1\r fi\r \r #parameter file path\r parametersFilePath=\"parameters.json\"\r \r if [ ! -f \"$parametersFilePath\" ]; then\r     echo \"$parametersFilePath not found\"\r     exit 1\r fi\r \r if [ -z \"$subscriptionId\" ] || [ -z \"$resourceGroupName\" ] || [ -z \"$deploymentName\" ]; then\r     echo \"Either one of subscriptionId, resourceGroupName, deploymentName is empty\"\r     usage\r fi\r \r #login to azure using your credentials\r az account show 1> /dev/null\r \r if [ $? != 0 ];\r then\r     az cloud set -n AzureChinaCloud\r     az login\r fi\r \r #set the default subscription id\r az account set --name $subscriptionId\r \r set +e\r \r #Check for existing RG\r az group show $resourceGroupName 1> /dev/null\r \r if [ $? != 0 ]; then\r     echo \"Resource group with name\" $resourceGroupName \"could not be found. Creating new resource group..\"\r     set -e\r     (\r         set -x\r         az group create --name $resourceGroupName --location $resourceGroupLocation 1> /dev/null\r     )\r     else\r     echo \"Using existing resource group...\"\r fi\r \r #Start deployment\r echo \"Starting deployment...\"\r (\r     set -x\r     az group deployment create --name $deploymentName --resource-group $resourceGroupName --template-file $templateFilePath --parameters $parametersFilePath\r )\r \r if [ $?  == 0 ];\r  then\r     echo \"Template has been successfully deployed\"\r fi\r ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r \r [!INCLUDE [mvss-next-steps-include](../../includes/mvss-next-steps.md)]\r \r "}