{"Title":"如何通过 Java 使用队列存储","Description":"了解如何使用 Azure 队列服务创建和删除队列，以及插入、获取和删除消息。 用 Java 编写的示例。","Content":"# <a name=\"how-to-use-queue-storage-from-java\"></a>如何通过 Java 使用队列存储\r [!INCLUDE [storage-selector-queue-include](../../../includes/storage-selector-queue-include.md)]\r \r [!INCLUDE [storage-check-out-samples-java](../../../includes/storage-check-out-samples-java.md)]\r \r ## <a name=\"overview\"></a>概述\r 本指南演示如何使用 Azure 队列存储服务执行常见方案。 这些示例用 Java 编写并使用[用于 Java 的 Azure 存储 SDK][Azure Storage SDK for Java]。 介绍的方案包括插入、扫视、获取和删除队列消息以及创建和删除队列。 有关队列的详细信息，请参阅[后续步骤](#Next-Steps)部分。\r \r 注意：为在 Android 设备上使用 Azure 存储的开发人员提供了 SDK。 有关详细信息，请参阅[用于 Android 的 Azure 存储 SDK][Azure Storage SDK for Android]。\r \r [!INCLUDE [storage-queue-concepts-include](../../../includes/storage-queue-concepts-include.md)]\r \r [!INCLUDE [storage-create-account-include](../../../includes/storage-create-account-include.md)]\r \r ## <a name=\"create-a-java-application\"></a>创建 Java 应用程序\r 本指南会使用存储功能，这些功能可在本地 Java 应用程序中运行，或在 Azure 的 Web 角色或辅助角色中通过运行的代码来运行。\r \r 为此，需要安装 Java 开发工具包 (JDK)，并在 Azure 订阅中创建一个 Azure 存储帐户。 完成此操作后，需要验证开发系统是否满足最低要求和 GitHub 上的[用于 Java 的 Azure 存储 SDK][Azure Storage SDK for Java] 存储库中列出的依赖项。 如果系统满足这些要求，可以按照说明下载和安装系统中该存储库的用于 Java 的 Azure 存储库。 完成这些任务后，便能够创建一个 Java 应用程序，以便使用本文中的示例。\r \r ## <a name=\"configure-your-application-to-access-queue-storage\"></a>配置应用程序以访问队列存储\r 将下列 import 语句添加到需要在其中使用 Azure 存储 API 来访问队列的 Java 文件的顶部：\r \r ```java\r // Include the following imports to use queue APIs.\r import com.microsoft.azure.storage.*;\r import com.microsoft.azure.storage.queue.*;\r ```\r \r ## <a name=\"setup-an-azure-storage-connection-string\"></a>设置 Azure 存储连接字符串\r Azure 存储客户端使用存储连接字符串来存储用于访问数据管理服务的终结点和凭据。 在客户端应用程序中运行时，必须提供以下格式的存储连接字符串，并对 AccountName 和 AccountKey 值使用 [Azure 门户](https://portal.azure.cn)中列出的存储帐户的名称和存储帐户的主访问密钥。 此示例演示如何声明一个静态字段以保存连接字符串：\r \r ```java\r // Define the connection-string with your values.\r public static final String storageConnectionString =\r     \"DefaultEndpointsProtocol=http;\" +\r     \"AccountName=your_storage_account;\" +\r     \"AccountKey=your_storage_account_key;\" +\r     \"EndpointSuffix=core.chinacloudapi.cn\";\r ```\r \r 在 Azure 的角色中运行的应用程序中，此字符串可存储在服务配置文件 *ServiceConfiguration.cscfg*中，并可通过调用 **RoleEnvironment.getConfigurationSettings** 方法进行访问。 下面是从服务配置文件中名为 **StorageConnectionString** 的 *Setting* 元素中获取连接字符串的示例：\r \r ```java\r // Retrieve storage account from connection-string.\r String storageConnectionString =\r     RoleEnvironment.getConfigurationSettings().get(\"StorageConnectionString\");\r ```\r \r 下面的示例假定使用了这两个方法之一来获取存储连接字符串。\r \r ## <a name=\"how-to-create-a-queue\"></a>如何：创建队列\r 利用 CloudQueueClient 对象，可以获取队列的引用对象。 以下代码将创建 CloudQueueClient 对象。 （注意：还有其他方式可创建 CloudStorageAccount 对象；有关详细信息，请参阅 [Azure 存储客户端 SDK 参考]中的 CloudStorageAccount。）\r \r 使用 **CloudQueueClient** 对象获取对要使用的队列的引用。 如果队列不存在，可以创建它。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r        CloudStorageAccount.parse(storageConnectionString);\r \r    // Create the queue client.\r    CloudQueueClient queueClient = storageAccount.createCloudQueueClient();\r \r    // Retrieve a reference to a queue.\r    CloudQueue queue = queueClient.getQueueReference(\"myqueue\");\r \r    // Create the queue if it doesn't already exist.\r    queue.createIfNotExists();\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-add-a-message-to-a-queue\"></a>如何：向队列添加消息\r 要将消息插入现有队列，请先创建一个新的 **CloudQueueMessage**。 接下来，调用 **addMessage** 方法。 可从字符串（UTF-8 格式）或字节数组创建 CloudQueueMessage。 以下代码将创建队列（如果队列不存在）并插入消息“Hello, World”。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r        CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the queue client.\r     CloudQueueClient queueClient = storageAccount.createCloudQueueClient();\r \r     // Retrieve a reference to a queue.\r     CloudQueue queue = queueClient.getQueueReference(\"myqueue\");\r \r     // Create the queue if it doesn't already exist.\r     queue.createIfNotExists();\r \r     // Create a message and add it to the queue.\r     CloudQueueMessage message = new CloudQueueMessage(\"Hello, World\");\r     queue.addMessage(message);\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-peek-at-the-next-message\"></a>如何：扫视下一条消息\r 通过调用 **peekMessage**，可以扫视队列前面的消息，而不会从队列中删除它。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r        CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the queue client.\r     CloudQueueClient queueClient = storageAccount.createCloudQueueClient();\r \r     // Retrieve a reference to a queue.\r     CloudQueue queue = queueClient.getQueueReference(\"myqueue\");\r \r     // Peek at the next message.\r     CloudQueueMessage peekedMessage = queue.peekMessage();\r \r     // Output the message value.\r     if (peekedMessage != null)\r     {\r       System.out.println(peekedMessage.getMessageContentAsString());\r    }\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-change-the-contents-of-a-queued-message\"></a>如何：更改已排队消息的内容\r 可更改队列中现有消息的内容。 如果消息表示工作任务，可使用此功能来更新该工作任务的状态。 以下代码使用新内容更新队列消息，并将可见性超时设置为再延长 60 秒。 这会保存与消息关联的工作的状态，并额外为客户端提供一分钟的时间来继续处理消息。 可使用此方法跟踪队列消息上的多步骤工作流，即使处理步骤因硬件或软件故障而失败，也无需从头开始操作。 通常也会保留重试计数，当消息重试次数超过 n 时再删除该消息。 这可避免每次处理某条消息时都触发应用程序错误。\r \r 下面的代码示例将搜索队列中的消息，查找内容中第一个与“Hello, World”匹配的消息，并对消息内容进行修改并退出。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the queue client.\r     CloudQueueClient queueClient = storageAccount.createCloudQueueClient();\r \r     // Retrieve a reference to a queue.\r     CloudQueue queue = queueClient.getQueueReference(\"myqueue\");\r \r     // The maximum number of messages that can be retrieved is 32.\r     final int MAX_NUMBER_OF_MESSAGES_TO_PEEK = 32;\r \r     // Loop through the messages in the queue.\r     for (CloudQueueMessage message : queue.retrieveMessages(MAX_NUMBER_OF_MESSAGES_TO_PEEK,1,null,null))\r     {\r         // Check for a specific string.\r         if (message.getMessageContentAsString().equals(\"Hello, World\"))\r         {\r             // Modify the content of the first matching message.\r             message.setMessageContent(\"Updated contents.\");\r             // Set it to be visible in 30 seconds.\r             EnumSet<MessageUpdateFields> updateFields =\r                 EnumSet.of(MessageUpdateFields.CONTENT,\r                 MessageUpdateFields.VISIBILITY);\r             // Update the message.\r             queue.updateMessage(message, 30, updateFields, null, null);\r             break;\r         }\r     }\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r 或者，以下代码示例只更新了队列中第一个可见消息\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r        CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the queue client.\r     CloudQueueClient queueClient = storageAccount.createCloudQueueClient();\r \r     // Retrieve a reference to a queue.\r     CloudQueue queue = queueClient.getQueueReference(\"myqueue\");\r \r     // Retrieve the first visible message in the queue.\r     CloudQueueMessage message = queue.retrieveMessage();\r \r     if (message != null)\r     {\r         // Modify the message content.\r         message.setMessageContent(\"Updated contents.\");\r         // Set it to be visible in 60 seconds.\r         EnumSet<MessageUpdateFields> updateFields =\r             EnumSet.of(MessageUpdateFields.CONTENT,\r             MessageUpdateFields.VISIBILITY);\r         // Update the message.\r         queue.updateMessage(message, 60, updateFields, null, null);\r     }\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-get-the-queue-length\"></a>如何：获取队列长度\r 可以获取队列中消息的估计数。 **downloadAttributes** 方法会询问队列服务一些当前值，包括队列中消息的计数。 此计数仅为近似值，因为只能在队列服务响应请求后添加或删除消息。 getApproximateMessageCount 方法返回通过调用 downloadAttributes 检索到的最后一个值，而不会调用队列服务。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r        CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the queue client.\r     CloudQueueClient queueClient = storageAccount.createCloudQueueClient();\r \r     // Retrieve a reference to a queue.\r     CloudQueue queue = queueClient.getQueueReference(\"myqueue\");\r \r    // Download the approximate message count from the server.\r     queue.downloadAttributes();\r \r     // Retrieve the newly cached approximate message count.\r     long cachedMessageCount = queue.getApproximateMessageCount();\r \r     // Display the queue length.\r     System.out.println(String.format(\"Queue length: %d\", cachedMessageCount));\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-dequeue-the-next-message\"></a>如何：取消对下一条消息的排队\r 代码通过两个步骤来取消对队列中某条消息的排队。 在调用 **retrieveMessage**时，你获得队列中的下一条消息。 从 **retrieveMessage** 返回的消息变得对从此队列读取消息的任何其他代码不可见。 默认情况下，此消息持续 30 秒不可见。 要从队列中删除消息，还必须调用 **deleteMessage**。 此删除消息的两步过程可确保，如果代码因硬件或软件故障而无法处理消息，则代码的其他实例可以获取相同消息并重试。 代码在处理消息后会立即调用 **deleteMessage**。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the queue client.\r     CloudQueueClient queueClient = storageAccount.createCloudQueueClient();\r \r     // Retrieve a reference to a queue.\r     CloudQueue queue = queueClient.getQueueReference(\"myqueue\");\r \r     // Retrieve the first visible message in the queue.\r     CloudQueueMessage retrievedMessage = queue.retrieveMessage();\r \r     if (retrievedMessage != null)\r     {\r         // Process the message in less than 30 seconds, and then delete the message.\r         queue.deleteMessage(retrievedMessage);\r     }\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"additional-options-for-dequeuing-messages\"></a>用于取消对消息进行排队的其他选项\r 可通过两种方式自定义队列中消息的检索。 首先，可获取一批消息（最多 32 条）。 其次，可以设置更长或更短的不可见超时时间，从而允许代码使用更多或更少时间来完全处理每个消息。\r \r 下面的代码示例使用 **retrieveMessages** 方法以在一次调用中获取 20 条消息。 然后，它会使用 **for** 循环处理每条消息。 它还将每条消息的不可见超时设置为 5 分钟（300 秒）。 请注意，这五分钟超时对于所有消息都是同时开始的，因此在调用 **retrieveMessages**五分钟后，尚未删除的任何消息都会再次变得可见。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the queue client.\r     CloudQueueClient queueClient = storageAccount.createCloudQueueClient();\r \r     // Retrieve a reference to a queue.\r     CloudQueue queue = queueClient.getQueueReference(\"myqueue\");\r \r     // Retrieve 20 messages from the queue with a visibility timeout of 300 seconds.\r     for (CloudQueueMessage message : queue.retrieveMessages(20, 300, null, null)) {\r         // Do processing for all messages in less than 5 minutes,\r         // deleting each message after processing.\r         queue.deleteMessage(message);\r     }\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-list-the-queues\"></a>如何：列出队列\r 若要获取当前队列的列表，请调用 CloudQueueClient.listQueues() 方法，它将返回 CloudQueue 对象的集合。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the queue client.\r     CloudQueueClient queueClient =\r         storageAccount.createCloudQueueClient();\r \r     // Loop through the collection of queues.\r     for (CloudQueue queue : queueClient.listQueues())\r     {\r         // Output each queue name.\r         System.out.println(queue.getName());\r     }\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"how-to-delete-a-queue\"></a>如何：删除队列\r 若要删除队列及其包含的所有消息，请对 CloudQueue 对象调用 deleteIfExists 方法。\r \r ```java\r try\r {\r     // Retrieve storage account from connection-string.\r     CloudStorageAccount storageAccount =\r         CloudStorageAccount.parse(storageConnectionString);\r \r     // Create the queue client.\r     CloudQueueClient queueClient = storageAccount.createCloudQueueClient();\r \r     // Retrieve a reference to a queue.\r     CloudQueue queue = queueClient.getQueueReference(\"myqueue\");\r \r     // Delete the queue if it exists.\r     queue.deleteIfExists();\r }\r catch (Exception e)\r {\r     // Output the stack trace.\r     e.printStackTrace();\r }\r ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r 现在，了解了有关队列存储的基础知识，可单击下面的链接来了解更复杂的存储任务。\r \r * [用于 Java 的 Azure 存储 SDK][Azure Storage SDK for Java]\r * [Azure 存储客户端 SDK 参考][Azure 存储客户端 SDK 参考]\r * [Azure 存储服务 REST API][Azure Storage Services REST API]\r * [Azure 存储团队博客][Azure Storage Team Blog]\r \r [Azure SDK for Java]: /develop/java/\r [Azure Storage SDK for Java]: https://github.com/azure/azure-storage-java\r [Azure Storage SDK for Android]: https://github.com/azure/azure-storage-android\r [Azure 存储客户端 SDK 参考]: http://azure.github.io/azure-storage-java/\r [Azure Storage Services REST API]: https://msdn.microsoft.com/library/azure/dd179355.aspx\r [Azure Storage Team Blog]: http://blogs.msdn.com/b/windowsazurestorage/"}