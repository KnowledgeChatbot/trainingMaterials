{"Title":"SQL 数据仓库中的临时表","Description":"开始使用 Azure SQL 数据仓库中的临时表。","Content":"\r # SQL 数据仓库中的临时表\r \r > [!div class=\"op_single_selector\"]\r >- [概述][]\r >- [数据类型][]\r >- [分布][]\r >- [索引][]\r >- [Partition][]\r >- [统计信息][]\r >- [临时][]\r \r 临时表在处理数据时非常有用 - 尤其是具有暂时性中间结果的转换期间。临时表存在于 SQL 数据仓库中的会话级别。它们仅对创建它们的会话可见，并在该会话注销时被自动删除。临时表可以提高性能，因为其结果将写入到本地而不是远程存储。Azure SQL 数据仓库中的临时表与 Azure SQL 数据库中的临时表略有不同，它们可以从会话内的任何位置进行访问，包括存储过程内部和外部。\r \r 本文包含使用临时表的基本指导，并重点介绍会话级别临时表的原则。使用本文中的信息可以帮助你将代码模块化，从而同时提高代码的可重用性和易维护性。\r \r ## 创建临时表\r \r 只需在表名的前面添加 `#` 作为前缀，即可创建临时表。例如：\r \r ```sql\r CREATE TABLE #stats_ddl\r (\r     [schema_name]\t\tNVARCHAR(128) NOT NULL\r ,\t[table_name]            NVARCHAR(128) NOT NULL\r ,\t[stats_name]            NVARCHAR(128) NOT NULL\r ,\t[stats_is_filtered]     BIT           NOT NULL\r ,\t[seq_nmbr]              BIGINT        NOT NULL\r ,\t[two_part_name]         NVARCHAR(260) NOT NULL\r ,\t[three_part_name]       NVARCHAR(400) NOT NULL\r )\r WITH\r (\r     DISTRIBUTION = HASH([seq_nmbr])\r ,\tHEAP\r )\r ```\r \r 此外可以使用 `CTAS` 通过完全相同的方法来创建临时表：\r \r ```sql\r CREATE TABLE #stats_ddl\r WITH\r (\r     DISTRIBUTION = HASH([seq_nmbr])\r ,\tHEAP\r )\r AS\r (\r SELECT\r         sm.[name]\t\t\t\t                                                AS [schema_name]\r ,\t\ttb.[name]\t\t\t\t                                                AS [table_name]\r ,\t\tst.[name]\t\t\t\t                                                AS [stats_name]\r ,\t\tst.[has_filter]\t\t\t                                                AS [stats_is_filtered]\r ,       ROW_NUMBER()\r         OVER(ORDER BY (SELECT NULL))                                            AS [seq_nmbr]\r ,\t\t\t\t\t\t\t\t QUOTENAME(sm.[name])+'.'+QUOTENAME(tb.[name])  AS [two_part_name]\r ,\t\tQUOTENAME(DB_NAME())+'.'+QUOTENAME(sm.[name])+'.'+QUOTENAME(tb.[name])  AS [three_part_name]\r FROM\tsys.objects\t\t\tAS ob\r JOIN\tsys.stats\t\t\tAS st\tON\tob.[object_id]\t\t= st.[object_id]\r JOIN\tsys.stats_columns\tAS sc\tON\tst.[stats_id]\t\t= sc.[stats_id]\r                                     AND st.[object_id]\t\t= sc.[object_id]\r JOIN\tsys.columns\t\t\tAS co\tON\tsc.[column_id]\t\t= co.[column_id]\r                                     AND\tsc.[object_id]\t\t= co.[object_id]\r JOIN\tsys.tables\t\t\tAS tb\tON\tco.[object_id]\t\t= tb.[object_id]\r JOIN\tsys.schemas\t\t\tAS sm\tON\ttb.[schema_id]\t\t= sm.[schema_id]\r WHERE\t1=1\r AND\t\tst.[user_created]   = 1\r GROUP BY\r         sm.[name]\r ,\t\ttb.[name]\r ,\t\tst.[name]\r ,\t\tst.[filter_definition]\r ,\t\tst.[has_filter]\r )\r SELECT\r     CASE @update_type\r     WHEN 1\r     THEN 'UPDATE STATISTICS '+[two_part_name]+'('+[stats_name]+');'\r     WHEN 2\r     THEN 'UPDATE STATISTICS '+[two_part_name]+'('+[stats_name]+') WITH FULLSCAN;'\r     WHEN 3\r     THEN 'UPDATE STATISTICS '+[two_part_name]+'('+[stats_name]+') WITH SAMPLE '+CAST(@sample_pct AS VARCHAR(20))+' PERCENT;'\r     WHEN 4\r     THEN 'UPDATE STATISTICS '+[two_part_name]+'('+[stats_name]+') WITH RESAMPLE;'\r     END AS [update_stats_ddl]\r ,   [seq_nmbr]\r FROM    t1\r ;\r ```\r \r >[!NOTE]\r > `CTAS` 是一个非常强大的命令，具有附加优势，可以非常有效地利用事务日志空间。\r \r ## 删除临时表\r \r 创建新会话时，应不存在任何临时表。但是，如果调用同一存储过程，它将使用相同名称创建临时表，若要确保 `CREATE TABLE` 语句成功执行，可以使用带 `DROP` 的简单预存在检查，如下面的示例中所示：\r \r ```sql\r IF OBJECT_ID('tempdb..#stats_ddl') IS NOT NULL\r BEGIN\r     DROP TABLE #stats_ddl\r END\r ```\r \r 为了实现编码一致性，好的做法是对表和临时表都使用此模式。当在代码中完成临时表时，使用 `DROP TABLE` 来删除临时表也很不错。在存储过程开发中，将 drop 命令捆绑在过程结尾来确保清除这些对象非常普遍。\r \r ```sql\r DROP TABLE #stats_ddl\r ```\r \r ##<a name=\"modularizing-code\"></a> 模块化代码\r \r 由于可以在用户会话中的任何位置查看临时表，可以利用这一点帮助将应用程序代码模块化。例如，下面的存储过程会将上面建议的做法组合在一起生成 DDL，该 DDL 会按统计名称更新数据库中的所有统计信息。\r \r ```sql\r CREATE PROCEDURE    [dbo].[prc_sqldw_update_stats]\r (   @update_type    tinyint -- 1 default 2 fullscan 3 sample 4 resample\r     ,@sample_pct     tinyint\r )\r AS\r \r IF @update_type NOT IN (1,2,3,4)\r BEGIN;\r     THROW 151000,'Invalid value for @update_type parameter. Valid range 1 (default), 2 (fullscan), 3 (sample) or 4 (resample).',1;\r END;\r \r IF @sample_pct IS NULL\r BEGIN;\r     SET @sample_pct = 20;\r END;\r \r IF OBJECT_ID('tempdb..#stats_ddl') IS NOT NULL\r BEGIN\r     DROP TABLE #stats_ddl\r END\r \r CREATE TABLE #stats_ddl\r WITH\r (\r     DISTRIBUTION = HASH([seq_nmbr])\r )\r AS\r (\r SELECT\r         sm.[name]\t\t\t\t                                                AS [schema_name]\r ,\t\ttb.[name]\t\t\t\t                                                AS [table_name]\r ,\t\tst.[name]\t\t\t\t                                                AS [stats_name]\r ,\t\tst.[has_filter]\t\t\t                                                AS [stats_is_filtered]\r ,       ROW_NUMBER()\r         OVER(ORDER BY (SELECT NULL))                                            AS [seq_nmbr]\r ,\t\t\t\t\t\t\t\t QUOTENAME(sm.[name])+'.'+QUOTENAME(tb.[name])  AS [two_part_name]\r ,\t\tQUOTENAME(DB_NAME())+'.'+QUOTENAME(sm.[name])+'.'+QUOTENAME(tb.[name])  AS [three_part_name]\r FROM\tsys.objects\t\t\tAS ob\r JOIN\tsys.stats\t\t\tAS st\tON\tob.[object_id]\t\t= st.[object_id]\r JOIN\tsys.stats_columns\tAS sc\tON\tst.[stats_id]\t\t= sc.[stats_id]\r                                     AND st.[object_id]\t\t= sc.[object_id]\r JOIN\tsys.columns\t\t\tAS co\tON\tsc.[column_id]\t\t= co.[column_id]\r                                     AND\tsc.[object_id]\t\t= co.[object_id]\r JOIN\tsys.tables\t\t\tAS tb\tON\tco.[object_id]\t\t= tb.[object_id]\r JOIN\tsys.schemas\t\t\tAS sm\tON\ttb.[schema_id]\t\t= sm.[schema_id]\r WHERE\t1=1\r AND\t\tst.[user_created]   = 1\r GROUP BY\r         sm.[name]\r ,\t\ttb.[name]\r ,\t\tst.[name]\r ,\t\tst.[filter_definition]\r ,\t\tst.[has_filter]\r )\r SELECT\r     CASE @update_type\r     WHEN 1\r     THEN 'UPDATE STATISTICS '+[two_part_name]+'('+[stats_name]+');'\r     WHEN 2\r     THEN 'UPDATE STATISTICS '+[two_part_name]+'('+[stats_name]+') WITH FULLSCAN;'\r     WHEN 3\r     THEN 'UPDATE STATISTICS '+[two_part_name]+'('+[stats_name]+') WITH SAMPLE '+CAST(@sample_pct AS VARCHAR(20))+' PERCENT;'\r     WHEN 4\r     THEN 'UPDATE STATISTICS '+[two_part_name]+'('+[stats_name]+') WITH RESAMPLE;'\r     END AS [update_stats_ddl]\r ,   [seq_nmbr]\r FROM    t1\r ;\r GO\r ```\r \r 在此阶段发生的唯一操作是创建存储过程，该存储过程只使用 DDL 语句生成了临时表 #stats\\_ddl。如果此存储过程在会话中运行了不止一次，它会删除已存在的 #stats\\_ddl，以确保它不会失败。但是，由于存储过程的末尾没有 `DROP TABLE`，当存储过程完成后，它将保留创建的表，以便可以在存储过程以外读取它。在 SQL 数据仓库中，与其他 SQL Server 数据库不同，有可能在创建临时表的过程外部使用该临时表。可以在会话中的**任何位置**使用 SQL 数据仓库临时表。这可以提高代码的模块化程度与易管理性，如以下示例所示：\r \r ```sql\r EXEC [dbo].[prc_sqldw_update_stats] @update_type = 1, @sample_pct = NULL;\r \r DECLARE @i INT              = 1\r ,       @t INT              = (SELECT COUNT(*) FROM #stats_ddl)\r ,       @s NVARCHAR(4000)   = N''\r \r WHILE @i <= @t\r BEGIN\r     SET @s=(SELECT update_stats_ddl FROM #stats_ddl WHERE seq_nmbr = @i);\r \r     PRINT @s\r     EXEC sp_executesql @s\r     SET @i+=1;\r END\r \r DROP TABLE #stats_ddl;\r ```\r \r ## 临时表的限制\r \r SQL 数据仓库在实现临时表时确实会施加一些限制。目前，仅支持会话范围的临时表。不支持全局临时表。此外，不能在临时表上创建视图。\r \r ## 后续步骤\r \r 若要了解详细信息，请参阅有关[表概述][Overview]、[表数据类型][Data Types]、[分布表][Distribute]、[为表编制索引][Index]、[将表分区][Partition]和[维护表统计信息][Statistics]的文章。有关最佳实践的详细信息，请参阅 [SQL 数据仓库最佳实践][]。\r \r <!--Image references-->\r \r <!--Article references-->\r [Overview]: ./sql-data-warehouse-tables-overview.md\r [概述]: ./sql-data-warehouse-tables-overview.md\r [Data Types]: ./sql-data-warehouse-tables-data-types.md\r [数据类型]: ./sql-data-warehouse-tables-data-types.md\r [Distribute]: ./sql-data-warehouse-tables-distribute.md\r [分布]: ./sql-data-warehouse-tables-distribute.md\r [Index]: ./sql-data-warehouse-tables-index.md\r [索引]: ./sql-data-warehouse-tables-index.md\r [Partition]: ./sql-data-warehouse-tables-partition.md\r [Statistics]: ./sql-data-warehouse-tables-statistics.md\r [统计信息]: ./sql-data-warehouse-tables-statistics.md\r [临时]: ./sql-data-warehouse-tables-temporary.md\r [SQL 数据仓库最佳实践]: ./sql-data-warehouse-best-practices.md\r \r <!--MSDN references-->\r \r <!--Other Web references-->\r \r <!---HONumber=Mooncake_1212_2016-->"}