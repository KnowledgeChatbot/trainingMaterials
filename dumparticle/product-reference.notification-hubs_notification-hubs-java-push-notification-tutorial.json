{"Title":"如何结合使用通知中心与 Java","Description":"了解如何从 Java 后端使用 Azure 通知中心。","Content":"\r # 如何通过 Java 使用通知中心\r [!INCLUDE [notification-hubs-backend-how-to-selector](../../includes/notification-hubs-backend-how-to-selector.md)]\r \r 本主题将向你介绍完全受支持的全新官方 Azure 通知中心 Java SDK 的主要功能。 \r 这是一个开源项目，你可以在 [Java SDK] 查看完整的 SDK 代码。\r \r 通常情况下，如 MSDN 主题[通知中心 REST API](http://msdn.microsoft.com/library/dn223264.aspx) 中所述，你可以使用通知中心 REST 接口从 Java/PHP/Python/Ruby 后端访问所有通知中心功能。此 Java SDK 在以 Java 形式表示的 REST 接口上提供瘦包装器。\r \r SDK 当前支持：\r \r - 通知中心上的 CRUD \r - 注册上的 CRUD\r - 安装管理\r - 导入/导出注册\r - 常规发送\r - 计划发送\r - 通过 Java NIO 的异步操作\r - 支持的平台：APNS (iOS)、GCM (Android)、WNS（Windows 应用商店应用）、MPNS (Windows Phone)、ADM (Amazon Kindle Fire)、百度（没有 Google 服务的 Android） \r \r ## SDK 用法\r \r ### 编译和生成\r \r 使用 [Maven]\r \r 生成：\r \r ```\r mvn package\r ```\r \r ## 代码\r \r ### 通知中心 CRUD\r \r **创建命名空间管理器：**\r \r ```\r NamespaceManager namespaceManager = new NamespaceManager(\"connection string\")\r ```\r \r **创建通知中心：**\r \r ```\r NotificationHubDescription hub = new NotificationHubDescription(\"hubname\");\r hub.setWindowsCredential(new WindowsCredential(\"sid\",\"key\"));\r hub = namespaceManager.createNotificationHub(hub);\r ```\r \r  或者\r \r     hub = new NotificationHub(\"connection string\", \"hubname\");\r \r **获取通知中心：**\r \r ```\r hub = namespaceManager.getNotificationHub(\"hubname\");\r ```\r \r **更新通知中心：**\r \r ```\r hub.setMpnsCredential(new MpnsCredential(\"mpnscert\", \"mpnskey\"));\r hub = namespaceManager.updateNotificationHub(hub);\r ```\r \r **删除通知中心：**\r \r ```\r namespaceManager.deleteNotificationHub(\"hubname\");\r ```\r \r ### 注册 CRUD\r **创建通知中心客户端：**\r \r ```\r hub = new NotificationHub(\"connection string\", \"hubname\");\r ```\r \r **创建 Windows 注册：**\r \r ```\r WindowsRegistration reg = new WindowsRegistration(new URI(CHANNELURI));\r reg.getTags().add(\"myTag\");\r reg.getTags().add(\"myOtherTag\");    \r hub.createRegistration(reg);\r ```\r \r **创建 iOS 注册：**\r \r ```\r AppleRegistration reg = new AppleRegistration(DEVICETOKEN);\r reg.getTags().add(\"myTag\");\r reg.getTags().add(\"myOtherTag\");\r hub.createRegistration(reg);\r ```\r \r 同样，可以针对 Android (GCM)、Windows Phone (MPNS) 和 Kindle Fire (ADM) 创建注册。\r \r **创建模板注册：**\r \r ```\r WindowsTemplateRegistration reg = new WindowsTemplateRegistration(new URI(CHANNELURI), WNSBODYTEMPLATE);\r reg.getHeaders().put(\"X-WNS-Type\", \"wns/toast\");\r hub.createRegistration(reg);\r ```\r \r **使用“创建 registrationid + upsert 模式”创建注册**\r \r 如果在设备上存储注册 ID，请删除重复项以防出现任何响应丢失：\r \r ```\r String id = hub.createRegistrationId();\r WindowsRegistration reg = new WindowsRegistration(id, new URI(CHANNELURI));\r hub.upsertRegistration(reg);\r ```\r \r **更新注册：**\r \r ```\r hub.updateRegistration(reg);\r ```\r \r **删除注册：**\r \r ```\r hub.deleteRegistration(regid);\r ```\r \r **查询注册：**\r \r * \t**获取单个注册：**\r \r     ```\r     hub.getRegistration(regid);\r     ```\r \r * \t**获取中心的所有注册：**\r \r     ```\r     hub.getRegistrations();\r     ```\r \r * \t**获取具有标记的注册：**\r \r     ```\r     hub.getRegistrationsByTag(\"myTag\");\r     ```\r \r * \t**按渠道获取注册：**\r \r     ```\r     hub.getRegistrationsByChannel(\"devicetoken\");\r     ```\r \r 所有集合查询都支持 $top 和继续标记。\r \r ### 安装 API 用法\r 安装 API 是一种注册管理的替代机制。其现在可以使用“单个”安装对象，而不是维护着多个注册，后者不但工作量较大，而且容易出错且效率低下。 \r 安装包含你所需的一切：推送通道（设备标记）、标记、模板、辅助磁贴（用于 WNS 和 APNS）。你不必再调用该服务以获取 ID - 只需生成 GUID 或任何其他标识符，将其保存在设备上并与推送通道（设备标记）一起发送到你的后端即可。 \r 在后端，你应当只做一个调用：CreateOrUpdateInstallation，其完全是幂等的，因此，如果需要，可随时重试。\r \r 针对 Amazon Kindle Fire，示例如下：\r \r ```\r Installation installation = new Installation(\"installation-id\", NotificationPlatform.Adm, \"adm-push-channel\");\r hub.createOrUpdateInstallation(installation);\r ```\r \r 如果你希望进行更新：\r \r ```\r installation.addTag(\"foo\");\r installation.addTemplate(\"template1\", new InstallationTemplate(\"{\\\"data\\\":{\\\"key1\\\":\\\"$(value1)\\\"}}\",\"tag-for-template1\"));\r installation.addTemplate(\"template2\", new InstallationTemplate(\"{\\\"data\\\":{\\\"key2\\\":\\\"$(value2)\\\"}}\",\"tag-for-template2\"));\r hub.createOrUpdateInstallation(installation);\r ```\r \r 对于高级方案，我们提供有部分更新功能，以允许仅修改安装对象的特定属性。基本上，部分更新是你针对安装对象运行 JSON Patch 操作的子集。\r \r ```\r PartialUpdateOperation addChannel = new PartialUpdateOperation(UpdateOperationType.Add, \"/pushChannel\", \"adm-push-channel2\");\r PartialUpdateOperation addTag = new PartialUpdateOperation(UpdateOperationType.Add, \"/tags\", \"bar\");\r PartialUpdateOperation replaceTemplate = new PartialUpdateOperation(UpdateOperationType.Replace, \"/templates/template1\", new InstallationTemplate(\"{\\\"data\\\":{\\\"key3\\\":\\\"$(value3)\\\"}}\",\"tag-for-template1\")).toJson());\r hub.patchInstallation(\"installation-id\", addChannel, addTag, replaceTemplate);\r ```\r \r 删除安装：\r \r ```\r hub.deleteInstallation(installation.getInstallationId());\r ```\r \r CreateOrUpdate、Patch 和 Delete 最终与 Get 一致。你请求的操作会在调用期间进入系统队列并在后台执行。请注意，Get 并不适用于主运行时方案，只适用于调试和故障排除，其会受到服务的严密限制。\r \r 安装的发送流与注册的一样。我们只是引入了一个选项以将通知锁定至特定安装 - 仅使用了标记 \"InstallationId:{desired-id}\"。对于上述情况，其如下所示：\r \r ```\r Notification n = Notification.createWindowsNotification(\"WNS body\");\r hub.sendNotification(n, \"InstallationId:{installation-id}\");\r ```\r \r 为多个模板之一：\r \r ```\r Map<String, String> prop =  new HashMap<String, String>();\r prop.put(\"value3\", \"some value\");\r Notification n = Notification.createTemplateNotification(prop);\r hub.sendNotification(n, \"InstallationId:{installation-id} && tag-for-template1\");\r ```\r \r ### 计划通知（适用于标准层）\r \r 与常规发送相同，但多了一个参数 - scheduledTime，表示通知应传递的时间。服务接受现在 + 5 分钟与现在 + 7 天之间的任何时间点。\r \r **计划 Windows 本机通知：**\r \r ```\r Calendar c = Calendar.getInstance();\r c.add(Calendar.DATE, 1);    \r Notification n = Notification.createWindowsNotification(\"WNS body\");\r hub.scheduleNotification(n, c.getTime());\r ```\r \r ### 导入/导出（可用于标准层）\r 有时需要针对注册执行批量操作。通常这是为了与另一个系统集成，或只是一个大规模修复以更新标记。如果涉及到数以千计的注册，强烈不建议使用 Get/Update 流。导入/导出功能专门针对以下方案设计。基本上，你会在存储帐户下提供对一些 BLOB 容器的访问权限作为传入数据的源和输出的位置。\r \r **提交导出作业：**\r \r ```\r NotificationHubJob job = new NotificationHubJob();\r job.setJobType(NotificationHubJobType.ExportRegistrations);\r job.setOutputContainerUri(\"container uri with SAS signature\");\r job = hub.submitNotificationHubJob(job);\r ```\r \r **提交导入作业：**\r \r ```\r NotificationHubJob job = new NotificationHubJob();\r job.setJobType(NotificationHubJobType.ImportCreateRegistrations);\r job.setImportFileUri(\"input file uri with SAS signature\");\r job.setOutputContainerUri(\"container uri with SAS signature\");\r job = hub.submitNotificationHubJob(job);\r ```\r \r **等待直到作业完成：**\r \r ```\r while(true){\r     Thread.sleep(1000);\r     job = hub.getNotificationHubJob(job.getJobId());\r     if(job.getJobStatus() == NotificationHubJobStatus.Completed)\r         break;\r }       \r ```\r \r **获取所有作业：**\r \r ```\r List<NotificationHubJob> jobs = hub.getAllNotificationHubJobs();\r ```\r \r **使用 SAS 签名的 URI：**\r 这是某些 BLOB 文件或 BLOB 容器的 URL，加上一组参数（例如权限和到期日期），再加上使用帐户的 SAS 密钥生成的所有这些内容的签名。Azure 存储 Java SDK 具有丰富的功能，包括创建这种类型的 URI。作为简单的替代，你可以考虑使用 ImportExportE2E 测试类（来自 github 位置），其具有非常基本、精简的签名算法。\r \r ###发送通知\r 通知对象只有带有标头的正文，一些实用工具方法可帮助你构建本机和模板通知对象。\r \r * **Windows 应用商店和 Windows Phone 8.1（非 Silverlight）**\r \r     ```\r     String toast = \"<toast><visual><binding template=\"ToastText01\"><text id=\"1\">Hello from Java!</text></binding></visual></toast>\";\r     Notification n = Notification.createWindowsNotification(toast);\r     hub.sendNotification(n);\r     ```\r \r * **iOS**\r \r     ```\r     String alert = \"{\"aps\":{\"alert\":\"Hello from Java!\"}}\";\r     Notification n = Notification.createAppleNotification(alert);\r     hub.sendNotification(n);\r     ```\r \r * **Android**\r \r     ```\r     String message = \"{\"data\":{\"msg\":\"Hello from Java!\"}}\";\r     Notification n = Notification.createGcmNotification(message);\r     hub.sendNotification(n);\r     ```\r \r * **Windows Phone 8.0 和 8.1 Silverlight**\r \r     ```\r     String toast = \"<?xml version=\"1.0\" encoding=\"utf-8\"?>\" +\r                 \"<wp:Notification xmlns:wp=\"WPNotification\">\" +\r                    \"<wp:Toast>\" +\r                         \"<wp:Text1>Hello from Java!</wp:Text1>\" +\r                    \"</wp:Toast> \" +\r                 \"</wp:Notification>\";\r     Notification n = Notification.createMpnsNotification(toast);\r     hub.sendNotification(n);\r     ```\r \r * **Kindle Fire**\r \r     ```\r     String message = \"{\"data\":{\"msg\":\"Hello from Java!\"}}\";\r     Notification n = Notification.createAdmNotification(message);\r     hub.sendNotification(n);\r     ```\r \r * **发送到标记**\r \r     ```\r     Set<String> tags = new HashSet<String>();\r     tags.add(\"boo\");\r     tags.add(\"foo\");\r     hub.sendNotification(n, tags);\r     ```\r \r * **发送到标记表达式**\r \r     ```\r     hub.sendNotification(n, \"foo && ! bar\");\r     ```\r \r * **发送模板通知**\r \r     ```\r     Map<String, String> prop =  new HashMap<String, String>();\r     prop.put(\"prop1\", \"v1\");\r     prop.put(\"prop2\", \"v2\");\r     Notification n = Notification.createTemplateNotification(prop);\r     hub.sendNotification(n);\r     ```\r \r 运行 Java 代码，现在应该生成显示在目标设备上的通知。\r \r ##<a name=\"next-steps\"></a>后续步骤\r 在本主题中，我们介绍了如何为通知中心创建简单的 Java REST 客户端。从这里你可以：\r \r * 下载完整的 [Java SDK]，其中包含整个 SDK 代码。\r * 播放示例：\r     - [通知中心入门]\r     - [发送突发新闻]\r     - [发送当地的突发新闻]\r     - [发送通知到经身份验证的用户]\r     - [发送跨平台通知到经身份验证的用户]\r \r [Java SDK]: https://github.com/Azure/azure-notificationhubs-java-backend\r [Get started tutorial]: ./notification-hubs-ios-apple-push-notification-apns-get-started.md\r [通知中心入门]: ./notification-hubs-windows-store-dotnet-get-started-wns-push-notification.md\r [发送突发新闻]: ./notification-hubs-windows-notification-dotnet-push-xplat-segmented-wns.md\r [发送当地的突发新闻]: ./notification-hubs-windows-store-dotnet-xplat-localized-wns-push-notification.md\r [Maven]: http://maven.apache.org/\r \r <!---HONumber=Mooncake_0808_2016-->"}