{"Title":"Azure 服务总线性能基准测试示例代码","Description":"Azure 服务总线性能基准测试示例代码","Content":"\r # Azure 服务总线性能基准测试示例代码\r \r 本文提供对 Azure 服务总线进行基准测试的示例代码。主要通过设置 Prefetch 和 MaxConcurrentCalls 来加快消息的获取和处理。更多性能优化建议参阅: [使用服务总线消息传递改进性能的最佳实践](/documentation/articles/service-bus-performance-improvements/)。\r \r ## 发送端\r \r 生成消息，并分批，然后按批次异步发送。\r \r     // Generate message batches\r     var batchMsgDic = new Dictionary<int, List<BrokeredMessage>>();\r     var batchMsgs = new List<BrokeredMessage>(batchSize);\r     var batchCount = 0;\r     for (int i = 1; i <= messagesCount; i++)\r     {\r         // Create message, passing a string message for the body.\r         var message = new BrokeredMessage($\"Test message {i}\");\r \r         // Set additional custom app-specific property.\r         message.Properties[\"MessageId\"] = Guid.NewGuid();\r         message.Properties[\"CreateTime\"] = DateTime.UtcNow.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture);\r         Console.WriteLine($\"{DateTime.UtcNow.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture)} --- Create message {i}\");\r \r         batchMsgs.Add(message);\r         if (i % batchSize == 0)\r         {\r                 batchCount++;\r                 batchMsgDic.Add(batchCount, batchMsgs);\r                 batchMsgs = new List<BrokeredMessage>(batchSize);\r         }\r     }\r \r     // Send message batches asynchronoursly without waiting\r     var sendTasks = new List<Task>(batchCount);\r     foreach (var batch in batchMsgDic)\r     {\r         sendTasks.Add(queueClient.SendBatchAsync(batch.Value));\r         Console.WriteLine($\"{DateTime.UtcNow.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture)} --- Sent batch {batch.Key}\");\r     }\r     Task.WaitAll(sendTasks.ToArray());\r     Console.WriteLine(\"All messages are sent!\");\r \r ## 接收端\r \r 设定 Prefetch 使得从服务总线队列中获取消息时，一次性可以获取设定条数的消息，我们这里设定 1000 就相当于一次性获取所有消息。\r \r 设定 MaxConcurrentCalls 使得同时可以有设定数目的线程数来处理消息，我们这里设定 1000 就相当于最多有 1000 个线程来处理消息，从而保证消息的最快处理。\r \r     // TODO: update the name of your queue\r     const string QueueName = \"yourqueuename\";\r \r     const int PrefetchCount = 1000;\r     const int MaxThreadsCount = 1000;\r \r     // QueueClient is thread-safe. Recommended that you cache \r     // rather than recreating it on every request\r     QueueClient Client;\r     ManualResetEvent CompletedEvent = new ManualResetEvent(false);\r \r     public override void Run()\r     {\r         Trace.WriteLine(\"Starting processing of messages\");\r \r         // Initiates the message pump and callback is invoked for each message that is received, calling close on the client will stop the pump.\r         Client.OnMessageAsync(async (receivedMessage) =>\r         {\r             Trace.WriteLine($\"Rcv Msg {receivedMessage.MessageId} --- C:{receivedMessage.Properties[\"CreateTime\"]} | E:{receivedMessage.EnqueuedTimeUtc.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture)} | R:{DateTime.UtcNow.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture)}\");\r             // sleep 1s to simulate processing\r             await Task.Delay(1000);\r             // Process the message\r             Trace.WriteLine($\"End Msg {receivedMessage.MessageId} --- F:{DateTime.UtcNow.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture)}\");\r         }, new OnMessageOptions { AutoComplete = true, MaxConcurrentCalls = MaxThreadsCount });\r \r         CompletedEvent.WaitOne();\r     }\r \r     public override bool OnStart()\r     {\r         // Set the maximum number of concurrent connections \r         ServicePointManager.DefaultConnectionLimit = 12;\r \r         // Create the queue if it does not exist already\r         string connectionString = CloudConfigurationManager.GetSetting(\"Microsoft.ServiceBus.ConnectionString\");\r         var namespaceManager = NamespaceManager.CreateFromConnectionString(connectionString);\r         if (!namespaceManager.QueueExists(QueueName))\r         {\r             namespaceManager.CreateQueue(QueueName);\r         }\r \r         // Initialize the connection to Service Bus Queue\r         Client = QueueClient.CreateFromConnectionString(connectionString, QueueName);\r         Client.PrefetchCount = PrefetchCount;\r         return base.OnStart();\r     }\r \r ## 运行\r \r 1. 设置服务总线信息\r \r     ** 发送端 **\r \r         // TODO: update with your own value here\r         var sbConnStr = \"yourservicebusconnectionstring\";\r         var queueName = \"yourqueuename\";\r \r     ** 接收端 **\r \r         // TODO: update the name of your queue\r         const string QueueName = \"yourqueuename\";\r \r         <ConfigurationSettings>\r         <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=[name];AccountKey=[key];EndpointSuffix=core.chinacloudapi.cn\" />\r         <Setting name=\"Microsoft.ServiceBus.ConnectionString\" value=\"Endpoint=sb://[your namespace].servicebus.chinalcoudapi.cn;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=[your key]\" />\r         </ConfigurationSettings>\r \r 2. 发布接收端项目 ReceiverWorkerRole 到 Azure 上\r \r 3. 运行发送端来发送消息\r \r 4. 查看步骤 1 中设置的存储账户中的 WADLogsTable 的日志，可通过 Microsoft Storage Explorer 来查看。\r \r 日志分析：\r \r - Rcv Msg 6ca4a6f26dcd4aaf956e422c90e5aee5 --- C:06:42:17.934 | E:06:42:19.192 | R:06:42:19.61\r \r     - C代表消息创建时间\r     - E代表消息到达服务总线队列时间\r     - R代表消息接收到的时间\r \r - End Msg 6ca4a6f26dcd4aaf956e422c90e5aee5 --- F:06:42:20.652\r \r     - F代表消息处理完成时间\r \r 源代码\r \r [https://github.com/wacn/AOG-CodeSample/tree/master/ServiceBus/CSharp/Benchmark%20Testing](\r https://github.com/wacn/AOG-CodeSample/tree/master/ServiceBus/CSharp/Benchmark%20Testing)"}