{"Title":"如何通过 Node.js 使用 Blob 存储","Description":"使用 Azure Blob 存储（对象存储）将非结构化数据存储在云中。","Content":"# <a name=\"how-to-use-blob-storage-from-nodejs\"></a>如何通过 Node.js 使用 Blob 存储\r [!INCLUDE [storage-selector-blob-include](../../../includes/storage-selector-blob-include.md)]\r \r [!INCLUDE [storage-check-out-samples-all](../../../includes/storage-check-out-samples-all.md)]\r \r ## <a name=\"overview\"></a>概述\r 本文介绍如何使用 Blob 存储执行常见方案。 相关示例是通过 Node.js API 编写的。 涉及的方案包括如何上传、列出、下载和删除 Blob。\r \r [!INCLUDE [storage-blob-concepts-include](../../../includes/storage-blob-concepts-include.md)]\r \r [!INCLUDE [storage-create-account-include](../../../includes/storage-create-account-include.md)]\r \r ## <a name=\"create-a-nodejs-application\"></a>创建 Node.js 应用程序\r 有关如何创建 Node.js 应用程序的说明，请参阅 [在 Azure 应用服务中创建 Node.js Web 应用]、[使用 Windows PowerShell 构建 Node.js 应用程序并将其部署到 Azure 云服务](../../cloud-services/cloud-services-nodejs-develop-deploy-app.md)或[使用 Web Matrix 构建 Node.js Web 应用并将其部署到 Azure](https://www.microsoft.com/web/webmatrix/)。\r \r ## <a name=\"configure-your-application-to-access-storage\"></a>配置应用程序以访问存储\r 若要使用 Azure 存储，需要 Azure Storage SDK for Node.js，其中包括一组便于与存储 REST 服务进行通信的库。\r \r ### <a name=\"use-node-package-manager-npm-to-obtain-the-package\"></a>使用 Node 包管理器 (NPM) 可获取该程序包\r 1. 使用命令行接口（如 PowerShell (Windows)、Terminal (Mac) 或 Bash (Unix)）导航到在其中创建示例应用程序的文件夹。\r 2. 在命令窗口中键入 **npm install azure-storage** 。 该命令的输出类似于以下代码示例。\r     ```\r     azure-storage@0.5.0 node_modules\\azure-storage +-- extend@1.2.1 +-- xmlbuilder@0.4.3 +-- mime@1.2.11 +-- node-uuid@1.4.3 +-- validator@3.22.2 +-- underscore@1.4.4 +-- readable-stream@1.0.33 (string_decoder@0.10.31, isarray@0.0.1, inherits@2.0.1, core-util-is@1.0.1) +-- xml2js@0.2.7 (sax@0.5.2) +-- request@2.57.0 (caseless@0.10.0, aws-sign2@0.5.0, forever-agent@0.6.1, stringstream@0.0.4, oauth-sign@0.8.0, tunnel-agent@0.4.1, isstream@0.1.2, json-stringify-safe@5.0.1, bl@0.9.4, combined-stream@1.0.5, qs@3.1.0, mime-types@2.0.14, form-data@0.2.0, http-signature@0.11.0, tough-cookie@2.0.0, hawk@2.3.1, har-validator@1.8.0)\r     ```\r 3. 可以手动运行 **ls** 命令来验证是否创建了 **node\\_modules** 文件夹。 在该文件夹中，找到 **azure-storage** 包，其中包含访问存储所需的库。\r \r ### <a name=\"import-the-package\"></a>导入包\r 使用记事本或其他文本编辑器，将以下内容添加到要在其中使用存储的应用程序的 **server.js** 文件顶部：\r \r ```nodejs\r var azure = require('azure-storage');\r ```\r \r ## <a name=\"set-up-an-azure-storage-connection\"></a>设置 Azure 存储连接\r Azure 模块将读取环境变量 `AZURE_STORAGE_ACCOUNT` 和 `AZURE_STORAGE_ACCESS_KEY` 或 `AZURE_STORAGE_CONNECTION_STRING`，获取连接到 Azure 存储帐户所需的信息。 如果未设置这些环境变量，则在调用 **createBlobService**时必须指定帐户信息。\r \r ## <a name=\"create-a-container\"></a>创建容器\r 使用 **BlobService** 对象可以对容器和 Blob 进行操作。 以下代码创建 **BlobService** 对象。 将以下代码添加到 **server.js** 的顶部附近：\r \r ```nodejs\r var blobSvc = azure.createBlobService();\r ```\r \r > [!NOTE]\r > 可以匿名访问 Blob，只需使用 **createBlobServiceAnonymous** 并提供主机地址即可。 例如，使用 `var blobSvc = azure.createBlobServiceAnonymous('https://myblob.blob.core.chinacloudapi.cn/');`。\r \r [!INCLUDE [storage-container-naming-rules-include](../../../includes/storage-container-naming-rules-include.md)]\r \r 若要创建一个新的容器，请使用 **createContainerIfNotExists**。 以下代码示例将创建名为“mycontainer”的新容器：\r \r ```nodejs\r blobSvc.createContainerIfNotExists('mycontainer', function(error, result, response){\r     if(!error){\r           // Container exists and is private\r     }\r });\r ```\r \r 如果该容器是新建的，则 `result.created` 为 true。 如果该容器已存在，则 `result.created` 为 false。 `response` 包含有关操作的信息，包括容器的 ETag 信息。\r \r ### <a name=\"container-security\"></a>容器安全性\r 默认情况下，新容器是私有的，不能匿名访问。 若要使容器公开，以便能对其进行匿名访问，可将容器的访问级别设置为“blob”或“容器”。\r \r * **Blob** - 可匿名读取此容器中的 Blob 内容和元数据，但无法匿名读取容器元数据（如列出容器中的所有 Blob）\r * **容器** - 可匿名读取 Blob 内容和元数据，以及容器元数据\r \r 以下代码示例演示如何将访问级别设置为“Blob”：\r \r ```nodejs\r blobSvc.createContainerIfNotExists('mycontainer', {publicAccessLevel : 'blob'}, function(error, result, response){\r     if(!error){\r       // Container exists and allows\r       // anonymous read access to blob\r       // content and metadata within this container\r     }\r });\r ```\r \r 另外，可以通过使用 **setContainerAcl** 指定访问级别来修改容器的访问级别。 以下代码示例将访问级别更改为“容器”：\r \r ```nodejs\r blobSvc.setContainerAcl('mycontainer', null /* signedIdentifiers */, {publicAccessLevel : 'container'} /* publicAccessLevel*/, function(error, result, response){\r   if(!error){\r     // Container access level set to 'container'\r   }\r });\r ```\r \r 结果包含有关操作的信息，包括容器的当前 **ETag** 。\r \r ### <a name=\"filters\"></a>筛选器\r 可以向使用 BlobService 执行的操作应用可选的筛选操作。 筛选操作可包括日志记录、自动重试等。筛选器是实现具有签名的方法的对象：\r \r ```nodejs\r function handle (requestOptions, next)\r ```\r \r 在对请求选项执行预处理后，该方法需要调用“next”并且传递具有以下签名的回调：\r \r ```nodejs\r function (returnObject, finalCallback, next)\r ```\r \r 在此回调中并且在处理 returnObject（来自对服务器请求的响应）后，回调需要调用 next（如果存在）以继续处理其他筛选器或只调用 finalCallback 以便结束服务调用。\r \r Azure SDK for Node.js 中附带了两个实现了重试逻辑的筛选器，分别是 **ExponentialRetryPolicyFilter** 和 **LinearRetryPolicyFilter**。 下面的代码将创建一个 BlobService 对象，该对象使用 ExponentialRetryPolicyFilter：\r \r ```nodejs\r var retryOperations = new azure.ExponentialRetryPolicyFilter();\r var blobSvc = azure.createBlobService().withFilter(retryOperations);\r ```\r \r ## <a name=\"upload-a-blob-into-a-container\"></a>将 Blob 上传到容器中\r 有三种类型的 Blob：块 Blob、页 Blob 和追加 Blob。 块 Blob 能够实现更高效地上传大型数据。 追加 Blob 针对追加操作进行了优化。 页 Blob 针对读取/写入操作进行了优化。 有关详细信息，请参阅 [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx)（了解块 Blob、追加 Blob 和页 Blob）。\r \r ### <a name=\"block-blobs\"></a>块 Blob\r 要将数据上传到块 Blob，可使用以下方法：\r \r * **createBlockBlobFromLocalFile** - 创建新的块 Blob 并上传文件的内容\r * **createBlockBlobFromStream** - 创建新的块 Blob 并上传流的内容\r * **createBlockBlobFromText** - 创建新的块 Blob 并上传字符串的内容\r * **createWriteStreamToBlockBlob** - 向块 Blob 提供写入流\r \r 下面的代码示例会将 test.txt 文件的内容上传到 myblob 中。\r \r ```nodejs\r blobSvc.createBlockBlobFromLocalFile('mycontainer', 'myblob', 'test.txt', function(error, result, response){\r   if(!error){\r     // file uploaded\r   }\r });\r ```\r \r 通过这些方法返回的 `result` 包含有关操作的信息，例如，Blob 的 **ETag**。\r \r ### <a name=\"append-blobs\"></a>追加 Blob\r 要将数据上传到新的追加 Blob，可使用以下方法：\r \r * **createAppendBlobFromLocalFile** - 创建新的追加 Blob 并上传文件的内容\r * **createAppendBlobFromStream** - 创建新的追加 Blob 并上传流的内容\r * **createAppendBlobFromText** - 创建新的追加 Blob 并上传字符串的内容\r * **createWriteStreamToNewAppendBlob** - 创建新的追加 blob，并向其提供要写入的流\r \r 以下代码示例会将 test.txt 文件的内容上传到 myappendblob 中。\r \r ```nodejs\r blobSvc.createAppendBlobFromLocalFile('mycontainer', 'myappendblob', 'test.txt', function(error, result, response){\r   if(!error){\r     // file uploaded\r   }\r });\r ```\r \r 要将块追加到现有追加 Blob，请使用以下方法：\r \r * **appendFromLocalFile** - 将文件的内容追加到现有追加 Blob\r * **appendFromStream** - 将流的内容追加到现有追加 Blob\r * **appendFromText** - 将字符串的内容追加到现有追加 Blob\r * **appendBlockFromStream** - 将流的内容追加到现有追加 Blob\r * **appendBlockFromText** - 将字符串的内容追加到现有追加 Blob\r \r > [!NOTE]\r > appendFromXXX API 会执行某些客户端验证以快速失败，从而避免不必要的服务器调用。 而 appendBlockFromXXX 则不会如此。\r >\r >\r \r 以下代码示例会将 test.txt 文件的内容上传到 myappendblob 中。\r \r ```nodejs\r blobSvc.appendFromText('mycontainer', 'myappendblob', 'text to be appended', function(error, result, response){\r   if(!error){\r     // text appended\r   }\r });\r ```\r \r ### <a name=\"page-blobs\"></a>页 Blob\r 要将数据上传到页 Blob，可使用以下方法：\r \r * **createPageBlob** - 创建新的特定长度的页 Blob\r * **createPageBlobFromLocalFile** - 创建新的页 Blob 并上传文件的内容\r * **createPageBlobFromStream** - 创建新的页 Blob 并上传流的内容\r * **createWriteStreamToExistingPageBlob** - 向现有页 Blob 提供写入流\r * **createWriteStreamToNewPageBlob** - 创建新的页 Blob，并向其提供要写入的流\r \r 以下代码示例会将 test.txt 文件的内容上传到 mypageblob 中。\r \r ```nodejs\r blobSvc.createPageBlobFromLocalFile('mycontainer', 'mypageblob', 'test.txt', function(error, result, response){\r   if(!error){\r     // file uploaded\r   }\r });\r ```\r \r > [!NOTE]\r > 页 Blob 包含 512 字节的“页面”。 如果上传大小不是 512 倍数的数据，则会收到错误。\r \r ## <a name=\"list-the-blobs-in-a-container\"></a>列出容器中的 Blob\r 若要列出容器中的 Blob，请使用 **listBlobsSegmented** 方法。 如果想要返回带特定前缀的 Blob，请使用 **listBlobsSegmentedWithPrefix**。\r \r ```nodejs\r blobSvc.listBlobsSegmented('mycontainer', null, function(error, result, response){\r   if(!error){\r       // result.entries contains the entries\r       // If not all blobs were returned, result.continuationToken has the continuation token.\r   }\r });\r ```\r \r `result` 包含一个 `entries` 集合，该集合是一组用于描述每个 blob 的对象。 如果不能返回所有 blob，`result` 还将提供 `continuationToken`，这可用作第二个参数来检索其他条目。\r \r ## <a name=\"download-blobs\"></a>下载 Blob\r 若要从 Blob 下载数据，可使用以下方法：\r \r * **getBlobToLocalFile** - 将 Blob 内容写入文件\r * **getBlobToStream** - 将 Blob 内容写入流\r * **getBlobToText** - 将 Blob 内容写入字符串\r * **createReadStream** - 提供可从 Blob 读取内容的流\r \r 以下代码示例演示如何使用 getBlobToStream 下载 myblob blob 的内容，并使用一个流将其存储到 output.txt 文件：\r \r ```nodejs\r var fs = require('fs');\r blobSvc.getBlobToStream('mycontainer', 'myblob', fs.createWriteStream('output.txt'), function(error, result, response){\r   if(!error){\r     // blob retrieved\r   }\r });\r ```\r \r `result` 包含有关 Blob 的信息，包括 **ETag** 信息。\r \r ## <a name=\"delete-a-blob\"></a>删除 Blob\r 最后，若要删除 Blob，请调用 **deleteBlob**。 以下代码示例删除名为 **myblob**的 Blob。\r \r ```nodejs\r blobSvc.deleteBlob(containerName, 'myblob', function(error, response){\r   if(!error){\r     // Blob has been deleted\r   }\r });\r ```\r \r ## <a name=\"concurrent-access\"></a>并发访问\r 若要允许从多个客户端或多个进程实例并发访问某个 blob，可以使用 ETag 或租用。\r \r * **Etag** - 用于检测 Blob 或容器是否已被其他进程修改\r * **租约** - 用于在某个时段内获取对 Blob 的独占式可续订写入或删除访问\r \r ### <a name=\"etag\"></a>ETag\r 如果需要允许多个客户端或实例同时写入块 Blob 或页 Blob，请使用 ETag。 ETag 用于确定自第一次读取或创建某个容器或 Blob 以来，该容器或 Blob 是否被修改，这样就可以避免覆盖其他客户端或进程提交的更改。\r \r 可以使用可选的 `options.accessConditions` 参数设置 ETag 条件。 如果 blob 已存在且具有 `etagToMatch` 所包含的 ETag 值，以下代码示例将仅上传 test.txt 文件。\r \r ```nodejs\r blobSvc.createBlockBlobFromLocalFile('mycontainer', 'myblob', 'test.txt', { accessConditions: { EtagMatch: etagToMatch} }, function(error, result, response){\r     if(!error){\r     // file uploaded\r   }\r });\r ```\r \r 当使用 ETag 时，常规模式为：\r \r 1. 通过创建、列出或获取操作来获取 ETag。\r 2. 执行一个操作，查看 ETag 值是否尚未修改。\r \r 如果值已修改，则表明在获得 ETag 值后，其他客户端或实例已修改该 Blob 或容器。\r \r ### <a name=\"lease\"></a>租约\r 新的租约可使用 **acquireLease** 方法获取，只需指定希望获取其租约的 Blob 或容器即可。 例如，以下代码将获取 **myblob** 的租约。\r \r ```nodejs\r blobSvc.acquireLease('mycontainer', 'myblob', function(error, result, response){\r   if(!error) {\r     console.log('leaseId: ' + result.id);\r   }\r });\r ```\r \r 对 myblob 的后续操作必须提供 `options.leaseId` 参数。 租约 ID 作为 `result.id` 从 **acquireLease**返回。\r \r > [!NOTE]\r > 默认情况下，租约期限为无期。 可以指定一个有限的租期（15 到 60 秒），只需提供 `options.leaseDuration` 参数即可。\r \r 若要删除租约，请使用 **releaseLease**。 若要中断租约，但又要防止其他人在原始租约到期之前获得新租约，则可使用 **breakLease**。\r \r ## <a name=\"work-with-shared-access-signatures\"></a>使用共享访问签名\r 共享访问签名 (SAS) 是一种安全的方法，用于对 blob 和容器进行细致访问而无需提供存储帐户名或密钥。 通常使用共享访问签名来提供对数据的有限访问权限，例如允许移动应用程序访问 Blob。\r \r > [!NOTE]\r > 虽然也可以允许匿名访问 Blob，但共享访问签名可以允许提供更受控制的访问，因为必须生成 SAS。\r \r 受信任的应用程序（例如基于云的服务）使用 BlobService 的 generateSharedAccessSignature 生成共享访问签名，然后将其提供给不受信任的或不完全受信任的应用程序，例如移动应用。 共享访问签名可使用策略生成，该策略描述了共享访问签名的生效日期和失效日期，以及授予共享访问签名持有者的访问级别。\r \r 以下代码示例生成了一个新的共享访问策略，该策略允许共享访问签名持有者对 **myblob** Blob 执行读取操作，并且在创建后 100 分钟过期。\r \r ```nodejs\r var startDate = new Date();\r var expiryDate = new Date(startDate);\r expiryDate.setMinutes(startDate.getMinutes() + 100);\r startDate.setMinutes(startDate.getMinutes() - 100);\r \r var sharedAccessPolicy = {\r   AccessPolicy: {\r     Permissions: azure.BlobUtilities.SharedAccessPermissions.READ,\r     Start: startDate,\r     Expiry: expiryDate\r   },\r };\r \r var blobSAS = blobSvc.generateSharedAccessSignature('mycontainer', 'myblob', sharedAccessPolicy);\r var host = blobSvc.host;\r ```\r \r 请注意，还必须提供主机信息，因为共享访问签名持有者尝试访问容器时，必须提供该信息。\r \r 然后，客户端应用程序共享访问签名用于 **BlobServiceWithSAS** ，以便针对 Blob 执行操作。 以下语句获取有关 **myblob**的信息。\r \r ```nodejs\r var sharedBlobSvc = azure.createBlobServiceWithSas(host, blobSAS);\r sharedBlobSvc.getBlobProperties('mycontainer', 'myblob', function (error, result, response) {\r   if(!error) {\r     // retrieved info\r   }\r });\r ```\r \r 由于共享访问签名在生成时具有只读访问权限，因此如果尝试修改 Blob，则会返回错误。\r \r ### <a name=\"access-control-lists\"></a>访问控制列表\r 还可以使用访问控制列表 (ACL) 为 SAS 设置访问策略。 如果希望允许多个客户端访问某个容器，但为每个客户端提供了不同的访问策略，则访问控制列表会很有用。\r \r ACL 是使用一组访问策略实施的，每个策略都有一个关联的 ID。 以下代码示例定义了两个策略，一个用于“user1”，一个用于“user2”：\r \r ```nodejs\r var sharedAccessPolicy = {\r   user1: {\r     Permissions: azure.BlobUtilities.SharedAccessPermissions.READ,\r     Start: startDate,\r     Expiry: expiryDate\r   },\r   user2: {\r     Permissions: azure.BlobUtilities.SharedAccessPermissions.WRITE,\r     Start: startDate,\r     Expiry: expiryDate\r   }\r };\r ```\r \r 以下代码示例将获取 mycontainer 的当前 ACL，然后使用 setBlobAcl 添加新策略。 此方法具有以下用途：\r \r ```nodejs\r var extend = require('extend');\r blobSvc.getBlobAcl('mycontainer', function(error, result, response) {\r   if(!error){\r     var newSignedIdentifiers = extend(true, result.signedIdentifiers, sharedAccessPolicy);\r     blobSvc.setBlobAcl('mycontainer', newSignedIdentifiers, function(error, result, response){\r       if(!error){\r         // ACL set\r       }\r     });\r   }\r });\r ```\r \r 设置 ACL 后，可以根据某个策略的 ID 创建共享访问签名。 以下代码示例将为“user2”创建新的共享访问签名：\r \r ```nodejs\r blobSAS = blobSvc.generateSharedAccessSignature('mycontainer', { Id: 'user2' });\r ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r 有关详细信息，请参阅以下资源。\r \r * [用于 Node API 参考的 Azure 存储 SDK][用于 Node API 参考的 Azure 存储 SDK]\r * [Azure 存储团队博客][Azure 存储团队博客]\r * [Azure Storage SDK for Node][Azure Storage SDK for Node] 存储库\r * [Node.js 开发人员中心](/develop/nodejs/)\r * [使用 AzCopy 命令行实用程序传输数据](../common/storage-use-azcopy.md?toc=%2fstorage%2fblobs%2ftoc.json)\r \r [Azure Storage SDK for Node]: https://github.com/Azure/azure-storage-node\r \r [Build and deploy a Node.js web app to Azure using Web Matrix]: https://www.microsoft.com/web/webmatrix/  \r [Using the REST API]: http://msdn.microsoft.com/library/azure/hh264518.aspx\r [Azure portal]: https://portal.azure.cn\r [生成 Node.js 应用程序并将其部署到 Azure 云服务](../../cloud-services/cloud-services-nodejs-develop-deploy-app.md) [Azure 存储团队博客]：http://blogs.msdn.com/b/windowsazurestorage/ [用于 Node API 参考的 Azure 存储 SDK]：http://dl.windowsazure.com/nodestoragedocs/index.htmll"}