{"Title":"SCP.NET 编程指南","Description":"了解如何通过 SCP.NET 创建可在 Storm on HDInsight 中使用的基于 .NET 的 Storm 拓扑。","Content":"# <a name=\"scp-programming-guide\"></a>SCP 编程指南\r SCP 是一个用于构建实时、可靠、一致和高性能的数据处理应用程序的平台。 它在 [Apache Storm](http://storm.incubator.apache.org/) 的基础上构建而成 -- Storm 是开源软件 (OSS) 社区设计的一个流处理系统。 Storm 由 Nathan Marz 设计，在 Twitter 上进行开源。 其利用 [Apache ZooKeeper](http://zookeeper.apache.org/)（另一个 Apache 项目）来实现高可靠性的分布式协调和状态管理。 \r \r SCP 项目不仅已移植到 Windows 的 Storm 中，还为 Windows 生态系统增加了扩展和自定义。 扩展包括 .NET 开发人员经验和库，自定义包括基于 Windows 的部署。 \r \r 我们无需派生 OSS 项目便可实现扩展和自定义，而且我们还可以利用在 Storm 上构建的派生生态系统。\r \r ## <a name=\"processing-model\"></a>处理模型\r SCP 中的数据以连续的元组流形式建模。 通常，元组首先流入某个队列，并被提取，再通过托管在 Storm 拓扑中的业务逻辑进行转换；最后，所产生的输出可作为元组传送到其他 SCP 系统，或者提交到存储（如分布式文件系统）或数据库（如 SQL Server）。\r \r ![馈送待处理数据的队列（在数据存储中馈送数据）示意图](./media/apache-storm-scp-programming-guide/queue-feeding-data-to-processing-to-data-store.png)\r \r 在 Storm 中，应用程序拓扑定义计算图。 拓扑中的每个节点都包含处理逻辑，节点之间的链接指明数据流。 用于将输入数据注入到拓扑中的节点名为 Spout，这些节点还可排列数据。 输入数据可驻留在文件日志、事务性数据库、系统性能计数器中或其他位置。具有输入和输出数据流的节点名为 Bolt。，这些节点执行实际数据过滤、选择和汇总。\r \r SCP 支持“尽力”、“至少一次”数据处理和“恰一次”数据处理。 在分布式流处理应用程序中，数据处理过程中可能会出现各种错误，例如，网络中断、机器故障、用户代码错误等等。“至少一次”处理会在出现错误时自动重新处理原来的数据，从而确保所有数据均至少被处理一次。 “至少一次”处理简单且可靠，适用于许多应用程序。 但是，当应用程序需要确切计数时，进行“至少一次”处理是不够的，因为相同的数据有可能用于应用程序拓扑中。 在此情况下，“恰一次”处理可确保即使数据被多次重复使用和处理，结果也是正确。\r \r 通过 SCP，.NET 开发人员可以开发实时数据处理应用程序，同时在后台通过 Storm 利用 Java 虚拟机 (JVM)。 .NET 和 JVM 通过 TCP 本地套接字进行通信。 基本上，每个 Spout/Bolt 都是一个 .Net/Java 进程对，在这些进程对中，用户逻辑作为插件在 .Net 进程中运行。\r \r 若要在 SCP 上开发数据处理应用程序，需要执行以下几个步骤：\r \r * 设计并实施 Spout，以从队列中提取数据。\r * 设计并实施 Bolt 以处理输入数据，以及将数据保存到外部存储（如数据库）中。\r * 设计拓扑，提交并运行拓扑。 拓扑定义顶点以及顶点之间的数据流。 SCP 会采用拓扑规范并将拓扑部署在 Storm 群集上，在 Storm 群集中，每个顶点在一个逻辑节点上运行。 Storm 任务计划程序会处理故障转移和缩放。\r \r 本文档使用一些简单示例来介绍如何使用 SCP 开发数据处理应用程序。\r \r ## <a name=\"scp-plugin-interface\"></a>SCP 插件接口\r SCP 插件（或应用程序）是独立的 EXE，可以在开发阶段在 Visual Studio 中运行，也可以在生产环境中部署后插入到 Storm 管道中。 编写 SCP 插件就像编写任何其他标准的 Windows 控制台应用程序一样。 SCP.NET 平台声明用于 Spout/Bolt 的接口，用户插件代码应实施这些接口。 这种设计的主要目的是使用户可以专注于自己的业务逻辑，其他事情则由 SCP.NET 平台处理。\r \r 用户插件代码应实施以下其中一个接口，具体取决于拓扑是事务性还是非事务性，以及组件是 Spout 还是 Bolt。\r \r * ISCPSpout\r * ISCPBolt\r * ISCPTxSpout\r * ISCPBatchBolt\r \r ### <a name=\"iscpplugin\"></a>ISCPPlugin\r ISCPPlugin 是各种插件的公共接口。 目前，该接口是一个虚拟接口。\r \r     public interface ISCPPlugin \r     {\r     }\r \r ### <a name=\"iscpspout\"></a>ISCPSpout\r ISCPSpout 是适用于非事务性 Spout 的接口。\r \r      public interface ISCPSpout : ISCPPlugin                    \r      {\r          void NextTuple(Dictionary<string, Object> parms);         \r          void Ack(long seqId, Dictionary<string, Object> parms);   \r          void Fail(long seqId, Dictionary<string, Object> parms);  \r      }\r \r 调用 `NextTuple()` 时，C\\# 用户代码会发送一个或多个元组。 如果没有要发送的数据，此方法应返回而不发送任何信息。 请注意，如果 C\\# 进程的单一线程出现紧凑循环，将会调用 `NextTuple()`、`Ack()` 和 `Fail()`。 如果没有要发送的元组，最好短暂地将 NextTuple 置于休眠状态（例如 10 毫秒），以免浪费太多 CPU。\r \r 仅在规范文件中启用了确认机制的情况下，才会调用 `Ack()` 和 `Fail()`。 `seqId` 用于识别已确认或失败的元组。 因此，如果在非事务性拓扑中启用了确认功能，应在 Spout 中使用以下 emit 函数：\r \r     public abstract void Emit(string streamId, List<object> values, long seqId); \r \r 如果非事务性拓扑不支持确认功能，则可以将 `Ack()` 和 `Fail()` 保留为空函数。\r \r 这些函数中的 `parms` 输入参数是空字典，保留供以后使用。\r \r ### <a name=\"iscpbolt\"></a>ISCPBolt\r ISCPBolt 是适用于非事务性 Bolt 的接口。\r \r     public interface ISCPBolt : ISCPPlugin \r     {\r     void Execute(SCPTuple tuple);           \r     }\r \r 有新的元组可用时，会调用 `Execute()` 函数来处理该元组。\r \r ### <a name=\"iscptxspout\"></a>ISCPTxSpout\r ISCPTxSpout 是适用于事务性 Spout 的接口。\r \r     public interface ISCPTxSpout : ISCPPlugin\r     {\r         void NextTx(out long seqId, Dictionary<string, Object> parms);  \r         void Ack(long seqId, Dictionary<string, Object> parms);         \r         void Fail(long seqId, Dictionary<string, Object> parms);        \r     }\r \r 与非事务性接口一样，如果 C\\# 进程的单一线程出现紧凑循环，将会调用 `NextTx()`、`Ack()` 和 `Fail()`。 如果没有要发送的数据，最好短暂地将 `NextTx` 置于休眠状态（例如 10 毫秒），以免浪费太多 CPU。\r \r 调用 `NextTx()` 可启动新的事务；输出参数 `seqId` 用于识别事务，该参数也用于 `Ack()` 和 `Fail()` 中。 在 `NextTx()` 中，用户可以将数据发送到 Java 端。 然后，数据会被存储在 ZooKeeper 中，以支持重用。 ZooKeeper 的容量有限，因此，用户应该只发送元数据，而不应该发送事务性 Spout 中的批量数据。\r \r 如果事务失败，Storm 会自动重新处理失败的事务，因此，一般情况下不应调用 `Fail()` 。 但是，如果 SCP 可以检查事务性 Spout 发送的元数据，当元数据无效时，SCP 可以调用 `Fail()` 。\r \r 这些函数中的 `parms` 输入参数是空字典，保留供以后使用。\r \r ### <a name=\"iscpbatchbolt\"></a>ISCPBatchBolt\r ISCPBatchBolt 是适用于事务性 Bolt 的接口。\r \r     public interface ISCPBatchBolt : ISCPPlugin           \r     {\r         void Execute(SCPTuple tuple);\r         void FinishBatch(Dictionary<string, Object> parms);  \r     }\r \r `Execute()` 。 `FinishBatch()` 。 保留 `parms` 输入参数供以后使用。\r \r 对于事务性拓扑，有一个重要概念 - `StormTxAttempt`。 它有两个字段：`TxId` 和 `AttemptId`。 `TxId` 用于识别特定事务，对于给定的事务，如果事务失败，可能会多次尝试对事务进行重新处理。 SCP.NET 新建一个 ISCPBatchBolt 对象来处理每个 `StormTxAttempt`，就像 Storm 在 Java 中所做的一样。 这种设计的目的是支持并行事务处理。 用户应记住，事务处理尝试结束后，应销毁相应的 ISCPBatchBolt 对象并回收所产生的垃圾。\r \r ## <a name=\"object-model\"></a>对象模型\r SCP.NET 还会提供可供开发人员用于编程的简单密钥对象集。 这些对象是 Context、StateStore 和 SCPRuntime。 本节余下部分会讨论这些对象。\r \r ### <a name=\"context\"></a>上下文\r 上下文为应用程序提供运行环境。 每个 ISCPPlugin 实例 (ISCPSpout/ISCPBolt/ISCPTxSpout/ISCPBatchBolt) 都有相应的上下文实例。 上下文提供的功能可分为两部分：(1) 静态部分，可用于整个 C\\# 进程；(2) 动态部分，仅可用于特定上下文实例。\r \r ### <a name=\"static-part\"></a>静态部分\r     public static ILogger Logger = null;\r     public static SCPPluginType pluginType;                      \r     public static Config Config { get; set; }                    \r     public static TopologyContext TopologyContext { get; set; }  \r \r `Logger` 用于日志记录。\r \r `pluginType` 用于指明 C\\# 进程的插件类型。 如果 C\\# 进程在本地测试模式下运行（没有 Java），则插件类型是 `SCP_NET_LOCAL`。\r \r     public enum SCPPluginType \r     {\r         SCP_NET_LOCAL = 0,       \r         SCP_NET_SPOUT = 1,       \r         SCP_NET_BOLT = 2,        \r         SCP_NET_TX_SPOUT = 3,   \r         SCP_NET_BATCH_BOLT = 4  \r     }\r \r `Config` 用于从 Java 端获取配置参数。 C\\# 插件初始化时，会从 Java 端传递这些参数。 `Config` 参数分为两部分：`stormConf` 和 `pluginConf`。\r \r     public Dictionary<string, Object> stormConf { get; set; }  \r     public Dictionary<string, Object> pluginConf { get; set; }  \r \r `stormConf` 是 Storm 定义的参数，`pluginConf` 是 SCP 定义的参数。 例如：\r \r     public class Constants\r     {\r         … …\r \r         // constant string for pluginConf\r         public static readonly String NONTRANSACTIONAL_ENABLE_ACK = \"nontransactional.ack.enabled\";  \r \r         // constant string for stormConf\r         public static readonly String STORM_ZOOKEEPER_SERVERS = \"storm.zookeeper.servers\";           \r         public static readonly String STORM_ZOOKEEPER_PORT = \"storm.zookeeper.port\";                 \r     }\r \r `TopologyContext` 用于获取拓扑上下文，对于具有多种并行执行能力的组件最有用。 下面是一个示例：\r \r     //demo how to get TopologyContext info\r     if (Context.pluginType != SCPPluginType.SCP_NET_LOCAL)                      \r     {\r         Context.Logger.Info(\"TopologyContext info:\");\r         TopologyContext topologyContext = Context.TopologyContext;                    \r         Context.Logger.Info(\"taskId: {0}\", topologyContext.GetThisTaskId());          \r         taskIndex = topologyContext.GetThisTaskIndex();\r         Context.Logger.Info(\"taskIndex: {0}\", taskIndex);\r         string componentId = topologyContext.GetThisComponentId();                    \r         Context.Logger.Info(\"componentId: {0}\", componentId);\r         List<int> componentTasks = topologyContext.GetComponentTasks(componentId);  \r         Context.Logger.Info(\"taskNum: {0}\", componentTasks.Count);                    \r     }\r \r ### <a name=\"dynamic-part\"></a>动态部分\r 以下接口与某个上下文实例相关。 上下文实例由 SCP.NET 平台创建，会被传递到用户代码：\r \r     // Declare the Output and Input Stream Schemas\r \r     public void DeclareComponentSchema(ComponentStreamSchema schema);   \r \r     // Emit tuple to default stream.\r     public abstract void Emit(List<object> values);                   \r \r     // Emit tuple to the specific stream.\r     public abstract void Emit(string streamId, List<object> values);  \r \r 对于支持确认功能的非事务性 Spout，提供了以下方法：\r \r     // for non-transactional Spout which supports ack\r     public abstract void Emit(string streamId, List<object> values, long seqId);  \r \r 对于支持确认功能的非事务性 Bolt，应对其接收到的元组明确执行 `Ack()` 或 `Fail()`。 发送新元组时，还必须指定新元组的定位点。 对于此类 Bolt，提供了以下方法。\r \r     public abstract void Emit(string streamId, IEnumerable<SCPTuple> anchors, List<object> values); \r     public abstract void Ack(SCPTuple tuple);\r     public abstract void Fail(SCPTuple tuple);\r \r ### <a name=\"statestore\"></a>StateStore\r `StateStore` 提供元数据服务、单调序列生成和无等待协调。 可以在 `StateStore`中构建高级分布式并发抽象，包括分布式锁、分布式队列、屏障和事务服务。\r \r SCP 可使用 `State` 对象在 ZooKeeper 中保留某些信息，尤其是适用于事务性拓扑的信息。 这样做时，如果事务性 Spout 崩溃并重新启动，它可以从 ZooKeeper 检索必要信息并重新开始数据传输。\r \r `StateStore` 对象主要提供以下方法：\r \r     /// <summary>\r     /// Static method to retrieve a state store of the given path and connStr \r     /// </summary>\r     /// <param name=\"storePath\">StateStore Path</param>\r     /// <param name=\"connStr\">StateStore Address</param>\r     /// <returns>Instance of StateStore</returns>\r     public static StateStore Get(string storePath, string connStr);\r \r     /// <summary>\r     /// Create a new state object in this state store instance\r     /// </summary>\r     /// <returns>State from StateStore</returns>\r     public State Create();\r \r     /// <summary>\r     /// Retrieve all states that were previously uncommitted, excluding all aborted states \r     /// </summary>\r     /// <returns>Uncommited States</returns>\r     public IEnumerable<State> GetUnCommitted();\r \r     /// <summary>\r     /// Get all the States in the StateStore\r     /// </summary>\r     /// <returns>All the States</returns>\r     public IEnumerable<State> States();\r \r     /// <summary>\r     /// Get state or registry object\r     /// </summary>\r     /// <param name=\"info\">Registry Name(Registry only)</param>\r     /// <typeparam name=\"T\">Type, Registry or State</typeparam>\r     /// <returns>Return Registry or State</returns>\r     public T Get<T>(string info = null);\r \r     /// <summary>\r     /// List all the committed states\r     /// </summary>\r     /// <returns>Registries contain the Committed State </returns> \r     public IEnumerable<Registry> Commited();\r \r     /// <summary>\r     /// List all the Aborted State in the StateStore\r     /// </summary>\r     /// <returns>Registries contain the Aborted State</returns>\r     public IEnumerable<Registry> Aborted();\r \r     /// <summary>\r     /// Retrieve an existing state object from this state store instance \r     /// </summary>\r     /// <returns>State from StateStore</returns>\r     /// <typeparam name=\"T\">stateId, id of the State</typeparam>\r     public State GetState(long stateId)\r \r `State` 对象主要提供以下方法：\r \r     /// <summary>\r     /// Set the status of the state object to commit \r     /// </summary>\r     public void Commit(bool simpleMode = true); \r \r     /// <summary>\r     /// Set the status of the state object to abort \r     /// </summary>\r     public void Abort();\r \r     /// <summary>\r     /// Put an attribute value under the give key \r     /// </summary>\r     /// <param name=\"key\">Key</param> \r     /// <param name=\"attribute\">State Attribute</param> \r     public void PutAttribute<T>(string key, T attribute); \r \r     /// <summary>\r     /// Get the attribute value associated with the given key \r     /// </summary>\r     /// <param name=\"key\">Key</param> \r     /// <returns>State Attribute</returns>               \r     public T GetAttribute<T>(string key);                    \r \r 对于 `Commit()` 方法，如果 simpleMode 设置为 true，此方法会删除 ZooKeeper 中相应的 ZNode。 否则，会删除当前 ZNode 并在 COMMITTED\\_PATH 中添加新节点。\r \r ### <a name=\"scpruntime\"></a>SCPRuntime\r SCPRuntime 提供以下两种方法：\r \r     public static void Initialize();\r \r     public static void LaunchPlugin(newSCPPlugin createDelegate);  \r \r `Initialize()` 用于初始化 SCP 运行时环境。 在此方法中，C\\# 进程会连接到 Java 端，并会获取配置参数和拓扑上下文。\r \r `LaunchPlugin()` 用于启动消息处理循环。 在此循环中，C\\# 插件接收来自 Java 端的消息（包括元组和控制信号），然后处理接收到的消息，也许还会调用用户代码提供的接口方法。 `LaunchPlugin()` 方法的输入参数是委托参数，可返回实施 ISCPSpout/IScpBolt/ISCPTxSpout/ISCPBatchBolt 接口的对象。\r \r     public delegate ISCPPlugin newSCPPlugin(Context ctx, Dictionary\\<string, Object\\> parms); \r \r 对于 ISCPBatchBolt，可从 `parms` 获取 `StormTxAttempt`，并利用它来判断某项操作是否是重复尝试。 对尝试重播的检查通常在 Commit Bolt 中完成，并在 `HelloWorldTx` 示例中进行演示。\r \r 一般来说，SCP 插件可在以下两种模式下运行：\r \r 1. 本地测试模式：在此模式下的开发阶段中，SCP 插件（C\\# 用户代码）在 Visual Studio 中运行。 `LocalContext` 可用于此模式，其提供方法对发送到本地文件的元组进行序列化并将这些元组重新读取到内存。\r \r         public interface ILocalContext\r         {\r             List\\<SCPTuple\\> RecvFromMsgQueue();\r             void WriteMsgQueueToFile(string filepath, bool append = false);  \r             void ReadFromFileToMsgQueue(string filepath);                    \r         }\r 2. 常规模式：在此模式下，SCP 插件由 Storm Java 进程启动。\r \r     下面是一个 SCP 插件启动示例：\r \r         namespace Scp.App.HelloWorld\r         {\r         public class Generator : ISCPSpout\r         {\r             … …\r             public static Generator Get(Context ctx, Dictionary<string, Object> parms)\r             {\r             return new Generator(ctx);\r             }\r         }\r \r         class HelloWorld\r         {\r             static void Main(string[] args)\r             {\r             /* Setting the environment variable here can change the log file name */\r             System.Environment.SetEnvironmentVariable(\"microsoft.scp.logPrefix\", \"HelloWorld\");\r \r             SCPRuntime.Initialize();\r             SCPRuntime.LaunchPlugin(new newSCPPlugin(Generator.Get));\r             }\r         }\r         }\r \r ## <a name=\"topology-specification-language\"></a>拓扑规范语言\r SCP 拓扑规范是一种特定于域的语言，用于描述和配置 SCP 拓扑。 它基于 Storm 的 Clojure DSL (<http://storm.incubator.apache.org/documentation/Clojure-DSL.html>)，可通过 SCP 进行扩展。\r \r 拓扑规范可通过 runspec 命令直接提交到 Storm 群集进行执行。\r \r SCP.NET 添加了以下函数来定义事务性拓扑：\r \r | **新函数** | **Parameters** | **说明** |\r | --- | --- | --- |\r | **tx-topolopy** |topology-name<br />spout-map<br />bolt-map |使用拓扑名称、Spout 定义图和 Bolt 定义图来定义事务性拓扑&nbsp; |\r | **scp-tx-spout** |exec-name<br />args<br />fields |定义事务性 Spout。 使用 args 运行带有 exec-name 的应用程序。<br /><br />fields 是用于 Spout 的输出字段 |\r | **scp-tx-batch-bolt** |exec-name<br />args<br />fields |定义事务性批处理 Bolt。 使用 args 运行带有 exec-name 的应用程序。<br /><br />Fields 是用于 Bolt 的输出字段。 |\r | **scp-tx-commit-bolt** |exec-name<br />args<br />fields |定义事务性 Committer Bolt。 使用 args 运行带有 exec-name 的应用程序。<br /><br />fields 是用于 Bolt 的输出字段 |\r | **nontx-topolopy** |topology-name<br />spout-map<br />bolt-map |使用拓扑名称、Spout 定义图和 Bolt 来定义非事务性拓扑&nbsp; |\r | **scp-spout** |exec-name<br />args<br />fields<br />参数 |定义非事务性 Spout。 使用 args 运行带有 exec-name 的应用程序。<br /><br />fields 是用于 Spout 的输出字段<br /><br />parameters 为可选，可使用它指定某些参数，例如“nontransactional.ack.enabled”。 |\r | **scp-bolt** |exec-name<br />args<br />fields<br />参数 |定义非事务性 Bolt。 使用 args 运行带有 exec-name 的应用程序。<br /><br />fields 是用于 Bolt 的输出字段<br /><br />parameters 为可选，可使用它指定某些参数，例如“nontransactional.ack.enabled”。 |\r \r SCP.NET 定义了以下关键字：\r \r | **关键字** | **说明** |\r | --- | --- |\r | **:name** |定义拓扑名称 |\r | **:topology** |使用上述函数和内置函数定义拓扑。 |\r | **:p** |定义每个 Spout 或 Bolt 的并行提示。 |\r | **:config** |定义配置参数或更新现有的配置参数 |\r | **:schema** |定义流架构。 |\r \r 常用参数：\r \r | **参数** | **说明** |\r | --- | --- |\r | **\"plugin.name\"** |C# 插件的 exe 文件名 |\r | **\"plugin.args\"** |plugin args |\r | **\"output.schema\"** |输出架构 |\r | **\"nontransactional.ack.enabled\"** |非事务性拓扑是否已启用确认功能 |\r \r runspec 命令会与位元一起部署，其用法如下：\r \r     .\\bin\\runSpec.cmd\r     usage: runSpec [spec-file target-dir [resource-dir] [-cp classpath]]\r     ex: runSpec examples\\HelloWorld\\HelloWorld.spec specs examples\\HelloWorld\\Target\r \r resource-dir 参数是可选参数，在想要启动 C\\# 应用程序时，需要指定此参数，此目录将包含应用程序、依赖项和配置。\r \r classpath 参数也是可选参数。 当规范文件包含 Java Spout 或 Bolt 时，此参数用于指定 Java classpath。\r \r ## <a name=\"miscellaneous-features\"></a>其他功能\r ### <a name=\"input-and-output-schema-declaration\"></a>输入和输出架构声明\r 用户可以在 C\\# 进程中发送元组；平台需要将元组序列化为 byte[]，传输到 Java 端；而 Storm 会将此元组传输到目标。 与此同时，在下游组件中，C\\# 进程会接收从 Java 端返回的元组，并将其转换为平台使用的原始类型 - 所有这些操作都在平台的后台进行。\r \r 为了支持序列化和反序列化，用户代码需要声明输入和输出的架构。\r \r 输入/输出流架构被定义为字典。 键为 StreamId。 值为列的类型。 组件可以声明多个数据流。\r \r     public class ComponentStreamSchema\r     {\r         public Dictionary<string, List<Type>> InputStreamSchema { get; set; }\r         public Dictionary<string, List<Type>> OutputStreamSchema { get; set; }\r         public ComponentStreamSchema(Dictionary<string, List<Type>> input, Dictionary<string, List<Type>> output)\r         {\r             InputStreamSchema = input;\r             OutputStreamSchema = output;\r         }\r     }\r \r 在上下文对象中，添加了以下 API：\r \r     public void DeclareComponentSchema(ComponentStreamSchema schema)\r \r 开发者必须确保发送的元组符合为该流定义的架构，否则，系统会引发运行时异常。\r \r ### <a name=\"multi-stream-support\"></a>多流支持\r SCP 支持用户代码同时向多个不同数据流发送元组或同时接收来自多个不同数据流的元组。 这种支持在上下文对象中体现为，Emit 方法采用可选的 stream ID 参数。\r \r 在 SCP.NET 上下文对象中添加了两种方法。 这些方法用于发送一个或多个元组以指定 StreamId。 StreamId 是字符串，必须在 C\\# 和拓扑定义规范中保持一致。\r \r         /* Emit tuple to the specific stream. */\r         public abstract void Emit(string streamId, List<object> values);\r \r         /* for non-transactional Spout only */\r         public abstract void Emit(string streamId, List<object> values, long seqId);\r \r 向不存在的数据流发送元组会导致运行时异常。\r \r ### <a name=\"fields-grouping\"></a>字段分组\r Storm 中内置的字段分组在 SCP.NET 中无法正常使用。 在 Java 代理端，所有字段数据类型实际上都是 byte[]，字段分组会使用 byte[] 对象来进行分组。 byte[] 对象哈希代码是该对象在内存中的地址。 因此，如果两个 byte[] 对象共享相同的内容但地址不相同，分组将会不正确。\r \r SCP.NET 添加了一个自定义的分组方法，该方法会使用 byte[] 的内容来进行分组。 在 **SPEC** 文件中，语法如下所示：\r \r     (bolt-spec\r         {\r             \"spout_test\" (scp-field-group :non-tx [0,1])\r         }\r         …\r     )\r \r 其中：\r \r 1. \"scp-field-group\" 表示“SCP 实现的自定义字段分组”。\r 2. \":tx\" 或 \":non-tx\" 表示是否是事务性拓扑。 我们需要此信息，因为事务性拓扑和非事务性拓扑的起始索引不一样。\r 3. [0,1] 表示从 0 开始的哈希集或字段 ID。\r \r ### <a name=\"hybrid-topology\"></a>混合拓扑\r 本机 Storm 是用 Java 编写的。 SCP.Net 已对其进行增强，使 C\\# 开发者能够编写 C\\# 代码来处理其业务逻辑。 但它也支持混合拓扑，这种拓扑不仅包含 C\\# Spout/Bolt，还包含 Java Spout/Bolt。\r \r ### <a name=\"specify-java-spoutbolt-in-spec-file\"></a>在规范文件中指定 Java Spout/Bolt\r 在规范文件中，“scp-spout”和“scp-bolt”也可用于指定 Java Spout 和 Bolt；下面是一个示例：\r \r     (spout-spec \r       (microsoft.scp.example.HybridTopology.Generator.)           \r       :p 1)\r \r 其中， `microsoft.scp.example.HybridTopology.Generator` 是 Java Spout 类的名称。\r \r ### <a name=\"specify-java-classpath-in-runspec-command\"></a>在 runSpec 命令中指定 Java Classpath\r 如果想要提交包含 Java Spout 或 Bolt 的拓扑，则首先需要编译 Java Spout 或 Bolt 并获取 Jar 文件。 然后，应在提交拓扑时指定包含 Jar 文件的 Java Classpath。 下面是一个示例：\r \r     bin\\runSpec.cmd examples\\HybridTopology\\HybridTopology.spec specs examples\\HybridTopology\\net\\Target -cp examples\\HybridTopology\\java\\target\\*\r \r 其中，examples\\\\HybridTopology\\\\java\\\\target\\\\ 是包含 Java Spout/Bolt Jar 文件的文件夹。\r \r ### <a name=\"serialization-and-deserialization-between-java-and-c\"></a>Java 和 C\\# 之间的序列化和反序列化\r SCP 组件包括 Java 端和 C\\# 端。 若要与本机 Java Spout/Bolt 交互，必须在 Java 端与 C\\# 端之间执行序列化/反序列化，如下图中所示。\r \r ![Java 组件示意图，发送到 SCP 组件，发送到 Java 组件](./media/apache-storm-scp-programming-guide/java-compent-sending-to-scp-component-sending-to-java-component.png)\r \r 1. Java 端的序列化和 C\\# 端的反序列化\r \r    最初，默认情况下是在 Java 端进行序列化并在 C\\# 端进行反序列化。 可以在规范文件中指定 Java 端的序列化方法：\r \r        (scp-bolt\r            {\r                \"plugin.name\" \"HybridTopology.exe\"\r                \"plugin.args\" [\"displayer\"]\r                \"output.schema\" {}\r                \"customized.java.serializer\" [\"microsoft.scp.storm.multilang.CustomizedInteropJSONSerializer\"]\r            })\r \r    应在 C\\# 用户代码中指定 C\\# 端的反序列化方法：\r \r        Dictionary<string, List<Type>> inputSchema = new Dictionary<string, List<Type>>();\r        inputSchema.Add(\"default\", new List<Type>() { typeof(Person) });\r        this.ctx.DeclareComponentSchema(new ComponentStreamSchema(inputSchema, null));\r        this.ctx.DeclareCustomizedDeserializer(new CustomizedInteropJSONDeserializer());            \r    \r    如果数据类型不是太复杂，这种默认实现方法应该能够应对大多数情况。 对于某些情况，由于用户数据类型太复杂，或者由于我们的默认实现性能不符合用户要求，用户可能会进行自定义实施。\r    \r    Java 端的序列化接口如下定义：\r \r        public interface ICustomizedInteropJavaSerializer {\r            public void prepare(String[] args);\r            public List<ByteBuffer> serialize(List<Object> objectList);\r        }\r \r    C\\# 端的反序列化接口如下定义：\r \r    公共接口 ICustomizedInteropCSharpDeserializer\r \r        public interface ICustomizedInteropCSharpDeserializer\r        {\r            List<Object> Deserialize(List<byte[]> dataList, List<Type> targetTypes);\r        }\r        \r 2. **C\\# 端的序列化和 Java 端的反序列化**\r    \r    应在 C\\# 用户代码中指定 C\\# 端的序列化方法：\r \r        this.ctx.DeclareCustomizedSerializer(new CustomizedInteropJSONSerializer()); \r \r    应在 SPEC 文件中指定 Java 端的反序列化方法：\r \r      (scp-spout\r \r        {\r          \"plugin.name\" \"HybridTopology.exe\"\r          \"plugin.args\" [\"generator\"]\r          \"output.schema\" {\"default\" [\"person\"]}\r          \"customized.java.deserializer\" [\"microsoft.scp.storm.multilang.CustomizedInteropJSONDeserializer\" \"microsoft.scp.example.HybridTopology.Person\"]\r        })\r \r    其中，\"microsoft.scp.storm.multilang.CustomizedInteropJSONDeserializer\" 是反序列化程序的名称，\"microsoft.scp.example.HybridTopology.Person\" 是数据要反序列化成的目标类。\r    \r    用户也可以外挂自己的 C\\# 序列化程序和 Java 反序列化程序的实现。 此代码是 C\\# 序列化程序的接口：\r    \r        public interface ICustomizedInteropCSharpSerializer\r        {\r            List<byte[]> Serialize(List<object> dataList);\r        }\r    \r    此代码是 Java 反列化程序的接口：\r    \r        public interface ICustomizedInteropJavaDeserializer {\r            public void prepare(String[] targetClassNames);\r            public List<Object> Deserialize(List<ByteBuffer> dataList);\r        }\r \r ## <a name=\"scp-host-mode\"></a>SCP 主机模式\r 在此模式下，用户可以将代码编译为 DLL，以及使用 SCP 提供的 SCPHost.exe 来提交拓扑。 规范文件下方代码所示：\r \r     (scp-spout\r       {\r         \"plugin.name\" \"SCPHost.exe\"\r         \"plugin.args\" [\"HelloWorld.dll\" \"Scp.App.HelloWorld.Generator\" \"Get\"]\r         \"output.schema\" {\"default\" [\"sentence\"]}\r       })\r \r 其中，`plugin.name` 指定为 SCP SDK 提供的 `SCPHost.exe`。 SCPHost.exe 接受三个参数：\r \r 1. 第一个参数是 DLL 名称，在本示例中为 `\"HelloWorld.dll\"` 。\r 2. 第二个参数是类名称，在本示例中为 `\"Scp.App.HelloWorld.Generator\"` 。\r 3. 第三个参数是公共静态方法的名称，调用此参数可获得 ISCPPlugin 的实例。\r \r 在主机模式下，用户代码被编译为 DLL，并由 SCP 平台调用。 因此，SCP 平台可以全面控制整个处理逻辑。 因此，我们建议客户在 SCP 主机模式下提交拓扑，因此这样做可以简化开发过程，获得更大的灵活性，以及对于以后版本的更好向后兼容性。\r \r ## <a name=\"scp-programming-examples\"></a>SCP 编程示例\r ### <a name=\"helloworld\"></a>HelloWorld\r HelloWorld 是一个简单的 SCP.Net 编程示例。 它使用非事务性拓扑，带有一个名为 generator 的 Spout，以及两个分别名为 splitter 和 counter 的 Bolt。 Spout 生成器会随机生成一些句子，然后将生成的句子发送到 拆分器。 Bolt 拆分器会将句子拆分为字词并将其发送到计数器 Bolt。 Bolt \"counter\" 使用字典记录每个字词出现的次数。\r \r 在本示例中，有两个规范文件：HelloWorld.spec 和 HelloWorld\\_EnableAck.spec。 在 C\\# 代码中，可以通过从 Java 端获取 pluginConf 来确定是否已启用确认功能。\r \r     /* demo how to get pluginConf info */\r     if (Context.Config.pluginConf.ContainsKey(Constants.NONTRANSACTIONAL_ENABLE_ACK))\r     {\r         enableAck = (bool)(Context.Config.pluginConf[Constants.NONTRANSACTIONAL_ENABLE_ACK]);\r     }\r     Context.Logger.Info(\"enableAck: {0}\", enableAck);\r \r 在 Spout 中，如果启用了确认功能，会使用字典将未确认的元组存储在缓存中。 如果调用了 Fail()，则会重新处理失败的元组：\r \r     public void Fail(long seqId, Dictionary<string, Object> parms)\r     {\r         Context.Logger.Info(\"Fail, seqId: {0}\", seqId);\r         if (cachedTuples.ContainsKey(seqId))\r         {\r             /* get the cached tuple */\r             string sentence = cachedTuples[seqId];\r \r             /* replay the failed tuple */\r             Context.Logger.Info(\"Re-Emit: {0}, seqId: {1}\", sentence, seqId);\r             this.ctx.Emit(Constants.DEFAULT_STREAM_ID, new Values(sentence), seqId);\r         }\r         else\r         {\r             Context.Logger.Warn(\"Fail(), can't find cached tuple for seqId {0}!\", seqId);\r         }\r     }\r \r ### <a name=\"helloworldtx\"></a>HelloWorldTx\r **HelloWorldTx** 示例展示如何实施事务性拓扑。 它有一个名为生成器的 Spout、一个名为 partial-count 的批处理 Bolt 以及一个名为 count-sum 的提交 Bolt。 还有三个预先创建的 txt 文件：DataSource0.txt、DataSource1.txt 和 DataSource2.txt。\r \r 在每个事务中，Spout 生成器从预先创建的三个文件中随机选择两个文件，并将那两个文件的名称发送给 partial-count Bolt。 Bolt partial-count 从接收到的元组获取文件名，然后打开文件并计算文件中的字词数量，最后将计算出的字词数量发送给 count-sum Bolt。 count-sum Bolt 对总计数进行汇总。\r \r 为了获得 exactly once 语义，提交 Bolt count-sum 需要判断事务是否是重复处理的事务。 在本示例中，它具有静态成员变量：\r \r     public static long lastCommittedTxId = -1; \r \r 创建 ISCPBatchBolt 实例后，它从输入参数获取 `txAttempt`：\r \r     public static CountSum Get(Context ctx, Dictionary<string, Object> parms)\r     {\r         /* for transactional topology, we can get txAttempt from the input parms */\r         if (parms.ContainsKey(Constants.STORM_TX_ATTEMPT))\r         {\r             StormTxAttempt txAttempt = (StormTxAttempt)parms[Constants.STORM_TX_ATTEMPT];\r             return new CountSum(ctx, txAttempt);\r         }\r         else\r         {\r             throw new Exception(\"null txAttempt\");\r         }\r     }\r \r 如果调用 `FinishBatch()`，在不是重复处理的事务的情况下，会更新 `lastCommittedTxId`。\r \r     public void FinishBatch(Dictionary<string, Object> parms)\r     {\r         /* judge whether it is a replayed transaction? */\r         bool replay = (this.txAttempt.TxId <= lastCommittedTxId);\r \r         if (!replay)\r         {\r             /* If it is not replayed, update the totalCount and lastCommittedTxId value */\r             totalCount = totalCount + this.count;\r             lastCommittedTxId = this.txAttempt.TxId;\r         }\r         … …\r     }\r \r ### <a name=\"hybridtopology\"></a>HybridTopology\r 此拓扑包含一个 Java Spout 和一个 C\\# Bolt。 它使用 SCP 平台提供的默认序列化和反序列化实现方法。 有关规范文件的详细信息，请参阅“示例\\\\HybridTopology”文件夹中的 HybridTopology.spec；有关如何指定 Java classpath，请参阅 SubmitTopology.bat。\r \r ### <a name=\"scphostdemo\"></a>SCPHostDemo\r 本质上，本示例与 HelloWorld 相同。 唯一不同之处是，在本示例中，用户代码被编译为 DLL，而且使用 SCPHost.exe 提交拓扑。 有关更详细说明，请参阅“SCP 主机模式”部分。\r \r ## <a name=\"next-steps\"></a>后续步骤\r 有关使用 SCP 创建的 Storm 拓扑示例，请参阅以下文档：\r \r * [使用 Visual Studio 开发 Apache Storm on HDInsight 的 C# 拓扑](apache-storm-develop-csharp-visual-studio-topology.md)\r * [使用 Storm on HDInsight 从 Azure 事件中心处理事件](apache-storm-develop-csharp-event-hub-topology.md)\r * [使用 Storm on HDInsight 处理事件中心的汽车传感器数据](https://github.com/hdinsight/hdinsight-storm-examples/tree/master/IotExample)\r * [从 Azure 事件中心提取、转换和加载 (ETL) 到 HBase](https://github.com/hdinsight/hdinsight-storm-examples/blob/master/RealTimeETLExample)\r \r \r \r <!--Update_Description: update wording and link references-->"}