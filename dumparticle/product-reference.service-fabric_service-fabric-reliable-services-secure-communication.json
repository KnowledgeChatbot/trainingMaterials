{"Title":"在 Service Fabric 中帮助保护服务的通信","Description":"概述如何帮助保护在 Azure Service Fabric 群集中运行的 Reliable Services 的通信。","Content":"\r # 在 Azure Service Fabric 中帮助保护服务的通信\r \r 安全是通信最为重视的要素之一。Reliable Services 应用程序框架提供了一些预先生成的通信堆栈和工具供你用来提高安全性。本文将介绍如何在使用服务远程处理和 Windows Communication Foundation \\(WCF\\) 通信堆栈时提高安全性。\r \r ## 使用服务远程处理时帮助保护服务\r \r 我们将使用一个现有[示例](./service-fabric-reliable-services-communication-remoting.md)，解释如何为 Reliable Services 设置远程处理。若要在使用服务远程处理时帮助保护服务，请遵循以下步骤：\r \r 1. 创建接口 `IHelloWorldStateful`，用于定义可供服务的远程过程调用使用的方法。服务将使用 `Microsoft.ServiceFabric.Services.Remoting.FabricTransport.Runtime` 命名空间中声明的 `FabricTransportServiceRemotingListener`。这是可以提供远程处理功能的 `ICommunicationListener` 实现。\r \r     ```csharp\r     public interface IHelloWorldStateful : IService\r     {\r         Task<string> GetHelloWorld();\r     }\r \r     internal class HelloWorldStateful : StatefulService, IHelloWorldStateful\r     {\r         protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()\r         {\r             return new[]{\r                     new ServiceReplicaListener(\r                         (context) => new FabricTransportServiceRemotingListener(context,this))};\r         }\r \r         public Task<string> GetHelloWorld()\r         {\r             return Task.FromResult(\"Hello World!\");\r         }\r     }\r     ```\r \r 2. 添加侦听器设置和安全凭据。\r \r     确保你要用来帮助保护服务通信的证书安装在群集中的所有节点上。有两种方式可用于提供侦听器设置和安全凭据：\r \r     1. 在服务代码中直接提供：\r \r         ```csharp\r         protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()\r         {\r             FabricTransportListenerSettings listenerSettings = new FabricTransportListenerSettings\r             {\r                 MaxMessageSize = 10000000,\r                 SecurityCredentials = GetSecurityCredentials()\r             };\r             return new[]\r             {\r                 new ServiceReplicaListener(\r                     (context) => new FabricTransportServiceRemotingListener(context,this,listenerSettings))\r             };\r         }\r \r         private static SecurityCredentials GetSecurityCredentials()\r         {\r             // Provide certificate details.\r             var x509Credentials = new X509Credentials\r             {\r                 FindType = X509FindType.FindByThumbprint,\r                 FindValue = \"4FEF3950642138446CC364A396E1E881DB76B48C\",\r                 StoreLocation = StoreLocation.LocalMachine,\r                 StoreName = \"My\",\r                 ProtectionLevel = ProtectionLevel.EncryptAndSign\r             };\r             x509Credentials.RemoteCommonNames.Add(\"ServiceFabric-Test-Cert\");\r             return x509Credentials;\r         }\r         ```\r \r     2. 使用[配置包](./service-fabric-application-model.md)提供：\r \r         在 settings.xml 文件中添加 `TransportSettings` 节。\r \r         ```xml\r         <!--Section name should always end with \"TransportSettings\".-->\r         <!--Here we are using a prefix \"HelloWorldStateful\".-->\r         <Section Name=\"HelloWorldStatefulTransportSettings\">\r             <Parameter Name=\"MaxMessageSize\" Value=\"10000000\" />\r             <Parameter Name=\"SecurityCredentialsType\" Value=\"X509\" />\r             <Parameter Name=\"CertificateFindType\" Value=\"FindByThumbprint\" />\r             <Parameter Name=\"CertificateFindValue\" Value=\"4FEF3950642138446CC364A396E1E881DB76B48C\" />\r             <Parameter Name=\"CertificateStoreLocation\" Value=\"LocalMachine\" />\r             <Parameter Name=\"CertificateStoreName\" Value=\"My\" />\r             <Parameter Name=\"CertificateProtectionLevel\" Value=\"EncryptAndSign\" />\r             <Parameter Name=\"CertificateRemoteCommonNames\" Value=\"ServiceFabric-Test-Cert\" />\r         </Section>\r         ```\r \r         在这种情况下，`CreateServiceReplicaListeners` 方法如下所示：\r \r         ```csharp\r         protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()\r         {\r             return new[]\r             {\r                 new ServiceReplicaListener(\r                     (context) => new FabricTransportServiceRemotingListener(\r                         context,this,FabricTransportListenerSettings.LoadFrom(\"HelloWorldStateful\")))\r             };\r         }\r         ```\r \r          如果将在 settings.xml 中添加 `TransportSettings` 节而不添加任何前缀，`FabricTransportListenerSettings` 将默认加载此节中的所有设置。\r \r          ```xml\r          <!--\"TransportSettings\" section without any prefix.-->\r          <Section Name=\"TransportSettings\">\r              ...\r          </Section>\r          ```\r \r          在这种情况下，`CreateServiceReplicaListeners` 方法如下所示：\r \r          ```csharp\r          protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()\r          {\r              return new[]\r              {\r                  return new[]{\r                          new ServiceReplicaListener(\r                              (context) => new FabricTransportServiceRemotingListener(context,this))};\r              };\r          }\r          ```\r \r 3. 在安全服务上使用远程处理堆栈而不是使用 `Microsoft.ServiceFabric.Services.Remoting.Client.ServiceProxy` 类调用方法来创建服务代理时，请使用 `Microsoft.ServiceFabric.Services.Remoting.Client.ServiceProxyFactory`。传入包含 `SecurityCredentials` 的 `FabricTransportSettings`。\r \r     ```csharp\r     var x509Credentials = new X509Credentials\r     {\r         FindType = X509FindType.FindByThumbprint,\r         FindValue = \"4FEF3950642138446CC364A396E1E881DB76B48C\",\r         StoreLocation = StoreLocation.LocalMachine,\r         StoreName = \"My\",\r         ProtectionLevel = ProtectionLevel.EncryptAndSign\r     };\r     x509Credentials.RemoteCommonNames.Add(\"ServiceFabric-Test-Cert\");\r \r     FabricTransportSettings transportSettings = new FabricTransportSettings\r     {\r         SecurityCredentials = x509Credentials,\r     };\r \r     ServiceProxyFactory serviceProxyFactory = new ServiceProxyFactory(\r         (c) => new FabricTransportServiceRemotingClientFactory(transportSettings));\r \r     IHelloWorldStateful client = serviceProxyFactory.CreateServiceProxy<IHelloWorldStateful>(\r         new Uri(\"fabric:/MyApplication/MyHelloWorldService\"));\r \r     string message = await client.GetHelloWorld();\r     ```\r \r     如果客户端代码正在作为服务一部分运行，你可以从 settings.xml 文件中加载 `FabricTransportSettings`。创建与服务代码类似的 TransportSettings 节，如上所示。对客户端代码进行以下更改：\r \r     ```csharp\r     ServiceProxyFactory serviceProxyFactory = new ServiceProxyFactory(\r         (c) => new FabricTransportServiceRemotingClientFactory(FabricTransportSettings.LoadFrom(\"TransportSettingsPrefix\")));\r \r     IHelloWorldStateful client = serviceProxyFactory.CreateServiceProxy<IHelloWorldStateful>(\r         new Uri(\"fabric:/MyApplication/MyHelloWorldService\"));\r \r     string message = await client.GetHelloWorld();\r     ```\r \r     如果客户端不是作为服务的一部分运行，你可以在 client\\_name.exe 所在的同一位置中创建 client\\_name.settings.xml 文件。然后，在该文件中创建 TransportSettings 节。\r \r     类似于服务，如果你在客户端 settings.xml/client\\_name.settings.xml 中添加 `TransportSettings` 节而不添加任何前缀，`FabricTransportSettings` 将默认加载此节中的所有设置。\r \r     在此情况下，上述代码将进一步简化：\r \r     ```csharp\r     IHelloWorldStateful client = ServiceProxy.Create<IHelloWorldStateful>(\r                  new Uri(\"fabric:/MyApplication/MyHelloWorldService\"));\r \r     string message = await client.GetHelloWorld();\r     ```\r \r ## 使用基于 WCF 的通信堆栈时帮助保护服务\r \r 我们将使用一个现有[示例](./service-fabric-reliable-services-communication-wcf.md)，解释如何为 Reliable Services 设置基于 WCF 的通信堆栈。若要在使用基于 WCF 的通信堆栈时帮助保护服务，请遵循以下步骤：\r \r 1. 对于服务，需要帮助保护你创建的 WCF 通信侦听器 \\(`WcfCommunicationListener`\\)。为此，请修改 `CreateServiceReplicaListeners` 方法。\r \r     ```csharp\r     protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()\r     {\r         return new[]\r         {\r             new ServiceReplicaListener(\r                 this.CreateWcfCommunicationListener)\r         };\r     }\r \r     private WcfCommunicationListener<ICalculator> CreateWcfCommunicationListener(StatefulServiceContext context)\r     {\r            var wcfCommunicationListener = new WcfCommunicationListener<ICalculator>(\r             serviceContext:context,\r             wcfServiceObject:this,\r             // For this example, we will be using NetTcpBinding.\r             listenerBinding: GetNetTcpBinding(),\r             endpointResourceName:\"WcfServiceEndpoint\");\r \r         // Add certificate details in the ServiceHost credentials.\r         wcfCommunicationListener.ServiceHost.Credentials.ServiceCertificate.SetCertificate(\r             StoreLocation.LocalMachine,\r             StoreName.My,\r             X509FindType.FindByThumbprint,\r             \"9DC906B169DC4FAFFD1697AC781E806790749D2F\");\r         return wcfCommunicationListener;\r     }\r \r     private static NetTcpBinding GetNetTcpBinding()\r     {\r         NetTcpBinding b = new NetTcpBinding(SecurityMode.TransportWithMessageCredential);\r         b.Security.Message.ClientCredentialType = MessageCredentialType.Certificate;\r         return b;\r     }\r     ```\r \r 2. 在客户端中，在前面[示例](./service-fabric-reliable-services-communication-wcf.md)中创建的 `WcfCommunicationClient` 类保持不变。但是，需要重写 `WcfCommunicationClientFactory` 的 `CreateClientAsync` 方法：\r \r     ```csharp\r     public class SecureWcfCommunicationClientFactory<TServiceContract> : WcfCommunicationClientFactory<TServiceContract> where TServiceContract : class\r     {\r         private readonly Binding clientBinding;\r         private readonly object callbackObject;\r         public SecureWcfCommunicationClientFactory(\r             Binding clientBinding,\r             IEnumerable<IExceptionHandler> exceptionHandlers = null,\r             IServicePartitionResolver servicePartitionResolver = null,\r             string traceId = null,\r             object callback = null)\r             : base(clientBinding, exceptionHandlers, servicePartitionResolver,traceId,callback)\r         {\r             this.clientBinding = clientBinding;\r             this.callbackObject = callback;\r         }\r \r         protected override Task<WcfCommunicationClient<TServiceContract>> CreateClientAsync(string endpoint, CancellationToken cancellationToken)\r         {\r             var endpointAddress = new EndpointAddress(new Uri(endpoint));\r             ChannelFactory<TServiceContract> channelFactory;\r             if (this.callbackObject != null)\r             {\r                 channelFactory = new DuplexChannelFactory<TServiceContract>(\r                 this.callbackObject,\r                 this.clientBinding,\r                 endpointAddress);\r             }\r             else\r             {\r                 channelFactory = new ChannelFactory<TServiceContract>(this.clientBinding, endpointAddress);\r             }\r             // Add certificate details to the ChannelFactory credentials.\r             // These credentials will be used by the clients created by\r             // SecureWcfCommunicationClientFactory.  \r             channelFactory.Credentials.ClientCertificate.SetCertificate(\r                 StoreLocation.LocalMachine,\r                 StoreName.My,\r                 X509FindType.FindByThumbprint,\r                 \"9DC906B169DC4FAFFD1697AC781E806790749D2F\");\r             var channel = channelFactory.CreateChannel();\r             var clientChannel = ((IClientChannel)channel);\r             clientChannel.OperationTimeout = this.clientBinding.ReceiveTimeout;\r             return Task.FromResult(this.CreateWcfCommunicationClient(channel));\r         }\r     }\r     ```\r \r     使用 `SecureWcfCommunicationClientFactory` 创建 WCF 通信客户端 \\(`WcfCommunicationClient`\\)。使用客户端调用服务方法。\r \r     ```csharp\r     IServicePartitionResolver partitionResolver = ServicePartitionResolver.GetDefault();\r \r     var wcfClientFactory = new SecureWcfCommunicationClientFactory<ICalculator>(clientBinding: GetNetTcpBinding(), servicePartitionResolver: partitionResolver);\r \r     var calculatorServiceCommunicationClient =  new WcfCommunicationClient(\r         wcfClientFactory,\r         ServiceUri,\r         ServicePartitionKey.Singleton);\r \r     var result = calculatorServiceCommunicationClient.InvokeWithRetryAsync(\r         client => client.Channel.Add(2, 3)).Result;\r     ```\r \r ## 后续步骤\r \r * [Reliable Services 中使用 OWIN 的 Web API](./service-fabric-reliable-services-communication-webapi.md)\r \r <!---HONumber=Mooncake_0213_2017-->\r <!--Update_Description: wording update-->"}