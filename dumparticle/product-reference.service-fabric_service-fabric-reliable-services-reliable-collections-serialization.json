{"Title":"Azure Service Fabric 中的 Reliable Collection 对象序列化","Description":"Azure Service Fabric Reliable Collections 对象序列化","Content":"# <a name=\"reliable-collection-object-serialization-in-azure-service-fabric\"></a>Azure Service Fabric 中的 Reliable Collection 对象序列化\r Reliable Collections 通过复制和保留项目，确保这些项目在机器故障和电力中断时能够持久。\r 若要复制和保留项目，Reliable Collections 需要对其进行串行化。\r \r Reliable Collections 从 Reliable State Manager 获取与给定类型对应的串行化程序。\r Reliable State Manager 包含内置序列化程序，允许针对给定类型注册自定义串行化程序。\r \r ## <a name=\"built-in-serializers\"></a>内置串行化程序\r \r Reliable State Manager 包含针对一些常见类型的内置串行化程序，以便在默认情况下对其进行高效串行化。 对于其他类型，Reliable State Manager 回退为使用 [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer(v=vs.110).aspx)。\r 内置串行化程序更高效，因为它们知道其类型无法更改，且它们无需包含类型名称等有关类型的信息。\r \r Reliable State Manager 拥有针对以下类型的内置串行化程序： \r - Guid\r - bool\r - byte\r - sbyte\r - byte[]\r - char\r - 字符串\r - decimal\r - double\r - float\r - int\r - uint\r - long\r - ulong\r - short\r - ushort\r \r ## <a name=\"custom-serialization\"></a>自定义序列化\r \r 自定义串行化程序通常用于提高性能，或用于在网络传输时以及在磁盘上加密数据。 除了其他原因外，自定义序列化程序还通常比通用序列化程序更高效，因为它们不需要串行化有关类型的信息。 \r \r [IReliableStateManager.TryAddStateSerializer<T>](https://docs.microsoft.com/dotnet/api/microsoft.servicefabric.data.ireliablestatemanager.tryaddstateserializer--1?Microsoft_ServiceFabric_Data_IReliableStateManager_TryAddStateSerializer__1_Microsoft_ServiceFabric_Data_IStateSerializer___0__) 用于为给定类型 T 注册自定义串行化程序。此注册应在 StatefulServiceBase 构造内发生，以确保在开始恢复前，所有 Reliable Collections 都有权访问相关串行化程序来读取其保留的数据。\r \r ```C#\r public StatefulBackendService(StatefulServiceContext context)\r   : base(context)\r   {\r     if (!this.StateManager.TryAddStateSerializer(new OrderKeySerializer()))\r     {\r       throw new InvalidOperationException(\"Failed to set OrderKey custom serializer\");\r     }\r   }\r ```\r \r > [!NOTE]\r > 自定义串行化程序优先于内置串行化程序。 例如，如果为 int 注册了自定义串行化程序，则会使用它来串行化整数，而不使用 int 的内置串行化程序。\r \r ### <a name=\"how-to-implement-a-custom-serializer\"></a>如何实现自定义串行化程序\r \r 自定义串行化程序需要实现 [IStateSerializer<T>](https://docs.microsoft.com/dotnet/api/microsoft.servicefabric.data.istateserializer-1) 接口。\r \r > [!NOTE]\r > IStateSerializer<T> 包含读取和写入重载，可接受名为基值的附加 T。 此 API 用于差分序列化。 当前未公开差分序列化功能。 因此，在公开和启用差分序列化前，不会调用这两个重载。\r \r 以下是名为 OrderKey 的自定义类型示例，它包含四个属性\r \r ```C#\r public class OrderKey : IComparable<OrderKey>, IEquatable<OrderKey>\r {\r     public byte Warehouse { get; set; }\r \r     public short District { get; set; }\r \r     public int Customer { get; set; }\r \r     public long Order { get; set; }\r \r     #region Object Overrides for GetHashCode, CompareTo and Equals\r     #endregion\r }\r ```\r \r 以下是 IStateSerializer<OrderKey> 的实现示例。\r 请注意，接受 baseValue 的读取和写入重载调用各自的重载来实现向前兼容。\r \r ```C#\r public class OrderKeySerializer : IStateSerializer<OrderKey>\r {\r   OrderKey IStateSerializer<OrderKey>.Read(BinaryReader reader)\r   {\r       var value = new OrderKey();\r       value.Warehouse = reader.ReadByte();\r       value.District = reader.ReadInt16();\r       value.Customer = reader.ReadInt32();\r       value.Order = reader.ReadInt64();\r \r       return value;\r   }\r \r   void IStateSerializer<OrderKey>.Write(OrderKey value, BinaryWriter writer)\r   {\r       writer.Write(value.Warehouse);\r       writer.Write(value.District);\r       writer.Write(value.Customer);\r       writer.Write(value.Order);\r   }\r   \r   // Read overload for differential de-serialization\r   OrderKey IStateSerializer<OrderKey>.Read(OrderKey baseValue, BinaryReader reader)\r   {\r       return ((IStateSerializer<OrderKey>)this).Read(reader);\r   }\r \r   // Write overload for differential serialization\r   void IStateSerializer<OrderKey>.Write(OrderKey baseValue, OrderKey newValue, BinaryWriter writer)\r   {\r       ((IStateSerializer<OrderKey>)this).Write(newValue, writer);\r   }\r }\r ```\r \r ## <a name=\"upgradability\"></a>可升级性\r 在[应用程序滚动升级](service-fabric-application-upgrade.md)过程中，升级应用于部分节点，一次一个升级域。 在此过程中，一些升级域将位于较新版本的应用程序上，而一些升级域将位于较旧版本的应用程序上。 在滚动更新期间，新版本的应用程序必须能够读取旧版本的数据，并且旧版本的应用程序必须能够读取新版本的数据。 如果数据格式不向前和向后兼容，则升级可能会失败（或更糟），甚至可能丢失数据。\r \r 如果使用内置串行化程序，无需担心兼容性问题。\r 但是，如果使用自定义串行化程序或 DataContractSerializer，数据必须能够无限向后和向前兼容。\r 换而言之，串行化程序的每个版本都需要能够序列化和反序列化类型的任何版本。\r \r 数据协定用户应遵循用于添加、删除和更改字段的定义完善的版本控制规则。 数据协定还支持处理未知字段、挂接到序列化和反序列化进程以及处理类继承。 有关详细信息，请参阅[使用数据协定](https://msdn.microsoft.com/library/ms733127.aspx)。\r \r 自定义串行化程序用户应遵循其使用的串行化程序的指导原则，以确保它向前和向后兼容。\r 支持所有版本的常用方法是在开头添加大小信息，并且仅添加可选属性。\r 这样一来，每个版本都可以读取尽可能多的数据并跳过数据流的其余部分。\r \r ## <a name=\"next-steps\"></a>后续步骤\r   * [序列化和升级](service-fabric-application-upgrade-data-serialization.md)\r   * [Reliable Collections 的开发人员参考](https://msdn.microsoft.com/library/azure/microsoft.servicefabric.data.collections.aspx)\r   * [使用 Visual Studio 升级应用程序](service-fabric-application-upgrade-tutorial.md)逐步讲解了如何使用 Visual Studio 进行应用程序升级。\r   * [使用 Powershell 升级应用程序](service-fabric-application-upgrade-tutorial-powershell.md)逐步讲解了如何使用 PowerShell 进行应用程序升级。\r   * 使用[升级参数](service-fabric-application-upgrade-parameters.md)来控制应用程序的升级方式。\r   * 参考[高级主题](service-fabric-application-upgrade-advanced.md)，了解如何在升级应用程序时使用高级功能。\r   * 参考[对应用程序升级进行故障排除](service-fabric-application-upgrade-troubleshooting.md)中的步骤来解决应用程序升级时的常见问题。\r "}