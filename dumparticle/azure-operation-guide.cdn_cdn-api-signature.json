{"Title":"Azure China CDN API doc-signature","Description":"Learn How to create Live Streaming acceleration type CDN on Azure Management Portal and default caching rules for Live Streaming CDN","Content":"\r # CDN API签名机制\r \r > [!div class=\"op_single_selector\"]\r > * [中文](https://docs.azure.cn/zh-cn/cdn/cdn-api-signature)\r > * [英文](https://docs.azure.cn/en-us/cdn/cdn-api-signature)\r \r ## 授权头计算方法\r Azure CDN restful API的每个请求都要进行身份验证，需要在请求中包含身份验证信息，协议为HTTPS。\r \r 身份验证信息以Authorization请求头发送，格式为\"AzureCDN {Key ID}:{HMAC-SHA256 signature using Key Value}\"。\r \r Key ID和Key Value可以到[Azure CDN新版管理门户](./cdn-management-v2-portal-how-to-use.md)的密钥管理处申请和管理。签名参数部分包括：请求绝对路径，用 \", \"连接起来的按字母序从小到大排序的查询参数对，请求的UTC时间(与请求头中的x-azurecdn-request-date一样)，大写的请求方法。以上几部分用回车换行连接后用Key Value进行HMAC-SHA256签名。\r \r \r ## Authorization请求头生成示例\r \r ### Python\r ```\r def calculate_authorization_header(request_url, request_time, key_id, key_value, http_method):\r     \"\"\" Calculate the authorization header.\r     @request_url: Complete request URL with scheme, host, path and queries\r     @request_time: UTC request time with format yyyy-MM-dd hh:mm:ss\r     @key_id: API key ID\r     @key_value: API key value\r     @http_method: Http method in upper case\r \r     \"\"\"\r     urlparts = urllib.parse.urlparse(request_url)\r     queries = urllib.parse.parse_qs(urlparts.query)\r     ordered_queries = OrderedDict(sorted(queries.items()))\r     message = \"%s\\r\\n%s\\r\\n%s\\r\\n%s\" % (urlparts.path, \", \".join(['%s:%s' % (key, value[0]) for (key, value) in ordered_queries.items()]), request_time, http_method)\r     digest = hmac.new(bytearray(key_value, \"utf-8\"), bytearray(message, \"utf-8\"), hashlib.sha256).hexdigest().upper()\r     return \"AzureCDN %s:%s\" % (key_id, digest)\r ```\r \r ### Java\r ```\r /**\r  * Calculate the authorization header\r  *\r  * @param  requestURL Complete request URL with scheme, host, path and queries\r  * @param  requestTime UTC request time with format \"yyyy-MM-dd hh:mm:ss\"\r  * @param  keyID API key ID\r  * @param  keyValue API key value\r  * @param  httpMethod HTTP method in upper case \r  * @return Calculated authorization header\r  */\r public static String calculateAuthorizationHeader(String requestURL, String requestTime, String keyID, String keyValue, String httpMethod) throws Exception {\r               URL url = new URL(requestURL);\r               String path = url.getPath();\r \r               // Get query parameters\r               String query = url.getQuery();      \r               String[] params = query.split(\"&\");\r               Map<String, String> paramMap = new TreeMap<String, String>();\r               for(String param: params) {\r                     String[] paramterParts = param.split(\"=\");\r                     if(paramterParts.length != 2) {\r                           continue;\r                     }\r \r                     paramMap.put(paramterParts[0], paramterParts[1]);\r               }\r \r               String orderedQueries = paramMap.entrySet()\r                                               .stream()\r                                               .map(entry -> entry.getKey() + \":\" + entry.getValue())\r                                               .collect(Collectors.joining(\", \"));\r \r               String content = String.format(\"%s\\r\\n%s\\r\\n%s\\r\\n%s\", path, orderedQueries, requestTime, httpMethod);        \r               Mac sha256HMAC = Mac.getInstance(\"HmacSHA256\");\r               SecretKeySpec secret_key = new SecretKeySpec(keyValue.getBytes(), \"HmacSHA256\");\r               sha256HMAC.init(secret_key);\r               byte[] bytes = sha256HMAC.doFinal(content.getBytes());\r \r               StringBuffer hash = new StringBuffer();\r               for (int i = 0; i < bytes.length; i++) {\r                   String hex = Integer.toHexString(0xFF & bytes[i]);\r                   if (hex.length() == 1) {\r                     hash.append('0');\r                   }\r                   hash.append(hex);\r               }\r \r               return String.format(\"AzureCDN %s:%s\", keyID, hash.toString().toUpperCase());\r }\r ```\r ### Go\r ```\r func calculateAuthorizationHeader(requestURL, requestTime, keyID, keyValue, httpMethod string) string {\r             u, err := url.Parse(requestURL)\r             if err != nil {\r                 panic(err)\r             }\r \r             var path = u.Path\r             m, _ := url.ParseQuery(u.RawQuery)\r \r             var keys []string\r             for k := range m {\r                             keys = append(keys, k)\r             }\r             sort.Strings(keys)\r             var orderedQueries []string\r             for _, k := range keys {\r                             orderedQueries = append(orderedQueries, fmt.Sprintf(\"%s:%s\", k, m[k][0]))\r             }\r \r             var queries = strings.Join(orderedQueries, \", \")\r             content := fmt.Sprintf(\"%s\\r\\n%s\\r\\n%s\\r\\n%s\", path, queries, requestTime, httpMethod)\r             hash := hmac.New(sha256.New, []byte(keyValue))\r             hash.Write([]byte(content))\r             digest := strings.ToUpper(hex.EncodeToString(hash.Sum(nil)))\r             return fmt.Sprintf(\"AzureCDN %s:%s\", keyID, digest)\r  }\r ```\r \r ### C Sharp\r ```\r /// <summary>\r /// Calculate the authorization header.\r /// </summary>\r /// <param name=\"requestUrl\">Complete request URL with scheme, host, path and queries</param>\r /// <param name=\"requestTime\">UTC request time with format yyyy-MM-dd hh:mm:ss.</param>\r /// <param name=\"keyID\">The API key ID.</param>\r /// <param name=\"keyValue\">The API key value.</param>\r /// <param name=\"httpMethod\">Http method in upper case</param>\r /// <returns>Calculated authorization header</returns>\r public static string CalculateAuthorizationHeader(string requestUrl, string requestTime, string keyID, string keyValue, string httpMethod)\r {\r           Uri requestUri = new Uri(requestUrl);\r \r           StringBuilder hashContentBuilder = new StringBuilder();\r           hashContentBuilder.Append(requestUri.AbsolutePath.ToLowerInvariant());\r           hashContentBuilder.Append(\"\\r\\n\");\r \r           var queryStrings = HttpUtility.ParseQueryString(requestUri.Query);\r           var sortedParameterNames = queryStrings.AllKeys.ToList();\r           sortedParameterNames.Sort((q1, q2) => string.Compare(q1, q2));\r           var result = string.Join(\", \", sortedParameterNames.Select(p => string.Format(\"{0}:{1}\", p, queryStrings[p])).ToArray());\r           if (!string.IsNullOrEmpty(result))\r           {\r               hashContentBuilder.Append(result);\r               hashContentBuilder.Append(\"\\r\\n\");\r           }\r \r           hashContentBuilder.Append(requestTime);\r           hashContentBuilder.Append(\"\\r\\n\");\r           hashContentBuilder.Append(httpMethod.ToUpper());\r           string hashContent = hashContentBuilder.ToString();\r \r           using (HMACSHA256 myhmacsha256 = new HMACSHA256(Encoding.UTF8.GetBytes(keyValue)))\r           {\r               byte[] byteArray = Encoding.UTF8.GetBytes(hashContent);\r               byte[] hashedValue = myhmacsha256.ComputeHash(byteArray);\r \r               string sbinary = string.Empty;\r               for (int i = 0; i < hashedValue.Length; i++)\r               {\r                   sbinary += hashedValue[i].ToString(\"X2\");\r               }\r \r               return string.Format(\"AzureCDN {0}:{1}\", keyID, sbinary);\r           }\r }\r ```\r "}