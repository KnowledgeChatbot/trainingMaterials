{"Title":"使用 DMV 监视工作负荷","Description":"了解如何使用 DMV 监视工作负荷。","Content":"# 使用 DMV 监视工作负荷\r <a name=\"monitor-your-workload-using-dmvs\" ></a>\r 本文介绍如何使用动态管理视图 (DMV) 在 Azure SQL 数据仓库中监视工作负荷及调查查询执行情况。\r \r ## 权限\r <a name=\"permissions\" ></a>\r 若要查询本文中的 DMV，需具有 VIEW DATABASE STATE 或 CONTROL 权限。 通常情况下，首选授予 VIEW DATABASE STATE 权限，因为该权限的限制要大得多。\r \r ```sql\r GRANT VIEW DATABASE STATE TO myuser;\r ```\r \r ## 监视连接\r <a name=\"monitor-connections\" ></a>\r 所有登录到 SQL 数据仓库的操作都记录到 [sys.dm_pdw_exec_sessions][sys.dm_pdw_exec_sessions]。  此 DMV 包含最后 10,000 个登录。  session_id 是主键，每次进行新的登录时按顺序分配。\r \r ```sql\r -- Other Active Connections\r SELECT * FROM sys.dm_pdw_exec_sessions where status <> 'Closed' and session_id <> session_id();\r ```\r \r ## 监视查询执行\r <a name=\"monitor-query-execution\" ></a>\r 在 SQL 数据仓库上执行的所有查询都记录到 [sys.dm_pdw_exec_requests][sys.dm_pdw_exec_requests]。  此 DMV 包含最后 10,000 个执行的查询。  request_id 对每个查询进行唯一标识，并且为此 DMV 的主键。  request_id 在每次进行新的查询时按顺序分配，并会加上前缀 QID，代表查询 ID。  针对给定 session_id 查询此 DMV 将显示给定登录的所有查询。\r \r > [!NOTE]\r > 存储过程使用多个请求 ID。  按先后顺序分配请求 ID。 \r > \r > \r \r 以下是调查特定查询的查询执行计划和时间所要遵循的步骤。\r \r ### 步骤 1：确定想要调查的查询\r <a name=\"step-1-identify-the-query-you-wish-to-investigate\" ></a>\r ```sql\r -- Monitor active queries\r SELECT * \r FROM sys.dm_pdw_exec_requests \r WHERE status not in ('Completed','Failed','Cancelled')\r   AND session_id <> session_id()\r ORDER BY submit_time DESC;\r \r -- Find top 10 queries longest running queries\r SELECT TOP 10 * \r FROM sys.dm_pdw_exec_requests \r ORDER BY total_elapsed_time DESC;\r \r -- Find a query with the Label 'My Query'\r -- Use brackets when querying the label column, as it it a key word\r SELECT  *\r FROM    sys.dm_pdw_exec_requests\r WHERE   [label] = 'My Query';\r ```\r \r 从前面的查询结果中，记下想要调查的查询的 **请求 ID** 。\r \r 处于**已暂停**状态的查询是指因并发限制而排队的查询。 这些查询也出现在类型为 UserConcurrencyResourceType 的 sys.dm_pdw_waits 等待查询中。 请参阅 [Concurrency and workload management][Concurrency and workload management] （并发和工作负荷管理），了解并发限制的更多详细信息。 查询也可能因其他原因（如对象锁定）处于等待状态。  如果查询正在等待资源，请参阅本文后面的 [调查等待资源的查询][Investigating queries waiting for resources] 。\r \r 为了简化在 sys.dm_pdw_exec_requests 表中查找查询的过程，请使用 [LABEL][LABEL] 将注释分配给可在 sys.dm_pdw_exec_requests 视图中查找的查询。\r \r ```sql\r -- Query with Label\r SELECT *\r FROM sys.tables\r OPTION (LABEL = 'My Query')\r ;\r ```\r \r ### 步骤 2：调查查询计划\r <a name=\"step-2-investigate-the-query-plan\" ></a>\r 使用请求 ID 从 [sys.dm_pdw_request_steps][sys.dm_pdw_request_steps] 检索查询的分布式 SQL (DSQL) 计划。\r \r ```sql\r -- Find the distributed query plan steps for a specific query.\r -- Replace request_id with value from Step 1.\r \r SELECT * FROM sys.dm_pdw_request_steps\r WHERE request_id = 'QID####'\r ORDER BY step_index;\r ```\r \r 当 DSQL 计划的执行时间超出预期时，原因可能是计划很复杂，包含许多 DSQL 步骤，也可能是一个步骤占用很长的时间。  如果计划有很多步骤，包含多个移动操作，可考虑优化表分布，减少数据移动。 [表分布][Table distribution] 一文说明了为何必须移动数据才能解决查询问题，并说明了如何使用某些分布策略，尽量减少数据移动。\r \r 若要进一步调查单个步骤的详细信息，可检查长时间运行的查询步骤的 *operation_type* 列并记下**步骤索引**：\r \r * 针对以下 **SQL 操作**继续执行步骤 3a：OnOperation、RemoteOperation、ReturnOperation。\r * 针对以下 **数据移动操作**继续执行步骤 3b：ShuffleMoveOperation、BroadcastMoveOperation、TrimMoveOperation、PartitionMoveOperation、MoveOperation、CopyOperation。\r \r ### 步骤 3a：查看分布式数据库上的 SQL\r <a name=\"step-3a-investigate-sql-on-the-distributed-databases\" ></a>\r 使用请求 ID 和步骤索引从 [sys.dm_pdw_sql_requests][sys.dm_pdw_sql_requests] 中检索详细信息，其中包含所有分布式数据库上的查询步骤的执行信息。\r \r ```sql\r -- Find the distribution run times for a SQL step.\r -- Replace request_id and step_index with values from Step 1 and 3.\r \r SELECT * FROM sys.dm_pdw_sql_requests\r WHERE request_id = 'QID####' AND step_index = 2;\r ```\r \r 当查询步骤正在运行时，可以使用 [DBCC PDW_SHOWEXECUTIONPLAN][DBCC PDW_SHOWEXECUTIONPLAN] 从 SQL Server 计划缓存中检索 SQL Server 估计计划，了解在特定分布基础上运行的步骤。\r \r ```sql\r -- Find the SQL Server execution plan for a query running on a specific SQL Data Warehouse Compute or Control node.\r -- Replace distribution_id and spid with values from previous query.\r \r DBCC PDW_SHOWEXECUTIONPLAN(1, 78);\r ```\r \r ### 步骤 3b：查看在分布式数据库上进行的数据移动\r <a name=\"step-3b-investigate-data-movement-on-the-distributed-databases\" ></a>\r 使用请求 ID 和步骤索引检索在 [sys.dm_pdw_dms_workers][sys.dm_pdw_dms_workers] 中的每个分布上运行的数据移动步骤的相关信息。\r \r ```sql\r -- Find the information about all the workers completing a Data Movement Step.\r -- Replace request_id and step_index with values from Step 1 and 3.\r \r SELECT * FROM sys.dm_pdw_dms_workers\r WHERE request_id = 'QID####' AND step_index = 2;\r ```\r \r * 检查 *total_elapsed_time* 列，以查看是否有特定分布在数据移动上比其他分布花费了更多时间。\r * 对于长时间运行的分布，请检查 *rows_processed* 列，以查看从该分布移动的行数是否远远多于其他分布。 如果是这样，这可能表示底层数据的偏斜。\r \r 如果查询正在运行，则可以使用 [DBCC PDW_SHOWEXECUTIONPLAN][DBCC PDW_SHOWEXECUTIONPLAN] 检索特定分发中当前正在运行的 SQL 步骤的 SQL Server 计划高速缓存中的 SQL Server 估计计划。\r \r ```sql\r -- Find the SQL Server estimated plan for a query running on a specific SQL Data Warehouse Compute or Control node.\r -- Replace distribution_id and spid with values from previous query.\r \r DBCC PDW_SHOWEXECUTIONPLAN(55, 238);\r ```\r \r ## <a name=\"waiting\"></a>监视正在等待的查询\r 如果查询未取得进展（因其正在等待资源），下面是显示查询正在等待的所有资源的查询。\r \r ```sql\r -- Find queries \r -- Replace request_id with value from Step 1.\r \r SELECT waits.session_id,\r       waits.request_id,  \r       requests.command,\r       requests.status,\r       requests.start_time,  \r       waits.type,\r       waits.state,\r       waits.object_type,\r       waits.object_name\r FROM   sys.dm_pdw_waits waits\r    JOIN  sys.dm_pdw_exec_requests requests\r    ON waits.request_id=requests.request_id\r WHERE waits.request_id = 'QID####'\r ORDER BY waits.object_name, waits.object_type, waits.state;\r ```\r \r 如果查询正在主动等待另一个查询中的资源，则状态将为 **AcquireResources**。  如果查询具有全部所需资源，则状态将为 **Granted**。\r \r ## 监视 tempdb\r <a name=\"monitor-tempdb\" ></a>\r 较高的 tempdb 利用率可能是性能缓慢和内存不足问题的根本原因。 请先检查是否存在数据倾斜或质量不佳的行组，并采取相应的措施。 如果发现 tempdb 在执行查询的过程中达到其限制，请考虑扩展数据仓库。 下面介绍如何确定每个节点上的每个查询的 tempdb 用量。 \r \r 创建以下视图，以关联 sys.dm_pdw_sql_requests 的相应节点 ID。 这样，便可以利用其他直通 DMV，并将这些表与 sys.dm_pdw_sql_requests 相联接。\r \r ```sql\r -- sys.dm_pdw_sql_requests with the correct node id\r CREATE VIEW sql_requests AS\r (SELECT\r        sr.request_id,\r        sr.step_index,\r        (CASE \r               WHEN (sr.distribution_id = -1 ) THEN \r               (SELECT pdw_node_id FROM sys.dm_pdw_nodes WHERE type = 'CONTROL') \r               ELSE d.pdw_node_id END) AS pdw_node_id,\r        sr.distribution_id,\r        sr.status,\r        sr.error_id,\r        sr.start_time,\r        sr.end_time,\r        sr.total_elapsed_time,\r        sr.row_count,\r        sr.spid,\r        sr.command\r FROM sys.pdw_distributions AS d\r RIGHT JOIN sys.dm_pdw_sql_requests AS sr ON d.distribution_id = sr.distribution_id)\r ```\r 运行以下查询来监视 tempdb：\r \r ```sql\r -- Monitor tempdb\r SELECT\r     sr.request_id,\r     ssu.session_id,\r     ssu.pdw_node_id,\r     sr.command,\r     sr.total_elapsed_time,\r     es.login_name AS 'LoginName',\r     DB_NAME(ssu.database_id) AS 'DatabaseName',\r     (es.memory_usage * 8) AS 'MemoryUsage (in KB)',\r     (ssu.user_objects_alloc_page_count * 8) AS 'Space Allocated For User Objects (in KB)',\r     (ssu.user_objects_dealloc_page_count * 8) AS 'Space Deallocated For User Objects (in KB)',\r     (ssu.internal_objects_alloc_page_count * 8) AS 'Space Allocated For Internal Objects (in KB)',\r     (ssu.internal_objects_dealloc_page_count * 8) AS 'Space Deallocated For Internal Objects (in KB)',\r     CASE es.is_user_process\r     WHEN 1 THEN 'User Session'\r     WHEN 0 THEN 'System Session'\r     END AS 'SessionType',\r     es.row_count AS 'RowCount'\r FROM sys.dm_pdw_nodes_db_session_space_usage AS ssu\r     INNER JOIN sys.dm_pdw_nodes_exec_sessions AS es ON ssu.session_id = es.session_id AND ssu.pdw_node_id = es.pdw_node_id\r     INNER JOIN sys.dm_pdw_nodes_exec_connections AS er ON ssu.session_id = er.session_id AND ssu.pdw_node_id = er.pdw_node_id\r     INNER JOIN sql_requests AS sr ON ssu.session_id = sr.spid AND ssu.pdw_node_id = sr.pdw_node_id\r WHERE DB_NAME(ssu.database_id) = 'tempdb'\r     AND es.session_id <> @@SPID\r     AND es.login_name <> 'sa' \r ORDER BY sr.request_id;\r ```\r ## 监视内存\r <a name=\"monitor-memory\" ></a>\r \r 内存可能是性能缓慢和内存不足问题的根本原因。 请先检查是否存在数据倾斜或质量不佳的行组，并采取相应的措施。 如果发现 SQL Server 内存用量在执行查询的过程中达到其限制，请考虑扩展数据仓库。\r \r 以下查询返回每个节点的 SQL Server 内存用量和内存压力：   \r ```sql\r -- Memory consumption\r SELECT\r   pc1.cntr_value as Curr_Mem_KB, \r   pc1.cntr_value/1024.0 as Curr_Mem_MB,\r   (pc1.cntr_value/1048576.0) as Curr_Mem_GB,\r   pc2.cntr_value as Max_Mem_KB,\r   pc2.cntr_value/1024.0 as Max_Mem_MB,\r   (pc2.cntr_value/1048576.0) as Max_Mem_GB,\r   pc1.cntr_value * 100.0/pc2.cntr_value AS Memory_Utilization_Percentage,\r   pc1.pdw_node_id\r FROM\r -- pc1: current memory\r sys.dm_pdw_nodes_os_performance_counters AS pc1\r -- pc2: total memory allowed for this SQL instance\r JOIN sys.dm_pdw_nodes_os_performance_counters AS pc2 \r ON pc1.object_name = pc2.object_name AND pc1.pdw_node_id = pc2.pdw_node_id\r WHERE\r pc1.counter_name = 'Total Server Memory (KB)'\r AND pc2.counter_name = 'Target Server Memory (KB)'\r ```\r ## 监视事务日志大小\r <a name=\"monitor-transaction-log-size\" ></a>\r 以下查询返回每个分布区的事务日志大小。 请检查是否存在数据倾斜或质量不佳的行组，并采取相应的措施。 如果某个日志文件即将达到 160GB，你应考虑扩展实例或限制事务大小。 \r ```sql\r -- Transaction log size\r SELECT\r   instance_name as distribution_db,\r   cntr_value*1.0/1048576 as log_file_size_used_GB,\r   pdw_node_id \r FROM sys.dm_pdw_nodes_os_performance_counters \r WHERE \r instance_name like 'Distribution_%' \r AND counter_name = 'Log File(s) Used Size (KB)'\r AND counter_name = 'Target Server Memory (KB)'\r ```\r ## 监视事务日志回滚\r <a name=\"monitor-transaction-log-rollback\" ></a>\r 如果查询失败或需要花费很长时间才能继续，则你可以检查并监视是否发生了任何事务回滚。\r ```sql\r -- Monitor rollback\r SELECT \r     SUM(CASE WHEN t.database_transaction_next_undo_lsn IS NOT NULL THEN 1 ELSE 0 END),\r     t.pdw_node_id,\r     nod.[type]\r FROM sys.dm_pdw_nodes_tran_database_transactions t\r JOIN sys.dm_pdw_nodes nod ON t.pdw_node_id = nod.pdw_node_id\r GROUP BY t.pdw_node_id, nod.[type]\r ```\r \r ## 后续步骤\r <a name=\"next-steps\" ></a>\r 请参阅 [系统视图][System views] ，了解 DMV 的详细信息。\r 有关最佳实践的详细信息，请参阅 [SQL 数据仓库最佳实践][SQL Data Warehouse best practices]\r \r <!--Image references-->\r \r <!--Article references-->\r [Manage overview]: ./sql-data-warehouse-overview-manage.md\r [SQL Data Warehouse best practices]: ./sql-data-warehouse-best-practices.md\r [System views]: ./sql-data-warehouse-reference-tsql-system-views.md\r [Table distribution]: ./sql-data-warehouse-tables-distribute.md\r [Concurrency and workload management]: ./sql-data-warehouse-develop-concurrency.md\r [Investigating queries waiting for resources]: ./sql-data-warehouse-manage-monitor.md#waiting\r \r <!--MSDN references-->\r [sys.dm_pdw_dms_workers]: http://msdn.microsoft.com/library/mt203878.aspx\r [sys.dm_pdw_exec_requests]: http://msdn.microsoft.com/library/mt203887.aspx\r [sys.dm_pdw_exec_sessions]: http://msdn.microsoft.com/library/mt203883.aspx\r [sys.dm_pdw_request_steps]: http://msdn.microsoft.com/library/mt203913.aspx\r [sys.dm_pdw_sql_requests]: http://msdn.microsoft.com/library/mt203889.aspx\r [DBCC PDW_SHOWEXECUTIONPLAN]: http://msdn.microsoft.com/library/mt204017.aspx\r [DBCC PDW_SHOWSPACEUSED]: http://msdn.microsoft.com/library/mt204028.aspx\r [LABEL]: https://msdn.microsoft.com/zh-cn/library/ms190322.aspx"}