{"Title":"远程监控解决方案中的设备模拟 - Azure","Description":"本教程介绍如何在远程监控预配置解决方案中使用设备模拟器。","Content":"# <a name=\"test-your-solution-with-simulated-devices\"></a>使用模拟设备测试解决方案\r \r 本教程介绍如何在远程监控预配置解决方案中使用和自定义设备模拟器微服务。 为了演示设备模拟器的功能，本教程在 Contoso IoT 应用程序中使用了两个方案。\r \r 在第一个方案中，Contoso 想要测试新的智能灯泡设备。 为了执行测试，我们创建了具有以下特征的新模拟设备：\r \r *属性*\r \r | 名称                     | 值                      |\r | ------------------------ | --------------------------- |\r | 颜色                    | 白、红、蓝            |\r | 亮度               | 0 到 100                    |\r | 估计剩余生命 | 从 10,000 小时开始倒计数 |\r \r *遥测*\r \r 下表显示了灯泡以数据流形式报告给云的数据：\r \r | 名称   | 值      |\r | ------ | ----------- |\r | 状态 | \"on\"、\"off\" |\r | 联机 | true、false |\r \r > [!NOTE]\r > 对于所有模拟类型来说，**联机**遥测值是必需的。\r \r *方法*\r \r 下表显示了新设备支持的操作：\r \r | 名称        |\r | ----------- |\r | 打开   |\r | 关闭  |\r \r *初始状态*\r \r 下表显示了设备的初始状态：\r \r | 名称                     | 值 |\r | ------------------------ | -------|\r | 初始颜色            | 白色  |\r | 初始亮度       | 75     |\r | 初始剩余生命   | 10,000 |\r | 初始遥测状态 | \"on\"   |\r \r 在第二个方案中，我们将新的遥测类型添加到 Contoso 的现有**冷却器**设备。\r \r 本教程将介绍如何在远程监控预配置解决方案中使用设备模拟器：\r \r 本教程介绍如何执行下列操作：\r \r >[!div class=\"checklist\"]\r > * 创建新设备类型\r > * 模拟自定义设备行为\r > * 将新设备类型添加到仪表板\r > * 从现有的设备类型发送自定义遥测数据\r \r ## <a name=\"prerequisites\"></a>先决条件\r \r 若要遵循本教程，需在 Azure 订阅中部署远程监控解决方案的实例。\r \r 如果尚未部署远程监控解决方案，应完成[部署远程监控预配置解决方案](iot-suite-remote-monitoring-deploy.md)教程。\r \r <!-- Dominic please this use as your reference https://github.com/Azure/device-simulation-dotnet/wiki/Device-Models -->\r \r ## <a name=\"the-device-simulation-service\"></a>设备模拟服务\r \r 使用预配置解决方案中的设备模拟服务可对内置的模拟设备类型进行更改，以及创建新的模拟设备类型。 将物理设备连接到解决方案之前，可以使用自定义设备类型测试远程监控解决方案的行为。\r \r ## <a name=\"create-a-simulated-device-type\"></a>创建模拟设备类型\r \r 在模拟微服务中创建新设备类型的最简单方法是复制并修改现有类型。 以下步骤说明如何复制内置的**冷却器**设备以创建新的**灯泡**设备：\r \r 1. 使用以下命令将**设备模拟** GitHub 存储库克隆到本地计算机：\r \r     ```cmd/sh\r     git clone https://github.com/Azure/device-simulation-dotnet.git\r     ```\r \r 1. 每种设备类型都有一个 JSON 模型文件，并且在 `Services/data/devicemodels` 文件夹中具有关联的脚本。 如下表中所示，复制**冷却器**文件以创建**灯泡**文件：\r \r     | 源                      | 目标                   |\r     | --------------------------- | ----------------------------- |\r     | chiller-01.json             | lightbulb-01.json             |\r     | scripts/chiller-01-state.js | scripts/lightbulb-01-state.js |\r     | scripts/reboot-method.js    | scripts/SwitchOn-method.js    |\r \r ### <a name=\"define-the-characteristics-of-the-new-device-type\"></a>定义新设备类型的特征\r \r `lightbulb-01.json` 文件定义类型的特征，例如，设备生成的遥测数据以及设备支持的方法。 以下步骤更新 `lightbulb-01.json` 文件以定义**灯泡**设备：\r \r 1. 在 `lightbulb-01.json` 文件中，如以下片段中所示更新设备元数据：\r \r     ```json\r     \"SchemaVersion\": \"1.0.0\",\r     \"Id\": \"lightbulb-01\",\r     \"Version\": \"0.0.1\",\r     \"Name\": \"Lightbulb\",\r     \"Description\": \"Smart lightbulb device.\",\r     \"Protocol\": \"MQTT\",\r     ```\r \r 1. 在 `lightbulb-01.json` 文件中，如以下片段中所示更新模拟定义：\r \r     ```json\r     \"Simulation\": {\r       \"InitialState\": {\r         \"online\": true,\r         \"status\": \"on\"\r       },\r       \"Script\": {\r         \"Type\": \"javascript\",\r         \"Path\": \"lightbulb-01-state.js\",\r         \"Interval\": \"00:00:20\"\r       }\r     },\r     ```\r \r 1. 在 `lightbulb-01.json` 文件中，如以下片段中所示更新设备类型属性：\r \r     ```json\r     \"Properties\": {\r       \"Type\": \"Lightbulb\",\r       \"Color\": \"White\",\r       \"Brightness\": 75,\r       \"EstimatedRemainingLife\": 10000\r     },\r     ```\r \r 1. 在 `lightbulb-01.json` 文件中，如以下片段中所示更新设备类型遥测定义：\r \r     ```json\r     \"Telemetry\": [\r       {\r         \"Interval\": \"00:00:20\",\r         \"MessageTemplate\": \"{\\\"status\\\":\\\"${status}\\\"}\",\r         \"MessageSchema\": {\r           \"Name\": \"lightbulb-status;v1\",\r           \"Format\": \"JSON\",\r           \"Fields\": {\r             \"status\": \"text\"\r           }\r         }\r       }\r     ],\r     ```\r \r 1. 在 `lightbulb-01.json` 文件中，如以下片段中所示更新设备类型方法：\r \r     ```json\r     \"CloudToDeviceMethods\": {\r       \"SwitchOn\": {\r         \"Type\": \"javascript\",\r         \"Path\": \"SwitchOn-method.js\"\r       },\r       \"SwitchOff\": {\r         \"Type\": \"javascript\",\r         \"Path\": \"SwitchOff-method.js\"\r       },\r     }\r     ```\r \r 1. 保存 `lightbulb-01.json` 文件。\r \r ### <a name=\"simulate-custom-device-behavior\"></a>模拟自定义设备行为\r \r `scripts/lightbulb-01-state.js` 文件定义 **Lightbulb** 类型的模拟行为。 以下步骤更新 `scripts/lightbulb-01-state.js` 文件，以定义**灯泡**设备的行为：\r \r 1. 在 `scripts/lightbulb-01-state.js` 文件中，如以下片段中所示编辑状态定义：\r \r     ```js\r     // Default state\r     var state = {\r       online: true,\r       status: \"on\"\r     };\r     ```\r \r 1. 将 **vary** 函数替换为以下 **flip** 函数：\r \r     ```js\r     /**\r     * Simple formula that sometimes flips the status of the lightbulb\r     */\r     function flip(value) {\r       if (Math.random() < 0.2) {\r         return (value == \"on\") ? \"off\" : \"on\"\r       }\r       return value;\r     }\r     ```\r \r 1. 如以下片段中所示，编辑 **main** 函数以实现行为：\r \r     ```js\r     function main(context, previousState) {\r \r       // Restore the global state before generating the new telemetry, so that\r       // the telemetry can apply changes using the previous function state.\r       restoreState(previousState);\r \r       // Make this flip every so often\r       state.status = flip(state.status);\r \r       return state;\r     }\r     ```\r \r 1. 保存 `scripts/lightbulb-01-state.js` 文件。\r \r `scripts/SwitchOn-method.js` 文件在**灯泡**设备中实现 **SwitchOn** 方法。 以下步骤更新 `scripts/SwitchOn-method.js` 文件：\r \r 1. 在 `scripts/SwitchOn-method.js` 文件中，如以下片段中所示编辑状态定义：\r \r     ```js\r     var state = {\r        status: \"on\"\r     };\r     ```\r \r 1. 若要打开灯泡，请按如下所示编辑 **main** 函数：\r \r     ```js\r     function main(context, previousState) {\r         log(\"Executing lightbulb Switch On method.\");\r         state.status = \"on\";\r         updateState(state);\r     }\r     ```\r \r 1. 保存 `scripts/SwitchOn-method.js` 文件。\r \r 1. 创建名为 `scripts/SwitchOff-method.js` 的 `scripts/SwitchOn-method.js` 文件副本。\r \r 1. 若要关闭灯泡，请在 `scripts/SwitchOff-method.js` 文件中按如下所示编辑 **main** 函数：\r \r     ```js\r     function main(context, previousState) {\r         log(\"Executing lightbulb Switch Off method.\");\r         state.status = \"off\";\r         updateState(state);\r     }\r     ```\r \r 1. 保存 `scripts/SwitchOff-method.js` 文件。\r \r ### <a name=\"test-the-lightbulb-device-type\"></a>测试灯泡设备类型\r \r 若要测试**灯泡**设备类型，可以首先通过运行**设备模拟**服务的本地副本来测试设备类型的行为是否符合预期。 在本地测试并调试新设备类型后，可以重新生成容器，并将**设备模拟**服务重新部署到 Azure。\r \r 若要在本地测试和调试更改，请参阅[设备模拟概述](https://github.com/Azure/device-simulation-dotnet/blob/master/README.md)。\r \r 配置项目，将新的“灯泡”设备文件复制到输出目录：\r \r * 如果使用 Visual Studio，请确保将上一部分中创建的三个新的灯泡文件复制到解决方案中的“服务”项目。 然后使用**解决方案资源管理器**将其标记为要复制到输出目录。\r \r * 如果使用 Visual Studio Code，请打开 **Services.csproj** 文件并添加在上一部分中创建的三个新的灯泡文件。 请参阅 **Services.csproj** 文件中的现有设备模型文件条目作为示例。\r \r 若要在已部署的解决方案中测试新设备，请参阅以下文档之一：\r \r * [从自定义的 Docker 中心帐户部署容器](https://github.com/Azure/azure-iot-pcs-remote-monitoring-dotnet/wiki/Developer-Reference-Guide#deploying-containers-from-custom-docker-hub-account)\r * [通过手动复制更新已部署的容器](https://github.com/Azure/azure-iot-pcs-remote-monitoring-dotnet/wiki/Developer-Reference-Guide#update-a-deployed-container-via-manual-copy)\r \r 在“设备”页上，可以预配新类型的实例：\r \r ![查看可用模拟的列表](./media/iot-suite-remote-monitoring-test/devicesmodellist.png)\r \r 可以查看来自模拟设备的遥测数据：\r \r ![查看灯泡遥测数据](./media/iot-suite-remote-monitoring-test/devicestelemetry.png)\r \r 可在设备上调用 **SwitchOn** 和 **SwitchOff** 方法：\r \r ![调用灯泡方法](./media/iot-suite-remote-monitoring-test/devicesmethods.png)\r \r 若要使用新设备类型生成可部署到 Azure 的 Docker 映像，请参阅[生成自定义的 Docker 映像](https://github.com/Azure/device-simulation-dotnet/blob/master/README.md#building-a-customized-docker-image)。\r \r ## <a name=\"add-a-new-telemetry-type\"></a>添加新的遥测类型\r \r 本部分介绍如何修改现有模拟设备类型，以支持新的遥测类型。\r \r ### <a name=\"locate-the-chiller-device-type-files\"></a>找到冷却器设备类型文件\r \r 以下步骤说明如何查找用于定义内置**冷却器**设备的文件：\r \r 1. 使用以下命令将**设备模拟** GitHub 存储库克隆到本地计算机（如果尚未这样做）：\r \r     ```cmd/sh\r     git clone https://github.com/Azure/azure-iot-pcs-remote-monitoring-dotnet.git\r     ```\r \r 1. 每种设备类型都有一个 JSON 模型文件，并且在 `data/devicemodels` 文件夹中具有关联的脚本。 定义模拟**冷却器**设备类型的文件为：\r     * `data/devicemodels/chiller-01.json`\r     * `data/devicemodels/scripts/chiller-01-state.js`\r \r ### <a name=\"specify-the-new-telemetry-type\"></a>指定新的遥测类型\r \r 以下步骤说明如何将新的**内部温度**类型添加到**冷却器**设备类型：\r \r 1. 打开 `chiller-01.json` 文件。\r \r 1. 如下所示更新 **SchemaVersion** 值：\r \r     ```json\r     \"SchemaVersion\": \"1.1.0\",\r     ```\r \r 1. 在 **InitialState** 节中添加以下两个定义：\r \r     ```json\r     \"internal_temperature\": 65.0,\r     \"internal_temperature_unit\": \"F\",\r     ```\r \r 1. 在 **Telemetry** 数组中添加以下定义：\r \r     ```json\r     {\r       \"Interval\": \"00:00:05\",\r       \"MessageTemplate\": \"{\\\"internal_temperature\\\":${internal_temperature},\\\"internal_temperature_unit\\\":\\\"${internal_temperature_unit}\\\"}\",\r       \"MessageSchema\": {\r         \"Name\": \"chiller-internal-temperature;v1\",\r         \"Format\": \"JSON\",\r         \"Fields\": {\r           \"temperature\": \"double\",\r           \"temperature_unit\": \"text\"\r         }\r       }\r     },\r     ```\r \r 1. 保存 `chiller-01.json` 文件。\r \r 1. 打开 `scripts/chiller-01-state.js` 文件。\r \r 1. 将以下字段添加到 **state** 变量：\r \r     ```js\r     internal_temperature: 65.0,\r     internal_temperature_unit: \"F\",\r     ```\r \r 1. 将以下行添加到 **main** 函数：\r \r     ```js\r     state.internal_temperature = vary(65, 2, 15, 125);\r     ```\r \r 1. 保存 `scripts/chiller-01-state.js` 文件。\r \r ### <a name=\"test-the-chiller-device-type\"></a>测试冷却器设备类型\r \r 若要测试已更新的**冷却器**设备类型，可以首先通过运行**设备模拟**服务的本地副本来测试设备类型的行为是否符合预期。 在本地测试并调试已更新的设备类型后，可以重新生成容器，并将**设备模拟**服务重新部署到 Azure。\r \r 在本地运行**设备模拟**服务时，该服务会将遥测数据发送到远程监控解决方案。 在“设备”页上，可以预配已更新类型的实例。\r \r 若要在本地测试和调试更改，请参阅[使用 Visual Studio 运行服务](https://github.com/Azure/device-simulation-dotnet/blob/master/README.md#running-the-service-with-visual-studio)或[从命令行生成和运行](https://github.com/Azure/device-simulation-dotnet/blob/master/README.md#build-and-run-from-the-command-line)。\r \r 若要在已部署的解决方案中测试新设备，请参阅以下文档之一：\r \r * [从自定义的 Docker 中心帐户部署容器](https://github.com/Azure/azure-iot-pcs-remote-monitoring-dotnet/wiki/Developer-Reference-Guide#deploying-containers-from-custom-docker-hub-account)\r * [通过手动复制更新已部署的容器](https://github.com/Azure/azure-iot-pcs-remote-monitoring-dotnet/wiki/Developer-Reference-Guide#update-a-deployed-container-via-manual-copy)\r \r 在“设备”页上，可以预配已更新类型的实例：\r \r ![添加已更新的冷却器](./media/iot-suite-remote-monitoring-test/devicesupdatedchiller.png)\r \r 可以查看来自模拟设备的新**内部温度**遥测数据。\r \r 若要使用新设备类型生成可部署到 Azure 的 Docker 映像，请参阅[生成自定义的 Docker 映像](https://github.com/Azure/device-simulation-dotnet/blob/master/README.md#building-a-customized-docker-image)。\r \r ## <a name=\"next-steps\"></a>后续步骤\r \r 本教程已介绍以下操作：\r \r <!-- Repeat task list from intro -->\r >[!div class=\"checklist\"]\r > * 创建新设备类型\r > * 模拟自定义设备行为\r > * 将新设备类型添加到仪表板\r > * 从现有的设备类型发送自定义遥测数据\r \r 了解如何使用设备模拟服务后，我们建议接下来了解如何[将物理设备连接到远程监控解决方案](iot-suite-connecting-devices-node.md)。\r \r 有关可供开发人员参考的远程监控解决方案详细信息，请参阅：\r \r * [开发人员参考指南](https://github.com/Azure/azure-iot-pcs-remote-monitoring-dotnet/wiki/Developer-Reference-Guide)\r * [开发人员故障排除指南](https://github.com/Azure/azure-iot-pcs-remote-monitoring-dotnet/wiki/Developer-Troubleshooting-Guide)\r \r <!-- Next tutorials in the sequence -->"}