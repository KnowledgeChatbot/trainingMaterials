{"Title":"创建适用于 Service Fabric 的 .NET 应用程序","Description":"了解如何使用 ASP.NET Core 前端和 Reliable Services 有状态后端创建一个应用程序，然后将其部署到群集。","Content":"# <a name=\"create-and-deploy-an-application-with-an-aspnet-core-web-api-front-end-service-and-a-stateful-back-end-service\"></a>使用 ASP.NET Core Web API 前端服务和有状态后端服务创建和部署应用程序\r 本教程是一个系列中的第一部分。  其中介绍了如何使用 ASP.NET Core Web API 前端和有状态后端服务创建 Azure Service Fabric 应用程序以存储数据。 完成后，将生成一个投票应用程序，其中包含 ASP.NET Core Web 前端，用于将投票结果保存到群集的有状态后端服务中。 如果不想手动创建投票应用程序，可以[下载已完成应用程序的源代码](https://github.com/Azure-Samples/service-fabric-dotnet-quickstart/)，跳到[大致了解投票示例应用程序](#walkthrough_anchor)。\r \r ![应用程序关系图](./media/service-fabric-tutorial-create-dotnet-app/application-diagram.png)\r \r 在该系列的第一部分中，你将学习如何：\r \r > [!div class=\"checklist\"]\r > * 将 ASP.NET Core Web API 服务作为有状态可靠服务创建\r > * 将 ASP.NET Core Web 应用程序服务作为无状态 Web 服务创建\r > * 使用反向代理与有状态服务通信\r \r 在此系列教程中，你将学习如何：\r > [!div class=\"checklist\"]\r > * 构建 .NET Service Fabric 应用程序\r > * [将应用程序部署到远程群集](service-fabric-tutorial-deploy-app-to-party-cluster.md)\r > * [使用 Visual Studio Team Services 配置 CI/CD](service-fabric-tutorial-deploy-app-with-cicd-vsts.md)\r > * [设置监视和诊断应用程序](service-fabric-tutorial-monitoring-aspnet.md)\r \r ## <a name=\"prerequisites\"></a>先决条件\r 在开始学习本教程之前：\r - 如果还没有 Azure 订阅，请创建一个[试用帐户](https://www.azure.cn/pricing/1rmb-trial/?WT.mc_id=A261C142F)\r - [安装 Visual Studio 2017](https://www.visualstudio.com/)，并安装 **Azure 开发**以及 **ASP.NET 和 Web 开发**工作负荷。\r - [安装 Service Fabric SDK](service-fabric-get-started.md)\r \r ## <a name=\"create-an-aspnet-web-api-service-as-a-reliable-service\"></a>将 ASP.NET Web API 服务作为 Reliable Services 创建\r 首先，使用 ASP.NET Core 创建投票应用程序的 Web 前端。 ASP.NET Core 是轻量跨平台的 Web 开发框架，可用于创建现代 Web UI 和 Web API。 若要全面了解 ASP.NET Core 如何与 Service Fabric 集成，强烈建议你通读 [Service Fabric Reliable Services 中的 ASP.NET Core](service-fabric-reliable-services-communication-aspnetcore.md) 一文。 现在可以按照本教程快速入门。 若要了解有关 ASP.NET Core 的详细信息，请参阅 [ASP.NET Core 文档](https://docs.microsoft.com/aspnet/core/)。\r \r > [!NOTE]\r > 本教程基于[用于 Visual Studio 2017 的 ASP.NET Core 工具](https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/start-mvc)。 用于 Visual Studio 2015 的 .NET Core 工具不再更新。\r \r 1. 以管理员身份启动 Visual Studio。\r \r 2. 通过单击“文件”->“新建”->“项目”创建项目\r \r 3. 在“新建项目”对话框中，选择“云”>“Service Fabric 应用程序”。\r \r 4. 将应用程序命名为“Voting”，然后按“确定”。\r \r    ![Visual Studio 中的新建项目对话框](./media/service-fabric-tutorial-create-dotnet-app/new-project-dialog.png)\r \r 5. 在“新建 Service Fabric 服务”页中，选择“无状态 ASP.NET Core”，然后将服务命名为“VotingWeb”。\r \r    ![在新建服务对话框中选择 ASP.NET Web 服务](./media/service-fabric-tutorial-create-dotnet-app/new-project-dialog-2.png) \r \r 6. 下一页提供一组 ASP.NET Core 项目模板。 本教程中，选择“Web 应用程序(MVC)”。 \r \r    ![选择 ASP.NET 项目类型](./media/service-fabric-tutorial-create-dotnet-app/vs-new-aspnet-project-dialog.png)\r \r    Visual Studio 会创建应用程序和服务项目，并在解决方案资源管理器中显示它们。\r \r    ![使用 ASP.NET Core Web API 服务创建应用程序之后的解决方案资源管理器]( ./media/service-fabric-tutorial-create-dotnet-app/solution-explorer-aspnetcore-service.png)\r \r ### <a name=\"add-angularjs-to-the-votingweb-service\"></a>将 AngularJS 添加到 VotingWeb 服务\r 使用内置的 [Bower 支持](https://docs.microsoft.com/aspnet/core/client-side/bower)将 [AngularJS](http://angularjs.org/) 添加到服务。 打开 bower.json，添加 angular 和 angular-bootstrap 的条目，然后保存所做更改。\r \r ```json\r {\r   \"name\": \"asp.net\",\r   \"private\": true,\r   \"dependencies\": {\r     \"bootstrap\": \"3.3.7\",\r     \"jquery\": \"2.2.0\",\r     \"jquery-validation\": \"1.14.0\",\r     \"jquery-validation-unobtrusive\": \"3.2.6\",\r     \"angular\": \"v1.6.5\",\r     \"angular-bootstrap\": \"v1.1.0\"\r   }\r }\r ```\r 保存 bower.json 文件后，Angular 安装在项目的 wwwroot/lib 文件夹中。 此外，它还会在 Dependencies/Bower 文件夹内列出。\r \r ### <a name=\"update-the-sitejs-file\"></a>更新 site.js 文件\r 打开 wwwroot/js/site.js 文件。  将其内容替换为“主文件夹”视图所用的 JavaScript：\r \r ```javascript\r var app = angular.module('VotingApp', ['ui.bootstrap']);\r app.run(function () { });\r \r app.controller('VotingAppController', ['$rootScope', '$scope', '$http', '$timeout', function ($rootScope, $scope, $http, $timeout) {\r \r     $scope.refresh = function () {\r         $http.get('api/Votes?c=' + new Date().getTime())\r             .then(function (data, status) {\r                 $scope.votes = data;\r             }, function (data, status) {\r                 $scope.votes = undefined;\r             });\r     };\r \r     $scope.remove = function (item) {\r         $http.delete('api/Votes/' + item)\r             .then(function (data, status) {\r                 $scope.refresh();\r             })\r     };\r \r     $scope.add = function (item) {\r         var fd = new FormData();\r         fd.append('item', item);\r         $http.put('api/Votes/' + item, fd, {\r             transformRequest: angular.identity,\r             headers: { 'Content-Type': undefined }\r         })\r             .then(function (data, status) {\r                 $scope.refresh();\r                 $scope.item = undefined;\r             })\r     };\r }]);\r ```\r \r ### <a name=\"update-the-indexcshtml-file\"></a>更新 Index.cshtml 文件\r 打开特定于主文件夹控制器的视图 Views/Home/Index.cshtml 文件。  将其内容替换为以下内容，然后保存所做更改。\r \r ```html\r @{\r     ViewData[\"Title\"] = \"Service Fabric Voting Sample\";\r }\r \r <div ng-controller=\"VotingAppController\" ng-init=\"refresh()\">\r     <div class=\"container-fluid\">\r         <div class=\"row\">\r             <div class=\"col-xs-8 col-xs-offset-2 text-center\">\r                 <h2>Service Fabric Voting Sample</h2>\r             </div>\r         </div>\r \r         <div class=\"row\">\r             <div class=\"col-xs-8 col-xs-offset-2\">\r                 <form class=\"col-xs-12 center-block\">\r                     <div class=\"col-xs-6 form-group\">\r                         <input id=\"txtAdd\" type=\"text\" class=\"form-control\" placeholder=\"Add voting option\" ng-model=\"item\" />\r                     </div>\r                     <button id=\"btnAdd\" class=\"btn btn-default\" ng-click=\"add(item)\">\r                         <span class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"></span>\r                         Add\r                     </button>\r                 </form>\r             </div>\r         </div>\r \r         <hr />\r \r         <div class=\"row\">\r             <div class=\"col-xs-8 col-xs-offset-2\">\r                 <div class=\"row\">\r                     <div class=\"col-xs-4\">\r                         Click to vote\r                     </div>\r                 </div>\r                 <div class=\"row top-buffer\" ng-repeat=\"vote in votes.data\">\r                     <div class=\"col-xs-8\">\r                         <button class=\"btn btn-success text-left btn-block\" ng-click=\"add(vote.key)\">\r                             <span class=\"pull-left\">\r                                 {{vote.key}}\r                             </span>\r                             <span class=\"badge pull-right\">\r                                 {{vote.value}} Votes\r                             </span>\r                         </button>\r                     </div>\r                     <div class=\"col-xs-4\">\r                         <button class=\"btn btn-danger pull-right btn-block\" ng-click=\"remove(vote.key)\">\r                             <span class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></span>\r                             Remove\r                         </button>\r                     </div>\r                 </div>\r             </div>\r         </div>\r     </div>\r </div>\r ```\r \r ### <a name=\"update-the-layoutcshtml-file\"></a>更新 _Layout.cshtml 文件\r 打开 ASP.NET 应用的默认布局 Views/Shared/_Layout.cshtml 文件。  将其内容替换为以下内容，然后保存所做更改。\r \r ```html\r <!DOCTYPE html>\r <html ng-app=\"VotingApp\" xmlns:ng=\"http://angularjs.org\">\r <head>\r     <meta charset=\"utf-8\" />\r     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r     <title>@ViewData[\"Title\"]</title>\r \r     <link href=\"~/lib/bootstrap/dist/css/bootstrap.min.css\" rel=\"stylesheet\" />\r     <link href=\"~/css/site.css\" rel=\"stylesheet\" />\r \r </head>\r <body>\r     <div class=\"container body-content\">\r         @RenderBody()\r     </div>\r \r     <script src=\"~/lib/jquery/dist/jquery.js\"></script>\r     <script src=\"~/lib/bootstrap/dist/js/bootstrap.js\"></script>\r     <script src=\"~/lib/angular/angular.js\"></script>\r     <script src=\"~/lib/angular-bootstrap/ui-bootstrap-tpls.js\"></script>\r     <script src=\"~/js/site.js\"></script>\r \r     @RenderSection(\"Scripts\", required: false)\r </body>\r </html>\r ```\r \r ### <a name=\"update-the-votingwebcs-file\"></a>更新 VotingWeb.cs 文件\r 打开 VotingWeb.cs 文件，该文件会使用 WebListener Web 服务器在无状态服务内创建 ASP.NET Core WebHost。  \r \r 在文件顶部，添加 `using System.Net.Http;` 指令。  \r \r 将 `CreateServiceInstanceListeners()` 函数替换为以下内容，然后保存所做更改。\r \r ```csharp\r protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners()\r {\r     return new ServiceInstanceListener[]\r     {\r         new ServiceInstanceListener(serviceContext =>\r             new WebListenerCommunicationListener(serviceContext, \"ServiceEndpoint\", (url, listener) =>\r             {\r                 ServiceEventSource.Current.ServiceMessage(serviceContext, $\"Starting WebListener on {url}\");\r \r                 return new WebHostBuilder().UseWebListener()\r                             .ConfigureServices(\r                                 services => services\r                                     .AddSingleton<StatelessServiceContext>(serviceContext)\r                                     .AddSingleton<HttpClient>())\r                             .UseContentRoot(Directory.GetCurrentDirectory())\r                             .UseStartup<Startup>()\r                             .UseApplicationInsights()\r                             .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None)\r                             .UseUrls(url)\r                             .Build();\r             }))\r     };\r }\r ```\r \r ### <a name=\"add-the-votescontrollercs-file\"></a>添加 VotesController.cs 文件\r 添加定义投票操作的控制器。 右键单击“控制器”文件夹，然后选择“添加”->“新建项目”->“类”。  将文件命名为“VotesController.cs”，然后单击“添加”。  \r \r 将文件内容替换为以下内容，然后保存所做更改。  之后，在[更新 VotesController.cs 文件](#updatevotecontroller_anchor)中，将修改此文件，以读取和写入来自后端服务的投票数据。  现在，控制器会将静态字符串数据返回到视图中。\r \r ```csharp\r using System;\r using System.Threading.Tasks;\r using Microsoft.AspNetCore.Mvc;\r using System.Collections.Generic;\r using Newtonsoft.Json;\r using System.Text;\r using System.Net.Http;\r using System.Net.Http.Headers;\r \r namespace VotingWeb.Controllers\r {\r     [Produces(\"application/json\")]\r     [Route(\"api/Votes\")]\r     public class VotesController : Controller\r     {\r         private readonly HttpClient httpClient;\r \r         public VotesController(HttpClient httpClient)\r         {\r             this.httpClient = httpClient;\r         }\r \r         // GET: api/Votes\r         [HttpGet]\r         public async Task<IActionResult> Get()\r         {\r             List<KeyValuePair<string, int>> votes= new List<KeyValuePair<string, int>>();\r             votes.Add(new KeyValuePair<string, int>(\"Pizza\", 3));\r             votes.Add(new KeyValuePair<string, int>(\"Ice cream\", 4));\r \r             return Json(votes);\r         }\r      }\r }\r ```\r \r ### <a name=\"configure-the-listening-port\"></a>配置侦听端口\r 创建 VotingWeb 前端服务后，Visual Studio 会随机选择服务侦听的端口。  VotingWeb 服务充当此应用程序的前端并接受外部流量，因此让我们将该服务绑定到已知的固定端口。 在解决方案资源管理器中，打开“VotingWeb/PackageRoot/ServiceManifest.xml”。  在“资源”部分中查找“终结点”资源，并将“端口”值更改为 80 或其他端口。 若要在本地部署和运行应用程序，应用程序侦听端口必须为打开状态且在你的计算机上可用。\r \r ```xml\r <Resources>\r     <Endpoints>\r       <!-- This endpoint is used by the communication listener to obtain the port on which to \r            listen. Please note that if your service is partitioned, this port is shared with \r            replicas of different partitions that are placed in your code. -->\r       <Endpoint Protocol=\"http\" Name=\"ServiceEndpoint\" Type=\"Input\" Port=\"80\" />\r     </Endpoints>\r   </Resources>\r ```\r \r 此外，更新投票项目中的应用程序 URL 属性值，使 Web 浏览器在用户使用“F5”进行调试时打开到正确的端口。  在解决方案资源管理器中，选择“投票”项目并更新“应用程序 URL”属性。\r \r ![应用程序 URL](./media/service-fabric-tutorial-deploy-app-to-party-cluster/application-url.png)\r \r ### <a name=\"deploy-and-run-the-application-locally\"></a>在本地部署并运行应用程序\r 现在，可以继续运行应用程序。 在 Visual Studio 中按 `F5`，部署用于调试的应用程序。 如果此前未以管理员身份打开 Visual Studio，则 `F5` 会失败。\r \r > [!NOTE]\r > 首次在本地运行和部署应用程序时，Visual Studio 会创建用于调试的本地群集。  创建群集可能需要一段时间。 群集创建状态显示在 Visual Studio 输出窗口中。\r \r 此时，Web 应用应如下所示：\r \r ![ASP.NET Core 前端](./media/service-fabric-tutorial-create-dotnet-app/debug-front-end.png)\r \r 若要停止调试应用程序，请返回到 Visual Studio 并按 Shift+F5。\r \r ## <a name=\"add-a-stateful-back-end-service-to-your-application\"></a>向应用程序添加有状态后端服务\r 在应用程序中运行 ASP.NET Web API 服务以后，即可进一步添加有状态 Reliable Services，以便在应用程序中存储一些数据。\r \r Service Fabric 允许使用 Reliable Collections 直接在服务内以一致、可靠的方式存储数据。 Reliable Collections 是一组高度可用的可靠集合类，用过 C# 集合的用户都对它很熟悉。\r \r 在本教程中，将创建一个服务，用于在 Reliable Collections 中存储计数器值。\r \r 1. 在解决方案资源管理器中，右键单击应用程序项目中的“服务”，并选择“添加 > 新建 Service Fabric 服务”。\r \r     ![将一个新服务添加到现有应用程序](./media/service-fabric-tutorial-create-dotnet-app/vs-add-new-service.png)\r \r 2. 在“新建 Service Fabric 服务”对话框中，选择“有状态 ASP.NET Core”，将服务命名为“VotingData”，然后按“确定”。\r \r     ![Visual Studio 中的新建服务对话框](./media/service-fabric-tutorial-create-dotnet-app/add-stateful-service.png)\r \r     创建服务项目后，应用程序中会有两个服务。 随着继续生成应用程序，可采用相同的方式添加更多服务。 每个服务都可以单独进行版本控制和升级。\r \r 3. 下一页提供一组 ASP.NET Core 项目模板。 本教程中，选择“Web API”。\r \r     ![选择 ASP.NET 项目类型](./media/service-fabric-tutorial-create-dotnet-app/vs-new-aspnet-project-dialog2.png)\r \r     Visual Studio 会创建一个服务项目，并在解决方案资源管理器中显示它们。\r \r     ![解决方案资源管理器](./media/service-fabric-tutorial-create-dotnet-app/solution-explorer-aspnetcore-webapi-service.png)\r \r ### <a name=\"add-the-votedatacontrollercs-file\"></a>添加 VoteDataController.cs 文件\r \r 在“VotingData”项目中，右键单击“控制器”文件夹，然后选择“添加”->“新建项目”->“类”。 将文件命名为“VoteDataController.cs”，然后单击“添加”。 将文件内容替换为以下内容，然后保存所做更改。\r \r ```csharp\r using System;\r using System.Collections.Generic;\r using System.Linq;\r using System.Threading.Tasks;\r using Microsoft.AspNetCore.Mvc;\r using Microsoft.ServiceFabric.Data;\r using System.Threading;\r using Microsoft.ServiceFabric.Data.Collections;\r \r namespace VotingData.Controllers\r {\r     [Route(\"api/[controller]\")]\r     public class VoteDataController : Controller\r     {\r         private readonly IReliableStateManager stateManager;\r \r         public VoteDataController(IReliableStateManager stateManager)\r         {\r             this.stateManager = stateManager;\r         }\r \r         // GET api/VoteData\r         [HttpGet]\r         public async Task<IActionResult> Get()\r         {\r             var ct = new CancellationToken();\r \r             var votesDictionary = await this.stateManager.GetOrAddAsync<IReliableDictionary<string, int>>(\"counts\");\r \r             using (ITransaction tx = this.stateManager.CreateTransaction())\r             {\r                 var list = await votesDictionary.CreateEnumerableAsync(tx);\r \r                 var enumerator = list.GetAsyncEnumerator();\r \r                 var result = new List<KeyValuePair<string, int>>();\r \r                 while (await enumerator.MoveNextAsync(ct))\r                 {\r                     result.Add(enumerator.Current);\r                 }\r \r                 return Json(result);\r             }\r         }\r \r         // PUT api/VoteData/name\r         [HttpPut(\"{name}\")]\r         public async Task<IActionResult> Put(string name)\r         {\r             var votesDictionary = await this.stateManager.GetOrAddAsync<IReliableDictionary<string, int>>(\"counts\");\r \r             using (ITransaction tx = this.stateManager.CreateTransaction())\r             {\r                 await votesDictionary.AddOrUpdateAsync(tx, name, 1, (key, oldvalue) => oldvalue + 1);\r                 await tx.CommitAsync();\r             }\r \r             return new OkResult();\r         }\r \r         // DELETE api/VoteData/name\r         [HttpDelete(\"{name}\")]\r         public async Task<IActionResult> Delete(string name)\r         {\r             var votesDictionary = await this.stateManager.GetOrAddAsync<IReliableDictionary<string, int>>(\"counts\");\r \r             using (ITransaction tx = this.stateManager.CreateTransaction())\r             {\r                 if (await votesDictionary.ContainsKeyAsync(tx, name))\r                 {\r                     await votesDictionary.TryRemoveAsync(tx, name);\r                     await tx.CommitAsync();\r                     return new OkResult();\r                 }\r                 else\r                 {\r                     return new NotFoundResult();\r                 }\r             }\r         }\r     }\r }\r ```\r \r ## <a name=\"connect-the-services\"></a>连接服务\r 下一步会连接这两个服务，使前端 Web 应用程序获取并设置来自后端服务的投票信息。\r \r 在如何与 Reliable Services 通信方面，Service Fabric 提供十足的弹性。 在单个应用程序中，可能有能够通过 TCP 访问的服务。 其他服务也许可以通过 HTTP REST API 访问，并且仍可通过 Web 套接字访问。 有关可用选项和相关权衡取舍的背景信息，请参阅[与服务通信](service-fabric-connect-and-communicate-with-services.md)。\r \r 在本教程中，我们将使用 [ASP.NET Core Web API](service-fabric-reliable-services-communication-aspnetcore.md)。\r \r <a id=\"updatevotecontroller\" name=\"updatevotecontroller_anchor\"></a>\r \r ### <a name=\"update-the-votescontrollercs-file\"></a>更新 VotesController.cs 文件\r 在“VotingWeb”项目中，打开 Controllers/VotesController.cs 文件。  将 `VotesController` 类定义内容替换为以下内容，然后保存所做更改。\r \r ```csharp\r     public class VotesController : Controller\r     {\r         private readonly HttpClient httpClient;\r         string serviceProxyUrl = \"http://localhost:19081/Voting/VotingData/api/VoteData\";\r         string partitionKind = \"Int64Range\";\r         string partitionKey = \"0\";\r \r         public VotesController(HttpClient httpClient)\r         {\r             this.httpClient = httpClient;\r         }\r \r         // GET: api/Votes\r         [HttpGet]\r         public async Task<IActionResult> Get()\r         {\r             IEnumerable<KeyValuePair<string, int>> votes;\r \r             HttpResponseMessage response = await this.httpClient.GetAsync($\"{serviceProxyUrl}?PartitionKind={partitionKind}&PartitionKey={partitionKey}\");\r \r             if (response.StatusCode != System.Net.HttpStatusCode.OK)\r             {\r                 return this.StatusCode((int)response.StatusCode);\r             }\r \r             votes = JsonConvert.DeserializeObject<List<KeyValuePair<string, int>>>(await response.Content.ReadAsStringAsync());\r \r             return Json(votes);\r         }\r \r         // PUT: api/Votes/name\r         [HttpPut(\"{name}\")]\r         public async Task<IActionResult> Put(string name)\r         {\r             string payload = $\"{{ 'name' : '{name}' }}\";\r             StringContent putContent = new StringContent(payload, Encoding.UTF8, \"application/json\");\r             putContent.Headers.ContentType = new MediaTypeHeaderValue(\"application/json\");\r \r             string proxyUrl = $\"{serviceProxyUrl}/{name}?PartitionKind={partitionKind}&PartitionKey={partitionKey}\";\r \r             HttpResponseMessage response = await this.httpClient.PutAsync(proxyUrl, putContent);\r \r             return new ContentResult()\r             {\r                 StatusCode = (int)response.StatusCode,\r                 Content = await response.Content.ReadAsStringAsync()\r             };\r         }\r \r         // DELETE: api/Votes/name\r         [HttpDelete(\"{name}\")]\r         public async Task<IActionResult> Delete(string name)\r         {\r             HttpResponseMessage response = await this.httpClient.DeleteAsync($\"{serviceProxyUrl}/{name}?PartitionKind={partitionKind}&PartitionKey={partitionKey}\");\r \r             if (response.StatusCode != System.Net.HttpStatusCode.OK)\r             {\r                 return this.StatusCode((int)response.StatusCode);\r             }\r \r             return new OkResult();\r \r         }\r     }\r ```\r <a id=\"walkthrough\" name=\"walkthrough_anchor\"></a>\r \r ## <a name=\"walk-through-the-voting-sample-application\"></a>大致了解投票示例应用程序\r 投票应用程序由以下两个服务组成：\r - Web 前端服务 (VotingWeb) - ASP.NET Core Web 前端服务，可提供网页服务，并公开用于与后端服务进行通信的 Web API。\r - 后端服务 (VotingData) - ASP.NET Core Web 服务，可公开用于将投票结果存储到磁盘上保留的可靠字典中的 API。\r \r ![应用程序关系图](./media/service-fabric-tutorial-create-dotnet-app/application-diagram.png)\r \r 在应用程序中投票时，将会发生以下事件：\r 1. JavaScript 将投票请求作为 HTTP PUT 请求发送给 Web 前端服务中的 Web API。\r \r 2. Web 前端服务使用代理定位并将 HTTP PUT 请求转发给后端服务。\r \r 3. 后端服务接收传入请求，并将更新后的结果存储在可靠字典中（结果复制到群集内的多个节点，并保留在磁盘上）。 应用程序的所有数据都存储在群集中，因此无需使用数据库。\r \r ## <a name=\"debug-in-visual-studio\"></a>在 Visual Studio 中进行调试\r 在 Visual Studio 中调试应用程序时，使用的是本地 Service Fabric 开发群集。 可以根据需要针对自己的方案调整调试体验。 在此应用程序中，我们使用可靠字典将数据存储到后端服务中。 停止调试程序时，Visual Studio 会默认删除应用程序。 删除应用程序后，后端服务中的数据也会随之一起删除。 若要跨调试会话保留数据，可以将“应用程序调试模式”作为 Visual Studio 中“投票”项目的属性进行更改。\r \r 若要查看代码，请完成以下步骤：\r 1. 打开 VotesController.cs 文件，并在 Web API 的 Put 方法（第 47 行）中设置断点。可以在 Visual Studio 的解决方案资源管理器中搜索此文件。\r \r 2. 打开 VoteDataController.cs 文件，并在此 Web API 的 Put 方法（第 50 行）中设置断点。\r \r 3. 返回到浏览器，再单击投票选项或添加新的投票选项。 点击 Web 前端 API 控制器中的第一个断点。\r \r     1. 此时，浏览器中的 JavaScript 将请求发送到前端服务中的 Web API 控制器。\r \r     ![添加投票前端服务](./media/service-fabric-tutorial-create-dotnet-app/addvote-frontend.png)\r \r     2. 首先，为后端服务的 ReverseProxy 构造 URL **(1)**。\r     3. 然后我们向 ReverseProxy 发送 HTTP PUT 请求 **(2)**。\r     4. 最后，将后端服务的响应返回到客户端 (3)。\r \r 4. 按 F5 以继续操作\r     1. 此时，到达后端服务中的断点。\r \r     ![添加投票后端服务](./media/service-fabric-tutorial-create-dotnet-app/addvote-backend.png)\r \r     2. 在方法的第一行（图中标识为 1）中，我们将使用 `StateManager` 获取或添加 `counts` 可靠字典。\r     3. 与可靠字典中的值进行的所有交互都需要使用事务，这个 using 语句（图中标识为2）负责创建此事务。\r     4. 接下来，我们在事务中更新投票选项的相关键值，并提交操作（图中标识为 (3)）。 提交方法返回后，便会更新字典中的数据，并将数据复制到群集中的其他节点。 数据现在安全地存储在群集中，并且后端服务可以故障转移到其他节点，同时数据仍可用。\r 5. 按 F5 继续操作\r \r 若要停止调试会话，请按 Shift+F5。\r \r ## <a name=\"next-steps\"></a>后续步骤\r 本教程的此部分介绍了如何：\r \r > [!div class=\"checklist\"]\r > * 将 ASP.NET Core Web API 服务作为有状态可靠服务创建\r > * 将 ASP.NET Core Web 应用程序服务作为无状态 Web 服务创建\r > * 使用反向代理与有状态服务通信\r \r 转到下一教程：\r > [!div class=\"nextstepaction\"]\r > [将应用程序部署到 Azure](service-fabric-tutorial-deploy-app-to-party-cluster.md)\r \r <!--Update_Description: update meta properties, add Configure the listening port content-->"}