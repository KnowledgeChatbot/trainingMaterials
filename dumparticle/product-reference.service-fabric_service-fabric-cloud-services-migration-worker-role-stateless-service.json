{"Title":"将 Azure 云服务应用转换为微服务","Description":"本指南将云服务 Web 角色和辅助角色与 Service Fabric 无状态服务进行比较，以帮助你从云服务迁移到 Service Fabric。","Content":"# <a name=\"guide-to-converting-web-and-worker-roles-to-service-fabric-stateless-services\"></a>将 Web 角色和辅助角色转换为 Service Fabric 无状态服务的指南\r 本文说明如何将云服务的 Web 角色和辅助角色迁移到 Service Fabric 无状态服务。 对于整体体系结构大致保持相同的应用程序来说，这是从云服务迁移到 Service Fabric 的最简单路径。\r \r ## <a name=\"cloud-service-project-to-service-fabric-application-project\"></a>云服务项目到 Service Fabric 应用程序项目\r  云服务项目和 Service Fabric 应用程序项目结构类似，两者都可代表应用程序的部署单位，也就是说，两者各自定义可在部署后运行应用程序的完整包。 云服务项目包含一个或多个 Web 角色或辅助角色。 同理，Service Fabric 应用程序项目包含一个或多个服务。 \r \r 两者的差别在于，云服务项目结合应用程序部署与 VM 部署，因此其中包含 VM 配置设置，而 Service Fabric 应用程序项目只定义将要部署到 Service Fabric 群集中一组现有 VM 的应用程序。 Service Fabric 群集本身只可通过资源管理器模板或 Azure 门户部署一次，但可在群集中部署多个 Service Fabric 应用程序。\r \r ![Service Fabric 与云服务项目的比较][3]\r \r ## <a name=\"worker-role-to-stateless-service\"></a>辅助角色到无状态服务\r 从概念上讲，辅助角色代表无状态的工作负荷，这意味着工作负荷的每个实例都是相同的，随时可将请求路由到任何实例。 每个实例不需要记住前一个请求。 工作负荷的运行状态由外部状态存储（例如 Azure 表存储或 Azure Document DB）管理。 在 Service Fabric 中，此类工作负荷以无状态服务表示。 将辅助角色迁移到 Service Fabric 的最简单方法是将辅助角色代码转换为无状态服务。\r \r ![辅助角色到无状态服务][4]\r \r ## <a name=\"web-role-to-stateless-service\"></a>Web 角色到无状态服务\r 与辅助角色类似，Web 角色也代表无状态的工作负荷，因此在概念上也能映射到 Service Fabric 无状态服务。 不过，与 Web 角色不同的是，Service Fabric 不支持 IIS。 要将 Web 应用程序从 Web 角色迁移到无状态服务，需要先移动到可以自托管且不依赖 IIS 或 System.Web 的 Web 框架（例如 ASP.NET Core 1）。\r \r | **应用程序** | **支持** | **迁移路径** |\r | --- | --- | --- |\r | ASP.NET Web 窗体 |否 |转换为 ASP.NET Core 1 MVC |\r | ASP.NET MVC |使用迁移 |升级到 ASP.NET Core 1 MVC |\r | ASP.NET Web API |使用迁移 |使用自托管服务器或 ASP.NET Core 1 |\r | ASP.NET Core 1 |是 |不适用 |\r \r ## <a name=\"entry-point-api-and-lifecycle\"></a>入口点 API 和生命周期\r 辅助角色和 Service Fabric 服务 API 提供类似的入口点： \r \r | **入口点** | **辅助角色** | **Service Fabric 服务** |\r | --- | --- | --- |\r | 正在处理 |`Run()` |`RunAsync()` |\r | VM 启动 |`OnStart()` |不适用 |\r | VM 停止 |`OnStop()` |不适用 |\r | 为客户端请求打开侦听器 |不适用 |<ul><li> 适用于无状态服务的 `CreateServiceInstanceListener()`</li><li>适用于有状态服务的 `CreateServiceReplicaListener()`</li></ul> |\r \r ### <a name=\"worker-role\"></a>辅助角色\r ```C#\r \r using Microsoft.WindowsAzure.ServiceRuntime;\r \r namespace WorkerRole1\r {\r     public class WorkerRole : RoleEntryPoint\r     {\r         public override void Run()\r         {\r         }\r \r         public override bool OnStart()\r         {\r         }\r \r         public override void OnStop()\r         {\r         }\r     }\r }\r \r ```\r \r ### <a name=\"service-fabric-stateless-service\"></a>Service Fabric 无状态服务\r ```C#\r \r using System.Collections.Generic;\r using System.Threading;\r using System.Threading.Tasks;\r using Microsoft.ServiceFabric.Services.Communication.Runtime;\r using Microsoft.ServiceFabric.Services.Runtime;\r \r namespace Stateless1\r {\r     public class Stateless1 : StatelessService\r     {\r         protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners()\r         {\r         }\r \r         protected override Task RunAsync(CancellationToken cancelServiceInstance)\r         {\r         }\r     }\r }\r \r ```\r \r 两者都有可从中开始处理的主要“Run”重写。 Service Fabric 服务将 `Run`、`Start` 和 `Stop` 合并为单一入口点 `RunAsync`。 当 `RunAsync` 启动时，服务应开始工作；发出 `RunAsync` 方法的 CancellationToken 信号时，应停止工作。 \r \r 辅助角色和 Service Fabric 服务的生命周期与生存期之间有几个主要差异：\r \r * **生命周期：** 最大的差异为辅助角色是 VM，因此其生命周期绑定到 VM，且包含 VM 启动和停止时的事件。 Service Fabric 服务的生命周期与 VM 的生命周期不同，因此不包含主机 VM 或计算机启动和停止时的事件，因为它们彼此不相关。\r * 生存期：如果 `Run` 方法退出，辅助角色实例将回收。 但是，Service Fabric 服务中的 `RunAsync` 方法可以运行到完成为止，服务实例将保持运行状态。 \r \r Service Fabric 为侦听客户端请求的服务提供可选的通信设置入口点。 RunAsync 和通信入口点都是 Service Fabric 服务中的可选重写（服务可选择只侦听客户端请求和/或只运行处理循环），这就是 RunAsync 方法无需重新启动服务实例就可退出的原因，因为它可以继续侦听客户端请求。\r \r ## <a name=\"application-api-and-environment\"></a>应用程序 API 和环境\r 云服务环境 API 提供当前 VM 实例的信息和功能，以及有关其他 VM 角色实例的信息。 Service Fabric 提供有关其运行时的信息，以及有关服务当前运行所在的节点的某些信息。 \r \r | **环境任务** | **云服务** | **Service Fabric** |\r | --- | --- | --- |\r | 配置设置和更改通知 |`RoleEnvironment` |`CodePackageActivationContext` |\r | 本地存储 |`RoleEnvironment` |`CodePackageActivationContext` |\r | 终结点信息 |`RoleInstance` <ul><li>当前实例：`RoleEnvironment.CurrentRoleInstance`</li><li>其他角色和实例：`RoleEnvironment.Roles`</li> |<ul><li>适用于当前节点地址的 `NodeContext`</li><li>适用于服务终结点发现的 `FabricClient` 和 `ServicePartitionResolver`</li> |\r | 环境模拟 |`RoleEnvironment.IsEmulated` |不适用 |\r | 同时更改事件 |`RoleEnvironment` |不适用 |\r \r ## <a name=\"configuration-settings\"></a>配置设置\r 云服务中的配置设置是针对 VM 角色设置的，应用到该 VM 角色的所有实例。 这些设置是 ServiceConfiguration.*.cscfg 文件中设置的键-值对，可直接通过 RoleEnvironment 进行访问。 在 Service Fabric 中，设置单独应用到每个服务和每个应用程序，而不是应用到 VM，因为 VM 可以托管多个服务和应用程序。 服务由三个包组成：\r \r * **代码：** 包含服务的可执行文件、二进制文件、DLL 和服务需要运行的任何其他文件。\r * **配置：** 服务的所有配置文件和设置。\r * **数据：** 与服务关联的静态数据文件。\r \r 其中每个包可独立设置版本和进行升级。 与云服务类似，可通过 API 以编程方式访问配置包。发生配置包更改时，系统会提供事件来通知服务。 Settings.xml 文件可用于键-值配置和编程访问，这与 App.config 文件的应用设置部分类似。 但是，与云服务不同的是，Service Fabric 配置包可以包含任何格式的任何配置文件，不管是 XML、JSON、YAML 还是自定义的二进制格式。 \r \r ### <a name=\"accessing-configuration\"></a>访问配置\r #### <a name=\"cloud-services\"></a>云服务\r 可通过 `RoleEnvironment` 访问 ServiceConfiguration.*.cscfg 中的配置设置。 这些设置可全局提供给同一云服务部署中的所有角色实例。\r \r ```C#\r \r string value = RoleEnvironment.GetConfigurationSettingValue(\"Key\");\r \r ```\r \r #### <a name=\"service-fabric\"></a>Service Fabric\r 每个服务都有自己的独立配置包。 可供群集中所有应用程序访问的全局配置设置没有内置机制。 使用配置包中的 Service Fabric 特殊配置文件 Settings.xml 时，Settings.xml 中的值可以在应用程序级别重写，实现应用程序级别的配置设置。\r \r 通过服务的 `CodePackageActivationContext`可在每个服务实例中访问配置设置。\r \r ```C#\r \r ConfigurationPackage configPackage = this.Context.CodePackageActivationContext.GetConfigurationPackageObject(\"Config\");\r \r // Access Settings.xml\r KeyedCollection<string, ConfigurationProperty> parameters = configPackage.Settings.Sections[\"MyConfigSection\"].Parameters;\r \r string value = parameters[\"Key\"]?.Value;\r \r // Access custom configuration file:\r using (StreamReader reader = new StreamReader(Path.Combine(configPackage.Path, \"CustomConfig.json\")))\r {\r     MySettings settings = JsonConvert.DeserializeObject<MySettings>(reader.ReadToEnd());\r }\r \r ```\r \r ### <a name=\"configuration-update-events\"></a>配置更新事件\r #### <a name=\"cloud-services\"></a>云服务\r 当环境中发生更改（例如配置更改）时，使用 `RoleEnvironment.Changed` 事件来通知所有角色实例。 通过此事件可以使用配置更新，无需回收角色实例或重新启动辅助角色进程。\r \r ```C#\r \r RoleEnvironment.Changed += RoleEnvironmentChanged;\r \r private void RoleEnvironmentChanged(object sender, RoleEnvironmentChangedEventArgs e)\r {\r    // Get the list of configuration changes\r    var settingChanges = e.Changes.OfType<RoleEnvironmentConfigurationSettingChange>();\r foreach (var settingChange in settingChanges) \r    {\r       Trace.WriteLine(\"Setting: \" + settingChange.ConfigurationSettingName, \"Information\");\r    }\r }\r \r ```\r \r #### <a name=\"service-fabric\"></a>Service Fabric\r 在服务中的三个包类型（代码、配置和数据）中，每个类型都会提供可在包更新、添加或删除时通知服务实例的事件。 一个服务可以包含每种类型的多个包。 例如，一个服务可以有多个配置包，其中每个包可单独进行版本控制和升级。 \r \r 通过这些事件可以使用服务包中的更改，无需重新启动服务实例。\r \r ```C#\r \r this.Context.CodePackageActivationContext.ConfigurationPackageModifiedEvent +=\r                     this.CodePackageActivationContext_ConfigurationPackageModifiedEvent;\r \r private void CodePackageActivationContext_ConfigurationPackageModifiedEvent(object sender, PackageModifiedEventArgs<ConfigurationPackage> e)\r {\r     this.UpdateCustomConfig(e.NewPackage.Path);\r     this.UpdateSettings(e.NewPackage.Settings);\r }\r \r ```\r \r ## <a name=\"startup-tasks\"></a>启动任务\r 启动任务是应用程序启动前执行的操作。 启动任务通常用于通过提升的特权运行设置脚本。 云服务和 Service Fabric 均支持启动任务。 两者的主要差异在于，云服务中的启动任务绑定到 VM，因为 VM 是角色实例的一部分；而 Service Fabric 中的启动任务绑定到服务，而不绑定到任何特定 VM。\r \r | 云服务 | Service Fabric |\r | --- | --- | --- |\r | 配置位置 |ServiceDefinition.csdef |\r | 特权 |“受限”或“提升” |\r | 序列 |“简单”、“后台”、“前台” |\r \r ### <a name=\"cloud-services\"></a>云服务\r 在云服务中，在 ServiceDefintion.csdef 中针对每个角色配置了启动入口点。 \r \r ```xml\r \r <ServiceDefinition>\r     <Startup>\r         <Task commandLine=\"Startup.cmd\" executionContext=\"limited\" taskType=\"simple\" >\r             <Environment>\r                 <Variable name=\"MyVersionNumber\" value=\"1.0.0.0\" />\r             </Environment>\r         </Task>\r     </Startup>\r     ...\r </ServiceDefinition>\r \r ```\r \r ### <a name=\"service-fabric\"></a>Service Fabric\r Service Fabric 中的启动入口点是在 ServiceManifest.xml 中针对每个服务配置的。\r \r ```xml\r \r <ServiceManifest>\r   <CodePackage Name=\"Code\" Version=\"1.0.0\">\r     <SetupEntryPoint>\r       <ExeHost>\r         <Program>Startup.bat</Program>\r       </ExeHost>\r     </SetupEntryPoint>\r     ...\r </ServiceManifest>\r \r ``` \r \r ## <a name=\"a-note-about-development-environment\"></a>有关开发环境的说明\r 云服务和 Service Fabric 都使用项目模板与 Visual Studio 集成，并支持在本地和 Azure 中调试、配置和部署。 此外，云服务和 Service Fabric 都提供本地开发运行时环境。 区别在于，云服务的开发运行时模拟其运行所在的 Azure 环境，Service Fabric 不使用模拟器，而是使用完整的 Service Fabric 运行时。 在本地开发计算机上运行的 Service Fabric 环境就是在生产时运行的同一环境。\r \r ## <a name=\"next-steps\"></a>后续步骤\r 阅读有关 Service Fabric Reliable Services 的详细信息以及云服务与 Service Fabric 应用程序体系结构之间的基本区别，以了解如何利用 Service Fabric 的完整功能集。\r \r * [Service Fabric Reliable Services 入门](service-fabric-reliable-services-quick-start.md)\r * [云服务与 Service Fabric 之间差异的概念指南](service-fabric-cloud-services-migration-differences.md)\r \r <!--Image references-->\r [3]: ./media/service-fabric-cloud-services-migration-worker-role-stateless-service/service-fabric-cloud-service-projects.png\r [4]: ./media/service-fabric-cloud-services-migration-worker-role-stateless-service/worker-role-to-stateless-service.png\r \r <!--Update_Description: update meta properties-->"}