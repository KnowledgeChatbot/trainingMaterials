{"Title":"在 HDInsight 中运行 Hadoop 示例 - Azure","Description":"使用所提供的示例开始使用 Azure HDInsight 服务。 在数据群集中使用运行 MapReduce 程序的 PowerShell 脚本。","Content":"# <a name=\"run-hadoop-mapreduce-samples-in-windows-based-hdinsight\"></a>在基于 Windows 的 HDInsight 中运行 Hadoop MapReduce 示例\r [!INCLUDE [samples-selector](../../includes/hdinsight-run-samples-selector.md)]\r \r 为帮助你开始使用 Azure HDInsight 在 Hadoop 群集上运行 MapReduce 作业，我们提供了一组示例。 在创建的每一个 HDInsight 托管群集上都可以使用这些示例。 运行这些示例可熟悉如何使用 Azure PowerShell cmdlet 在 Hadoop 群集上运行作业。\r \r * [字数统计][hdinsight-sample-wordcount]：计算单词在文本文件中出现的次数。\r * [C# 流式处理字数统计][hdinsight-sample-csharp-streaming]：使用 Hadoop 流式处理接口计算单词在文本文件中出现的次数。\r * [Pi 估计器][hdinsight-sample-pi-estimator]：使用统计学方法（拟蒙特卡罗法）估算 pi 值。\r * [**10-GB Graysort**][hdinsight-sample-10gb-graysort]：使用 HDInsight 对 10 GB 文件运行常规用途的 GraySort。 有三个作业要运行：Teragen 生成数据，Terasort 对数据排序，而 Teravalidate 确认数据已正确排序。\r \r > [!NOTE]\r > 可以在附录中找到源代码。\r \r Web 上有许多介绍 Hadoop 相关技术（例如基于 Java 的 MapReduce 编程和流式处理）的其他文档，以及有关 Windows PowerShell 脚本中使用的 cmdlet 的文档。 有关这些资源的详细信息，请参阅：\r \r * [为 HDInsight 中的 Hadoop 开发 Java MapReduce 程序](hadoop/apache-hadoop-develop-deploy-java-mapreduce-linux.md)\r * [在 HDInsight 中提交 Hadoop 作业](hadoop/submit-apache-hadoop-jobs-programmatically.md)\r * [Azure HDInsight 简介][hdinsight-introduction]\r \r 现今，许多人选择 Hive 和 Pig，而不是 MapReduce。  有关详细信息，请参阅：\r \r * [在 HDInsight 中使用 Hive](hadoop/hdinsight-use-hive.md)\r * [在 HDInsight 中使用 Pig](hadoop/hdinsight-use-pig.md)\r \r **先决条件**：\r \r * **一个 Azure 订阅**。 请参阅[获取 Azure 试用版](https://www.azure.cn/pricing/1rmb-trial/)。\r * **一个 HDInsight 群集**。 有关可用于创建这类群集的不同方法的说明，请参阅[在 HDInsight 中创建 Hadoop 群集](hdinsight-hadoop-provision-linux-clusters.md)。\r * **配备 Azure PowerShell 的工作站**。\r \r     > [!IMPORTANT]\r     > Azure PowerShell 对于使用 Azure Service Manager 管理 HDInsight 资源的支持已**弃用**，会于 2017 年 1 月 1 日删除。 本文档中的步骤使用的是与 Azure Resource Manager 兼容的新 HDInsight cmdlet。\r     >\r     > 请按照[安装和配置 Azure PowerShell](https://docs.microsoft.com/powershell/azureps-cmdlets-docs) 中的步骤安装最新版本的 Azure PowerShell。 如果脚本需要修改后才能使用与 Azure Resource Manager 兼容的新 cmdlet，请参阅[迁移到基于 Azure Resource Manager 的面向 HDInsight 群集的开发工具](hdinsight-hadoop-development-using-azure-resource-manager.md)。\r \r ## <a name=\"hdinsight-sample-wordcount\"></a>字数统计 - Java\r 若要提交 MapReduce 项目，请先创建 MapReduce 作业定义。 在作业定义中，指定 MapReduce 程序 jar 文件和 jar 文件的位置（即 wasbs:///example/jars/hadoop-mapreduce-examples.jar）、类名和参数。  Wordcount MapReduce 程序采用两个参数：输出位置以及用于计算字数的源文件。\r \r 可以在 [附录 A](#apendix-a---the-word-count-MapReduce-program-in-java)中找到源代码。\r \r 有关开发 Java MapReduce 程序的过程，请参阅[开发适用于 HDInsight 中的 Hadoop 的 Java MapReduce 程序](hadoop/apache-hadoop-develop-deploy-java-mapreduce-linux.md)\r \r **提交字数统计 MapReduce 作业**\r \r 1. 打开 **Windows PowerShell ISE**。 有关说明，请参阅 [安装和配置 Azure PowerShell][powershell-install-configure]。\r 2. 粘贴以下 PowerShell 脚本：\r \r     ```powershell\r     $subscriptionName = \"<Azure Subscription Name>\"\r     $resourceGroupName = \"<Resource Group Name>\"\r     $clusterName = \"<HDInsight cluster name>\"             # HDInsight cluster name\r \r     Select-AzureRmSubscription -SubscriptionName $subscriptionName\r \r     # Define the MapReduce job\r     $mrJobDefinition = New-AzureRmHDInsightMapReduceJobDefinition `\r                                 -JarFile \"wasb:///example/jars/hadoop-mapreduce-examples.jar\" `\r                                 -ClassName \"wordcount\" `\r                                 -Arguments \"wasb:///example/data/gutenberg/davinci.txt\", \"wasb:///example/data/WordCountOutput\"\r \r     # Submit the job and wait for job completion\r     $cred = Get-Credential -Message \"Enter the HDInsight cluster HTTP user credential:\"\r     $mrJob = Start-AzureRmHDInsightJob `\r                         -ResourceGroupName $resourceGroupName `\r                         -ClusterName $clusterName `\r                         -HttpCredential $cred `\r                         -JobDefinition $mrJobDefinition\r \r     Wait-AzureRmHDInsightJob `\r         -ResourceGroupName $resourceGroupName `\r         -ClusterName $clusterName `\r         -HttpCredential $cred `\r         -JobId $mrJob.JobId\r \r     # Get the job output\r     $cluster = Get-AzureRmHDInsightCluster -ResourceGroupName $resourceGroupName -ClusterName $clusterName\r     $defaultStorageAccount = $cluster.DefaultStorageAccount -replace '.blob.core.chinacloudapi.cn'\r     $defaultStorageAccountKey = (Get-AzureRmStorageAccountKey -ResourceGroupName $resourceGroupName -Name $defaultStorageAccount)[0].Value\r     $defaultStorageContainer = $cluster.DefaultStorageContainer\r \r     Get-AzureRmHDInsightJobOutput `\r         -ResourceGroupName $resourceGroupName `\r         -ClusterName $clusterName `\r         -HttpCredential $cred `\r         -DefaultStorageAccountName $defaultStorageAccount `\r         -DefaultStorageAccountKey $defaultStorageAccountKey `\r         -DefaultContainer $defaultStorageContainer  `\r         -JobId $mrJob.JobId `\r         -DisplayOutputType StandardError\r \r     # Download the job output to the workstation\r     $storageContext = New-AzureStorageContext -StorageAccountName $defaultStorageAccount -StorageAccountKey $defaultStorageAccountKey\r     Get-AzureStorageBlobContent -Container $defaultStorageContainer -Blob example/data/WordCountOutput/part-r-00000 -Context $storageContext -Force\r \r     # Display the output file\r     cat ./example/data/WordCountOutput/part-r-00000 | findstr \"there\"\r     ```\r \r     MapReduce 作业将生成一个名为 part-r-00000 的文件，其中包含单词和计数。 该脚本使用 findstr 命令列出包含“there”的所有单词。\r 3. 设置前 3 个变量，并运行脚本。\r \r ## <a name=\"hdinsight-sample-csharp-streaming\"></a>字数统计 - C# 流式处理\r Hadoop 向 MapReduce 提供流式处理 API，利用它，可以采用 Java 以外的语言编写映射函数和化简函数。\r \r > [!NOTE]\r > 本教程中的步骤仅适用于基于 Windows 的 HDInsight 群集。 有关基于 Linux 的 HDInsight 群集流式处理的示例，请参阅[开发适用于 HDInsight 的 Python 流式处理程序](hadoop/apache-hadoop-streaming-python.md)。\r \r 在示例中，映射器和化简器都是可执行的，它们从 [stdin][stdin-stdout-stderr] 读取输入（逐行）并将输出结果发送到 [stdout][stdin-stdout-stderr]。 程序将计算文本中所有单词的数量。\r \r 如果为**映射器**指定可执行文件，则当初始化映射器时，每个映射器任务都将启动此可执行文件作为一个单独的进程。 当映射器任务运行时，它将其输入转换为行，并将这些行馈送到进程的 [stdin][stdin-stdout-stderr]。\r \r 同时，映射器从进程的 stdout 中收集面向行的输出。 将每行转换为一个键/值对（作为映射程序的输出而收集）。 默认情况下，一行的前缀直至第一个制表符是键，而该行的剩余部分（不包括制表符）是值。 如果行中没有制表符，则整行被视为键，而值为 Null。\r \r 如果为 **化简器**指定可执行文件，则当初始化化简器时，每个化简器任务都会将此可执行文件作为一个单独的进程启动。 当化简器任务运行时，它将其输入键/值对转换为行，并将这些行馈送到进程的 [stdin][stdin-stdout-stderr] 。\r \r 同时，化简器从进程的 [stdout][stdin-stdout-stderr] 中收集面向行的输出。 将每行转换为一个键/值对（作为化简器的输出收集）。 默认情况下，一行的前缀直至第一个制表符是键，而该行的剩余部分（不包括制表符）是值。\r \r 提交 C# 流式处理字数统计作业\r \r * 请按照[字数统计 - Java](#word-count-java) 中的步骤操作，并将作业定义替换为以下内容：\r \r     ```powershell\r     $mrJobDefinition = New-AzureRmHDInsightStreamingMapReduceJobDefinition `\r                             -Files \"/example/apps/cat.exe\",\"/example/apps/wc.exe\" `\r                             -Mapper \"cat.exe\" `\r                             -Reducer \"wc.exe\" `\r                             -InputPath \"/example/data/gutenberg/davinci.txt\" `\r                             -OutputPath \"/example/data/StreamingOutput/wc.txt\"\r     ```\r \r     输出文件应该是：\r \r         example/data/StreamingOutput/wc.txt/part-00000\r \r ## <a name=\"hdinsight-sample-pi-estimator\"></a>PI 估计器\r pi 估计器使用统计学方法（拟蒙特卡罗法）估算 pi 值。 单位平方形内部随机放置的点也落入该平方形内嵌的圆圈内，其概率等于圆圈面积 pi/4。 pi 的值可以从 4R 的值估算出来，其中 R 是圆圈内的点数与正方形内的总点数之比。 点数越多，估算值越准确。\r \r 此示例的脚本提交了一个 Hadoop jar 作业，并且设置为使用运行 16 个映射，每个映射通过参数值计算 1 千万个点。 通过更改这些参数值可以提高 pi 的估算值的精度。 例如，pi 采用前 10 位小数时为 3.1415926535。\r \r **提交 pi 估计器作业**\r \r * 请按照[字数统计 - Java](#word-count-java) 中的步骤操作，并将作业定义替换为以下内容：\r \r     ```powershell\r     $mrJobJobDefinition = New-AzureRmHDInsightMapReduceJobDefinition `\r                                 -JarFile \"wasb:///example/jars/hadoop-mapreduce-examples.jar\" `\r                                 -ClassName \"pi\" `\r                                 -Arguments \"16\", \"10000000\"\r     ```\r \r ## <a name=\"hdinsight-sample-10gb-graysort\"></a>10-GB Graysort\r 此示例使用适度的 10GB 数据，这样运行速度相对更快。 它使用由 Owen O'Malley 和 Arun Murthy 开发的 MapReduce 应用程序，此应用程序以 0.578TB/分钟（100TB 用时 173 分钟）的速率赢得了 2009 年年度常用（“daytona”）TB 级排序基准。 有关这一排序基准和其他排序基准的详细信息，请参阅 [Sortbenchmark](http://sortbenchmark.org/) 站点。\r \r 本示例使用三组 MapReduce 程序：\r \r 1. **TeraGen** 是一个 MapReduce 程序，可用于生成要排序的数据行。\r 2. TeraSort 以输入数据为例，使用 MapReduce 将数据排序到总序中。 TeraSort 是 MapReduce 函数的一种标准排序，但自定义的分区程序除外，此分区程序使用 N-1 个抽样键（用于定义每次简化的键范围）的已排序列表。 具体说来，sample[i-1] <= key < sample[i] 的所有键都会发送到化简变量 i。 这样可确保化简变量 i 的输出全都小于化简变量 i+1 的输出。\r 3. **TeraValidate** 是一个 MapReduce 程序，用于验证输出是否已全局排序。 它在输出目录中为每个文件创建一个映射，每个映射都确保每个键均小于或等于前一个键。 映射函数也会生成每个文件的第一个和最后一个键的记录，并且化简函数可确保文件 i 的第一个键大于文件 i-1 的最后一个键。 任何问题都会报告为包含无次序键的化简的输出结果。\r \r 所有三个应用程序使用的输入和输出格式都以正确格式读写文本文件。 化简的输出结果的复制设置为 1，而不是默认值 3，因为基准比赛不要求输出结果数据复制到多个节点上。\r \r 此示例要求三个任务，每个任务对应于简介部分介绍的一个 MapReduce 程序：\r \r 1. 通过运行 **TeraGen** MapReduce 作业生成要排序的数据。\r 2. 通过运行 **TeraSort** MapReduce 作业对数据进行排序。\r 3. 通过运行 **TeraValidate** MapReduce 作业确认数据已正确排序。\r \r **提交作业**\r \r * 按照 [字数统计 - Java](#word-count-java)中的过程操作，并使用以下作业定义：\r \r     ```powershell\r     $teragen = New-AzureRmHDInsightMapReduceJobDefinition `\r                                 -JarFile \"/example/jars/hadoop-mapreduce-examples.jar\" `\r                                 -ClassName \"teragen\" `\r                                 -Arguments \"-Dmapred.map.tasks=50\", \"100000000\", \"/example/data/10GB-sort-input\"\r \r     $terasort = New-AzureRmHDInsightMapReduceJobDefinition `\r                                 -JarFile \"/example/jars/hadoop-mapreduce-examples.jar\" `\r                                 -ClassName \"terasort\" `\r                                 -Arguments \"-Dmapred.map.tasks=50\", \"-Dmapred.reduce.tasks=25\", \"/example/data/10GB-sort-input\", \"/example/data/10GB-sort-output\"\r \r     $teravalidate = New-AzureRmHDInsightMapReduceJobDefinition `\r                                 -JarFile \"/example/jars/hadoop-mapreduce-examples.jar\" `\r                                 -ClassName \"teravalidate\" `\r                                 -Arguments \"-Dmapred.map.tasks=50\", \"-Dmapred.reduce.tasks=25\", \"/example/data/10GB-sort-output\", \"/example/data/10GB-sort-validate\"\r     ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r 从本文和每个示例的相关文章中，了解到如何使用 Azure PowerShell 运行 HDInsight 群集附带的示例。 有关 Pig、Hive 和 MapReduce 如何与 HDInsight 配合使用的教程，请参阅以下主题：\r \r * [将 Hadoop 与 HDInsight 中的 Hive 配合使用以分析手机使用情况][hdinsight-get-started]\r * [将 Pig 与 Hadoop on HDInsight 配合使用][hdinsight-use-pig]\r * [将 Hive 与 Hadoop on HDInsight 配合使用][hdinsight-use-hive]\r * [在 HDInsight 中提交 Hadoop 作业][hdinsight-submit-jobs]\r * [Azure HDInsight SDK 文档][hdinsight-sdk-documentation]\r \r ## <a name=\"appendix-a---the-word-count-source-code\"></a>附录 A - 字数统计源代码\r \r ```java\r package org.apache.hadoop.examples;\r import java.io.IOException;\r import java.util.StringTokenizer;\r import org.apache.hadoop.conf.Configuration;\r import org.apache.hadoop.fs.Path;\r import org.apache.hadoop.io.IntWritable;\r import org.apache.hadoop.io.Text;\r import org.apache.hadoop.mapreduce.Job;\r import org.apache.hadoop.mapreduce.Mapper;\r import org.apache.hadoop.mapreduce.Reducer;\r import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\r import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\r import org.apache.hadoop.util.GenericOptionsParser;\r \r public class WordCount {\r \r     public static class TokenizerMapper\r     extends Mapper<Object, Text, Text, IntWritable>{\r \r private final static IntWritable one = new IntWritable(1);\r private Text word = new Text();\r \r public void map(Object key, Text value, Context context\r                 ) throws IOException, InterruptedException {\r     StringTokenizer itr = new StringTokenizer(value.toString());\r     while (itr.hasMoreTokens()) {\r     word.set(itr.nextToken());\r     context.write(word, one);\r         }\r     }\r     }\r \r     public static class IntSumReducer\r     extends Reducer<Text,IntWritable,Text,IntWritable> {\r private IntWritable result = new IntWritable();\r \r public void reduce(Text key, Iterable<IntWritable> values,\r                     Context context\r                     ) throws IOException, InterruptedException {\r     int sum = 0;\r     for (IntWritable val : values) {\r     sum += val.get();\r     }\r     result.set(sum);\r     context.write(key, result);\r     }\r     }\r \r     public static void main(String[] args) throws Exception {\r Configuration conf = new Configuration();\r String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();\r if (otherArgs.length != 2) {\r     System.err.println(\"Usage: wordcount <in> <out>\");\r     System.exit(2);\r     }\r Job job = new Job(conf, \"word count\");\r job.setJarByClass(WordCount.class);\r job.setMapperClass(TokenizerMapper.class);\r job.setCombinerClass(IntSumReducer.class);\r job.setReducerClass(IntSumReducer.class);\r job.setOutputKeyClass(Text.class);\r job.setOutputValueClass(IntWritable.class);\r FileInputFormat.addInputPath(job, new Path(otherArgs[0]));\r FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));\r System.exit(job.waitForCompletion(true) ? 0 : 1);\r     }\r     }\r ```\r \r ## <a name=\"appendix-b---the-word-count-streaming-source-code\"></a>附录 B - 字数统计流式处理源代码\r MapReduce 程序使用 cat.exe 应用程序作为映射接口将文本流式传输到控制台，并使用 wc.exe 应用程序作为化简接口来统计从文档中流式传输的字数。 映射器和化简器都从标准输入流 (stdin) 逐行读取字符，并写入到标准输出流 (stdout)。\r \r ```csharp\r // The source code for the cat.exe (Mapper).\r \r using System;\r using System.IO;\r \r namespace cat\r {\r     class cat\r     {\r         static void Main(string[] args)\r         {\r             if (args.Length > 0)\r             {\r                 Console.SetIn(new StreamReader(args[0]));\r             }\r \r             string line;\r             char[] separators = { ' ', '\\n'};\r             while ((line = Console.ReadLine()) != null)\r             {\r                 string[] words = line.Split(separators);\r                 foreach (var word in words)\r                 {\r                     Console.WriteLine(\"{0}\\t1\", word);\r                 }\r             }\r         }\r     }\r }\r ```\r \r cat.cs 文件中的映射器代码使用 [StreamReader][streamreader] 对象，将传入流的字符读入到控制台，而控制台使用静态 [Console.Writeline][console-writeline] 方法将流写入标准输出流。\r \r ```csharp\r // The source code for wc.exe (Reducer) is:\r \r using System;\r using System.IO;\r using System.Linq;\r using System.Collections;\r \r namespace wc\r {\r     class wc\r     {\r         static void Main(string[] args)\r         {\r             string line;\r \r             if (args.Length > 0)\r             {\r                 Console.SetIn(new StreamReader(args[0]));\r             }\r \r             Hashtable wordCount = new Hashtable();\r             while ((line = Console.ReadLine()) != null)\r             {\r                 string[] words = line.Split('\\t');\r \r                 string key = words[0];\r \r                 if (wordCount.ContainsKey(key) == true)\r                 {\r                     int n = Convert.ToInt32(wordCount[key]);\r                     wordCount[key] = Convert.ToString(n + 1);\r                 }\r                 else\r                 {\r                     wordCount[key] = words[1];\r                 }\r             }\r             foreach (var key in wordCount.Keys)\r             {\r                 Console.WriteLine(\"{0} {1}\", key, wordCount[key]);\r             }\r         }\r     }\r }\r ```\r \r wc.cs 文件中的化简器代码使用 [StreamReader][streamreader] 对象，从 cat.exe 映射器输出的标准输入流读取字符。 当它使用 [Console.Writeline][console-writeline] 方法读取字符时，可通过统计位于每个单词末尾的空格和行结束字符的数目来计算单词数量。 然后使用 [Console.Writeline][console-writeline] 方法将总数写入标准输出流。\r \r ## <a name=\"appendix-c---the-pi-estimator-source-code\"></a>附录 C - PI 估计器源代码\r 在下面可以检查包含映射器函数和化简器函数的 pi estimator Java 代码。 映射器程序生成在单位平方形内部随机放置的指定点数，并计算位于圆圈内部的这些点的数目。 化简器程序累计由映射器统计的点数，并根据公式 4R 估算 pi 的值，其中 R 是圆圈内统计的点数与方形内总点数的比率。\r \r ```java\r /**\r * Licensed to the Apache Software Foundation (ASF) under one\r * or more contributor license agreements. See the NOTICE file\r * distributed with this work for additional information\r * regarding copyright ownership. The ASF licenses this file\r * to you under the Apache License, Version 2.0 (the\r * \"License\"); you may not use this file except in compliance\r * with the License. You may obtain a copy of the License at\r *\r * http://www.apache.org/licenses/LICENSE-2.0\r *\r * Unless required by applicable law or agreed to in writing, software\r * distributed under the License is distributed on an \"AS IS\" BASIS,\r * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or     implied.\r * See the License for the specific language governing permissions and\r * limitations under the License.\r */\r \r package org.apache.hadoop.examples;\r \r import java.io.IOException;\r import java.math.BigDecimal;\r import java.util.Iterator;\r \r import org.apache.hadoop.conf.Configured;\r import org.apache.hadoop.fs.FileSystem;\r import org.apache.hadoop.fs.Path;\r import org.apache.hadoop.io.BooleanWritable;\r import org.apache.hadoop.io.LongWritable;\r import org.apache.hadoop.io.SequenceFile;\r import org.apache.hadoop.io.Writable;\r import org.apache.hadoop.io.WritableComparable;\r import org.apache.hadoop.io.SequenceFile.CompressionType;\r import org.apache.hadoop.mapred.FileInputFormat;\r import org.apache.hadoop.mapred.FileOutputFormat;\r import org.apache.hadoop.mapred.JobClient;\r import org.apache.hadoop.mapred.JobConf;\r import org.apache.hadoop.mapred.MapReduceBase;\r import org.apache.hadoop.mapred.Mapper;\r import org.apache.hadoop.mapred.OutputCollector;\r import org.apache.hadoop.mapred.Reducer;\r import org.apache.hadoop.mapred.Reporter;\r import org.apache.hadoop.mapred.SequenceFileInputFormat;\r import org.apache.hadoop.mapred.SequenceFileOutputFormat;\r import org.apache.hadoop.util.Tool;\r import org.apache.hadoop.util.ToolRunner;\r \r //A Map-reduce program to estimate the value of Pi\r //using quasi-Monte Carlo method.\r //\r //Mapper:\r //Generate points in a unit square\r //and then count points inside/outside of the inscribed circle of the square.\r //\r //Reducer:\r //Accumulate points inside/outside results from the mappers.\r //Let numTotal = numInside + numOutside.\r //The fraction numInside/numTotal is a rational approximation of\r //the value (Area of the circle)/(Area of the square),\r //where the area of the inscribed circle is Pi/4\r //and the area of unit square is 1.\r //Then, Pi is estimated value to be 4(numInside/numTotal).\r //\r \r public class PiEstimator extends Configured implements Tool {\r //tmp directory for input/output\r static private final Path TMP_DIR = new Path(\r PiEstimator.class.getSimpleName() + \"_TMP_3_141592654\");\r \r //2-dimensional Halton sequence {H(i)},\r //where H(i) is a 2-dimensional point and i >= 1 is the index.\r //Halton sequence is used to generate sample points for Pi estimation.\r private static class HaltonSequence {\r // Bases\r static final int[] P = {2, 3};\r //Maximum number of digits allowed\r static final int[] K = {63, 40};\r \r private long index;\r private double[] x;\r private double[][] q;\r private int[][] d;\r \r //Initialize to H(startindex),\r //so the sequence begins with H(startindex+1).\r HaltonSequence(long startindex) {\r index = startindex;\r x = new double[K.length];\r q = new double[K.length][];\r d = new int[K.length][];\r for(int i = 0; i < K.length; i++) {\r q[i] = new double[K[i]];\r d[i] = new int[K[i]];\r }\r \r for(int i = 0; i < K.length; i++) {\r long k = index;\r x[i] = 0;\r \r for(int j = 0; j < K[i]; j++) {\r q[i][j] = (j == 0? 1.0: q[i][j-1])/P[i];\r d[i][j] = (int)(k % P[i]);\r k = (k - d[i][j])/P[i];\r x[i] += d[i][j] * q[i][j];\r }\r }\r }\r \r //Compute next point.\r //Assume the current point is H(index).\r //Compute H(index+1).\r //@return a 2-dimensional point with coordinates in [0,1)^2\r double[] nextPoint() {\r index++;\r for(int i = 0; i < K.length; i++) {\r for(int j = 0; j < K[i]; j++) {\r d[i][j]++;\r x[i] += q[i][j];\r if (d[i][j] < P[i]) {\r break;\r }\r d[i][j] = 0;\r x[i] -= (j == 0? 1.0: q[i][j-1]);\r }\r }\r return x;\r }\r }\r \r //Mapper class for Pi estimation.\r //Generate points in a unit square and then\r //count points inside/outside of the inscribed circle of the square.\r public static class PiMapper extends MapReduceBase\r implements Mapper<LongWritable, LongWritable, BooleanWritable, LongWritable> {\r \r //Map method.\r //@param offset samples starting from the (offset+1)th sample.\r //@param size the number of samples for this map\r //@param out output {ture->numInside, false->numOutside}\r //@param reporter\r public void map(LongWritable offset,\r LongWritable size,\r OutputCollector<BooleanWritable, LongWritable> out,\r Reporter reporter) throws IOException {\r \r final HaltonSequence haltonsequence = new HaltonSequence(offset.get());\r long numInside = 0L;\r long numOutside = 0L;\r \r for(long i = 0; i < size.get(); ) {\r //generate points in a unit square\r final double[] point = haltonsequence.nextPoint();\r \r //count points inside/outside of the inscribed circle of the square\r final double x = point[0] - 0.5;\r final double y = point[1] - 0.5;\r if (x*x + y*y > 0.25) {\r numOutside++;\r } else {\r numInside++;\r }\r \r //report status\r i++;\r if (i % 1000 == 0) {\r reporter.setStatus(\"Generated \" + i + \" samples.\");\r }\r }\r \r //output map results\r out.collect(new BooleanWritable(true), new LongWritable(numInside));\r out.collect(new BooleanWritable(false), new LongWritable(numOutside));\r }\r }\r \r //Reducer class for Pi estimation.\r //Accumulate points inside/outside results from the mappers.\r public static class PiReducer extends MapReduceBase\r implements Reducer<BooleanWritable, LongWritable, WritableComparable<?>, Writable> {\r \r private long numInside = 0;\r private long numOutside = 0;\r private JobConf conf; //configuration for accessing the file system\r \r //Store job configuration.\r @Override\r public void configure(JobConf job) {\r conf = job;\r }\r \r // Accumulate number of points inside/outside results from the mappers.\r // @param isInside Is the points inside?\r // @param values An iterator to a list of point counts\r // @param output dummy, not used here.\r // @param reporter\r \r public void reduce(BooleanWritable isInside,\r Iterator<LongWritable> values,\r OutputCollector<WritableComparable<?>, Writable> output,\r Reporter reporter) throws IOException {\r if (isInside.get()) {\r for(; values.hasNext(); numInside += values.next().get());\r } else {\r for(; values.hasNext(); numOutside += values.next().get());\r }\r }\r \r //Reduce task done, write output to a file.\r @Override\r public void close() throws IOException {\r //write output to a file\r Path outDir = new Path(TMP_DIR, \"out\");\r Path outFile = new Path(outDir, \"reduce-out\");\r FileSystem fileSys = FileSystem.get(conf);\r SequenceFile.Writer writer = SequenceFile.createWriter(fileSys, conf,\r outFile, LongWritable.class, LongWritable.class,\r CompressionType.NONE);\r writer.append(new LongWritable(numInside), new LongWritable(numOutside));\r writer.close();\r }\r }\r \r //Run a map/reduce job for estimating Pi.\r //@return the estimated value of Pi.\r public static BigDecimal estimate(int numMaps, long numPoints, JobConf jobConf\r )\r throws IOException {\r //setup job conf\r jobConf.setJobName(PiEstimator.class.getSimpleName());\r \r jobConf.setInputFormat(SequenceFileInputFormat.class);\r \r jobConf.setOutputKeyClass(BooleanWritable.class);\r jobConf.setOutputValueClass(LongWritable.class);\r jobConf.setOutputFormat(SequenceFileOutputFormat.class);\r \r jobConf.setMapperClass(PiMapper.class);\r jobConf.setNumMapTasks(numMaps);\r \r jobConf.setReducerClass(PiReducer.class);\r jobConf.setNumReduceTasks(1);\r \r // turn off speculative execution, because DFS doesn't handle\r // multiple writers to the same file.\r jobConf.setSpeculativeExecution(false);\r \r //setup input/output directories\r final Path inDir = new Path(TMP_DIR, \"in\");\r final Path outDir = new Path(TMP_DIR, \"out\");\r FileInputFormat.setInputPaths(jobConf, inDir);\r FileOutputFormat.setOutputPath(jobConf, outDir);\r \r final FileSystem fs = FileSystem.get(jobConf);\r if (fs.exists(TMP_DIR)) {\r throw new IOException(\"Tmp directory \" + fs.makeQualified(TMP_DIR)\r + \" already exists. Remove it first.\");\r }\r if (!fs.mkdirs(inDir)) {\r throw new IOException(\"Cannot create input directory \" + inDir);\r }\r \r //generate an input file for each map task\r try {\r for(int i=0; i < numMaps; ++i) {\r final Path file = new Path(inDir, \"part\"+i);\r final LongWritable offset = new LongWritable(i * numPoints);\r final LongWritable size = new LongWritable(numPoints);\r final SequenceFile.Writer writer = SequenceFile.createWriter(\r fs, jobConf, file,\r LongWritable.class, LongWritable.class, CompressionType.NONE);\r try {\r writer.append(offset, size);\r } finally {\r writer.close();\r }\r System.out.println(\"Wrote input for Map #\"+i);\r }\r \r //start a map/reduce job\r System.out.println(\"Starting Job\");\r final long startTime = System.currentTimeMillis();\r JobClient.runJob(jobConf);\r final double duration = (System.currentTimeMillis() - startTime)/1000.0;\r System.out.println(\"Job Finished in \" + duration + \" seconds\");\r \r //read outputs\r Path inFile = new Path(outDir, \"reduce-out\");\r LongWritable numInside = new LongWritable();\r LongWritable numOutside = new LongWritable();\r SequenceFile.Reader reader = new SequenceFile.Reader(fs, inFile, jobConf);\r try {\r reader.next(numInside, numOutside);\r } finally {\r reader.close();\r }\r \r //compute estimated value\r return BigDecimal.valueOf(4).setScale(20)\r .multiply(BigDecimal.valueOf(numInside.get()))\r .divide(BigDecimal.valueOf(numMaps))\r .divide(BigDecimal.valueOf(numPoints));\r } finally {\r fs.delete(TMP_DIR, true);\r }\r }\r \r //Parse arguments and then runs a map/reduce job.\r //Print output in standard out.\r //@return a non-zero if there is an error. Otherwise, return 0.\r public int run(String[] args) throws Exception {\r if (args.length != 2) {\r System.err.println(\"Usage: \"+getClass().getName()+\" <nMaps> <nSamples>\");\r ToolRunner.printGenericCommandUsage(System.err);\r return -1;\r }\r \r final int nMaps = Integer.parseInt(args[0]);\r final long nSamples = Long.parseLong(args[1]);\r \r System.out.println(\"Number of Maps = \" + nMaps);\r System.out.println(\"Samples per Map = \" + nSamples);\r \r final JobConf jobConf = new JobConf(getConf(), getClass());\r System.out.println(\"Estimated value of Pi is \"\r + estimate(nMaps, nSamples, jobConf));\r return 0;\r }\r \r //main method for running it as a stand alone command.\r public static void main(String[] argv) throws Exception {\r System.exit(ToolRunner.run(null, new PiEstimator(), argv));\r }\r }\r ```\r \r ## <a name=\"appendix-d---the-10gb-graysort-source-code\"></a>附录 D - 10gb graysort 源代码\r 本节提供 TeraSort MapReduce 程序的代码以供检查。\r \r ```java\r /**\r     * Licensed to the Apache Software Foundation (ASF) under one\r     * or more contributor license agreements.  See the NOTICE file\r     * distributed with this work for additional information\r     * regarding copyright ownership.  The ASF licenses this file\r     * to you under the Apache License, Version 2.0 (the\r     * \"License\"); you may not use this file except in compliance\r     * with the License.  You may obtain a copy of the License at\r     *\r     *     http://www.apache.org/licenses/LICENSE-2.0\r     *\r     * Unless required by applicable law or agreed to in writing, software\r     * distributed under the License is distributed on an \"AS IS\" BASIS,\r     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r     * See the License for the specific language governing permissions and\r     * limitations under the License.\r     */\r \r package org.apache.hadoop.examples.terasort;\r \r import java.io.IOException;\r import java.io.PrintStream;\r import java.net.URI;\r import java.util.ArrayList;\r import java.util.List;\r \r import org.apache.commons.logging.Log;\r import org.apache.commons.logging.LogFactory;\r import org.apache.hadoop.conf.Configured;\r import org.apache.hadoop.filecache.DistributedCache;\r import org.apache.hadoop.fs.FileSystem;\r import org.apache.hadoop.fs.Path;\r import org.apache.hadoop.io.NullWritable;\r import org.apache.hadoop.io.SequenceFile;\r import org.apache.hadoop.io.Text;\r import org.apache.hadoop.mapred.FileOutputFormat;\r import org.apache.hadoop.mapred.JobClient;\r import org.apache.hadoop.mapred.JobConf;\r import org.apache.hadoop.mapred.Partitioner;\r import org.apache.hadoop.util.Tool;\r import org.apache.hadoop.util.ToolRunner;\r \r /**\r     * Generates the sampled split points, launches the job,\r     * and waits for it to finish.\r     * <p>\r     * To run the program:\r     * <b>bin/hadoop jar hadoop-examples-*.jar terasort in-dir out-dir</b>\r     */\r \r public class TeraSort extends Configured implements Tool {\r     private static final Log LOG = LogFactory.getLog(TeraSort.class);\r \r     /**\r     * A partitioner that splits text keys into roughly equal\r     * partitions in a global sorted order.\r     */\r \r     static class TotalOrderPartitioner implements Partitioner<Text,Text>{\r     private TrieNode trie;\r     private Text[] splitPoints;\r \r     /**\r         * A generic trie node\r         */\r     static abstract class TrieNode {\r         private int level;\r         TrieNode(int level) {\r         this.level = level;\r         }\r         abstract int findPartition(Text key);\r         abstract void print(PrintStream strm) throws IOException;\r         int getLevel() {\r         return level;\r         }\r     }\r \r     /**\r         * An inner trie node that contains 256 children based on the next\r         * character.\r         */\r     static class InnerTrieNode extends TrieNode {\r         private TrieNode[] child = new TrieNode[256];\r \r         InnerTrieNode(int level) {\r         super(level);\r         }\r         int findPartition(Text key) {\r         int level = getLevel();\r         if (key.getLength() <= level) {\r             return child[0].findPartition(key);\r         }\r         return child[key.getBytes()[level]].findPartition(key);\r         }\r         void setChild(int idx, TrieNode child) {\r         this.child[idx] = child;\r         }\r         void print(PrintStream strm) throws IOException {\r         for(int ch=0; ch < 255; ++ch) {\r             for(int i = 0; i < 2*getLevel(); ++i) {\r             strm.print(' ');\r             }\r             strm.print(ch);\r             strm.println(\" ->\");\r             if (child[ch] != null) {\r             child[ch].print(strm);\r             }\r         }\r         }\r     }\r \r     /**\r         * A leaf trie node that does string compares to figure out where the given\r         * key belongs between lower..upper.\r         */\r     static class LeafTrieNode extends TrieNode {\r         int lower;\r         int upper;\r         Text[] splitPoints;\r         LeafTrieNode(int level, Text[] splitPoints, int lower, int upper) {\r         super(level);\r         this.splitPoints = splitPoints;\r         this.lower = lower;\r         this.upper = upper;\r         }\r         int findPartition(Text key) {\r         for(int i=lower; i<upper; ++i) {\r             if (splitPoints[i].compareTo(key) >= 0) {\r             return i;\r             }\r         }\r         return upper;\r         }\r         void print(PrintStream strm) throws IOException {\r         for(int i = 0; i < 2*getLevel(); ++i) {\r             strm.print(' ');\r         }\r         strm.print(lower);\r         strm.print(\", \");\r         strm.println(upper);\r         }\r     }\r \r     /**\r         * Read the cut points from the given sequence file.\r         * @param fs the file system\r         * @param p the path to read\r         * @param job the job config\r         * @return the strings to split the partitions on\r         * @throws IOException\r         */\r     private static Text[] readPartitions(FileSystem fs, Path p,\r                                             JobConf job) throws IOException {\r         SequenceFile.Reader reader = new SequenceFile.Reader(fs, p, job);\r         List<Text> parts = new ArrayList<Text>();\r         Text key = new Text();\r         NullWritable value = NullWritable.get();\r         while (reader.next(key, value)) {\r         parts.add(key);\r         key = new Text();\r         }\r         reader.close();\r         return parts.toArray(new Text[parts.size()]);\r     }\r \r     /**\r         * Given a sorted set of cut points, build a trie that will find the correct\r         * partition quickly.\r         * @param splits the list of cut points\r         * @param lower the lower bound of partitions 0..numPartitions-1\r         * @param upper the upper bound of partitions 0..numPartitions-1\r         * @param prefix the prefix that we have already checked against\r         * @param maxDepth the maximum depth we will build a trie for\r         * @return the trie node that will divide the splits correctly\r         */\r     private static TrieNode buildTrie(Text[] splits, int lower, int upper,\r                                         Text prefix, int maxDepth) {\r         int depth = prefix.getLength();\r         if (depth >= maxDepth || lower == upper) {\r         return new LeafTrieNode(depth, splits, lower, upper);\r         }\r         InnerTrieNode result = new InnerTrieNode(depth);\r         Text trial = new Text(prefix);\r         // append an extra byte on to the prefix\r         trial.append(new byte[1], 0, 1);\r         int currentBound = lower;\r         for(int ch = 0; ch < 255; ++ch) {\r         trial.getBytes()[depth] = (byte) (ch + 1);\r         lower = currentBound;\r         while (currentBound < upper) {\r             if (splits[currentBound].compareTo(trial) >= 0) {\r             break;\r             }\r             currentBound += 1;\r         }\r         trial.getBytes()[depth] = (byte) ch;\r         result.child[ch] = buildTrie(splits, lower, currentBound, trial,\r                                         maxDepth);\r         }\r         // pick up the rest\r         trial.getBytes()[depth] = 127;\r         result.child[255] = buildTrie(splits, currentBound, upper, trial,\r                                     maxDepth);\r         return result;\r     }\r \r     public void configure(JobConf job) {\r         try {\r         FileSystem fs = FileSystem.getLocal(job);\r         Path partFile = new Path(TeraInputFormat.PARTITION_FILENAME);\r         splitPoints = readPartitions(fs, partFile, job);\r         trie = buildTrie(splitPoints, 0, splitPoints.length, new Text(), 2);\r         } catch (IOException ie) {\r         throw new IllegalArgumentException(\"can't read paritions file\", ie);\r         }\r     }\r \r     public TotalOrderPartitioner() {\r     }\r \r     public int getPartition(Text key, Text value, int numPartitions) {\r         return trie.findPartition(key);\r     }\r \r     }\r \r     public int run(String[] args) throws Exception {\r     LOG.info(\"starting\");\r     JobConf job = (JobConf) getConf();\r     Path inputDir = new Path(args[0]);\r     inputDir = inputDir.makeQualified(inputDir.getFileSystem(job));\r     Path partitionFile = new Path(inputDir, TeraInputFormat.PARTITION_FILENAME);\r     URI partitionUri = new URI(partitionFile.toString() +\r                                 \"#\" + TeraInputFormat.PARTITION_FILENAME);\r     TeraInputFormat.setInputPaths(job, new Path(args[0]));\r     FileOutputFormat.setOutputPath(job, new Path(args[1]));\r     job.setJobName(\"TeraSort\");\r     job.setJarByClass(TeraSort.class);\r     job.setOutputKeyClass(Text.class);\r     job.setOutputValueClass(Text.class);\r     job.setInputFormat(TeraInputFormat.class);\r     job.setOutputFormat(TeraOutputFormat.class);\r     job.setPartitionerClass(TotalOrderPartitioner.class);\r     TeraInputFormat.writePartitionFile(job, partitionFile);\r     DistributedCache.addCacheFile(partitionUri, job);\r     DistributedCache.createSymlink(job);\r     job.setInt(\"dfs.replication\", 1);\r     TeraOutputFormat.setFinalSync(job, true);\r     JobClient.runJob(job);\r     LOG.info(\"done\");\r     return 0;\r     }\r \r     /**\r     * @param args\r     */\r \r     public static void main(String[] args) throws Exception {\r     int res = ToolRunner.run(new JobConf(), new TeraSort(), args);\r     System.exit(res);\r     }\r }\r ```\r \r [hdinsight-sdk-documentation]: https://msdn.microsoft.com/library/azure/dn479185.aspx\r \r [hdinsight-submit-jobs]: hadoop/submit-apache-hadoop-jobs-programmatically.md\r [hdinsight-introduction]:hadoop/apache-hadoop-introduction.md\r \r [powershell-install-configure]: https://docs.microsoft.com/powershell/azureps-cmdlets-docs\r \r [hdinsight-get-started]:hadoop/apache-hadoop-linux-tutorial-get-started.md\r \r [hdinsight-samples]: hdinsight-run-samples.md\r [hdinsight-sample-10gb-graysort]: #hdinsight-sample-10gb-graysort\r [hdinsight-sample-csharp-streaming]: #hdinsight-sample-csharp-streaming\r [hdinsight-sample-pi-estimator]: #hdinsight-sample-pi-estimator\r [hdinsight-sample-wordcount]: #hdinsight-sample-wordcount\r \r [hdinsight-use-hive]: hadoop/hdinsight-use-hive.md\r [hdinsight-use-pig]: hadoop/hdinsight-use-pig.md\r \r [streamreader]: http://msdn.microsoft.com/library/system.io.streamreader.aspx\r [console-writeline]: http://msdn.microsoft.com/library/system.console.writeline\r [stdin-stdout-stderr]: https://msdn.microsoft.com/library/3x292kth.aspx\r \r \r <!--Update_Description: update wording and link references-->"}