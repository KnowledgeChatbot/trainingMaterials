{"Title":"如何通过 Java 使用 Azure 服务总线主题","Description":"在 Azure 中使用服务总线主题和订阅。","Content":"# <a name=\"how-to-use-service-bus-topics-and-subscriptions-with-java\"></a>如何通过 Java 使用服务总线主题和订阅\r \r [!INCLUDE [service-bus-selector-topics](../../includes/service-bus-selector-topics.md)]\r \r 本指南介绍如何使用服务总线主题和订阅。 这些示例采用 Java 编写，并且使用了 [Azure SDK for Java][Azure SDK for Java]。 涉及的应用场景包括**创建主题和订阅**、**创建订阅筛选器**、**将消息发送到主题**、**从订阅接收消息**以及**删除主题和订阅**。\r \r ## <a name=\"what-are-service-bus-topics-and-subscriptions\"></a>什么是服务总线主题和订阅？\r 服务总线主题和订阅支持 *发布/订阅* 消息通信模型。 在使用主题和订阅时，分布式应用程序的组件不会直接相互通信，而是通过充当中介的主题交换消息。\r \r ![TopicConcepts](./media/service-bus-java-how-to-use-topics-subscriptions/sb-topics-01.png)\r \r 与每条消息由单个使用方处理的 Service Bus 队列相比，主题和订阅通过发布/订阅模式提供“一对多”通信方式。 可向一个主题注册多个订阅。 当消息发送到主题时，每个订阅会分别对该消息进行处理。\r \r 主题订阅类似于接收发送至该主题的消息副本的虚拟队列。 可以选择基于每个订阅注册主题的筛选规则，这样就可以筛选/限制哪些主题订阅接收发送至某个主题的哪些消息。\r \r 利用服务总线主题和订阅，可以进行扩展以处理跨大量用户和应用程序的许多消息。\r \r ## <a name=\"create-a-service-namespace\"></a>创建服务命名空间\r 若要开始在 Azure 中使用服务总线主题和订阅，必须先创建一个命名空间，该命名空间提供一个范围容器，用于对应用程序中的服务总线资源进行寻址。\r \r 创建命名空间：\r \r [!INCLUDE [service-bus-create-namespace-portal](../../includes/service-bus-create-namespace-portal.md)]\r \r ## <a name=\"configure-your-application-to-use-service-bus\"></a>配置应用程序以使用 Service Bus\r 在生成本示例之前，请确保已安装 [Azure SDK for Java][Azure SDK for Java]。 如果使用 Eclipse，则可以安装包含 Azure SDK for Java 的[用于 Eclipse 的 Azure 工具包][Azure Toolkit for Eclipse]。 然后，用户可以将 **Microsoft Azure Libraries for Java** 添加到项目：\r \r ![](./media/service-bus-java-how-to-use-topics-subscriptions/eclipselibs.png)\r \r 将以下 `import` 语句添加到 Java 文件顶部：\r \r ```java\r import com.microsoft.windowsazure.services.servicebus.*;\r import com.microsoft.windowsazure.services.servicebus.models.*;\r import com.microsoft.windowsazure.core.*;\r import javax.xml.datatype.*;\r ```\r \r 向生成路径添加 Azure Libraries for Java，并将其包含在项目部署程序集中。\r \r ## <a name=\"create-a-topic\"></a>创建主题\r 服务总线主题的管理操作可通过 **ServiceBusContract** 类执行。 **ServiceBusContract** 对象是使用封装了 SAS 令牌及用于管理其权限的适当配置构造的，而 **ServiceBusContract** 类是与 Azure 进行通信的单一点。\r \r **ServiceBusService** 类提供了创建、枚举和删除主题的方法。 以下示例演示了如何通过名为 `HowToSample` 的命名空间，使用 **ServiceBusService** 对象创建名为 `TestTopic` 的主题：\r \r ```java\r Configuration config =\r     ServiceBusConfiguration.configureWithSASAuthentication(\r       \"HowToSample\",\r       \"RootManageSharedAccessKey\",\r       \"SAS_key_value\",\r       \".servicebus.chinacloudapi.cn\"\r       );\r \r ServiceBusContract service = ServiceBusService.create(config);\r TopicInfo topicInfo = new TopicInfo(\"TestTopic\");\r try  \r {\r     CreateTopicResult result = service.createTopic(topicInfo);\r }\r catch (ServiceException e) {\r     System.out.print(\"ServiceException encountered: \");\r     System.out.println(e.getMessage());\r     System.exit(-1);\r }\r ```\r \r **TopicInfo** 上有一些方法可设置主题的属性（例如，将默认的生存时间 (TTL) 值设置为应用于发送到主题的消息）。 以下示例演示了如何创建最大空间为 5 GB 且名为 `TestTopic` 的主题：\r \r ```java\r long maxSizeInMegabytes = 5120;  \r TopicInfo topicInfo = new TopicInfo(\"TestTopic\");  \r topicInfo.setMaxSizeInMegabytes(maxSizeInMegabytes);\r CreateTopicResult result = service.createTopic(topicInfo);\r ```\r \r 可以对 **ServiceBusContract** 对象使用 **listTopics** 方法来检查具有指定名称的主题在某个服务命名空间中是否已存在。\r \r ## <a name=\"create-subscriptions\"></a>创建订阅\r \r 主题订阅也是使用 **ServiceBusService** 类创建的。 订阅已命名，并且具有一个限制传递到订阅的虚拟队列的消息集的可选筛选器。\r \r ### <a name=\"create-a-subscription-with-the-default-matchall-filter\"></a>创建具有默认 (MatchAll) 筛选器的订阅\r 如果创建新订阅时未指定筛选器，则 **MatchAll** 筛选器是所使用的默认筛选器。 使用 **MatchAll** 筛选器时，发布到主题的所有消息都会置于订阅的虚拟队列中。 以下示例创建名为“AllMessages”的订阅，并使用默认的 **MatchAll** 筛选器。\r \r ```java\r SubscriptionInfo subInfo = new SubscriptionInfo(\"AllMessages\");\r CreateSubscriptionResult result =\r     service.createSubscription(\"TestTopic\", subInfo);\r ```\r \r ### <a name=\"create-subscriptions-with-filters\"></a>创建具有筛选器的订阅\r \r 还可以创建筛选器，以确定发送到主题的哪些消息应该在特定主题订阅中显示。\r \r 订阅支持的最灵活的筛选器类型是 [SqlFilter][SqlFilter]，它实现了一部分 SQL92 功能。 SQL 筛选器对发布到主题的消息的属性进行操作。 有关可用于 SQL 筛选器的表达式的更多详细信息，请参阅 [SqlFilter.SqlExpression][SqlFilter.SqlExpression] 语法。\r \r 以下示例创建了一个名为 `HighMessages` 的订阅，其包含的 [SqlFilter][SqlFilter] 对象只选择自定义 **MessageNumber** 属性大于 3 的消息：\r \r ```java\r // Create a \"HighMessages\" filtered subscription  \r SubscriptionInfo subInfo = new SubscriptionInfo(\"HighMessages\");\r CreateSubscriptionResult result = service.createSubscription(\"TestTopic\", subInfo);\r RuleInfo ruleInfo = new RuleInfo(\"myRuleGT3\");\r ruleInfo = ruleInfo.withSqlExpressionFilter(\"MessageNumber > 3\");\r CreateRuleResult ruleResult = service.createRule(\"TestTopic\", \"HighMessages\", ruleInfo);\r // Delete the default rule, otherwise the new rule won't be invoked.\r service.deleteRule(\"TestTopic\", \"HighMessages\", \"$Default\");\r ```\r \r 类似地，以下示例创建一个名为 `LowMessages` 的订阅，其包含的 [SqlFilter][SqlFilter] 对象只选择 **MessageNumber** 属性小于或等于 3 的消息：\r \r ```java\r // Create a \"LowMessages\" filtered subscription\r SubscriptionInfo subInfo = new SubscriptionInfo(\"LowMessages\");\r CreateSubscriptionResult result = service.createSubscription(\"TestTopic\", subInfo);\r RuleInfo ruleInfo = new RuleInfo(\"myRuleLE3\");\r ruleInfo = ruleInfo.withSqlExpressionFilter(\"MessageNumber <= 3\");\r CreateRuleResult ruleResult = service.createRule(\"TestTopic\", \"LowMessages\", ruleInfo);\r // Delete the default rule, otherwise the new rule won't be invoked.\r service.deleteRule(\"TestTopic\", \"LowMessages\", \"$Default\");\r ```\r \r 现在，当消息发送到 `TestTopic` 时，它始终会传送给订阅了 `AllMessages` 订阅的接收者，并且选择性地传送给订阅了 `HighMessages` 和 `LowMessages` 订阅的接收者（具体取决于消息内容）。\r \r ## <a name=\"send-messages-to-a-topic\"></a>将消息发送到主题\r 将消息发送到服务总线主题，应用程序获得 **ServiceBusContract** 对象。 以下代码演示了如何将消息发送到之前在 `HowToSample` 命名空间内创建的 `TestTopic` 主题：\r \r ```java\r BrokeredMessage message = new BrokeredMessage(\"MyMessage\");\r service.sendTopicMessage(\"TestTopic\", message);\r ```\r \r 发送到服务总线主题的消息是 [BrokeredMessage][BrokeredMessage] 类的实例。 [BrokeredMessage][BrokeredMessage]* 对象包含一组标准方法（如 **setLabel** 和 **TimeToLive**）、一个用来保存特定于应用程序的自定义属性的字典，以及大量的任意应用程序数据。 应用程序可通过将任何可序列化对象传入到 [BrokeredMessage][BrokeredMessage] 的构造函数中来设置消息的正文，系统将使用适当的 **DataContractSerializer** 对对象进行序列化操作。 或者，也可以提供 **java.io.InputStream**。\r \r 以下示例演示了如何将五条测试消息发送到在前面的代码片段中获取的 `TestTopic` **MessageSender**。\r 请注意每条消息的 **MessageNumber** 属性值如何随循环迭代而变化（此值确定接收消息的订阅）：\r \r ```java\r for (int i=0; i<5; i++)  {\r // Create message, passing a string message for the body\r BrokeredMessage message = new BrokeredMessage(\"Test message \" + i);\r // Set some additional custom app-specific property\r message.setProperty(\"MessageNumber\", i);\r // Send message to the topic\r service.sendTopicMessage(\"TestTopic\", message);\r }\r ```\r \r 服务总线主题在标准层中支持的最大消息大小为 256 KB。 标头最大为 64 KB，其中包括标准和自定义应用程序属性。 一个主题中包含的消息数量不受限制，但消息的总大小受限制。 此主题大小是在创建时定义的，上限为 5 GB。\r \r ## <a name=\"how-to-receive-messages-from-a-subscription\"></a>如何从订阅接收消息\r 若要从订阅接收消息，请使用 **ServiceBusContract** 对象。 收到的消息可在两种不同模式下工作：**ReceiveAndDelete** 和 **PeekLock**（默认模式）。\r \r 当使用 **ReceiveAndDelete** 模式时，接收是一个单次操作。即，当服务总线收到对消息的读取请求时，它会将该消息标记为“已使用”并将其返回给应用程序。 **ReceiveAndDelete** 模式是最简单的模式，最适合应用程序允许在出现故障时不处理消息的方案。 例如，可以考虑这样一种情形：使用者发出接收请求，但在处理该请求前发生了故障。 由于服务总线已将消息标记为“已使用”，因此当应用程序重新启动并重新开始使用消息时，它会漏掉在发生崩溃前使用的消息。\r \r 在 **PeekLock** 模式下，接收变成了一个两阶段操作，从而有可能支持无法允许遗漏消息的应用程序。 当 Service Bus 收到请求时，它会查找下一条要使用的消息，锁定该消息以防其他使用者接收，并将该消息返回到应用程序。 应用程序完成消息处理（或可靠地存储消息以供将来处理）后，会通过对收到的消息调用 **Delete** 完成接收过程的第二个阶段。 服务总线发现 **Delete** 调用时，它会将消息标记为“已使用”并将其从主题中删除。\r \r 以下示例演示了如何使用 **PeekLock** 模式（默认模式）接收和处理消息。 此示例执行一个循环并处理 `HighMessages` 订阅中的消息，并在处理完所有消息后退出循环（另外，还可将其设置为等待新消息）。\r \r ```java\r try\r {\r     ReceiveMessageOptions opts = ReceiveMessageOptions.DEFAULT;\r     opts.setReceiveMode(ReceiveMode.PEEK_LOCK);\r \r     while(true)  {\r         ReceiveSubscriptionMessageResult  resultSubMsg =\r             service.receiveSubscriptionMessage(\"TestTopic\", \"HighMessages\", opts);\r         BrokeredMessage message = resultSubMsg.getValue();\r         if (message != null && message.getMessageId() != null)\r         {\r             System.out.println(\"MessageID: \" + message.getMessageId());\r             // Display the topic message.\r             System.out.print(\"From topic: \");\r             byte[] b = new byte[200];\r             String s = null;\r             int numRead = message.getBody().read(b);\r             while (-1 != numRead)\r             {\r                 s = new String(b);\r                 s = s.trim();\r                 System.out.print(s);\r                 numRead = message.getBody().read(b);\r             }\r             System.out.println();\r             System.out.println(\"Custom Property: \" +\r                 message.getProperty(\"MessageNumber\"));\r             // Delete message.\r             System.out.println(\"Deleting this message.\");\r             service.deleteMessage(message);\r         }  \r         else  \r         {\r             System.out.println(\"Finishing up - no more messages.\");\r             break;\r             // Added to handle no more messages.\r             // Could instead wait for more messages to be added.\r         }\r     }\r }\r catch (ServiceException e) {\r     System.out.print(\"ServiceException encountered: \");\r     System.out.println(e.getMessage());\r     System.exit(-1);\r }\r catch (Exception e) {\r     System.out.print(\"Generic exception encountered: \");\r     System.out.println(e.getMessage());\r     System.exit(-1);\r }\r ```\r \r ## <a name=\"how-to-handle-application-crashes-and-unreadable-messages\"></a>如何处理应用程序崩溃和不可读消息\r Service Bus 提供了相关功能来帮助你轻松地从应用程序错误或消息处理问题中恢复。 如果接收方应用程序出于某种原因无法处理消息，则其可以对收到的消息调用 **unlockMessage** 方法（而不是 **deleteMessage** 方法）。 这会导致服务总线解锁主题中的消息并使其能够重新被同一个正在使用的应用程序或其他正在使用的应用程序接收。\r \r 还存在与主题中的已锁定消息关联的超时，并且如果应用程序无法在锁定超时到期之前处理消息（例如，如果应用程序崩溃），则服务总线将自动解锁该消息并使它可再次被接收。\r \r 如果在处理消息之后，发出 **deleteMessage** 请求之前，应用程序发生崩溃，则在应用程序重启时会将该消息重新传送给它。 此过程通常称作“至少处理一次”，即每条消息将至少被处理一次，但在某些情况下，同一消息可能会被重新传送。 如果方案无法容忍重复处理，则应用程序开发人员应向其应用程序添加更多逻辑以处理重复消息传送。 通常可使用消息的 **getMessageId** 方法实现此操作，这在多个传送尝试中保持不变。\r \r ## <a name=\"delete-topics-and-subscriptions\"></a>删除主题和订阅\r 删除主题和订阅的主要方法是使用 **ServiceBusContract** 对象。 删除某个主题也会删除向该主题注册的所有订阅。 也可以单独删除订阅。\r \r ```java\r // Delete subscriptions\r service.deleteSubscription(\"TestTopic\", \"AllMessages\");\r service.deleteSubscription(\"TestTopic\", \"HighMessages\");\r service.deleteSubscription(\"TestTopic\", \"LowMessages\");\r \r // Delete a topic\r service.deleteTopic(\"TestTopic\");\r ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r 现在，已了解服务总线队列的基础知识，请参阅[服务总线队列、主题和订阅][Service Bus queues, topics, and subscriptions]以了解详细信息。\r \r   [Azure SDK for Java]: https://www.azure.cn/develop/java/\r [Azure Toolkit for Eclipse]: ../azure-toolkit-for-eclipse.md\r   [Service Bus queues, topics, and subscriptions]: ./service-bus-queues-topics-subscriptions.md\r [SqlFilter]: https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.sqlfilter?view=azure-dotnet \r [SqlFilter.SqlExpression]: https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.sqlfilter.sqlexpression?view=azure-dotnet\r [BrokeredMessage]: https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.brokeredmessage\r   [0]: ./media/service-bus-java-how-to-use-topics-subscriptions/sb-queues-13.png\r   [2]: ./media/service-bus-java-how-to-use-topics-subscriptions/sb-queues-04.png\r   [3]: ./media/service-bus-java-how-to-use-topics-subscriptions/sb-queues-09.png\r   \r   <!--Update_Description:update link references and wording-->"}