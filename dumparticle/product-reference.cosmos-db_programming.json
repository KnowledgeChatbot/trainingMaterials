{"Title":"Azure Cosmos DB 的服务器端 JavaScript 编程","Description":"了解如何使用 Azure Cosmos DB 以 JavaScript 编写存储过程、数据库触发器和用户定义的函数 (UDF) 了解数据库编程技巧以及更多内容。","Content":"# <a name=\"azure-cosmos-db-server-side-programming-stored-procedures-database-triggers-and-udfs\"></a>Azure Cosmos DB 服务器端编程：存储过程、数据库触发器和 UDF\r 了解 Azure Cosmos DB 的语言如何集成、JavaScript 的事务执行如何使开发人员以 [ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/) JavaScript 本机编写**存储过程**、**触发器**和**用户定义的函数 (UDF)**。 因此，我们能够编写可以在数据库存储分区上直接传送和执行的数据库程序应用程序逻辑。 \r \r <!-- Not Available VIDEO https://channel9.msdn.com-->\r \r 然后，返回到本文，用户将在其中了解以下问题的答案：  \r \r * 如何使用 JavaScript 编写存储过程、触发器或 UDF？\r * Cosmos DB 如何保证 ACID？\r * 事务在 Cosmos DB 中如何工作？\r * 什么是预触发器和后触发器，以及如何编写它们？\r * 如何通过使用 HTTP 以 RESTful 方式注册并执行存储过程、触发器或 UDF？\r * 可用什么 Cosmos DB SDK 来创建和执行存储过程、触发器和 UDF？\r \r ## <a name=\"introduction-to-stored-procedure-and-udf-programming\"></a>存储过程和 UDF 编程简介\r 这种“将 JavaScript 用作新式 T-SQL”的方法让应用程序开发人员摆脱了类型系统不匹配和对象关系映射技术的复杂性。 它还具有许多可利用以构建丰富应用程序的内在优势：  \r \r * **过程逻辑：** JavaScript 作为一种高级别的编程语言，提供了表达业务逻辑的丰富且熟悉的界面。 可以执行与数据更接近的操作的复杂序列。\r * **原子事务：** Cosmos DB 保证在单个存储过程或触发器内部执行的数据库操作是原子事务。 这使得应用程序能在单个批处理中合并相关操作，因此要么它们全部成功，要么全部不成功。 \r * **性能：**JSON 在本质上映射到 Javascript 语言类型系统且 JSON 是 Cosmos DB 中的存储基本单位，这一事实让许多优化成为可能，例如缓冲池中 JSON 文档的滞后具体化以及根据需要向执行代码提供这些文档。 还有更多与传送业务逻辑到数据库相关的性能优点：\r \r   * 批处理 – 开发人员可以分组操作（如插入）并批量提交它们。 用于创建单独事务的网络流量延迟成本和存储开销显著降低。 \r   * 预编译 – Cosmos DB 预编译存储过程、触发器和用户定义的函数 (UDF) 以避免每次调用产生的 JavaScript 编译成本。 对于过程逻辑生成字节代码的开销被摊销为最小值。\r   * 序列化 - 很多操作需要可能涉及执行一个或多个次要存储操作的副作用（“触发器”）。 除了原子性之外，当移动到服务器时，它的性能也更高。 \r * **封装：** 可以使用存储过程在一个位置对业务逻辑进行分组。 这样做有两个优点：\r   * 它会在原始数据之上添加抽象层，这使得数据架构师能够从数据独立发展他们的应用程序。 当数据无架构时，如果他们必须直接处理数据，则由于可能需要兼并到应用程序中的脆性假设，使得这样做尤其有益。  \r   * 这种抽象使企业通过从脚本简化访问来保证他们的数据安全。  \r \r 数据库触发器、存储过程和自定义查询运算符的创建和执行通过 [REST API](https://docs.microsoft.com/rest/api/documentdb/)、[Azure DocumentDB Studio](https://github.com/mingaliu/DocumentDBStudio/releases) 和[客户端 SDK](documentdb-sdk-dotnet.md) 在许多平台（包括 .NET、Node.js 和 JavaScript）中得到支持。\r \r 本教程使用[具有 Q Promises 的 Node.js SDK](http://azure.github.io/azure-documentdb-node-q/) 来阐明存储过程、触发器和 UDF 的语法和用法。   \r \r ## <a name=\"stored-procedures\"></a>存储过程\r ### <a name=\"example-write-a-simple-stored-procedure\"></a>示例：编写简单的存储过程\r 让我们从一个返回“Hello World”响应的简单存储过程开始。\r \r     var helloWorldStoredProc = {\r         id: \"helloWorld\",\r         serverScript: function () {\r             var context = getContext();\r             var response = context.getResponse();\r \r             response.setBody(\"Hello, World\");\r         }\r     }\r \r 存储过程是按集合注册的，且可以在该集合中存在的任何文档和附件中运作。 以下代码段显示如何使用一个集合注册 helloWorld 存储过程。 \r \r     // register the stored procedure\r     var createdStoredProcedure;\r     client.createStoredProcedureAsync('dbs/testdb/colls/testColl', helloWorldStoredProc)\r         .then(function (response) {\r             createdStoredProcedure = response.resource;\r             console.log(\"Successfully created stored procedure\");\r         }, function (error) {\r             console.log(\"Error\", error);\r         });\r \r 注册存储过程后，我们可以针对集合进行执行，并读取返回到客户端的结果。 \r \r     // execute the stored procedure\r     client.executeStoredProcedureAsync('dbs/testdb/colls/testColl/sprocs/helloWorld')\r         .then(function (response) {\r             console.log(response.result); // \"Hello, World\"\r         }, function (err) {\r             console.log(\"Error\", error);\r         });\r \r 上下文对象提供对所有可在 Cosmos DB 存储上执行的操作的访问，以及对请求和响应对象的访问。 在本例中，我们使用响应对象来设置发送回客户端的响应的主体。 有关更多详细信息，请参阅 [Azure Cosmos DB JavaScript 服务器 SDK 文档](http://azure.github.io/azure-documentdb-js-server/)。  \r \r 让我们扩展此示例，并将更多数据库相关的功能添加到存储过程中。 存储过程可以创建、更新、读取、查询和删除集合内部的文档和附件。    \r \r ### <a name=\"example-write-a-stored-procedure-to-create-a-document\"></a>示例：编写创建文档的存储过程。\r 下一个代码段将演示如何使用上下文对象与 Cosmos DB 资源进行交互。\r \r     var createDocumentStoredProc = {\r         id: \"createMyDocument\",\r         serverScript: function createMyDocument(documentToCreate) {\r             var context = getContext();\r             var collection = context.getCollection();\r \r             var accepted = collection.createDocument(collection.getSelfLink(),\r                   documentToCreate,\r                   function (err, documentCreated) {\r                       if (err) throw new Error('Error' + err.message);\r                       context.getResponse().setBody(documentCreated.id)\r                   });\r             if (!accepted) return;\r         }\r     }\r \r 此存储过程将 documentToCreate 作为输入，它是要在当前集合中创建的文档的主体。 所有此类操作均是异步操作且依赖 JavaScript 函数回调。 回调函数具有两个参数，一个用于错误对象（假如操作失败），另一个用于已创建的对象。 在回调内部，用户可以处理异常或引发错误。 如果未提供回调而又存在错误，则 Azure Cosmos DB 运行时会引发错误。   \r \r 在上面的示例中，如果操作失败，回调会引发错误。 否则，它会将已创建文档的 ID 设置为对客户端的响应的主体。 此为该存储过程如何使用输入参数进行执行。\r \r     // register the stored procedure\r     client.createStoredProcedureAsync('dbs/testdb/colls/testColl', createDocumentStoredProc)\r         .then(function (response) {\r             var createdStoredProcedure = response.resource;\r \r             // run stored procedure to create a document\r             var docToCreate = {\r                 id: \"DocFromSproc\",\r                 book: \"The Hitchhiker's Guide to the Galaxy\",\r                 author: \"Douglas Adams\"\r             };\r \r             return client.executeStoredProcedureAsync('dbs/testdb/colls/testColl/sprocs/createMyDocument',\r                   docToCreate);\r         }, function (error) {\r             console.log(\"Error\", error);\r         })\r     .then(function (response) {\r         console.log(response); // \"DocFromSproc\"\r     }, function (error) {\r         console.log(\"Error\", error);\r     });\r \r 请注意，可以修改该存储过程以将文档主体的数组作为输入并在同一存储过程执行中创建它们全部，而不用执行多个网络请求以单独创建它们中的每一个。 这可用来实现 Cosmos DB 的有效批量导入程序（已在本教程的后面部分讨论）。   \r \r 所述的示例演示了如何使用存储过程。 我们会在教程的后面部分介绍触发器和用户定义的函数 (UDF)。\r \r ## <a name=\"database-program-transactions\"></a>数据库程序事务\r 典型数据库中的事务可以定义为一系列作为单个逻辑单元工作执行的操作。 每个事务提供 **ACID 保证**。 ACID 是一个很有名的缩写词，代表四个属性：Atomicity（原子性）、Consistency（一致性）、Isolation（隔离）和 Durability（持续性）。  \r \r 简单地说，原子性保证所有在一个事物内部执行的工作被视为单个单元，其中要么全部工作都提交，要么都不提交。 一致性确保数据始终在各个事务间处于良好内部状态。 隔离保证没有两个互相干扰的事务存在 – 一般来说，大多数商业系统都提供多个可以基于应用程序需求而使用的隔离级别。 持续性确保数据库中提交的任何更改将始终存在。   \r \r 在 Cosmos DB 中，JavaScript 被托管在与数据库相同的内存空间中。 因此，在存储过程和触发器内提出的请求会在相同范围的数据库会话中执行。 这让 Cosmos DB 能够保证所有属于单个存储过程/触发器的操作的 ACID。 考虑以下存储过程定义：\r \r     // JavaScript source code\r     var exchangeItemsSproc = {\r         id: \"exchangeItems\",\r         serverScript: function (playerId1, playerId2) {\r             var context = getContext();\r             var collection = context.getCollection();\r             var response = context.getResponse();\r \r             var player1Document, player2Document;\r \r             // query for players\r             var filterQuery = 'SELECT * FROM Players p where p.id  = \"' + playerId1 + '\"';\r             var accept = collection.queryDocuments(collection.getSelfLink(), filterQuery, {},\r                 function (err, documents, responseOptions) {\r                     if (err) throw new Error(\"Error\" + err.message);\r \r                     if (documents.length != 1) throw \"Unable to find both names\";\r                     player1Document = documents[0];\r \r                     var filterQuery2 = 'SELECT * FROM Players p where p.id = \"' + playerId2 + '\"';\r                     var accept2 = collection.queryDocuments(collection.getSelfLink(), filterQuery2, {},\r                         function (err2, documents2, responseOptions2) {\r                             if (err2) throw new Error(\"Error\" + err2.message);\r                             if (documents2.length != 1) throw \"Unable to find both names\";\r                             player2Document = documents2[0];\r                             swapItems(player1Document, player2Document);\r                             return;\r                         });\r                     if (!accept2) throw \"Unable to read player details, abort \";\r                 });\r \r             if (!accept) throw \"Unable to read player details, abort \";\r \r             // swap the two players' items\r             function swapItems(player1, player2) {\r                 var player1ItemSave = player1.item;\r                 player1.item = player2.item;\r                 player2.item = player1ItemSave;\r \r                 var accept = collection.replaceDocument(player1._self, player1,\r                     function (err, docReplaced) {\r                         if (err) throw \"Unable to update player 1, abort \";\r \r                         var accept2 = collection.replaceDocument(player2._self, player2,\r                             function (err2, docReplaced2) {\r                                 if (err) throw \"Unable to update player 2, abort\"\r                             });\r \r                         if (!accept2) throw \"Unable to update player 2, abort\";\r                     });\r \r                 if (!accept) throw \"Unable to update player 1, abort\";\r             }\r         }\r     }\r \r     // register the stored procedure in Node.js client\r     client.createStoredProcedureAsync(collection._self, exchangeItemsSproc)\r         .then(function (response) {\r             var createdStoredProcedure = response.resource;\r         }\r     );\r \r 此存储过程使用游戏应用内的事务在单个操作中的两个玩家之间交易项。 该存储过程尝试读取两个分别与作为参数传递的玩家 ID 对应的文档。 如果两个玩家文档都被找到，那么存储过程会通过交换它们的项来更新文档。 如果在此过程中遇到了任何错误，它会引发隐式终止事务的 JavaScript 异常。\r \r 如果存储过程针对其注册的集合是单区集合，那么该事务的范围为该集合内的所有文档。 如果集合已分区，那么存储过程会在单个分区键的事务范围中执行。 每个存储过程执行必须包含对应于事务在其下运行的范围的分区键值。 有关详细信息，请参阅 [Azure Cosmos DB 分区](partition-data.md)。\r \r ### <a name=\"commit-and-rollback\"></a>提交和回滚\r 事务原本就深入集成到了 Cosmos DB 的 JavaScript 编程模型中。 在 JavaScript 函数内，所有操作都在单个事务下自动包装。 如果 JavaScript 在没有任何异常的情况下完成，将提交针对数据库的操作。 实际上，关系型数据库中的“BEGIN TRANSACTION”和“COMMIT TRANSACTION”语句在 Cosmos DB 中是隐式的。  \r \r 如果存在任何传播自脚本的异常，Cosmos DB 的 JavaScript 运行时将回滚整个事务。 正如之前的示例中所示，引发异常实际上等同于 Cosmos DB 中的“ROLLBACK TRANSACTION”。\r \r ### <a name=\"data-consistency\"></a>数据一致性\r 存储过程和触发器始终在 Azure Cosmos DB 容器的主要副本上执行。 这确保了从存储过程内部的读取提供强一致性。 使用用户定义的函数的查询可以在主要或任何次要副本上执行，但通过选择合适的副本我们可以确保满足所要求的一致性级别。\r \r ## <a name=\"bounded-execution\"></a>绑定的执行\r 所有 Cosmos DB 操作必须在服务器指定的请求超时持续时间内完成。 此约束也适用于 JavaScript 函数（存储过程、触发器和用户定义的函数）。 如果某个操作未在时间限制内完成，则回滚事务。 JavaScript 函数必须在时间限制内完成，或实施一个基于延续的模型以批处理/继续执行过程。  \r \r 为了简化存储过程和触发器的开发以处理时间限制，集合对象内的所有函数（文档和附件的创建、读取、替换和删除）返回表示该操作是否完成的布尔值。 如果该值为 false，则表示时间限制马上会过期且该过程必须完成执行。  如果存储过程及时完成且没有任何更多请求在排队的话，将保证完成排在第一个拒绝存储操作之前的操作。  \r \r JavaScript 函数也被绑定在资源消耗量上。 Cosmos DB 基于预配的数据库帐户大小按集合保留吞吐量。 吞吐量按照规范化单位的 CPU、内存和 IO 消耗量（称为请求单位或 RU）来表示。 JavaScript 函数可能在短时间内耗尽大量的 RU，如果达到了集合的限制，则可能受到速率限制。 资源密集型存储过程还可能被隔离以确保原始数据库操作的可用性。  \r \r ### <a name=\"example-bulk-importing-data-into-a-database-program\"></a>示例：将数据批量导入到数据库程序中\r 下面是一个编写以批量导入文档到集合的存储过程的示例。 请注意存储过程通过检查来自 createDocument 的布尔返回值，并使用插入在每次存储过程调用中的文档的计数以在批处理之间跟踪和恢复进度，从而处理绑定执行的方式。\r \r     function bulkImport(docs) {\r         var collection = getContext().getCollection();\r         var collectionLink = collection.getSelfLink();\r \r         // The count of imported docs, also used as current doc index.\r         var count = 0;\r \r         // Validate input.\r         if (!docs) throw new Error(\"The array is undefined or null.\");\r \r         var docsLength = docs.length;\r         if (docsLength == 0) {\r             getContext().getResponse().setBody(0);\r         }\r \r         // Call the create API to create a document.\r         tryCreate(docs[count], callback);\r \r         // Note that there are 2 exit conditions:\r         // 1) The createDocument request was not accepted. \r         //    In this case the callback will not be called, we just call setBody and we are done.\r         // 2) The callback was called docs.length times.\r         //    In this case all documents were created and we don't need to call tryCreate anymore. Just call setBody and we are done.\r         function tryCreate(doc, callback) {\r             var isAccepted = collection.createDocument(collectionLink, doc, callback);\r \r             // If the request was accepted, callback will be called.\r             // Otherwise report current count back to the client, \r             // which will call the script again with remaining set of docs.\r             if (!isAccepted) getContext().getResponse().setBody(count);\r         }\r \r         // This is called when collection.createDocument is done in order to process the result.\r         function callback(err, doc, options) {\r             if (err) throw err;\r \r             // One more document has been inserted, increment the count.\r             count++;\r \r             if (count >= docsLength) {\r                 // If we created all documents, we are done. Just set the response.\r                 getContext().getResponse().setBody(count);\r             } else {\r                 // Create next document.\r                 tryCreate(docs[count], callback);\r             }\r         }\r     }\r \r ## <a name=\"trigger\"></a> 数据库触发器\r ### <a name=\"database-pre-triggers\"></a>数据库预触发器\r Cosmos DB 提供由对文档的操作执行或触发的触发器。 例如，创建文档时可以指定预触发器 – 此预触发器会在文档创建之前运行。 下面就是如何使用预触发器来验证正在创建的文档的属性的示例：\r \r     var validateDocumentContentsTrigger = {\r         id: \"validateDocumentContents\",\r         serverScript: function validate() {\r             var context = getContext();\r             var request = context.getRequest();\r \r             // document to be created in the current operation\r             var documentToCreate = request.getBody();\r \r             // validate properties\r             if (!(\"timestamp\" in documentToCreate)) {\r                 var ts = new Date();\r                 documentToCreate[\"my timestamp\"] = ts.getTime();\r             }\r \r             // update the document that will be created\r             request.setBody(documentToCreate);\r         },\r         triggerType: TriggerType.Pre,\r         triggerOperation: TriggerOperation.Create\r     }\r \r 该触发器对应的 Node.js 客户端注册代码：\r \r     // register pre-trigger\r     client.createTriggerAsync(collection.self, validateDocumentContentsTrigger)\r         .then(function (response) {\r             console.log(\"Created\", response.resource);\r             var docToCreate = {\r                 id: \"DocWithTrigger\",\r                 event: \"Error\",\r                 source: \"Network outage\"\r             };\r \r             // run trigger while creating above document \r             var options = { preTriggerInclude: \"validateDocumentContents\" };\r \r             return client.createDocumentAsync(collection.self,\r                   docToCreate, options);\r         }, function (error) {\r             console.log(\"Error\", error);\r         })\r     .then(function (response) {\r         console.log(response.resource); // document with timestamp property added\r     }, function (error) {\r         console.log(\"Error\", error);\r     });\r \r 预触发器不能有任何输入参数。 可以使用请求对象操纵与操作相关联的请求消息。 此处，预触发器随文档的创建而运行，且请求消息正文包含要以 JSON 格式创建的文档。   \r \r 当注册触发器后，用户可以指定随触发器一起运行的操作。 此触发器使用的是 TriggerOperation.Create 创建的，这意味着下列操作不被允许。\r \r     var options = { preTriggerInclude: \"validateDocumentContents\" };\r \r     client.replaceDocumentAsync(docToReplace.self,\r                   newDocBody, options)\r     .then(function (response) {\r         console.log(response.resource);\r     }, function (error) {\r         console.log(\"Error\", error);\r     });\r \r     // Fails, can't use a create trigger in a replace operation\r \r ### <a name=\"database-post-triggers\"></a>数据库后触发器\r 后触发器，跟预触发器一样，与文档上的操作相关联且不接受任何输入参数。 它们在操作完成 **之后** 运行，且具有对发送到客户端的响应消息的访问权限。   \r \r 下面的示例显示正在运作的后触发器：\r \r     var updateMetadataTrigger = {\r         id: \"updateMetadata\",\r         serverScript: function updateMetadata() {\r             var context = getContext();\r             var collection = context.getCollection();\r             var response = context.getResponse();\r \r             // document that was created\r             var createdDocument = response.getBody();\r \r             // query for metadata document\r             var filterQuery = 'SELECT * FROM root r WHERE r.id = \"_metadata\"';\r             var accept = collection.queryDocuments(collection.getSelfLink(), filterQuery,\r                 updateMetadataCallback);\r             if(!accept) throw \"Unable to update metadata, abort\";\r \r             function updateMetadataCallback(err, documents, responseOptions) {\r                 if(err) throw new Error(\"Error\" + err.message);\r                          if(documents.length != 1) throw 'Unable to find metadata document';\r \r                          var metadataDocument = documents[0];\r \r                          // update metadata\r                          metadataDocument.createdDocuments += 1;\r                          metadataDocument.createdNames += \" \" + createdDocument.id;\r                          var accept = collection.replaceDocument(metadataDocument._self,\r                                metadataDocument, function(err, docReplaced) {\r                                       if(err) throw \"Unable to update metadata, abort\";\r                                });\r                          if(!accept) throw \"Unable to update metadata, abort\";\r                          return;                    \r             }                                                                                            \r         },\r         triggerType: TriggerType.Post,\r         triggerOperation: TriggerOperation.All\r     }\r \r 可以按照下面示例中所示方法注册触发器。\r \r     // register post-trigger\r     client.createTriggerAsync('dbs/testdb/colls/testColl', updateMetadataTrigger)\r         .then(function(createdTrigger) { \r             var docToCreate = { \r                 name: \"artist_profile_1023\",\r                 artist: \"The Band\",\r                 albums: [\"Hellujah\", \"Rotators\", \"Spinning Top\"]\r             };\r \r             // run trigger while creating above document \r             var options = { postTriggerInclude: \"updateMetadata\" };\r \r             return client.createDocumentAsync(collection.self,\r                   docToCreate, options);\r         }, function(error) {\r             console.log(\"Error\" , error);\r         })\r     .then(function(response) {\r         console.log(response.resource); \r     }, function(error) {\r         console.log(\"Error\" , error);\r     });\r \r 此触发器查询元数据文档并在其中更新新建文档的详细信息。  \r \r 务必要注意的一点是 Cosmos DB 中的触发器的**事务性**执行。 此后触发器作为与原始文档的创建相同的事务的一部分运行。 因此，如果我们从后触发器引发异常（假设我们无法更新元数据文档），整个事务都会失败并回滚。 不会创建文档，而会返回异常。  \r \r ## <a name=\"udf\"></a>用户定义的函数\r 将用户定义的函数 (UDF) 用来扩展 DocumentDB API SQL 查询语言语法和实现自定义业务逻辑。 它们只能从查询内部调用。 它们不具有对上下文对象的访问权限且旨在被用作仅计算的 JavaScript。 因此，UDF 可以在 Cosmos DB 服务的次要副本上运行。  \r \r 以下示例创建 UDF 来计算基于各种收入档次的税率的所得税，并在查询内部使用它查找所有支付税款超过 $20,000 的人。\r \r     var taxUdf = {\r         id: \"tax\",\r         serverScript: function tax(income) {\r \r             if(income == undefined) \r                 throw 'no input';\r \r             if (income < 1000) \r                 return income * 0.1;\r             else if (income < 10000) \r                 return income * 0.2;\r             else\r                 return income * 0.4;\r         }\r     }\r \r UDF 随后可以用在诸如下面示例的查询中：\r \r     // register UDF\r     client.createUserDefinedFunctionAsync('dbs/testdb/colls/testColl', taxUdf)\r         .then(function(response) { \r             console.log(\"Created\", response.resource);\r \r             var query = 'SELECT * FROM TaxPayers t WHERE udf.tax(t.income) > 20000'; \r             return client.queryDocuments('dbs/testdb/colls/testColl',\r                    query).toArrayAsync();\r         }, function(error) {\r             console.log(\"Error\" , error);\r         })\r     .then(function(response) {\r         var documents = response.feed;\r         console.log(response.resource); \r     }, function(error) {\r         console.log(\"Error\" , error);\r     });\r \r ## <a name=\"javascript-language-integrated-query-api\"></a>JavaScript 语言集成的查询 API\r 除了使用 DocumentDB 的 SQL 语法发起查询外，服务器端 SDK 还允许在没有任何 SQL 知识的情况下使用流畅的 JavaScript 接口来执行优化的查询。 JavaScript 查询 API 允许使用与 ECMAScript5 的数组内置项类似的语法和如 lodash 等热门的 JavaScript 库，通过将谓词函数传递到可链的函数调用中以编程方式生成查询。 查询由将使用 Azure Cosmos DB 的索引有效执行的 JavaScript 运行时进行分析。\r \r > [!NOTE]\r > `__`（双下划线）是 `getContext().getCollection()` 的别名。\r > <br/>\r > 换言之，可以使用 `__` 或 `getContext().getCollection()` 来访问 JavaScript 查询 API。\r > \r > \r \r 支持的函数包括：\r \r <ul>\r <li>\r <b>chain() ... .value([callback] [, options])</b>\r <ul>\r <li>\r 发起一个必须用 value() 终止的连锁调用。\r </li>\r </ul>\r </li>\r <li>\r <b>filter(predicateFunction [, options] [, callback])</b>\r <ul>\r <li>\r 使用返回 true/false 的谓词函数对输入进行筛选，以便将输入文档筛选出或筛选到结果集。 这与 SQL 中的 WHERE 子句行为相似。\r </li>\r </ul>\r </li>\r <li>\r <b>map(transformationFunction [, options] [, callback])</b>\r <ul>\r <li>\r 应用给定一个转换函数的投影，该函数将每个输入项映射到 JavaScript 对象或值。 这与 SQL 中的 SELECT 子句行为相似。\r </li>\r </ul>\r </li>\r <li>\r <b>pluck([propertyName] [, options] [, callback])</b>\r <ul>\r <li>\r 这是从每个输入项提取单个属性的值的映射的快捷方式。\r </li>\r </ul>\r </li>\r <li>\r <b>flatten([isShallow] [, options] [, callback])</b>\r <ul>\r <li>\r 将每个输入项中的数组进行组合并平展到单个数组。 这与 LINQ 中的 SelectMany 行为相似。\r </li>\r </ul>\r </li>\r <li>\r <b>sortBy([predicate] [, options] [, callback])</b>\r <ul>\r <li>\r 通过使用给定的谓词按升序对输入文档流中的文档进行排序来生成新的一组文档。 这与 SQL 中的 ORDER BY 子句行为相似。\r </li>\r </ul>\r </li>\r <li>\r <b>sortByDescending([predicate] [, options] [, callback])</b>\r <ul>\r <li>\r 通过使用给定的谓词按降序对输入文档流中的文档进行排序来生成新的一组文档。 这与 SQL 中的 ORDER BY x DESC 子句行为相似。\r </li>\r </ul>\r </li>\r </ul>\r \r 当其中包含谓词和/或选择器函数时，以下 JavaScript 构造将自动优化以在 Azure Cosmos DB 索引上直接运行：\r \r * 简单运算符：= + - * / % | ^ &amp; == != === !=== &lt; &gt; &lt;= &gt;= || &amp;&amp; &lt;&lt; &gt;&gt; &gt;&gt;&gt;! ~\r * 文本（包括对象文本）：{}\r * var, return\r \r 以下 JavaScript 构造不会针对 Azure Cosmos DB 索引进行优化：\r \r * 控制流（如 if、for、while）\r * 函数调用\r \r 有关详细信息，请查看 [服务器端 JSDocs](http://azure.github.io/azure-documentdb-js-server/)。\r \r ### <a name=\"example-write-a-stored-procedure-using-the-javascript-query-api\"></a>示例：使用 JavaScript 查询 API 编写存储过程\r 下面的代码示例是一个有关可如何在存储过程的上下文中使用 JavaScript 查询 API 的示例。 存储过程使用 `__.filter()` 方法插入一个由输入参数给定的文档并更新元数据文档，其中 minSize、maxSize 和 totalSize 以输入文档的大小属性为基础。\r \r     /**\r      * Insert actual doc and update metadata doc: minSize, maxSize, totalSize based on doc.size.\r      */\r     function insertDocumentAndUpdateMetadata(doc) {\r       // HTTP error codes sent to our callback funciton by DocDB server.\r       var ErrorCode = {\r         RETRY_WITH: 449,\r       }\r \r       var isAccepted = __.createDocument(__.getSelfLink(), doc, {}, function(err, doc, options) {\r         if (err) throw err;\r \r         // Check the doc (ignore docs with invalid/zero size and metaDoc itself) and call updateMetadata.\r         if (!doc.isMetadata && doc.size > 0) {\r           // Get the meta document. We keep it in the same collection. it's the only doc that has .isMetadata = true.\r           var result = __.filter(function(x) {\r             return x.isMetadata === true\r           }, function(err, feed, options) {\r             if (err) throw err;\r \r             // We assume that metadata doc was pre-created and must exist when this script is called.\r             if (!feed || !feed.length) throw new Error(\"Failed to find the metadata document.\");\r \r             // The metadata document.\r             var metaDoc = feed[0];\r \r             // Update metaDoc.minSize:\r             // for 1st document use doc.Size, for all the rest see if it's less than last min.\r             if (metaDoc.minSize == 0) metaDoc.minSize = doc.size;\r             else metaDoc.minSize = Math.min(metaDoc.minSize, doc.size);\r \r             // Update metaDoc.maxSize.\r             metaDoc.maxSize = Math.max(metaDoc.maxSize, doc.size);\r \r             // Update metaDoc.totalSize.\r             metaDoc.totalSize += doc.size;\r \r             // Update/replace the metadata document in the store.\r             var isAccepted = __.replaceDocument(metaDoc._self, metaDoc, function(err) {\r               if (err) throw err;\r               // Note: in case concurrent updates causes conflict with ErrorCode.RETRY_WITH, we can't read the meta again \r               //       and update again because due to Snapshot isolation we will read same exact version (we are in same transaction).\r               //       We have to take care of that on the client side.\r             });\r             if (!isAccepted) throw new Error(\"replaceDocument(metaDoc) returned false.\");\r           });\r           if (!result.isAccepted) throw new Error(\"filter for metaDoc returned false.\");\r         }\r       });\r       if (!isAccepted) throw new Error(\"createDocument(actual doc) returned false.\");\r     }\r \r ## <a name=\"sql-to-javascript-cheat-sheet\"></a>SQL 到 Javascript 备忘单\r 下表表示各种不同的 SQL 查询和对应的 JavaScript 查询。\r \r 对于 SQL 查询，文档属性键（例如 `doc.id`）区分大小写。\r \r |SQL| JavaScript 查询 API|说明如下|\r |---|---|---|\r |SELECT *<br>FROM docs| __.map(function(doc) { <br>&nbsp;&nbsp;&nbsp;&nbsp;return doc;<br>});|1|\r |SELECT docs.id, docs.message AS msg, docs.actions <br>FROM docs|__.map(function(doc) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: doc.id,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg: doc.message,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actions:doc.actions<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>});|2|\r |SELECT *<br>FROM docs<br>WHERE docs.id=\"X998_Y998\"|__.filter(function(doc) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return doc.id ===\"X998_Y998\";<br>});|3|\r |SELECT *<br>FROM docs<br>WHERE ARRAY_CONTAINS(docs.Tags, 123)|__.filter(function(x) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return x.Tags && x.Tags.indexOf(123) > -1;<br>});|4|\r |SELECT docs.id, docs.message AS msg<br>FROM docs<br>WHERE docs.id=\"X998_Y998\"|__.chain()<br>&nbsp;&nbsp;&nbsp;&nbsp;.filter(function(doc) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return doc.id ===\"X998_Y998\";<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;.map(function(doc) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: doc.id,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg: doc.message<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>.value();|5|\r |SELECT VALUE tag<br>FROM docs<br>JOIN tag IN docs.Tags<br>ORDER BY docs._ts|__.chain()<br>&nbsp;&nbsp;&nbsp;&nbsp;.filter(function(doc) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return doc.Tags && Array.isArray(doc.Tags);<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;.sortBy(function(doc) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return doc._ts;<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;.pluck(\"Tags\")<br>&nbsp;&nbsp;&nbsp;&nbsp;.flatten()<br>&nbsp;&nbsp;&nbsp;&nbsp;.value()|6|\r \r 以下描述对上表中的每个查询进行了阐释。\r 1. 结果为所有文档（使用延续令牌分页）保持原样。\r 2. 从所有文档投影 ID、消息（别名为 msg）和操作。\r 3. 查询具有此谓词的文档：id = \"X998_Y998\"。\r 4. 查询具有 Tags 属性且 Tags 为一个包含值 123 的数组的文档。\r 5. 查询具有谓词 id = \"X998_Y998\" 的文档，并投影 ID 和消息（别名为 msg）。\r 6. 筛选具有数组属性 Tags 的文档，按 _ts 时间戳系统属性对生成的文档进行排序，并投影并平展 Tags 数组。\r \r ## <a name=\"runtime-support\"></a>运行时支持\r [DocumentDB JavaScript 服务器端 API](http://azure.github.io/azure-documentdb-js-server/) 为大多数 [ECMA-262](http://www.ecma-international.org/publications/standards/Ecma-262.htm) 规范的主流 JavaScript 语言功能提供支持。\r \r ### <a name=\"security\"></a>“安全”\r JavaScript 存储过程和触发器经过沙盒处理，以使一个脚本的效果不会在未经过数据库级别的快照事务隔离的情况下泄漏到其他脚本。 运行时环境是共用的，但是在每次运行后都会清理上下文。 因此可以保证它们安全避免互相之间的任何意外副作用。\r \r ### <a name=\"pre-compilation\"></a>预编译\r 存储过程、触发器和 UDF 是隐式预编译到字节代码格式的，这是为了避免每次脚本调用时产生的编译成本。 这可确保存储过程的调用迅速且痕迹较少。\r \r ## <a name=\"client-sdk-support\"></a>客户端 SDK 支持\r 除了适用于 [Node.js](documentdb-sdk-node.md) 客户端的 DocumentDB API 外，Azure Cosmos DB 还有适用于 DocumentDB API 的 [.NET](documentdb-sdk-dotnet.md)、[.NET Core](documentdb-sdk-dotnet-core.md)、[Java](documentdb-sdk-java.md)、[JavaScript](http://azure.github.io/azure-documentdb-js/) 和[Python SDK](documentdb-sdk-python.md)。 也可以使用这些 SDK 来创建和执行存储过程、触发器和 UDF。 以下示例演示如何使用 .NET 客户端创建和执行存储过程。 请注意 .NET 类型是如何以 JSON 传递到存储过程中并从中读回的。\r \r     var markAntiquesSproc = new StoredProcedure\r     {\r         Id = \"ValidateDocumentAge\",\r         Body = @\"\r                 function(docToCreate, antiqueYear) {\r                     var collection = getContext().getCollection();    \r                     var response = getContext().getResponse();    \r \r                     if(docToCreate.Year != undefined && docToCreate.Year < antiqueYear){\r                         docToCreate.antique = true;\r                     }\r \r                     collection.createDocument(collection.getSelfLink(), docToCreate, {}, \r                         function(err, docCreated, options) { \r                             if(err) throw new Error('Error while creating document: ' + err.message);                              \r                             if(options.maxCollectionSizeInMb == 0) throw 'max collection size not found'; \r                             response.setBody(docCreated);\r                     });\r              }\"\r     };\r \r     // register stored procedure\r     StoredProcedure createdStoredProcedure = await client.CreateStoredProcedureAsync(UriFactory.CreateDocumentCollectionUri(\"db\", \"coll\"), markAntiquesSproc);\r     dynamic document = new Document() { Id = \"Borges_112\" };\r     document.Title = \"Aleph\";\r     document.Year = 1949;\r \r     // execute stored procedure\r     Document createdDocument = await client.ExecuteStoredProcedureAsync<Document>(UriFactory.CreateStoredProcedureUri(\"db\", \"coll\", \"ValidateDocumentAge\"), document, 1920);\r \r 本示例演示如何使用 [DocumentDB .NET API](https://docs.microsoft.com/dotnet/api/overview/azure/cosmosdb?view=azure-dotnet) 创建预触发器，并使用已启用的触发器创建文档。 \r \r     Trigger preTrigger = new Trigger()\r     {\r         Id = \"CapitalizeName\",\r         Body = @\"function() {\r             var item = getContext().getRequest().getBody();\r             item.id = item.id.toUpperCase();\r             getContext().getRequest().setBody(item);\r         }\",\r         TriggerOperation = TriggerOperation.Create,\r         TriggerType = TriggerType.Pre\r     };\r \r     Document createdItem = await client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri(\"db\", \"coll\"), new Document { Id = \"documentdb\" },\r         new RequestOptions\r         {\r             PreTriggerInclude = new List<string> { \"CapitalizeName\" },\r         });\r \r 以下示例演示了如何创建用户定义的函数 (UDF) 并在 [DocumentDB API SQL 查询](documentdb-sql-query.md)中使用它。\r \r     UserDefinedFunction function = new UserDefinedFunction()\r     {\r         Id = \"LOWER\",\r         Body = @\"function(input) \r         {\r             return input.toLowerCase();\r         }\"\r     };\r \r     foreach (Book book in client.CreateDocumentQuery(UriFactory.CreateDocumentCollectionUri(\"db\", \"coll\"),\r         \"SELECT * FROM Books b WHERE udf.LOWER(b.Title) = 'war and peace'\"))\r     {\r         Console.WriteLine(\"Read {0} from query\", book);\r     }\r \r ## <a name=\"rest-api\"></a>REST API\r 所有 Azure Cosmos DB 操作都能以 RESTful 方式执行。 可以通过在集合下使用 HTTP POST 来注册存储过程、触发器和用户定义的函数。 下面为如何注册存储过程的一个示例：\r \r     POST https://<url>/sprocs/ HTTP/1.1\r     authorization: <<auth>>\r     x-ms-date: Thu, 07 Aug 2014 03:43:10 GMT\r \r     var x = {\r       \"name\": \"createAndAddProperty\",\r       \"body\": function (docToCreate, addedPropertyName, addedPropertyValue) {\r                 var collectionManager = getContext().getCollection();\r                 collectionManager.createDocument(\r                     collectionManager.getSelfLink(),\r                     docToCreate,\r                     function(err, docCreated) {\r                       if(err) throw new Error('Error:  ' + err.message);\r                       docCreated[addedPropertyName] = addedPropertyValue;\r                       getContext().getResponse().setBody(docCreated);\r                     });\r             }\r     }\r \r 通过针对 URI dbs/testdb/colls/testColl/sprocs 执行 POST 请求（其主体包含要创建的存储过程）来注册存储过程。 同样，可以通过分别针对 /triggers 和 /udfs 发出 POST 来注册触发器和 UDF。\r 然后可以通过针对其资源链接发出 POST 请求来执行此存储过程。\r \r     POST https://<url>/sprocs/<sproc> HTTP/1.1\r     authorization: <<auth>>\r     x-ms-date: Thu, 07 Aug 2014 03:43:20 GMT\r \r     [ { \"name\": \"TestDocument\", \"book\": \"Autumn of the Patriarch\"}, \"Price\", 200 ]\r \r 此处，存储过程的输入在请求主体中传递。 请注意，输入是作为输入参数的 JSON 数组进行传递的。 存储过程将第一个输入作为响应主体的文档。 我们收到的响应如下：\r \r     HTTP/1.1 200 OK\r \r     { \r       name: 'TestDocument',\r       book: 'Autumn of the Patriarch',\r       id: 'V7tQANV3rAkDAAAAAAAAAA==',\r       ts: 1407830727,\r       self: 'dbs/V7tQAA==/colls/V7tQANV3rAk=/docs/V7tQANV3rAkDAAAAAAAAAA==/',\r       etag: '6c006596-0000-0000-0000-53e9cac70000',\r       attachments: 'attachments/',\r       Price: 200\r     }\r \r 与存储过程不一样，不能直接执行触发器。 相反，它们将作为文档上的操作的一部分进行执行。 我们可以使用 HTTP 标头，指定触发器通过请求进行运行。 下面为创建文档的请求。\r \r     POST https://<url>/docs/ HTTP/1.1\r     authorization: <<auth>>\r     x-ms-date: Thu, 07 Aug 2014 03:43:10 GMT\r     x-ms-documentdb-pre-trigger-include: validateDocumentContents \r     x-ms-documentdb-post-trigger-include: bookCreationPostTrigger\r \r     {\r        \"name\": \"newDocument\",\r        \"title\": \"The Wizard of Oz\",\r        \"author\": \"Frank Baum\",\r        \"pages\": 92\r     }\r \r 此处，要通过请求运行的预触发器在 x-ms-documentdb-pre-trigger-include 标头中指定。 相应地，任何后触发器会在 x-ms-documentdb-post-trigger-include 标头中给定。 请注意，可以针对某个给定的请求指定预触发器和后触发器。\r \r ## <a name=\"sample-code\"></a>代码示例\r 可在 [GitHub 存储库](https://github.com/Azure/azure-documentdb-js-server/tree/master/samples)上找到更多服务器端代码示例（包括 [bulk-delete](https://github.com/Azure/azure-documentdb-js-server/tree/master/samples/stored-procedures/bulkDelete.js) 和 [update](https://github.com/Azure/azure-documentdb-js-server/tree/master/samples/stored-procedures/update.js)）。\r \r 想要共享令人惊叹的存储过程吗？ 请向我们发送拉取请求！ \r \r ## <a name=\"next-steps\"></a>后续步骤\r 创建了一个或多个存储过程、触发器和用户定义的函数之后，可以使用数据资源管理器在 Azure 门户中加载和查看它们。\r \r 还可以查找以下参考和资源，可帮助了解更多有关 Azure Cosmos DB 服务器端编程的信息：\r \r * [Azure Cosmos DB SDK](documentdb-sdk-dotnet.md)\r * [DocumentDB Studio](https://github.com/mingaliu/DocumentDBStudio/releases)\r * [JSON](http://www.json.org/) \r * [JavaScript ECMA-262](http://www.ecma-international.org/publications/standards/Ecma-262.htm)\r * [安全和可移植的数据库扩展性](http://dl.acm.org/citation.cfm?id=276339) \r * [面向服务的数据库体系结构](http://dl.acm.org/citation.cfm?id=1066267&coll=Portal&dl=GUIDE) \r * [在 Microsoft SQL 服务器中托管 .NET 运行时](http://dl.acm.org/citation.cfm?id=1007669)\r \r <!--Update_Description: wording update-->"}