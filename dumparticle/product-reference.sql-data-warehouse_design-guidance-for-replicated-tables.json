{"Title":"针对复制的表的设计指南 - Azure SQL 数据仓库","Description":"有关在 Azure SQL 数据仓库架构中设计复制的表的建议。","Content":"# <a name=\"design-guidance-for-using-replicated-tables-in-azure-sql-data-warehouse\"></a>有关在 Azure SQL 数据仓库中使用复制的表的设计指南\r 本文提供了有关在 SQL 数据仓库架构中设计复制的表的建议。 可以使用这些建议通过减少数据移动和降低查询复杂性来提高查询性能。\r \r > [!NOTE]\r > 复制的表功能当前为公共预览版。 某些行为会更改。\r > \r \r ## <a name=\"prerequisites\"></a>先决条件\r 本文假定你熟悉 SQL 数据仓库中的数据分发和数据移动概念。  有关详细信息，请参阅[体系结构](massively-parallel-processing-mpp-architecture.md)一文。 \r \r 作为表设计的一部分，请尽可能多地去了解你的数据及其查询方式。  例如，请考虑以下问题：\r \r - 表有多大？   \r - 表的刷新频率是多少？   \r - 数据仓库中是否有事实数据表和维度表？   \r \r ## <a name=\"what-is-a-replicated-table\"></a>什么是复制的表？\r 复制的表具有可在每个计算节点上访问的完整表副本。 复制表后，在执行联接或聚合前将无需在计算节点之间传输数据。 由于表具有多个副本，因此当表压缩后的大小小于 2 GB 时，复制的表性能最佳。\r \r 下图显示了可在每个计算节点上访问的复制表。 在 SQL 数据仓库中，复制的表将完整复制到每个计算节点上的分发数据库。 \r \r ![Replicated table](media/guidance-for-using-replicated-tables/replicated-table.png \"Replicated table\")  \r \r 复制的表比较适合星型架构中的小型维度表。 通常情况下，维度表的大小让存储并维护多个副本变得可行。 维度存储着不常更改的描述性数据，例如，客户名称和地址以及产品详细信息。 该数据的缓变本性使复制的表不会经历太多的重新生成。 \r \r 在下列情况下，请考虑使用复制的表：\r \r - 磁盘上的表大小小于 2 GB，无论有多少行。 若要查明表的大小，可以使用 [DBCC PDW_SHOWSPACEUSED](https://docs.microsoft.com/sql/t-sql/database-console-commands/dbcc-pdw-showspaceused-transact-sql) 命令：`DBCC PDW_SHOWSPACEUSED('ReplTableCandidate')`。 \r - 表用于不采用复制的表时将要求移动数据的联接中。 例如，当联接列不同于分布列时，针对哈希分布式表的联接将要求移动数据。 如果其中一个哈希分布式表很小，请考虑使用复制的表。 针对循环表的联接要求移动数据。 大多数情况下，我们建议使用复制的表而非循环表。 \r \r 在下列情况下，请考虑将现有分布式表转换为复制的表：\r \r - 查询计划使用了将数据广播到所有计算节点的数据移动操作。 BroadcastMoveOperation 代价高昂并且会降低查询性能。 若要查看查询计划中的数据移动操作，请使用 [sys.dm_pdw_request_steps](https://docs.microsoft.com/sql/relational-databases/system-dynamic-management-views/sys-dm-pdw-request-steps-transact-sql)。\r \r 在下列情况下，复制的表可能不会产生最佳查询性能：\r \r - 表具有频繁的插入、更新和删除操作。 这些数据操作语言 (DML) 操作要求重新生成复制的表。 频繁地重新生成会导致性能降低。\r - 数据仓库会频繁地进行缩放。 缩放数据仓库会更改计算节点的数目，这将引发重新生成。\r - 表具有大量列，但数据操作通常仅访问少量的列。 在这种情况下，不要复制整个表，对表进行哈希分布然后针对频繁访问的列创建索引可能更为高效。 当查询要求移动数据时，SQL 数据仓库将仅移动所请求的列中的数据。 \r \r ## <a name=\"use-replicated-tables-with-simple-query-predicates\"></a>将复制的表与简单的查询谓词一起使用\r 在选择分发或复制表之前，请考虑计划对表运行的查询类型。 只要可能，\r \r - 对于具有简单查询谓词（例如等于或不等于）的查询，请使用复制的表。\r - 对于具有复杂查询谓词（例如 LIKE 或 NOT LIKE）的查询，请使用分布式表。\r \r 当工作分布在所有计算节点中时，CPU 密集型查询的性能最佳。 例如，对表的每个行运行计算的查询在分布式表上的性能要好于在复制的表上的性能。 由于复制的表完整存储在每个计算节点上，因此，针对复制的表的 CPU 密集型查询将针对每个计算节点上的整个表运行。 此额外的计算会降低查询性能。\r \r 例如，以下查询具有复杂谓词。  当提供者是分布式表而非复制的表时，它运行更快。 在此示例中，提供者可以是哈希分布式的，也可以是循环分布式的。\r \r ```sql\r \r SELECT EnglishProductName \r FROM DimProduct \r WHERE EnglishDescription LIKE '%frame%comfortable%'\r \r ```\r \r ## <a name=\"convert-existing-round-robin-tables-to-replicated-tables\"></a>将现有的循环表转换为复制的表\r 如果已经具有循环表，如果它们满足本文中列出的条件，建议将其转换为复制的表。 与循环表相比，复制的表可以提高性能，因为它们不要求移动数据。  循环表始终要求为联接移动数据。 \r \r 此示例使用 [CTAS](https://docs.microsoft.com/sql/t-sql/statements/create-table-as-select-azure-sql-data-warehouse) 将 DimSalesTerritory 表更改为复制的表。 无论 DimSalesTerritory 是哈希分布式表还是循环表，此示例都是可行的。\r \r ```sql\r CREATE TABLE [dbo].[DimSalesTerritory_REPLICATE]   \r WITH   \r   (   \r     CLUSTERED COLUMNSTORE INDEX,  \r     DISTRIBUTION = REPLICATE  \r   )  \r AS SELECT * FROM [dbo].[DimSalesTerritory]\r OPTION  (LABEL  = 'CTAS : DimSalesTerritory_REPLICATE') \r \r --Create statistics on new table\r CREATE STATISTICS [SalesTerritoryKey] ON [DimSalesTerritory_REPLICATE] ([SalesTerritoryKey]);\r CREATE STATISTICS [SalesTerritoryAlternateKey] ON [DimSalesTerritory_REPLICATE] ([SalesTerritoryAlternateKey]);\r CREATE STATISTICS [SalesTerritoryRegion] ON [DimSalesTerritory_REPLICATE] ([SalesTerritoryRegion]);\r CREATE STATISTICS [SalesTerritoryCountry] ON [DimSalesTerritory_REPLICATE] ([SalesTerritoryCountry]);\r CREATE STATISTICS [SalesTerritoryGroup] ON [DimSalesTerritory_REPLICATE] ([SalesTerritoryGroup]);\r \r -- Switch table names\r RENAME OBJECT [dbo].[DimSalesTerritory] to [DimSalesTerritory_old];\r RENAME OBJECT [dbo].[DimSalesTerritory_REPLICATE] TO [DimSalesTerritory];\r \r DROP TABLE [dbo].[DimSalesTerritory_old];\r ```  \r \r ### <a name=\"query-performance-example-for-round-robin-versus-replicated\"></a>循环表与复制的表的查询性能对比示例 \r \r 复制的表不要求为联接移动任何数据，因为整个表已存在于每个计算节点上。 如果维度表是循环分布式的，则联接会将维度表整个复制到每个计算节点。 为了移动数据，查询计划包含了一个名为 BroadcastMoveOperation 的操作。 此类数据移动操作会降低查询性能，使用复制的表可以避免。 若要查看查询计划步骤，请使用 [sys.dm_pdw_request_steps](https://docs.microsoft.com/sql/relational-databases/system-dynamic-management-views/sys-dm-pdw-request-steps-transact-sql) 系统目录视图。 \r \r 例如，在针对 AdventureWorks 架构的以下查询中，` FactInternetSales` 表是哈希分布式的。 `DimDate` 和 `DimSalesTerritory` 表是较小的维度表。 此查询返回 2004 会计年度在北美的总销售额：\r \r ```sql\r SELECT [TotalSalesAmount] = SUM(SalesAmount)\r FROM dbo.FactInternetSales s\r INNER JOIN dbo.DimDate d\r   ON d.DateKey = s.OrderDateKey\r INNER JOIN dbo.DimSalesTerritory t\r   ON t.SalesTerritoryKey = s.SalesTerritoryKey\r WHERE d.FiscalYear = 2004\r   AND t.SalesTerritoryGroup = 'North America'\r ```\r 我们已将 `DimDate` 和 `DimSalesTerritory` 重新创建为循环表。 因此，查询显示了以下查询计划，该计划具有多个广播移动操作： \r \r ![轮循查询计划](media/design-guidance-for-replicated-tables/round-robin-tables-query-plan.jpg) \r \r 我们将 `DimDate` 和 `DimSalesTerritory` 重新创建为复制的表，然后再次运行了查询。 得到的查询计划短了很多，而且没有任何广播移动。\r \r ![复制查询计划](media/design-guidance-for-replicated-tables/replicated-tables-query-plan.jpg) \r \r ## <a name=\"performance-considerations-for-modifying-replicated-tables\"></a>修改复制的表时的性能注意事项\r SQL 数据仓库通过维护表的主版本来实现复制的表。 它将主版本复制到每个计算节点上的一个分发数据库。 当发生更改时，SQL 数据仓库首先更新主表。 然后，它要求在每个计算节点上重新生成该表。 重新生成复制的表包括将该表复制到每个计算节点并重新生成索引。\r \r 发生下列情况后，需要重新生成：\r - 加载或修改了数据\r - 数据仓库缩放为不同的[服务级别](performance-tiers.md#service-levels)\r - 更新了表定义\r \r 发生下列情况后，不需要重新生成：\r - 暂停操作\r - 恢复操作\r \r 在修改数据后，重新生成不会立即进行。 重新生成将在查询首次从表中选择数据时触发。  在针对表执行首个 select 语句时，有一些步骤是重新生成复制的表。  因为重新生成是在查询内执行的，所以对首个 select 语句的影响可能比较显著，具体取决于表的大小。  如果涉及的多个复制的表都需要重新生成，则会在该语句的步骤中连续重新生成每个副本。  在重新生成复制的表期间，为了维护数据一致性，会在该表上放置一个排他锁。  该锁将阻止在重新生成持续时间内对该表的所有访问。 \r \r ### <a name=\"use-indexes-conservatively\"></a>谨慎使用索引\r 标准索引做法适用于复制的表。 在重新生成过程中，SQL 数据仓库会重新生成每个复制的表索引。 只有当提升性能比重新生成索引的成本更重要时，才应使用索引。  \r \r ### <a name=\"batch-data-loads\"></a>批量数据加载\r 向复制的表中加载数据时，请尝试通过批量处理加载来尽量减少重新生成。 请在运行 select 语句之前执行所有批量加载。\r \r 例如，以下加载模式从四个源加载数据并调用四个重新生成。 \r \r - 从源 1 进行加载。\r - Select 语句触发重新生成 1。\r - 从源 2 进行加载。\r - Select 语句触发重新生成 2。\r - 从源 3 进行加载。\r - Select 语句触发重新生成 3。\r - 从源 4 进行加载。\r - Select 语句触发重新生成 4。\r \r 例如，以下加载模式从四个源加载数据，但仅调用一个重新生成。\r \r - 从源 1 进行加载。\r - 从源 2 进行加载。\r - 从源 3 进行加载。\r - 从源 4 进行加载。\r - Select 语句触发重新生成。\r \r ### <a name=\"rebuild-a-replicated-table-after-a-batch-load\"></a>在批量加载后重新生成复制的表\r 为确保一致的查询执行时间，建议在批量加载后强制刷新复制的表。 否则，首个查询必须等待表进行刷新，这包括重新生成索引。 这对性能的影响可能比较显著，具体取决于受影响的复制的表的大小和数量。  \r \r 以下查询使用 [sys.pdw_replicated_table_cache_state](https://docs.microsoft.com/sql/relational-databases/system-catalog-views/sys-pdw-replicated-table-cache-state-transact-sql) DMV 列出已修改但未重新生成的复制的表。\r \r ```sql \r SELECT [ReplicatedTable] = t.[name]\r   FROM sys.tables t  \r   JOIN sys.pdw_replicated_table_cache_state c  \r     ON c.object_id = t.object_id \r   JOIN sys.pdw_table_distribution_properties p \r     ON p.object_id = t.object_id \r   WHERE c.[state] = 'NotReady'\r     AND p.[distribution_policy_desc] = 'REPLICATE'\r ```\r \r 若要强制重新生成，请对前面的输出中的每个表运行以下语句。 \r \r ```sql\r SELECT TOP 1 * FROM [ReplicatedTable]\r ``` \r \r ## <a name=\"next-steps\"></a>后续步骤 \r 若要创建复制的表，请使用下列语句之一：\r \r - [CREATE TABLE（Azure SQL 数据仓库）](https://docs.microsoft.com/sql/t-sql/statements/create-table-azure-sql-data-warehouse)\r - [CREATE TABLE AS SELECT（Azure SQL 数据仓库）](https://docs.microsoft.com/sql/t-sql/statements/create-table-as-select-azure-sql-data-warehouse)\r \r 有关分布式表的概述，请参阅[分布式表](sql-data-warehouse-tables-distribute.md)。\r \r <!--Update_Description: wording update, update link -->"}