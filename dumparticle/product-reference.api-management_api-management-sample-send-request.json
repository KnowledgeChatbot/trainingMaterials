{"Title":"使用 API 管理服务生成 HTTP 请求","Description":"了解如何使用 API 管理中的请求和响应策略从 API 调用外部服务","Content":"# <a name=\"using-external-services-from-the-azure-api-management-service\"></a>通过 Azure API 管理服务使用外部服务\r Azure API 管理服务中的策略可以单纯根据传入的请求、传出的响应以及基本配置信息执行多种不同的有用工作。 但是，如果能够与 API 管理策略中的外部服务进行交互，则可以使更多的想法成为可能。\r \r 我们以前曾经介绍过如何与[日志记录、监视及分析的 Azure 事件中心服务](./api-management-log-to-eventhub-sample.md)交互。 本文将演示可用来与基于 HTTP 的任何外部服务进行交互的策略。 这些策略可用于触发远程事件，或检索可用于以某种方式处理原始请求和响应的信息。\r \r ## <a name=\"send-one-way-request\"></a>Send-One-Way-Request\r 最简单的外部交互方式也许是即发即弃，使外部服务能够获得某种重要事件的通知。 我们可以使用控制流策略 `choose` 来检测任何一种感兴趣的状况，如果条件成立，可以使用 [send-one-way-request](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendOneWayRequest) 策略发出外部 HTTP 请求。 这可以是对消息传送系统（例如 Hipchat 或 Slack）的请求，也可能是对邮件 API（例如 SendGrid 或 MailChimp）的请求，或者是针对某些例如 PagerDuty 的重大支持事件的请求。 所有这些消息传送系统都提供可方便调用的简单 HTTP API。\r \r ### <a name=\"alerting-with-slack\"></a>使用 Slack 发出警报\r 以下示例演示了当 HTTP 响应状态代码大于或等于 500 时如何将消息发送到 Slack 聊天室。 500 范围错误表示后端 API 发生问题，而 API 的客户端无法解决此类问题。 通常我们需要进行某种形式的介入。  \r \r ```xml\r <choose>\r     <when condition=\"@(context.Response.StatusCode >= 500)\">\r       <send-one-way-request mode=\"new\">\r         <set-url>https://hooks.slack.com/services/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</set-url>\r         <set-method>POST</set-method>\r         <set-body>@{\r                 return new JObject(\r                         new JProperty(\"username\",\"APIM Alert\"),\r                         new JProperty(\"icon_emoji\", \":ghost:\"),\r                         new JProperty(\"text\", String.Format(\"{0} {1}\\nHost: {2}\\n{3} {4}\\n User: {5}\",\r                                                 context.Request.Method,\r                                                 context.Request.Url.Path + context.Request.Url.QueryString,\r                                                 context.Request.Url.Host,\r                                                 context.Response.StatusCode,\r                                                 context.Response.StatusReason,\r                                                 context.User.Email\r                                                 ))\r                         ).ToString();\r             }</set-body>\r       </send-one-way-request>\r     </when>\r </choose>\r ```\r \r Slack 具有入站 Web Hook 的概念。 配置入站 Web Hook 时，Slack 将生成特殊的 URL，让用户执行简单的 POST 请求，并将消息传递到 Slack 通道。 我们创建的 JSON 主体基于 Slack 定义的格式。\r \r ![Slack Web Hook](./media/api-management-sample-send-request/api-management-slack-webhook.png)\r \r ### <a name=\"is-fire-and-forget-good-enough\"></a>即发即弃是否足够好？\r 使用请求的即发即弃形式有一些特定的权衡取舍。 如果出于某些原因导致请求失败，系统不会报告失败。 在这种特定情况下，无法保证具有辅助失败报告系统的复杂性，以及等待响应所需的其他性能成本。 如果检查响应很重要，则 [send-request](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendRequest) 策略是较好的选项。\r \r ## <a name=\"send-request\"></a>Send-Request\r `send-request` 策略能够使用外部服务来执行复杂的处理函数，并将数据返回到 API 管理服务，此服务可用于进一步处理策略。\r \r ### <a name=\"authorizing-reference-tokens\"></a>授权引用令牌\r API 管理的主要功能是保护后端资源。 如果 API 使用的授权服务器可以像 Azure Active Directory 一样在其 OAuth2 流程中创建 [JWT 令牌](http://jwt.io/)，则可以使用 `validate-jwt` 策略来验证令牌的有效性。 但是，某些授权服务器创建所谓的[引用令牌](http://leastprivilege.com/2015/11/25/reference-tokens-and-introspection/)，这些令牌无法在不对授权服务器进行回调的情况下进行验证。\r \r ### <a name=\"standardized-introspection\"></a>标准化自检\r 过去一直没有标准化的方式可使用授权服务器来验证引用令牌。 但是，IETF 最近发布的提议标准 [RFC 7662](https://tools.ietf.org/html/rfc7662) 定义了资源服务器如何验证令牌的有效性。\r \r ### <a name=\"extracting-the-token\"></a>提取令牌\r 第一个步骤是从授权标头提取令牌。 标头值应该使用 `Bearer` 授权方案、单个空格和授权令牌根据 [RFC 6750](http://tools.ietf.org/html/rfc6750#section-2.1) 进行格式化。 但是，有一些情况需要省略授权分配。 为了在分析时说明这一点，我们使用空格来分区标头值，并从字符串的返回数组中选择最后一个字符串。 这样可为格式错误的授权标头提供应对措施。\r \r ```xml\r <set-variable name=\"token\" value=\"@(context.Request.Headers.GetValueOrDefault(\"Authorization\",\"scheme param\").Split(' ').Last())\" />\r ```\r \r ### <a name=\"making-the-validation-request\"></a>发出验证请求\r 获取授权令牌后，可以发出请求来验证令牌。 RFC 7662 调用此程序进行自检，并请求将 HTML 窗体 `POST` 到自检资源。 HTML 窗体必须至少包含具有键 `token` 的键/值对。 对授权服务器的请求也必须经过身份验证，确保恶意客户端无法获取有效令牌。\r \r ```xml\r <send-request mode=\"new\" response-variable-name=\"tokenstate\" timeout=\"20\" ignore-error=\"true\">\r   <set-url>https://microsoft-apiappec990ad4c76641c6aea22f566efc5a4e.azurewebsites.net/introspection</set-url>\r   <set-method>POST</set-method>\r   <set-header name=\"Authorization\" exists-action=\"override\">\r     <value>basic dXNlcm5hbWU6cGFzc3dvcmQ=</value>\r   </set-header>\r   <set-header name=\"Content-Type\" exists-action=\"override\">\r     <value>application/x-www-form-urlencoded</value>\r   </set-header>\r   <set-body>@($\"token={(string)context.Variables[\"token\"]}\")</set-body>\r </send-request>\r ```\r \r ### <a name=\"checking-the-response\"></a>检查响应\r `response-variable-name` 属性用于提供所返回响应的访问权限。 此属性中定义的名称可以用于作为 `context.Variables` 字典的键来访问 `IResponse` 对象。\r \r 从响应对象中可以检索主体，RFC 7622 告诉我们，响应必须是 JSON 对象，并且必须至少包含一个名为 `active` 的属性（布尔值）。 如果 `active` 为 true，则令牌被视为有效。\r \r ### <a name=\"reporting-failure\"></a>报告失败\r 我们使用 `<choose>` 策略来检测令牌是否无效，如果无效，则返回 401 响应。\r \r ```xml\r <choose>\r   <when condition=\"@((bool)((IResponse)context.Variables[\"tokenstate\"]).Body.As<JObject>()[\"active\"] == false)\">\r     <return-response response-variable-name=\"existing response variable\">\r       <set-status code=\"401\" reason=\"Unauthorized\" />\r       <set-header name=\"WWW-Authenticate\" exists-action=\"override\">\r         <value>Bearer error=\"invalid_token\"</value>\r       </set-header>\r     </return-response>\r   </when>\r </choose>\r ```\r \r 根据 [RFC 6750](https://tools.ietf.org/html/rfc6750#section-3) 中说明的 `bearer` 令牌的使用方式，我们还返回了 `WWW-Authenticate` 标头以及 401 响应。 WWW-Authenticate 的目的是告诉客户端如何构造适当授权的请求。 由于有各式各样可能具有 OAuth2 架构的处理方法，因此很难传达所有必要的信息。 幸运的是，我们仍持续努力来帮助[客户端发现如何适当地将请求授权给资源服务器](http://tools.ietf.org/html/draft-jones-oauth-discovery-00)。\r \r ### <a name=\"final-solution\"></a>最终解决方案\r 将所有信息放在一起，就能得到以下策略：\r \r ```xml\r <inbound>\r   <!-- Extract Token from Authorization header parameter -->\r   <set-variable name=\"token\" value=\"@(context.Request.Headers.GetValueOrDefault(\"Authorization\",\"scheme param\").Split(' ').Last())\" />\r \r   <!-- Send request to Token Server to validate token (see RFC 7662) -->\r   <send-request mode=\"new\" response-variable-name=\"tokenstate\" timeout=\"20\" ignore-error=\"true\">\r     <set-url>https://microsoft-apiappec990ad4c76641c6aea22f566efc5a4e.azurewebsites.net/introspection</set-url>\r     <set-method>POST</set-method>\r     <set-header name=\"Authorization\" exists-action=\"override\">\r       <value>basic dXNlcm5hbWU6cGFzc3dvcmQ=</value>\r     </set-header>\r     <set-header name=\"Content-Type\" exists-action=\"override\">\r       <value>application/x-www-form-urlencoded</value>\r     </set-header>\r     <set-body>@($\"token={(string)context.Variables[\"token\"]}\")</set-body>\r   </send-request>\r \r   <choose>\r           <!-- Check active property in response -->\r           <when condition=\"@((bool)((IResponse)context.Variables[\"tokenstate\"]).Body.As<JObject>()[\"active\"] == false)\">\r               <!-- Return 401 Unauthorized with http-problem payload -->\r               <return-response response-variable-name=\"existing response variable\">\r                   <set-status code=\"401\" reason=\"Unauthorized\" />\r                   <set-header name=\"WWW-Authenticate\" exists-action=\"override\">\r                       <value>Bearer error=\"invalid_token\"</value>\r                   </set-header>\r               </return-response>\r           </when>\r       </choose>\r   <base />\r </inbound>\r ```\r \r 这是众多示例中唯一一个说明如何使用 `send-request` 策略，通过 API 管理服务将有用的外部服务集成到请求和响应的过程。\r \r ## <a name=\"response-composition\"></a>响应组合\r `send-request` 策略可用于增强对后端系统的主要请求（如同我们在上述示例中所见），或者用于完全取代后端调用。 使用此技术可以轻松创建聚合自多个不同系统的复合资源。\r \r ### <a name=\"building-a-dashboard\"></a>构建仪表板\r 有时我们希望能够公开多个后端系统中的信息，例如，驱动仪表板。 KPI 来自所有不同的后端，但是习惯不提供它们的直接访问权限，并且如果所有信息都是检索自单个请求，这就非常有用。 也许有些后端信息需要进行某种切片和细分，需要先稍微处理一下！ 如果知道用户习惯按 F5 键来查看其性能不佳的指标是否可能更改时，为了降低后端负载，能够缓存该复合资源就非常有用。    \r \r ### <a name=\"faking-the-resource\"></a>伪装资源\r 构建仪表板资源的第一个步骤是在 API 管理发布者门户中配置新的操作。 这用于设置编写策略以构建动态资源的占位符操作。\r \r ![仪表板操作](./media/api-management-sample-send-request/api-management-dashboard-operation.png)\r \r ### <a name=\"making-the-requests\"></a>发出请求\r 创建 `dashboard` 操作后，可以专门针对该操作配置策略。 \r \r ![仪表板操作](./media/api-management-sample-send-request/api-management-dashboard-policy.png)\r \r 第一个步骤是提取来自传入请求的任何查询参数，以便可以将其转发到后端。 在本示例中，仪表板每隔一段时间显示信息，因此具有 `fromDate` 和 `toDate` 参数。 我们可以使用 `set-variable` 策略来提取请求 URL 中的信息。\r \r ```xml\r <set-variable name=\"fromDate\" value=\"@(context.Request.Url.Query[\"fromDate\"].Last())\">\r <set-variable name=\"toDate\" value=\"@(context.Request.Url.Query[\"toDate\"].Last())\">\r ```\r \r 获取此信息后，可以对所有后端系统发出请求。 每个请求使用参数信息构造新 URL，调用相应的服务器，并将响应存储在上下文变量中。\r \r ```xml\r <send-request mode=\"new\" response-variable-name=\"revenuedata\" timeout=\"20\" ignore-error=\"true\">\r   <set-url>@($\"https://accounting.acme.com/salesdata?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\r   <set-method>GET</set-method>\r </send-request>\r \r <send-request mode=\"new\" response-variable-name=\"materialdata\" timeout=\"20\" ignore-error=\"true\">\r   <set-url>@($\"https://inventory.acme.com/materiallevels?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\r   <set-method>GET</set-method>\r </send-request>\r \r <send-request mode=\"new\" response-variable-name=\"throughputdata\" timeout=\"20\" ignore-error=\"true\">\r <set-url>@($\"https://production.acme.com/throughput?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\r   <set-method>GET</set-method>\r </send-request>\r \r <send-request mode=\"new\" response-variable-name=\"accidentdata\" timeout=\"20\" ignore-error=\"true\">\r <set-url>@($\"https://production.acme.com/throughput?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\r   <set-method>GET</set-method>\r </send-request>\r ```\r \r 这些请求将按顺序执行，但这不是理想的做法。 在即将推出的版本中，将引入名为 `wait` 的新策略，它能使所有这些请求并行运行。\r \r ### <a name=\"responding\"></a>响应\r 若要构造复合响应，可以使用 [return-response](https://msdn.microsoft.com/library/azure/dn894085.aspx#ReturnResponse) 策略。 `set-body` 元素可以使用表达式构造新的 `JObject` 以及嵌入为属性的所有组件表示形式。\r \r ```xml\r <return-response response-variable-name=\"existing response variable\">\r   <set-status code=\"200\" reason=\"OK\" />\r   <set-header name=\"Content-Type\" exists-action=\"override\">\r     <value>application/json</value>\r   </set-header>\r   <set-body>\r     @(new JObject(new JProperty(\"revenuedata\",((IResponse)context.Variables[\"revenuedata\"]).Body.As<JObject>()),\r                   new JProperty(\"materialdata\",((IResponse)context.Variables[\"materialdata\"]).Body.As<JObject>()),\r                   new JProperty(\"throughputdata\",((IResponse)context.Variables[\"throughputdata\"]).Body.As<JObject>()),\r                   new JProperty(\"accidentdata\",((IResponse)context.Variables[\"accidentdata\"]).Body.As<JObject>())\r                   ).ToString())\r   </set-body>\r </return-response>\r ```\r \r 完整的策略如下所示：\r \r ```xml\r <policies>\r     <inbound>\r \r   <set-variable name=\"fromDate\" value=\"@(context.Request.Url.Query[\"fromDate\"].Last())\">\r   <set-variable name=\"toDate\" value=\"@(context.Request.Url.Query[\"toDate\"].Last())\">\r \r     <send-request mode=\"new\" response-variable-name=\"revenuedata\" timeout=\"20\" ignore-error=\"true\">\r       <set-url>@($\"https://accounting.acme.com/salesdata?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\r       <set-method>GET</set-method>\r     </send-request>\r \r     <send-request mode=\"new\" response-variable-name=\"materialdata\" timeout=\"20\" ignore-error=\"true\">\r       <set-url>@($\"https://inventory.acme.com/materiallevels?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\r       <set-method>GET</set-method>\r     </send-request>\r \r     <send-request mode=\"new\" response-variable-name=\"throughputdata\" timeout=\"20\" ignore-error=\"true\">\r     <set-url>@($\"https://production.acme.com/throughput?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\r       <set-method>GET</set-method>\r     </send-request>\r \r     <send-request mode=\"new\" response-variable-name=\"accidentdata\" timeout=\"20\" ignore-error=\"true\">\r     <set-url>@($\"https://production.acme.com/throughput?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\r       <set-method>GET</set-method>\r     </send-request>\r \r     <return-response response-variable-name=\"existing response variable\">\r       <set-status code=\"200\" reason=\"OK\" />\r       <set-header name=\"Content-Type\" exists-action=\"override\">\r         <value>application/json</value>\r       </set-header>\r       <set-body>\r         @(new JObject(new JProperty(\"revenuedata\",((IResponse)context.Variables[\"revenuedata\"]).Body.As<JObject>()),\r                       new JProperty(\"materialdata\",((IResponse)context.Variables[\"materialdata\"]).Body.As<JObject>()),\r                       new JProperty(\"throughputdata\",((IResponse)context.Variables[\"throughputdata\"]).Body.As<JObject>()),\r                       new JProperty(\"accidentdata\",((IResponse)context.Variables[\"accidentdata\"]).Body.As<JObject>())\r                       ).ToString())\r       </set-body>\r     </return-response>\r     </inbound>\r     <backend>\r         <base />\r     </backend>\r     <outbound>\r         <base />\r     </outbound>\r </policies>\r ```\r \r 在占位符操作的配置中，可以将仪表板资源设置为至少缓存一小时，因为我们知道数据的性质意味着即使它在一个小时后就会过期，但仍可以充分有效地向用户传达重要信息。\r \r ## <a name=\"summary\"></a>摘要\r Azure API 管理服务提供可根据需要应用到 HTTP 流量的灵活策略，并支持后端服务的组合。 不管是要使用警报、校验、验证功能还是基于多个后端服务创建新的复合资源来增强 API 网关，`send-request` 和相关策略都能使这种想法成为可能。\r \r \r "}