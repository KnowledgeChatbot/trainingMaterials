{"Title":"通知中心突发新闻教程 - iOS","Description":"了解如何使用 Azure 服务总线通知中心向 iOS 设备发送突发新闻通知。","Content":"\r # 使用通知中心发送突发新闻\r \r [!INCLUDE [notification-hubs-selector-breaking-news](../../includes/notification-hubs-selector-breaking-news.md)]\r \r ## 概述\r \r 本主题说明如何使用 Azure 通知中心将突发新闻通知广播到 iOS 应用程序。完成时，你可以注册感兴趣的突发新闻类别并仅接收这些类别的推送通知。此方案对于很多应用程序来说是常见模式，在其中必须将通知发送到以前声明过对它们感兴趣的一组用户，这样的应用程序有 RSS 阅读器、针对音乐迷的应用程序等。\r \r 在创建通知中心的注册时，通过加入一个或多个标记来启用广播方案。将通知发送到标签时，已注册该标签的所有设备将接收通知。因为标签是简单的字符串，它们不必提前设置。有关标记的详细信息，请参阅[通知中心路由和标记表达式](./notification-hubs-tags-segment-push-message.md)。\r \r ## 先决条件\r \r 本主题以你在[通知中心入门][get-started]中创建的应用程序为基础。在开始本教程之前，必须先阅读[通知中心入门][get-started]。\r \r ## 向应用程序中添加类别选择\r \r 第一步是向现有 Storyboard 添加 UI 元素，这些元素允许用户选择要注册的类别。用户选择的类别存储在设备上。应用程序启动时，使用所选类别作为标签在你的通知中心创建设备注册。\r \r 1. 在 MainStoryboard\\_iPhone.storyboard 中，从对象库添加以下组件：\r     + 具有“Breaking News”文本的标签\r     + 具有“World”、“Politics”、“Business”、“Technology”、“Science”、“Sports”类别文本的标签\r     + 六个开关，每个类别一个。默认情况下，每个开关的 **State** 设置为 **Off**。\r     + 一个标有“Subscribe”的按钮\r \r     Storyboard 应类似于：\r \r     ![][3]\r \r 2. 在助手编辑器中，为所有开关创建插座并称它们为“WorldSwitch”、“PoliticsSwitch”、“BusinessSwitch”、“TechnologySwitch”、“ScienceSwitch”、“SportsSwitch”\r \r 3. 为名为“subscribe”的按钮创建一个操作。ViewController.h 应包含以下内容：\r \r     ```\r     @property (weak, nonatomic) IBOutlet UISwitch *WorldSwitch;\r     @property (weak, nonatomic) IBOutlet UISwitch *PoliticsSwitch;\r     @property (weak, nonatomic) IBOutlet UISwitch *BusinessSwitch;\r     @property (weak, nonatomic) IBOutlet UISwitch *TechnologySwitch;\r     @property (weak, nonatomic) IBOutlet UISwitch *ScienceSwitch;\r     @property (weak, nonatomic) IBOutlet UISwitch *SportsSwitch;\r \r     - (IBAction)subscribe:(id)sender;\r     ```\r \r 4. 创建名为 `Notifications` 的新 **Cocoa Touch 类**。在文件 Notifications.h 的接口部分中复制以下代码：\r \r     ```\r     @property NSData* deviceToken;\r \r     - (id)initWithConnectionString:(NSString*)listenConnectionString HubName:(NSString*)hubName;\r \r     - (void)storeCategoriesAndSubscribeWithCategories:(NSArray*)categories\r                 completion:(void (^)(NSError* error))completion;\r \r     - (NSSet*)retrieveCategories;\r \r     - (void)subscribeWithCategories:(NSSet*)categories completion:(void (^)(NSError *))completion;\r     ```\r \r 5. 将以下导入指令添加到 Notifications.m：\r \r     ```\r     #import <WindowsAzureMessaging/WindowsAzureMessaging.h>\r     ```\r \r 6. 在文件 Notifications.m 的实现部分中复制以下代码。\r \r     ```\r     SBNotificationHub* hub;\r \r     - (id)initWithConnectionString:(NSString*)listenConnectionString HubName:(NSString*)hubName{\r \r         hub = [[SBNotificationHub alloc] initWithConnectionString:listenConnectionString\r                                     notificationHubPath:hubName];\r \r         return self;\r     }\r \r     - (void)storeCategoriesAndSubscribeWithCategories:(NSSet *)categories completion:(void (^)(NSError *))completion {\r         NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];\r         [defaults setValue:[categories allObjects] forKey:@\"BreakingNewsCategories\"];\r \r         [self subscribeWithCategories:categories completion:completion];\r     }\r \r     - (NSSet*)retrieveCategories {\r         NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];\r \r         NSArray* categories = [defaults stringArrayForKey:@\"BreakingNewsCategories\"];\r \r         if (!categories) return [[NSSet alloc] init];\r         return [[NSSet alloc] initWithArray:categories];\r     }\r \r     - (void)subscribeWithCategories:(NSSet *)categories completion:(void (^)(NSError *))completion\r     {\r        //[hub registerNativeWithDeviceToken:self.deviceToken tags:categories completion: completion];\r \r         NSString* templateBodyAPNS = @\"{\"aps\":{\"alert\":\"$(messageParam)\"}}\";\r \r         [hub registerTemplateWithDeviceToken:self.deviceToken name:@\"simpleAPNSTemplate\" \r             jsonBodyTemplate:templateBodyAPNS expiryTemplate:@\"0\" tags:categories completion:completion];\r     }\r     ```\r \r     此类使用本地存储区存储和检索此设备将要接收的新闻类别。此外，它还包含了一个方法用于通过[模板](./notification-hubs-templates-cross-platform-push-messages.md)注册来注册这些类别。\r \r 7. 在 AppDelegate.h 文件中，添加 Notifications.h 的导入语句，并添加 Notifications 类实例的属性：\r \r     ```\r     #import \"Notifications.h\"\r \r     @property (nonatomic) Notifications* notifications;\r     ```\r \r 8. 在 AppDelegate.m 的 **didFinishLaunchingWithOptions** 方法中，于方法开头添加代码来初始化 notifications 实例：\r \r     在 hubinfo.h 中定义的 `HUBNAME` 和 `HUBLISTENACCESS` 内，`<hub name>` 和 `<connection string with listen access>` 占位符应已替换为你的通知中心的名称和你之前获取的 *DefaultListenSharedAccessSignature* 的连接字符串。\r \r     ```\r     self.notifications = [[Notifications alloc] initWithConnectionString:HUBLISTENACCESS HubName:HUBNAME];\r     ```\r \r     > [!NOTE]\r     > 由于使用客户端应用程序分发的凭据通常是不安全的，你只应使用客户端应用程序分发具有侦听访问权限的密钥。侦听访问权限允许应用程序注册通知，但是无法修改现有注册，也无法发送通知。在受保护的后端服务中使用完全访问权限密钥，以便发送通知和更改现有注册。\r \r 9. 在 AppDelegate.m 的 **didRegisterForRemoteNotificationsWithDeviceToken** 方法中，使用以下代码来替换方法中的代码，以将设备令牌传递给 notifications 类。notifications 类将通知注册到类别。如果用户更改类别选择，我们将调用 `subscribeWithCategories` 方法以响应“订阅”按钮来进行更新。\r \r     > [!NOTE]\r     > 由于 Apple 推送通知服务 (APNS) 分配的设备标记随时可能更改，因此你应该经常注册通知以避免通知失败。此示例在每次应用程序启动时注册通知。对于经常运行（一天一次以上）的应用程序，如果每次注册间隔时间不到一天，你可以跳过注册来节省带宽。\r \r     ```\r     self.notifications.deviceToken = deviceToken;\r \r     // Retrieves the categories from local storage and requests a registration for these categories\r     // each time the app starts and performs a registration.\r \r     NSSet* categories = [self.notifications retrieveCategories];\r     [self.notifications subscribeWithCategories:categories completion:^(NSError* error) {\r         if (error != nil) {\r             NSLog(@\"Error registering for notifications: %@\", error);\r         }\r     }];\r     ```\r \r     请注意，此时 **didRegisterForRemoteNotificationsWithDeviceToken** 方法中应没有其他代码。\r \r 10. 完成[通知中心入门][get-started]教程时，以下方法应已经出现在 AppDelegate.m 中。否则，请添加这些方法。\r \r     ```\r     -(void)MessageBox:(NSString *)title message:(NSString *)messageText\r     {\r         UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title message:messageText delegate:self\r             cancelButtonTitle:@\"OK\" otherButtonTitles: nil];\r         [alert show];\r     }\r \r     - (void)application:(UIApplication *)application didReceiveRemoteNotification:\r         (NSDictionary *)userInfo {\r         NSLog(@\"%@\", userInfo);\r         [self MessageBox:@\"Notification\" message:[[userInfo objectForKey:@\"aps\"] valueForKey:@\"alert\"]];\r     }\r     ```\r \r     此方法通过显示简单的 **UIAlert** 处理运行应用程序时收到的通知。\r \r 11. 在 ViewController.m 中，添加 AppDelegate.h 的导入语句，并将以下代码复制到 XCode 生成的 **subscribe** 方法中。此代码将更新通知注册，以使用用户在用户界面中选择的新类别标记。\r \r     ```\r     #import \"Notifications.h\"\r \r     NSMutableArray* categories = [[NSMutableArray alloc] init];\r \r     if (self.WorldSwitch.isOn) [categories addObject:@\"World\"];\r     if (self.PoliticsSwitch.isOn) [categories addObject:@\"Politics\"];\r     if (self.BusinessSwitch.isOn) [categories addObject:@\"Business\"];\r     if (self.TechnologySwitch.isOn) [categories addObject:@\"Technology\"];\r     if (self.ScienceSwitch.isOn) [categories addObject:@\"Science\"];\r     if (self.SportsSwitch.isOn) [categories addObject:@\"Sports\"];\r \r     Notifications* notifications = [(AppDelegate*)[[UIApplication sharedApplication]delegate] notifications];\r \r     [notifications storeCategoriesAndSubscribeWithCategories:categories completion: ^(NSError* error) {\r         if (!error) {\r             [(AppDelegate*)[[UIApplication sharedApplication]delegate] MessageBox:@\"Notification\" message:@\"Subscribed!\"];\r         } else {\r             NSLog(@\"Error subscribing: %@\", error);\r         }\r     }];\r     ```\r \r     此方法创建一个类别的 **NSMutableArray** 并使用 **Notifications** 类将该列表存储在本地存储区中，将相应的标记注册到你的通知中心。更改类别时，使用新类别重新创建注册。\r \r 12. 在 ViewController.m 中，于 **viewDidLoad** 方法中添加以下代码，以根据前面保存的类别来设置用户界面。\r \r     ```\r     // This updates the UI on startup based on the status of previously saved categories.\r \r     Notifications* notifications = [(AppDelegate*)[[UIApplication sharedApplication]delegate] notifications];\r \r     NSSet* categories = [notifications retrieveCategories];\r \r     if ([categories containsObject:@\"World\"]) self.WorldSwitch.on = true;\r     if ([categories containsObject:@\"Politics\"]) self.PoliticsSwitch.on = true;\r     if ([categories containsObject:@\"Business\"]) self.BusinessSwitch.on = true;\r     if ([categories containsObject:@\"Technology\"]) self.TechnologySwitch.on = true;\r     if ([categories containsObject:@\"Science\"]) self.ScienceSwitch.on = true;\r     if ([categories containsObject:@\"Sports\"]) self.SportsSwitch.on = true;\r     ```\r \r 应用程序现在可以在设备的本地存储区中存储一组类别，每当应用程序启动时，将使用这些类别注册到通知中心。用户可以在运行时更改选择的类别，然后单击 **subscribe** 方法来更新设备注册。接下来，你将更新应用程序，以直接从应用本身发送突发新闻通知。\r \r ## （可选）发送带标记的通知\r \r 如果你无权访问 Visual Studio，可以跳到下一部分，并从应用内部发送通知。你还可以在 [Azure 经典管理门户]中使用通知中心的调试选项卡发送适当的模板通知。\r \r [!INCLUDE [notification-hubs-send-categories-template](../../includes/notification-hubs-send-categories-template.md)]\r \r ## （可选）从设备发送通知\r \r 通常，通知将由后端服务发送，但你也可以直接从应用发送突发新闻通知。为此，我们需要更新[通知中心入门][get-started]教程中所定义的 `SendNotificationRESTAPI` 方法。\r \r 1. 在 ViewController.m 中，按如下所示更新 `SendNotificationRESTAPI` 方法，使其接受类别标记的参数并发送适当的[模板](./notification-hubs-templates-cross-platform-push-messages.md)通知。\r \r     ```\r     - (void)SendNotificationRESTAPI:(NSString*)categoryTag\r     {\r         NSURLSession* session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration\r                                  defaultSessionConfiguration] delegate:nil delegateQueue:nil];\r \r         NSString *json;\r \r         // Construct the messages REST endpoint\r         NSURL* url = [NSURL URLWithString:[NSString stringWithFormat:@\"%@%@/messages/%@\", HubEndpoint,\r                                            HUBNAME, API_VERSION]];\r \r         // Generated the token to be used in the authorization header.\r         NSString* authorizationToken = [self generateSasToken:[url absoluteString]];\r \r         //Create the request to add the template notification message to the hub\r         NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];\r         [request setHTTPMethod:@\"POST\"];\r \r         // Add the category as a tag\r         [request setValue:categoryTag forHTTPHeaderField:@\"ServiceBusNotification-Tags\"];\r \r         // Template notification\r         json = [NSString stringWithFormat:@\"{\"messageParam\":\"Breaking %@ News : %@\"}\",\r                 categoryTag, self.notificationMessage.text];\r \r         // Signify template notification format\r         [request setValue:@\"template\" forHTTPHeaderField:@\"ServiceBusNotification-Format\"];\r \r         // JSON Content-Type\r         [request setValue:@\"application/json;charset=utf-8\" forHTTPHeaderField:@\"Content-Type\"];\r \r         //Authenticate the notification message POST request with the SaS token\r         [request setValue:authorizationToken forHTTPHeaderField:@\"Authorization\"];\r \r         //Add the notification message body\r         [request setHTTPBody:[json dataUsingEncoding:NSUTF8StringEncoding]];\r \r         // Send the REST request\r         NSURLSessionDataTask* dataTask = [session dataTaskWithRequest:request\r                    completionHandler:^(NSData *data, NSURLResponse *response, NSError *error)\r            {\r            NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*) response;\r                if (error || httpResponse.statusCode != 200)\r                {\r                    NSLog(@\"\\nError status: %d\\nError: %@\", httpResponse.statusCode, error);\r                }\r                if (data != NULL)\r                {\r                    //xmlParser = [[NSXMLParser alloc] initWithData:data];\r                    //[xmlParser setDelegate:self];\r                    //[xmlParser parse];\r                }\r            }];\r \r         [dataTask resume];\r     }\r     ```\r \r 2. 在 ViewController.m 中，更新“发送通知”操作（如以下代码所示）。因此，它将使用每个标记分别发送通知，并发送到多个平台。\r \r     ```\r     - (IBAction)SendNotificationMessage:(id)sender\r     {\r         self.sendResults.text = @\"\";\r \r         NSArray* categories = [NSArray arrayWithObjects: @\"World\", @\"Politics\", @\"Business\",\r                                 @\"Technology\", @\"Science\", @\"Sports\", nil];\r \r         // Lets send the message as breaking news for each category to WNS, GCM, and APNS\r         // using a template.\r         for(NSString* category in categories)\r         {\r             [self SendNotificationRESTAPI:category];\r         }\r     }\r     ```\r \r 3. 重新生成项目，并确定没有生成错误。\r \r ##运行应用并生成通知\r \r 1. 按“运行”按钮生成项目并启动应用程序。选择要订阅的一些突发新闻选项，然后按“订阅”按钮。你应会看到一个对话框，表示已订阅通知。\r \r     ![][1]\r \r     选择“订阅”时，应用程序将所选类别转换为标记并针对所选标签从通知中心请求注册新设备。\r \r 2. 输入要以突发新闻形式发送的消息，然后按“发送通知”按钮。或者，运行 .NET 控制台应用以生成通知。\r \r     ![][2]\r \r 3. 每个订阅突发新闻的设备都会收到刚刚发送的突发新闻通知。\r \r ## 后续步骤\r \r 在本教程中，我们了解了如何按类别广播突发消息。请考虑学习侧重说明其他高级通知中心方案的以下教程之一：\r \r + **[使用通知中心广播本地化的突发新闻]**\r \r     了解如何扩展突发新闻应用程序以允许发送本地化的通知。\r \r <!-- Images. -->\r [1]: ./media/notification-hubs-ios-xplat-segmented-apns-push-notification/notification-hub-breakingnews-subscribed.png\r [2]: ./media/notification-hubs-ios-xplat-segmented-apns-push-notification/notification-hub-breakingnews-ios1.png\r [3]: ./media/notification-hubs-ios-xplat-segmented-apns-push-notification/notification-hub-breakingnews-ios2.png\r \r <!-- URLs. -->\r [How To: Service Bus Notification Hubs (iOS Apps)]: http://msdn.microsoft.com/zh-cn/library/jj927168.aspx\r [使用通知中心广播本地化的突发新闻]: ./notification-hubs-ios-xplat-localized-apns-push-notification.md\r [Notify users with Notification Hubs]: ./notification-hubs-aspnet-backend-ios-apple-apns-notification.md\r [Notification Hubs Guidance]: http://msdn.microsoft.com/zh-cn/library/dn530749.aspx\r [Notification Hubs How-To for iOS]: http://msdn.microsoft.com/zh-cn/library/jj927168.aspx\r [get-started]: ./notification-hubs-ios-apple-push-notification-apns-get-started.md\r [Azure 经典管理门户]: https://manage.windowsazure.cn\r \r <!---HONumber=Mooncake_0808_2016-->"}