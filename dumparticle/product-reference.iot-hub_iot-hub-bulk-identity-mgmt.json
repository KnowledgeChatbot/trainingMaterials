{"Title":"导入和导出 Azure IoT 中心设备标识","Description":"如何使用 Azure IoT 服务 SDK 针对标识注册表执行批量操作，以导入和导出设备标识。 借助导入操作，可批量创建、更新和删除设备标识。","Content":"# <a name=\"manage-your-iot-hub-device-identities-in-bulk\"></a>批量管理 IoT 中心设备标识\r \r 每个 IoT 中心都有一个标识注册表，可以使用该注册表在服务中创建每设备资源。 标识注册表还可用于控制对面向设备的终结点的访问。 本文介绍如何从标识注册表批量导入和导出设备标识。\r \r 导入和导出操作在 *作业* 的上下文中进行，可让用户对 IoT 中心执行批量服务操作。\r \r **RegistryManager** 类包括使用**作业**框架的 **ExportDevicesAsync** 和 **ImportDevicesAsync** 方法。 这些方法可以导出、导入和同步整个 IoT 中心标识注册表。\r \r ## <a name=\"what-are-jobs\"></a>什么是作业？\r \r 当操作出现以下情况时，标识注册表操作使用“作业”系统：\r \r * 相较标准运行时操作，其执行时间可能很长。\r * 向用户返回大量数据。\r \r 操作将以异步方式为该 IoT 中心创建**作业**，而不是对操作结果进行单一的 API 调用等待或阻塞。 然后，操作立即返回 **JobProperties** 对象。\r \r 以下 C# 代码段演示如何创建导出作业：\r \r ```csharp\r // Call an export job on the IoT Hub to retrieve all devices\r JobProperties exportJob = await registryManager.ExportDevicesAsync(containerSasUri, false);\r ```\r \r > [!NOTE]\r > 若要在 C# 代码中使用 **RegistryManager** 类，请将 **Microsoft.Azure.Devices** NuGet 包添加到项目。 **RegistryManager** 类位于 **Microsoft.Azure.Devices** 命名空间。\r \r \r 可使用 **RegistryManager** 类，查询使用返回的 **JobProperties** 元数据的**作业**的状态。\r \r 以下 C# 代码段演示如何每隔五秒轮询一次以查看作业是否已完成执行：\r \r ```csharp\r // Wait until job is finished\r while(true)\r {\r   exportJob = await registryManager.GetJobAsync(exportJob.JobId);\r   if (exportJob.Status == JobStatus.Completed || \r       exportJob.Status == JobStatus.Failed ||\r       exportJob.Status == JobStatus.Cancelled)\r   {\r     // Job has finished executing\r     break;\r   }\r \r   await Task.Delay(TimeSpan.FromSeconds(5));\r }\r ```\r \r ## <a name=\"export-devices\"></a>导出设备\r \r 使用 **ExportDevicesAsync** 方法，将整个 IoT 中心标识注册表导出到使用[共享访问签名](../storage/common/storage-security-guide.md#data-plane-security)的 [Azure 存储](/storage/) Blob 容器。\r \r 使用此方法可在所控制的 Blob 容器中创建可靠的设备信息备份。\r \r **ExportDevicesAsync** 方法需要两个参数：\r \r * 包含 Blob 容器 URI 的 *字符串* 。 此 URI 必须包含可授予容器写入权限的 SAS 令牌。 作业在此容器中创建用于存储序列化导出设备数据的块 Blob。 SAS 令牌必须包含这些权限：\r \r    ```csharp\r    SharedAccessBlobPermissions.Write | SharedAccessBlobPermissions.Read | SharedAccessBlobPermissions.Delete\r    ```\r \r * 指示你是否要在导出数据中排除身份验证密钥的 *布尔值*。 如果为 **false**，则身份验证密钥包含在导出输出中。 否则，密钥导出为 **null**。\r \r 下面的 C# 代码段演示了如何启动在导出数据中包含设备身份验证密钥的导出作业，并对完成情况进行轮询：\r \r ```csharp\r // Call an export job on the IoT Hub to retrieve all devices\r JobProperties exportJob = await registryManager.ExportDevicesAsync(containerSasUri, false);\r \r // Wait until job is finished\r while(true)\r {\r     exportJob = await registryManager.GetJobAsync(exportJob.JobId);\r     if (exportJob.Status == JobStatus.Completed || \r         exportJob.Status == JobStatus.Failed ||\r         exportJob.Status == JobStatus.Cancelled)\r     {\r     // Job has finished executing\r     break;\r     }\r \r     await Task.Delay(TimeSpan.FromSeconds(5));\r }\r ```\r \r 该作业将其输出以名为 **devices.txt** 的块 Blob 的形式存储在提供的 Blob 容器中。 输出数据包含 JSON 序列化设备数据，每行代表一个设备。\r \r 以下示例显示输出数据：\r \r ```json\r {\"id\":\"Device1\",\"eTag\":\"MA==\",\"status\":\"enabled\",\"authentication\":{\"symmetricKey\":{\"primaryKey\":\"abc=\",\"secondaryKey\":\"def=\"}}}\r {\"id\":\"Device2\",\"eTag\":\"MA==\",\"status\":\"enabled\",\"authentication\":{\"symmetricKey\":{\"primaryKey\":\"abc=\",\"secondaryKey\":\"def=\"}}}\r {\"id\":\"Device3\",\"eTag\":\"MA==\",\"status\":\"disabled\",\"authentication\":{\"symmetricKey\":{\"primaryKey\":\"abc=\",\"secondaryKey\":\"def=\"}}}\r {\"id\":\"Device4\",\"eTag\":\"MA==\",\"status\":\"disabled\",\"authentication\":{\"symmetricKey\":{\"primaryKey\":\"abc=\",\"secondaryKey\":\"def=\"}}}\r {\"id\":\"Device5\",\"eTag\":\"MA==\",\"status\":\"enabled\",\"authentication\":{\"symmetricKey\":{\"primaryKey\":\"abc=\",\"secondaryKey\":\"def=\"}}}\r ```\r \r 如果设备具有孪生数据，则孪生数据也将随设备数据一起导出。 以下示例显示了此格式。 从“twinETag”行开始直至结尾的所有数据都是孪生数据。\r \r ```json\r {\r    \"id\":\"export-6d84f075-0\",\r    \"eTag\":\"MQ==\",\r    \"status\":\"enabled\",\r    \"statusReason\":\"firstUpdate\",\r    \"authentication\":null,\r    \"twinETag\":\"AAAAAAAAAAI=\",\r    \"tags\":{\r       \"Location\":\"LivingRoom\"\r    },\r    \"properties\":{\r       \"desired\":{\r          \"Thermostat\":{\r             \"Temperature\":75.1,\r             \"Unit\":\"F\"\r          },\r          \"$metadata\":{\r             \"$lastUpdated\":\"2017-03-09T18:30:52.3167248Z\",\r             \"$lastUpdatedVersion\":2,\r             \"Thermostat\":{\r                \"$lastUpdated\":\"2017-03-09T18:30:52.3167248Z\",\r                \"$lastUpdatedVersion\":2,\r                \"Temperature\":{\r                   \"$lastUpdated\":\"2017-03-09T18:30:52.3167248Z\",\r                   \"$lastUpdatedVersion\":2\r                },\r                \"Unit\":{\r                   \"$lastUpdated\":\"2017-03-09T18:30:52.3167248Z\",\r                   \"$lastUpdatedVersion\":2\r                }\r             }\r          },\r          \"$version\":2\r       },\r       \"reported\":{\r          \"$metadata\":{\r             \"$lastUpdated\":\"2017-03-09T18:30:51.1309437Z\"\r          },\r          \"$version\":1\r       }\r    }\r }\r ```\r \r 如果需要在代码中访问此数据，可以使用 **ExportImportDevice** 类轻松反序列化此数据。 以下 C# 代码段演示如何读取前面导出到块 Blob 的设备信息：\r \r ```csharp\r var exportedDevices = new List<ExportImportDevice>();\r \r using (var streamReader = new StreamReader(await blob.OpenReadAsync(AccessCondition.GenerateIfExistsCondition(), null, null), Encoding.UTF8))\r {\r   while (streamReader.Peek() != -1)\r   {\r     string line = await streamReader.ReadLineAsync();\r     var device = JsonConvert.DeserializeObject<ExportImportDevice>(line);\r     exportedDevices.Add(device);\r   }\r }\r ```\r \r > [!NOTE]\r >  还可以使用 **RegistryManager** 类的 **GetDevicesAsync** 方法获取设备的列表。 但是，此方法有一个硬性限制，那就是返回的设备对象数最多只能有 1000 个。 **GetDevicesAsync** 方法的预期用例适用于开发方案，其目的是要帮助调试，因此不建议用于生产工作负荷。\r \r ## <a name=\"import-devices\"></a>导入设备\r \r 通过 **RegistryManager** 类中的 **ImportDevicesAsync** 方法，可以在 IoT 中心标识注册表中执行批量导入和同步操作。 如同 **ExportDevicesAsync** 方法，**ImportDevicesAsync** 方法也使用**作业**框架。\r \r 请小心使用 **ImportDevicesAsync** 方法，因为除了在标识注册表中预配新设备以外，它还可以更新和删除现有设备。\r \r > [!WARNING]\r > 导入操作不可撤消。 请始终先使用 **ExportDevicesAsync** 方法将现有数据备份到其他 Blob 容器，再对标识注册表进行批量更改。\r > \r > \r \r **ImportDevicesAsync** 方法采用两个参数：\r \r * 一个字符串，其中包含作为作业的输入使用的 [Azure 存储](/storage/) Blob 容器的 URI。 此 URI 必须包含可授予容器读取权限的 SAS 令牌。 此容器必须包含名为 **devices.txt** 的 Blob，其中包含要导入标识注册表的序列化设备数据。 导入数据包含的设备信息必须采用 **ExportImportDevice** 作业在创建 **devices.txt** Blob 时使用的同一种 JSON 格式。 SAS 令牌必须包含这些权限：\r \r    ```csharp\r    SharedAccessBlobPermissions.Read\r    ```\r \r *  一个*字符串*，其中包含用作作业*输出*的 [Azure 存储](/storage/) Blob 容器的 URI。 作业在此容器中创建块 Blob，用于存储已完成的导入 **作业**中的任何错误信息。 SAS 令牌必须包含这些权限：\r \r    ```csharp\r    SharedAccessBlobPermissions.Write | SharedAccessBlobPermissions.Read | SharedAccessBlobPermissions.Delete\r    ```\r \r > [!NOTE]\r > 这两个参数可以指向同一 Blob 容器。 单独的参数只会让你更好地控制数据，因为输出容器需要其他权限。\r \r 以下 C# 代码片段演示如何启动导入作业：\r \r ```csharp\r JobProperties importJob = await registryManager.ImportDevicesAsync(containerSasUri, containerSasUri);\r ```\r \r 还可以使用此方法导入设备孪生的数据。 数据输入的格式与 **ExportDevicesAsync** 部分中显示的格式相同。 这样，可以重新导入已导出的数据。 **$metadata** 是可选项。\r \r ## <a name=\"import-behavior\"></a>导入行为\r 可以使用 **ImportDevicesAsync** 方法在标识注册表中执行以下批量操作：\r \r -   批量注册新设备\r -   批量删除现有设备\r -   批量更改状态（启用或禁用设备）\r -   批量分配新设备身份验证密钥\r -   批量自动重新生成设备身份验证密钥\r -   批量更新孪生数据\r \r 可以在单个 **ImportDevicesAsync** 调用中执行上述操作的任意组合。 例如，可以同时注册新设备并删除或更新现有设备。 与 **ExportDevicesAsync** 方法一起使用时，可以将一个 IoT 中心内的所有设备全部迁移到另一个 IoT 中心。\r \r 如果导入文件包括孪生元数据，则此元数据将覆盖现有的孪生元数据。 如果导入文件未包括孪生元数据，则只会使用当前时间更新 `lastUpdateTime` 元数据。\r \r 可以在每个设备的导入序列化数据中使用可选 **importMode** 属性来控制每个设备的导入过程。 **importMode** 属性具有以下选项：\r \r | importMode |  说明 |\r | --- | --- |\r | **createOrUpdate** |如果不存在具有指定 **ID**的设备，则表示是新注册的设备。 <br/>如果设备已存在，则以所提供的输入数据覆盖现有信息，而不管 **ETag** 值为何。 <br> 用户可以选择在指定设备数据的同时指定孪生数据。 如果指定了孪生的 etag，它的处理独立于设备 etag 的处理。 如果与现有孪生的 etag 不匹配，则会将错误写入日志文件。 |\r | **create** |如果不存在具有指定 **ID**的设备，则表示是新注册的设备。 <br/>如果设备已存在，则在日志文件中写入错误。 <br> 用户可以选择在指定设备数据的同时指定孪生数据。 如果指定了孪生的 etag，它的处理独立于设备 etag 的处理。 如果与现有孪生的 etag 不匹配，则会将错误写入日志文件。 |\r | **update** |如果具有指定 **id** 的设备已存在，则使用提供的输入数据覆盖现有信息，与 **ETag** 值无关。 <br/>如果设备不存在，则在日志文件中写入错误。 |\r | **updateIfMatchETag** |如果具有指定 **id** 的设备已存在，则只有当 **ETag** 匹配时，才使用提供的输入数据覆盖现有信息。 <br/>如果设备不存在，则在日志文件中写入错误。 <br/>如果 **ETag** 不匹配，则在日志文件中写入错误。 |\r | **createOrUpdateIfMatchETag** |如果不存在具有指定 **ID**的设备，则表示是新注册的设备。 <br/>如果设备已存在，则仅当 **ETag** 匹配时，才以提供的输入数据覆盖现有信息。 <br/>如果 **ETag** 不匹配，则在日志文件中写入错误。 <br> 用户可以选择在指定设备数据的同时指定孪生数据。 如果指定了孪生的 etag，它的处理独立于设备 etag 的处理。 如果与现有孪生的 etag 不匹配，则会将错误写入日志文件。 |\r | **delete** |如果具有指定 **id** 的设备已存在，则删除该设备，与 **ETag** 值无关。 <br/>如果设备不存在，则在日志文件中写入错误。 |\r | **deleteIfMatchETag** |如果具有指定 **id** 的设备已存在，则只有当 **ETag** 匹配时才删除该设备。 如果设备不存在，则在日志文件中写入错误。 <br/>如果 ETag 不匹配，则在日志文件中写入错误。 |\r \r > [!NOTE]\r > 如果序列化数据未显式定义设备的 **importMode** 标志，则该标志在导入操作过程中默认为 **createOrUpdate**。\r \r ## <a name=\"import-devices-example--bulk-device-provisioning\"></a>导入设备示例 – 批量预配设备 \r \r 以下 C# 代码示例说明了如何生成多个具有下述功能的设备标识：\r \r - 包括身份验证密钥。\r - 将该设备信息写入块 blob。\r - 将设备导入标识注册表。\r \r ```csharp\r // Provision 1,000 more devices\r var serializedDevices = new List<string>();\r \r for (var i = 0; i < 1000; i++)\r {\r   // Create a new ExportImportDevice\r   // CryptoKeyGenerator is in the Microsoft.Azure.Devices.Common namespace\r   var deviceToAdd = new ExportImportDevice()\r   {\r     Id = Guid.NewGuid().ToString(),\r     Status = DeviceStatus.Enabled,\r     Authentication = new AuthenticationMechanism()\r     {\r       SymmetricKey = new SymmetricKey()\r       {\r         PrimaryKey = CryptoKeyGenerator.GenerateKey(32),\r         SecondaryKey = CryptoKeyGenerator.GenerateKey(32)\r       }\r     },\r     ImportMode = ImportMode.Create\r   };\r \r   // Add device to the list\r   serializedDevices.Add(JsonConvert.SerializeObject(deviceToAdd));\r }\r \r // Write the list to the blob\r var sb = new StringBuilder();\r serializedDevices.ForEach(serializedDevice => sb.AppendLine(serializedDevice));\r await blob.DeleteIfExistsAsync();\r \r using (CloudBlobStream stream = await blob.OpenWriteAsync())\r {\r   byte[] bytes = Encoding.UTF8.GetBytes(sb.ToString());\r   for (var i = 0; i < bytes.Length; i += 500)\r   {\r     int length = Math.Min(bytes.Length - i, 500);\r     await stream.WriteAsync(bytes, i, length);\r   }\r }\r \r // Call import using the blob to add new devices\r // Log information related to the job is written to the same container\r // This normally takes 1 minute per 100 devices\r JobProperties importJob = await registryManager.ImportDevicesAsync(containerSasUri, containerSasUri);\r \r // Wait until job is finished\r while(true)\r {\r   importJob = await registryManager.GetJobAsync(importJob.JobId);\r   if (importJob.Status == JobStatus.Completed || \r       importJob.Status == JobStatus.Failed ||\r       importJob.Status == JobStatus.Cancelled)\r   {\r     // Job has finished executing\r     break;\r   }\r \r   await Task.Delay(TimeSpan.FromSeconds(5));\r }\r ```\r \r ## <a name=\"import-devices-example--bulk-deletion\"></a>导入设备示例 – 批量删除\r \r 以下代码示例演示如何删除使用前面代码示例添加的设备：\r \r ```csharp\r // Step 1: Update each device's ImportMode to be Delete\r sb = new StringBuilder();\r serializedDevices.ForEach(serializedDevice =>\r {\r   // Deserialize back to an ExportImportDevice\r   var device = JsonConvert.DeserializeObject<ExportImportDevice>(serializedDevice);\r \r   // Update property\r   device.ImportMode = ImportMode.Delete;\r \r   // Re-serialize\r   sb.AppendLine(JsonConvert.SerializeObject(device));\r });\r \r // Step 2: Write the new import data back to the block blob\r await blob.DeleteIfExistsAsync();\r using (CloudBlobStream stream = await blob.OpenWriteAsync())\r {\r   byte[] bytes = Encoding.UTF8.GetBytes(sb.ToString());\r   for (var i = 0; i < bytes.Length; i += 500)\r   {\r     int length = Math.Min(bytes.Length - i, 500);\r     await stream.WriteAsync(bytes, i, length);\r   }\r }\r \r // Step 3: Call import using the same blob to delete all devices\r importJob = await registryManager.ImportDevicesAsync(containerSasUri, containerSasUri);\r \r // Wait until job is finished\r while(true)\r {\r   importJob = await registryManager.GetJobAsync(importJob.JobId);\r   if (importJob.Status == JobStatus.Completed || \r       importJob.Status == JobStatus.Failed ||\r       importJob.Status == JobStatus.Cancelled)\r   {\r     // Job has finished executing\r     break;\r   }\r \r   await Task.Delay(TimeSpan.FromSeconds(5));\r }\r \r ```\r \r ## <a name=\"get-the-container-sas-uri\"></a>获取容器 SAS URI\r \r 下面的代码示例演示如何使用 Blob 容器的读取、写入和删除权限生成 [SAS URI](../storage/blobs/storage-dotnet-shared-access-signature-part-2.md)：\r \r ```csharp\r static string GetContainerSasUri(CloudBlobContainer container)\r {\r   // Set the expiry time and permissions for the container.\r   // In this case no start time is specified, so the\r   // shared access signature becomes valid immediately.\r   var sasConstraints = new SharedAccessBlobPolicy();\r   sasConstraints.SharedAccessExpiryTime = DateTime.UtcNow.AddHours(24);\r   sasConstraints.Permissions = \r     SharedAccessBlobPermissions.Write | \r     SharedAccessBlobPermissions.Read | \r     SharedAccessBlobPermissions.Delete;\r \r   // Generate the shared access signature on the container,\r   // setting the constraints directly on the signature.\r   string sasContainerToken = container.GetSharedAccessSignature(sasConstraints);\r \r   // Return the URI string for the container,\r   // including the SAS token.\r   return container.Uri + sasContainerToken;\r }\r \r ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r 在本文中，已学习如何对 IoT 中心内的标识注册表执行批量操作。 若要了解有关如何管理 Azure IoT 中心的详细信息，请参阅以下链接：\r \r * [IoT 中心指标][lnk-metrics]\r * [操作监视][lnk-monitor]\r \r 若要进一步探索 IoT 中心的功能，请参阅：\r \r * [IoT 中心开发人员指南][lnk-devguide]\r * [使用 Azure IoT Edge 将 AI 部署到边缘设备][lnk-iotedge]\r \r [lnk-metrics]: ./iot-hub-metrics.md\r [lnk-monitor]: ./iot-hub-operations-monitoring.md\r \r [lnk-devguide]: ./iot-hub-devguide.md\r [lnk-iotedge]: ./iot-hub-linux-iot-edge-simulated-device.md\r \r <!--Update_Description: update meta data and wording-->"}