{"Title":"Service Fabric 上的 Reliable Actors","Description":"介绍 Reliable Actors 如何在 Reliable Services 上进行分层以及如何使用 Service Fabric 平台的功能。","Content":"# <a name=\"how-reliable-actors-use-the-service-fabric-platform\"></a>Reliable Actors 如何使用 Service Fabric 平台\r 本文介绍了 Reliable Actors 如何使用 Azure Service Fabric 平台。 Reliable Actors 在有状态的可靠服务（称为*执行组件服务*）的实现托管的框架中运行。 执行组件服务包含管理执行组件的生命周期和消息发送所需的所有组件：\r \r * 执行组件运行时管理生命周期、垃圾回收，并强制执行单线程访问。\r * 执行组件服务远程处理侦听器接受对执行组件的远程访问调用，并将它们发送到调度程序，以便路由到合适的执行组件实例。\r * 执行组件状态提供程序包装状态提供程序（例如 Reliable Collections 状态提供程序），并为执行组件状态管理提供一个适配器。\r \r 这些组件共同构成了 Reliable Actor 框架。\r \r ## <a name=\"service-layering\"></a>服务分层\r 因为执行组件服务本身是一种可靠服务，Reliable Services 的所有[应用程序模型](service-fabric-application-model.md)、生命周期、[打包](service-fabric-package-apps.md)、[部署](service-fabric-deploy-remove-applications.md)、升级和缩放概念同样适用于执行组件服务。\r \r ![执行组件服务分层][1]\r \r 上图显示了 Service Fabric 应用程序框架和用户代码之间的关系。 蓝色元素代表 Reliable Services 应用程序框架，橙色代表 Reliable Actor 框架，绿色则代表用户代码。\r \r 在 Reliable Services 中，服务会继承 `StatefulService` 类。 该类本身派生自 `StatefulServiceBase`（或无状态服务的 `StatelessService`）。 在 Reliable Actors 中，使用执行组件服务。 执行组件服务是一种不同的 `StatefulServiceBase` 类的实现，该类可实现运行执行组件的执行组件模式。 由于执行组件服务只是 `StatefulServiceBase` 的一个实现，因此可以编写自己的派生自 `ActorService` 的服务，并且以与继承 `StatefulService` 时一样的方式实现服务级别的功能，例如：\r \r * 服务备份和还原。\r * 共享给所有执行组件的功能，例如断路器。\r * 对执行组件服务自身和每个执行组件的远程过程调用。\r \r > [!NOTE]\r > Java/Linux 目前不支持有状态服务。\r \r ### <a name=\"using-the-actor-service\"></a>使用执行组件服务\r 执行组件实例可访问运行这些实例的执行组件服务。 通过执行组件服务，执行组件实例可以编程方式获取服务上下文。 服务上下文包括分区 ID、服务名称、应用程序名称以及其他特定于 Service Fabric 平台的信息：\r \r ```csharp\r Task MyActorMethod()\r {\r     Guid partitionId = this.ActorService.Context.PartitionId;\r     string serviceTypeName = this.ActorService.Context.ServiceTypeName;\r     Uri serviceInstanceName = this.ActorService.Context.ServiceName;\r     string applicationInstanceName = this.ActorService.Context.CodePackageActivationContext.ApplicationName;\r }\r ```\r ```Java\r CompletableFuture<?> MyActorMethod()\r {\r     UUID partitionId = this.getActorService().getServiceContext().getPartitionId();\r     String serviceTypeName = this.getActorService().getServiceContext().getServiceTypeName();\r     URI serviceInstanceName = this.getActorService().getServiceContext().getServiceName();\r     String applicationInstanceName = this.getActorService().getServiceContext().getCodePackageActivationContext().getApplicationName();\r }\r ```\r \r 与所有 Reliable Services 一样，执行组件服务必须使用 Service Fabric 运行时中的服务类型注册。 为了使执行组件服务能够运行执行组件实例，还必须向执行组件服务注册执行组件类型。 `ActorRuntime` 注册方法为执行组件执行此操作。 最简单的情况是，用户只需注册执行组件类型，并隐式使用具有默认设置的执行组件服务：\r \r ```csharp\r static class Program\r {\r     private static void Main()\r     {\r         ActorRuntime.RegisterActorAsync<MyActor>().GetAwaiter().GetResult();\r \r         Thread.Sleep(Timeout.Infinite);\r     }\r }\r ```\r \r 或者，可以使用此注册方法提供的 lambda 自己构造执行组件服务。 可以配置执行组件服务和显式构造执行组件实例，从中可通过执行组件的构造函数向执行组件注入依赖项：\r \r ```csharp\r static class Program\r {\r     private static void Main()\r     {\r         ActorRuntime.RegisterActorAsync<MyActor>(\r             (context, actorType) => new ActorService(context, actorType, () => new MyActor()))\r             .GetAwaiter().GetResult();\r \r         Thread.Sleep(Timeout.Infinite);\r     }\r }\r ```\r ```Java\r static class Program\r {\r     private static void Main()\r     {\r       ActorRuntime.registerActorAsync(\r               MyActor.class,\r               (context, actorTypeInfo) -> new FabricActorService(context, actorTypeInfo),\r               timeout);\r \r         Thread.sleep(Long.MAX_VALUE);\r     }\r }\r ```\r \r ### <a name=\"actor-service-methods\"></a>执行组件服务方法\r 执行组件服务实现了 `IActorService` (C#) 或 `ActorService` (Java)，后者又实现了 `IService` (C#) 或 `Service` (Java)。 这是 Reliable Services 远程控制所使用的接口，该远程控制允许对服务方法执行远程过程调用。 它包含可以通过服务远程控制进行远程调用的服务级别方法。\r \r #### <a name=\"enumerating-actors\"></a>枚举执行组件\r 执行组件服务允许客户端枚举有关该服务托管的执行组件的元数据。 由于执行组件服务是已分区的有状态服务，因此将按分区执行枚举。 因为每个分区可能包含许多执行组件，所以枚举以一组分页结果的形式返回。 将循环读取这些页面，直到读取所有页面。 以下示例演示了如何创建执行组件服务的一个分区中所有活动执行组件的列表：\r \r ```csharp\r IActorService actorServiceProxy = ActorServiceProxy.Create(\r     new Uri(\"fabric:/MyApp/MyService\"), partitionKey);\r \r ContinuationToken continuationToken = null;\r List<ActorInformation> activeActors = new List<ActorInformation>();\r \r do\r {\r     PagedResult<ActorInformation> page = await actorServiceProxy.GetActorsAsync(continuationToken, cancellationToken);\r \r     activeActors.AddRange(page.Items.Where(x => x.IsActive));\r \r     continuationToken = page.ContinuationToken;\r }\r while (continuationToken != null);\r ```\r \r ```Java\r ActorService actorServiceProxy = ActorServiceProxy.create(\r     new URI(\"fabric:/MyApp/MyService\"), partitionKey);\r \r ContinuationToken continuationToken = null;\r List<ActorInformation> activeActors = new ArrayList<ActorInformation>();\r \r do\r {\r     PagedResult<ActorInformation> page = actorServiceProxy.getActorsAsync(continuationToken);\r \r     while(ActorInformation x: page.getItems())\r     {\r          if(x.isActive()){\r               activeActors.add(x);\r          }\r     }\r \r     continuationToken = page.getContinuationToken();\r }\r while (continuationToken != null);\r ```\r \r #### <a name=\"deleting-actors\"></a>删除执行组件\r 执行组件服务提供了一个用于删除执行组件的函数：\r \r ```csharp\r ActorId actorToDelete = new ActorId(id);\r \r IActorService myActorServiceProxy = ActorServiceProxy.Create(\r     new Uri(\"fabric:/MyApp/MyService\"), actorToDelete);\r \r await myActorServiceProxy.DeleteActorAsync(actorToDelete, cancellationToken)\r ```\r ```Java\r ActorId actorToDelete = new ActorId(id);\r \r ActorService myActorServiceProxy = ActorServiceProxy.create(\r     new URI(\"fabric:/MyApp/MyService\"), actorToDelete);\r \r myActorServiceProxy.deleteActorAsync(actorToDelete);\r ```\r \r 有关删除执行组件及其状态的详细信息，请参阅[执行组件生命周期文档](service-fabric-reliable-actors-lifecycle.md)。\r \r ### <a name=\"custom-actor-service\"></a>自定义执行组件服务\r 通过使用执行组件注册 lambda，可以注册从 `ActorService` (C#) 和 `FabricActorService` (Java) 派生的自定义执行组件服务。 在此自定义执行组件服务中，可以通过编写从 `ActorService` (C#) 或 `FabricActorService` (Java) 继承的服务类来实现自己的服务级功能。 自定义执行组件服务从 `ActorService` (C#) 或 `FabricActorService` (Java) 继承了所有执行组件运行时功能，可用来实现自己的服务方法。\r \r ```csharp\r class MyActorService : ActorService\r {\r     public MyActorService(StatefulServiceContext context, ActorTypeInformation typeInfo, Func<ActorBase> newActor)\r         : base(context, typeInfo, newActor)\r     { }\r }\r ```\r ```Java\r class MyActorService extends FabricActorService\r {\r     public MyActorService(StatefulServiceContext context, ActorTypeInformation typeInfo, BiFunction<FabricActorService, ActorId, ActorBase> newActor)\r     {\r          super(context, typeInfo, newActor);\r     }\r }\r ```\r \r ```csharp\r static class Program\r {\r     private static void Main()\r     {\r         ActorRuntime.RegisterActorAsync<MyActor>(\r             (context, actorType) => new MyActorService(context, actorType, () => new MyActor()))\r             .GetAwaiter().GetResult();\r \r         Thread.Sleep(Timeout.Infinite);\r     }\r }\r ```\r ```Java\r public class Program\r {\r     public static void main(String[] args)\r     {\r         ActorRuntime.registerActorAsync(\r                 MyActor.class,\r                 (context, actorTypeInfo) -> new FabricActorService(context, actorTypeInfo),\r                 timeout);\r         Thread.sleep(Long.MAX_VALUE);\r     }\r }\r ```\r \r #### <a name=\"implementing-actor-backup-and-restore\"></a>实现执行组件备份和还原\r  在下面的示例中，自定义执行组件服务通过利用已存在于 `ActorService` 中的远程侦听器公开备份执行组件数据的方法：\r \r ```csharp\r public interface IMyActorService : IService\r {\r     Task BackupActorsAsync();\r }\r \r class MyActorService : ActorService, IMyActorService\r {\r     public MyActorService(StatefulServiceContext context, ActorTypeInformation typeInfo, Func<ActorBase> newActor)\r         : base(context, typeInfo, newActor)\r     { }\r \r     public Task BackupActorsAsync()\r     {\r         return this.BackupAsync(new BackupDescription(PerformBackupAsync));\r     }\r \r     private async Task<bool> PerformBackupAsync(BackupInfo backupInfo, CancellationToken cancellationToken)\r     {\r         try\r         {\r            // store the contents of backupInfo.Directory\r            return true;\r         }\r         finally\r         {\r            Directory.Delete(backupInfo.Directory, recursive: true);\r         }\r     }\r }\r ```\r ```Java\r public interface MyActorService extends Service\r {\r     CompletableFuture<?> backupActorsAsync();\r }\r \r class MyActorServiceImpl extends ActorService implements MyActorService\r {\r     public MyActorService(StatefulServiceContext context, ActorTypeInformation typeInfo, Func<FabricActorService, ActorId, ActorBase> newActor)\r     {\r        super(context, typeInfo, newActor);\r     }\r \r     public CompletableFuture backupActorsAsync()\r     {\r         return this.backupAsync(new BackupDescription((backupInfo, cancellationToken) -> performBackupAsync(backupInfo, cancellationToken)));\r     }\r \r     private CompletableFuture<Boolean> performBackupAsync(BackupInfo backupInfo, CancellationToken cancellationToken)\r     {\r         try\r         {\r            // store the contents of backupInfo.Directory\r            return true;\r         }\r         finally\r         {\r            deleteDirectory(backupInfo.Directory)\r         }\r     }\r \r     void deleteDirectory(File file) {\r         File[] contents = file.listFiles();\r         if (contents != null) {\r             for (File f : contents) {\r                deleteDirectory(f);\r              }\r         }\r         file.delete();\r     }\r }\r ```\r \r \r 在本示例中，`IMyActorService` 是一个实现 `IService` (C#) 和 `Service` (Java)，并由 `MyActorService` 实现的远程协定。 通过添加此远程协定，并通过 `ActorServiceProxy` 创建远程代理，现在 `IMyActorService` 的方法也可用于客户端：\r \r ```csharp\r IMyActorService myActorServiceProxy = ActorServiceProxy.Create<IMyActorService>(\r     new Uri(\"fabric:/MyApp/MyService\"), ActorId.CreateRandom());\r \r await myActorServiceProxy.BackupActorsAsync();\r ```\r ```Java\r MyActorService myActorServiceProxy = ActorServiceProxy.create(MyActorService.class,\r     new URI(\"fabric:/MyApp/MyService\"), actorId);\r \r myActorServiceProxy.backupActorsAsync();\r ```\r \r ## <a name=\"application-model\"></a>应用程序模型\r 执行组件服务都是 Reliable Services，因此服务的应用程序模型是相同的。 但是，执行组件框架生成工具生成某些应用程序模型文件。\r \r ### <a name=\"service-manifest\"></a>服务清单\r 执行组件框架生成工具自动生成执行组件服务的 ServiceManifest.xml 文件的内容。 此文件包括：\r \r * 执行组件服务类型。 根据执行组件项目名称生成此类型名称。 根据执行组件的持久性属性，还会相应设置 HasPersistedState 标志。\r * 代码包。\r * 配置包。\r * 资源和终结点。\r \r ### <a name=\"application-manifest\"></a>应用程序清单\r 执行组件框架生成工具为你的执行组件服务自动创建默认的服务定义。 生成工具填充默认的服务属性：\r \r * 副本集计数由执行组件的持久性属性决定。 每次更改执行组件的持久性属性时，会相应地重置默认服务定义中的副本集计数。\r * 分区方案和范围设置为具有完整的 Int64 键范围的统一 Int64。\r \r <a name=\"service-fabric-partition-concepts-for-stateful-actors\"></a>\r ## <a name=\"service-fabric-partition-concepts-for-actors\"></a>针对执行组件的 Service Fabric 分区概念\r 执行组件服务是已分区的有状态服务。 执行组件服务的每个分区包含一组执行组件。 服务分区在 Service Fabric 的多个节点中自动分布。 因此，执行组件实例分布到各个节点中。\r \r ![执行组件分区和分布][5]\r \r 可使用不同的分区方案和分区键范围创建 Reliable Services。 执行组件服务使用具有完整的 Int64 键范围的 Int64 分区方案将执行组件映射到分区。\r \r ### <a name=\"actor-id\"></a>执行组件 ID\r 服务中创建的每个执行组件具有与之关联的唯一 ID，并使用 `ActorId` 类表示。 `ActorId` 是一个不透明的 ID 值，通过生成随机 ID，可将此值用于在各个服务分区中统一分布执行组件：\r \r ```csharp\r ActorProxy.Create<IMyActor>(ActorId.CreateRandom());\r ```\r ```Java\r ActorProxyBase.create<MyActor>(MyActor.class, ActorId.newId());\r ```\r \r 每个 `ActorId` 都经过哈希算法转换为 Int64 类型值。 因此，执行组件服务必须使用具有完整 Int64 键范围的 Int64 分区方案。 不过，`ActorID` 也可以使用自定义 ID 值，包括 GUID/UUID、字符串和 Int64。\r \r ```csharp\r ActorProxy.Create<IMyActor>(new ActorId(Guid.NewGuid()));\r ActorProxy.Create<IMyActor>(new ActorId(\"myActorId\"));\r ActorProxy.Create<IMyActor>(new ActorId(1234));\r ```\r ```Java\r ActorProxyBase.create(MyActor.class, new ActorId(UUID.randomUUID()));\r ActorProxyBase.create(MyActor.class, new ActorId(\"myActorId\"));\r ActorProxyBase.create(MyActor.class, new ActorId(1234));\r ```\r \r 使用 GUID/UUID 和字符串时，这些值经过哈希算法转换为 Int64。 但是，如果向 `ActorId` 显式提供 Int64，此 Int64 会直接映射到分区，而无需进行哈希转换。 可以使用此方法来控制将执行组件置于哪个分区。\r \r ## <a name=\"actor-using-remoting-v2-stack\"></a>使用 Remoting V2 堆栈的参与者\r 借助 2.8 Nuget 包，用户现在可以使用更高性能的 Remoting V2 堆栈，它提供自定义序列化等功能。 Remoting V2 不与现有的 Remoting 堆栈（称为 V1 Remoting 堆栈）向后兼容。\r \r 需要进行以下更改才能使用 Remoting V2 堆栈。\r  1. 在参与者界面中添加以下程序集属性。\r    ```csharp\r    [assembly:FabricTransportActorRemotingProvider(RemotingListener = RemotingListener.V2Listener,RemotingClient = RemotingClient.V2Client)]\r    ```\r \r  2. 生成并升级 ActorService 和参与者客户端项目以开始使用 V2 堆栈。\r \r ### <a name=\"actor-service-upgrade-to-remoting-v2-stack-without-impacting-service-availability\"></a>在不影响服务可用性的情况下将参与者服务升级到 Remoting V2 堆栈。\r 这项更改是包括 2 个步骤的升级过程。 按照所列的顺序执行步骤。\r \r 1.  在参与者界面中添加以下程序集属性。 此属性针对 ActorService 启动两个侦听器：V1（现有）和 V2 侦听器。 通过此项更改升级 ActorService。\r \r   ```csharp\r   [assembly:FabricTransportActorRemotingProvider(RemotingListener = RemotingListener.CompatListener,RemotingClient = RemotingClient.V2Client)]\r   ```\r \r 2. 完成上述升级后，升级 ActorClients。\r 此步骤确保参与者代理使用 Remoting V2 堆栈。\r \r 3. 此步骤是可选的。 更改上述属性可删除 V1 侦听器。\r \r     ```csharp\r     [assembly:FabricTransportActorRemotingProvider(RemotingListener = RemotingListener.V2Listener,RemotingClient = RemotingClient.V2Client)]\r     ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r * [执行组件状态管理](service-fabric-reliable-actors-state-management.md)\r * [执行组件生命周期和垃圾回收](service-fabric-reliable-actors-lifecycle.md)\r * [执行组件 API 参考文档](https://msdn.microsoft.com/library/azure/dn971626.aspx)\r * [.NET 代码示例](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started)\r * [Java 代码示例](http://github.com/Azure-Samples/service-fabric-java-getting-started)\r \r <!--Image references-->\r [1]: ./media/service-fabric-reliable-actors-platform/actor-service.png\r [2]: ./media/service-fabric-reliable-actors-platform/app-deployment-scripts.png\r [3]: ./media/service-fabric-reliable-actors-platform/actor-partition-info.png\r [4]: ./media/service-fabric-reliable-actors-platform/actor-replica-role.png\r [5]: ./media/service-fabric-reliable-actors-introduction/distribution.png\r \r <!--Update_Description: update meta properties, add content of Actor using Remoting V2 Stacks-->"}