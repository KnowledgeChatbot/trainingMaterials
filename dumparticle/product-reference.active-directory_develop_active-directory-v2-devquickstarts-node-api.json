{"Title":"使用 Node.js 保护 Azure Active Directory v2.0 Web API","Description":"了解如何构建一个可从个人 Microsoft 帐户及公司或学校帐户接受令牌的 Node.js Web API。","Content":"# <a name=\"secure-a-web-api-by-using-nodejs\"></a>使用 Node.js 保护 Web API\r > [!NOTE]\r > 并非所有 Azure Active Directory 方案和功能都可与 v2.0 终结点配合使用。 若要确定是应该使用 v2.0 终结点还是应该使用 v1.0 终结点，请阅读 [v2.0 限制](active-directory-v2-limitations.md)。\r > \r > \r \r 使用 Azure Active Directory (Azure AD) v2.0 终结点时，可以使用 [OAuth 2.0](active-directory-v2-protocols.md) 访问令牌来保护 Web API。 同时拥有个人 Microsoft 帐户以及工作或学校帐户的用户可以使用 OAuth 2.0 访问令牌安全访问你的 Web API。\r \r *Passport* 是 Node.js 的身份验证中间件。 Passport 很灵活并且采用模块化结构，可以在不造成干扰的情况下放入任何基于 Express 的应用程序或 Resitify Web 应用程序。 在 Passport 中，有一套综合性策略支持使用用户名和密码、Facebook、Twitter 或其他选项进行身份验证。 我们针对 Azure AD 开发了一项策略。 本文介绍了如何安装该模块及添加 Azure AD `passport-azure-ad` 插件。\r \r ## <a name=\"download\"></a>下载\r 本教程的代码 [在 GitHub 上](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs)维护。 若要按照本教程操作，可以[下载 .zip 文件格式的应用框架](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs/archive/skeleton.zip)，或克隆该框架：\r \r ```git clone --branch skeleton https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs.git```\r \r 还可以在本教程结束时获得完整的应用程序。\r \r ## <a name=\"1-register-an-app\"></a>1：注册应用\r 在 [apps.dev.microsoft.com](https://apps.dev.microsoft.com/?deeplink=/appList) 上创建新应用，或按照[以下详细步骤](active-directory-v2-app-registration.md)注册应用。 确保：\r \r - 复制分配给应用的**应用程序 ID**。 在本教程中需要用到它。\r - 为应用添加 **移动** 平台。\r - 从门户复制 **重定向 URI** 。 必须使用默认的 URI 值 `urn:ietf:wg:oauth:2.0:oob`。\r \r ## <a name=\"2-install-nodejs\"></a>2：安装 Node.js\r 若要使用本教程中的示例，必须[安装 Node.js](http://nodejs.org)。\r \r ## <a name=\"3-install-mongodb\"></a>3：安装 MongoDB\r 若要成功使用本示例，必须[安装 MongoDB](http://www.mongodb.org)。 本示例使用 MongoDB 来使 REST API 持久保留在服务器实例之间。\r \r > [!NOTE]\r > 本文假设对 MongoDB 使用默认的安装与服务器终结点：mongodb://localhost。\r > \r > \r \r ## <a name=\"4-install-the-restify-modules-in-your-web-api\"></a>4：在 Web API 中安装 Restify 模块\r 我们使用 Resitfy 来构建 REST API。 Restify 是派生自 Express 的精简弹性 Node.js 应用程序框架。 Restify 提供了一套稳健功能用于在 Connect 的顶层构建 REST API。\r \r ### <a name=\"install-restify\"></a>安装 Restify\r 1.  在命令行中，将目录切换到 **azuread**：\r \r     `cd azuread`\r \r     如果 **azuread** 目录不存在，请创建该目录。\r \r     `mkdir azuread`\r \r 2.  安装 Restify：\r \r     `npm install restify`\r \r     此命令的输出应如下所示：\r \r     ```\r     restify@2.6.1 node_modules/restify\r     ├── assert-plus@0.1.4\r     ├── once@1.3.0\r     ├── deep-equal@0.0.0\r     ├── escape-regexp-component@1.0.2\r     ├── qs@0.6.5\r     ├── tunnel-agent@0.3.0\r     ├── keep-alive-agent@0.0.1\r     ├── lru-cache@2.3.1\r     ├── node-uuid@1.4.0\r     ├── negotiator@0.3.0\r     ├── mime@1.2.11\r     ├── semver@2.2.1\r     ├── spdy@1.14.12\r     ├── backoff@2.3.0\r     ├── formidable@1.0.14\r     ├── verror@1.3.6 (extsprintf@1.0.2)\r     ├── csv@0.3.6\r     ├── http-signature@0.10.0 (assert-plus@0.1.2, asn1@0.1.11, ctype@0.5.2)\r     └── bunyan@0.22.0(mv@0.0.5)\r     ```\r \r #### <a name=\"did-you-get-an-error\"></a>遇到了错误吗？\r 在某些操作系统上使用 `npm` 命令时，可能会看到此消息：`Error: EPERM, chmod '/usr/local/bin/..'`。 发生此错误后，接着会要求以管理员身份尝试运行帐户。 如果发生此问题，请使用 `sudo` 命令，以更高特权级别运行 `npm`。\r \r #### <a name=\"did-you-get-an-error-related-to-dtrace\"></a>遇到了 DTrace 相关的错误吗？\r 安装 Restify 时，可能会看到以下消息：\r \r ```Shell\r clang: error: no such file or directory: 'HD/azuread/node_modules/restify/node_modules/dtrace-provider/libusdt'\r make: *** [Release/DTraceProviderBindings.node] Error 1\r gyp ERR! build error\r gyp ERR! stack Error: `make` failed with exit code: two\r gyp ERR! stack     at ChildProcess.onExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:267:23)\r gyp ERR! stack     at ChildProcess.EventEmitter.emit (events.js:98:17)\r gyp ERR! stack     at Process.ChildProcess._handle.onexit (child_process.js:789:12)\r gyp ERR! System Darwin 13.1.0\r gyp ERR! command \"node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"\r gyp ERR! cwd /Volumes/Development HD/azuread/node_modules/restify/node_modules/dtrace-provider\r gyp ERR! node -v v0.10.11\r gyp ERR! node-gyp -v v0.10.0\r gyp ERR! not ok\r npm WARN optional dep failed, continuing dtrace-provider@0.2.8\r ```\r \r Restify 提供强大的机制来使用 DTrace 跟踪 REST 调用。 但是，许多操作系统不提供 DTrace。 可以放心地忽略此错误消息。\r \r \r ## <a name=\"5-install-passportjs-in-your-web-api\"></a>5：将 Passport.js 安装到 Web API 中\r 1.  在命令行提示符下，将目录切换到 **azuread**。\r \r 2.  安装 Passport.js：\r \r     `npm install passport`\r \r     此命令的输出应如下所示：\r \r     ```\r      passport@0.1.17 node_modules\\passport\r     ├── pause@0.0.1\r     └── pkginfo@0.2.3\r     ```\r \r ## <a name=\"6-add-passport-azure-ad-to-your-web-api\"></a>6：将 passport-azure-ad 添加到 Web API\r 接下来，使用 passport-azuread 添加 OAuth 策略。 `passport-azuread` 是一套将 Azure AD 连接到 Passport 的策略。 在此 REST API 示例中，我们将针对持有者令牌使用此策略。\r \r > [!NOTE]\r > 尽管 OAuth 2.0 提供了可以颁发任何已知令牌类型的框架，但我们通常使用其中的某些令牌类型。 我们往往使用持有者令牌保护终结点。 持有者令牌是 OAuth 2.0 中最广泛颁发的令牌类型。 许多 OAuth 2.0 实现假设持有者令牌是唯一颁发的令牌类型。\r > \r > \r \r 1.  在命令行中，将目录切换到 **azuread**。\r \r     `cd azuread`\r \r 2.  安装 Passport.js `passport-azure-ad` 模块：\r \r     `npm install passport-azure-ad`\r \r     此命令的输出应如下所示：\r \r     ```\r     passport-azure-ad@1.0.0 node_modules/passport-azure-ad\r     ├── xtend@4.0.0\r     ├── xmldom@0.1.19\r     ├── passport-http-bearer@1.0.1 (passport-strategy@1.0.0)\r     ├── underscore@1.8.3\r     ├── async@1.3.0\r     ├── jsonwebtoken@5.0.2\r     ├── xml-crypto@0.5.27 (xpath.js@1.0.6)\r     ├── ursa@0.8.5 (bindings@1.2.1, nan@1.8.4)\r     ├── jws@3.0.0 (jwa@1.0.1, base64url@1.0.4)\r     ├── request@2.58.0 (caseless@0.10.0, aws-sign2@0.5.0, forever-agent@0.6.1, stringstream@0.0.4, tunnel-agent@0.4.1, oauth-sign@0.8.0, isstream@0.1.2, extend@2.0.1, json-stringify-safe@5.0.1, node-uuid@1.4.3, qs@3.1.0, combined-stream@1.0.5, mime-types@2.0.14, form-data@1.0.0-rc1, http-signature@0.11.0, bl@0.9.4, tough-cookie@2.0.0, hawk@2.3.1, har-validator@1.8.0)\r     └── xml2js@0.4.9 (sax@0.6.1, xmlbuilder@2.6.4)\r     ```\r \r ## <a name=\"7-add-mongodb-modules-to-your-web-api\"></a>7：将 MongoDB 模块添加到 Web API\r 本示例使用 MongoDB 作为数据存储。 \r \r 1.  安装 Mongoose，这是广泛用于管理模型和架构的插件： \r \r     `npm install mongoose`\r \r 2.  安装 MongoDB 的数据库驱动程序（也称为 MongoDB）：\r \r     `npm install mongodb`\r \r ## <a name=\"8-install-additional-modules\"></a>8：安装其他模块\r 安装剩余的所需模块。\r \r 1.  在命令行中，将目录切换到 **azuread**：\r \r     `cd azuread`\r \r 2.  输入以下命令。 这些命令在 node_modules 目录中安装以下模块：\r \r     *   `npm install crypto`\r     *   `npm install assert-plus`\r     *   `npm install posix-getopt`\r     *   `npm install util`\r     *   `npm install path`\r     *   `npm install connect`\r     *   `npm install xml-crypto`\r     *   `npm install xml2js`\r     *   `npm install xmldom`\r     *   `npm install async`\r     *   `npm install request`\r     *   `npm install underscore`\r     *   `npm install grunt-contrib-jshint@0.1.1`\r     *   `npm install grunt-contrib-nodeunit@0.1.2`\r     *   `npm install grunt-contrib-watch@0.2.0`\r     *   `npm install grunt@0.4.1`\r     *   `npm install xtend@2.0.3`\r     *   `npm install bunyan`\r     *   `npm update`\r \r ## <a name=\"9-create-a-serverjs-file-for-your-dependencies\"></a>9：创建依赖项的 Server.js 文件\r Server.js 文件保存 Web API 服务器的大多数功能。 大部分代码将添加到此文件中。 用于生产目的，可以将功能重构为较小的文件，例如单独的路由和控制器。 本文为此目的使用 Server.js。\r \r 1.  在命令行中，将目录切换到 **azuread**：\r \r     `cd azuread`\r \r 2.  使用所选的编辑器创建 Server.js 文件。 在文件中添加以下信息：\r \r     ```Javascript\r     'use strict';\r     /**\r     * Module dependencies.\r     */\r     var util = require('util');\r     var assert = require('assert-plus');\r     var mongoose = require('mongoose/');\r     var bunyan = require('bunyan');\r     var restify = require('restify');\r     var config = require('./config');\r     var passport = require('passport');\r     var OIDCBearerStrategy = require('passport-azure-ad').OIDCStrategy;\r     ```\r \r 3.  保存文件。 稍后将要使用此文件。\r \r ## <a name=\"10-create-a-config-file-to-store-your-azure-ad-settings\"></a>10：创建一个配置文件用于存储 Azure AD 设置\r 此代码文件将配置参数从 Azure AD 门户传递到 Passport.js。 在本文开头部分向门户添加 Web API 时，你创建了这些配置值。 在你复制代码后，我们将解释要输入其中的哪些参数值。\r \r 1.  在命令行中，将目录切换到 **azuread**：\r \r     `cd azuread`\r \r 2.  在编辑器中创建 Config.js 文件。 添加以下信息：\r \r     ```Javascript\r     // Don't commit this file to your public repos. This config is for first-run.\r     exports.creds = {\r     mongoose_auth_local: 'mongodb://localhost/tasklist', // Your Mongo auth URI goes here.\r     issuer: 'https://sts.chinacloudapi.cn/**<your application id>**/',\r     audience: '<your redirect URI>',\r     identityMetadata: 'https://login.partner.microsoftonline.cn/common/.well-known/openid-configuration' // For Microsoft, you should never need to change this.\r     };\r \r     ```\r \r \r \r ### <a name=\"required-values\"></a>必需的值\r \r -   **IdentityMetadata**：`passport-azure-ad` 将在此处查找适用于标识提供者 (IDP) 的配置数据，以及用于验证 JSON Web 令牌 (JWT) 的密钥。 如果使用 Azure AD，可能不需要更改此值。\r \r -   audience：来自门户的重定向 URI。\r \r > [!NOTE]\r > 频繁滚动更新密钥。 请确保始终从“openid_keys”URL 提取密钥，并且应用程序能够访问 Internet。\r > \r > \r \r ## <a name=\"11-add-the-configuration-to-your-serverjs-file\"></a>11：将配置添加到 Server.js 文件\r 应用程序需要从刚刚创建的配置文件读取值。 在应用程序中添加 .config 文件作为所需的资源。 将全局变量设置为 Config.js 中的值。\r \r 1.  在命令行提示符下，将目录切换到 **azuread**：\r \r     `cd azuread`\r \r 2.  在编辑器中打开 Server.js。 添加以下信息：\r \r     ```Javascript\r     var config = require('./config');\r     ```\r \r 3.  将一个新节添加到 Server.js：\r \r     ```Javascript\r     // Pass these options in to the ODICBearerStrategy.\r     var options = {\r     // The URL of the metadata document for your app. Put the keys for token validation from the URL found in the jwks_uri tag in the metadata.\r     identityMetadata: config.creds.identityMetadata,\r     issuer: config.creds.issuer,\r     audience: config.creds.audience\r     };\r     // Array to hold signed-in users and the current signed-in user (owner).\r     var users = [];\r     var owner = null;\r     // Your logger\r     var log = bunyan.createLogger({\r     name: 'Azure Active Directory Sample'\r     });\r     ```\r \r ## <a name=\"12-add-the-mongodb-model-and-schema-information-by-using-mongoose\"></a>12：使用 Mongoose 添加 MongoDB 模型和架构信息\r 接下来，在 REST API 服务中连接这三个文件。\r \r 本文使用 MongoDB 来存储任务。 *步骤 4* 将介绍此操作。\r \r 在步骤 11 创建的 Config.js 文件中，数据库名为 *tasklist*。 该名称也是在 mongoose_auth_local 连接 URL 末尾处输入的内容。 不需要在 MongoDB 中事先创建此数据库。 首次运行服务器应用程序时，将会创建该数据库（假设该数据库尚不存在）。\r \r 你已告知服务器要使用哪个 MongoDB 数据库。 接下来，需要编写一些额外的代码，为服务器的任务创建模型和架构。\r \r ### <a name=\"the-model\"></a>模型\r 架构模型非常简单。 可以根据需要扩展它。 \r \r 架构模型具有以下值：\r \r -   **NAME**。 分配给任务的人员。 这是一个**字符串**值。\r -   **TASK**。 任务的名称。 这是一个**字符串**值。\r -   **DATE**。 任务截止日期。 这是一个**日期时间**值。\r -   **COMPLETED**。 任务是否已完成。 这是一个**布尔**值。\r \r ### <a name=\"create-the-schema-in-the-code\"></a>在代码中创建架构\r 1.  在命令行中，将目录切换到 **azuread**：\r \r     `cd azuread`\r \r 2.  在编辑器中打开 Server.js。 在配置项下面添加以下信息：\r \r     ```Javascript\r     // MongoDB setup.\r     // Set up some configuration.\r     var serverPort = process.env.PORT || 8080;\r     var serverURI = (process.env.PORT) ? config.creds.mongoose_auth_mongohq : config.creds.mongoose_auth_local;\r     // Connect to MongoDB.\r     global.db = mongoose.connect(serverURI);\r     var Schema = mongoose.Schema;\r     log.info('MongoDB Schema loaded');\r     ```\r \r 此代码连接到 MongoDB 服务器。 它还返回架构对象。\r \r #### <a name=\"using-the-schema-create-your-model-in-the-code\"></a>使用该架构在代码中创建模型\r 在上述代码的下面添加以下代码：\r \r ```Javascript\r // Create a basic schema to store your tasks and users.\r var TaskSchema = new Schema({\r owner: String,\r task: String,\r completed: Boolean,\r date: Date\r });\r // Use the schema to register a model.\r mongoose.model('Task', TaskSchema);\r var Task = mongoose.model('Task');\r ```\r \r 从该代码中可以看到，首先会创建架构。 接下来，创建模型对象。 定义**路由**时，将使用模型对象存储整个代码中的数据。\r \r ## <a name=\"13-add-your-routes-for-your-task-rest-api-server\"></a>13：为任务 REST API 服务器添加路由\r 现在，你已创建了可以使用的数据库模型，接下来请添加用于 REST API 服务器的路由。\r \r ### <a name=\"about-routes-in-restify\"></a>关于 Restify 中的路由\r Restify 中路由的工作原理与使用 Express 堆栈时的工作原理完全相同。 可以使用客户端应用程序应该调用的 URI 定义路由。 通常，需要在单独的文件中定义路由。 本教程将在 Server.js 中放置路由。 对于生产用途，我们建议在各自的文件中构建路由。\r \r Restify 路由的典型模式是：\r \r ```Javascript\r function createObject(req, res, next) {\r // Do work on object.\r _object.name = req.params.object; // Passed value is in req.params under object.\r ///...\r return next(); // Keep the server going.\r }\r ....\r server.post('/service/:add/:object', createObject); // calls createObject on routes that match this.\r ```\r \r \r 这是最基本级别的模式。 Resitfy（以及 Express）提供更深层的功能，例如，定义应用程序类型，以及跨不同的终结点提供复杂路由。\r \r #### <a name=\"add-default-routes-to-your-server\"></a>将默认路由添加到服务器\r 添加基本 CRUD 路由：**create**、**retrieve**、**update** 和 **delete**。\r \r 1.  在命令行中，将目录切换到 **azuread**：\r \r     `cd azuread`\r \r 2.  在编辑器中打开 Server.js。 在前面输入的数据库项下面添加以下信息：\r \r     ```Javascript\r     /**\r     *\r     * APIs for your REST task server\r     */\r     // Create a task.\r     function createTask(req, res, next) {\r     // Resitify currently has a bug that doesn't allow you to set default headers.\r     // These headers comply with CORS, and allow you to use MongoDB Server as your response to any origin.\r     res.header(\"Access-Control-Allow-Origin\", \"*\");\r     res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\r     // Create a new task model, fill it, and save it to MongoDB.\r     var _task = new Task();\r     if (!req.params.task) {\r     req.log.warn({\r     params: p\r     }, 'createTodo: missing task');\r     next(new MissingTaskError());\r     return;\r     }\r     _task.owner = owner;\r     _task.task = req.params.task;\r     _task.date = new Date();\r     _task.save(function(err) {\r     if (err) {\r     req.log.warn(err, 'createTask: unable to save');\r     next(err);\r     } else {\r     res.send(201, _task);\r     }\r     });\r     return next();\r     }\r     // Delete a task by name.\r     function removeTask(req, res, next) {\r     Task.remove({\r     task: req.params.task,\r     owner: owner\r     }, function(err) {\r     if (err) {\r     req.log.warn(err,\r     'removeTask: unable to delete %s',\r     req.params.task);\r     next(err);\r     } else {\r     log.info('Deleted task:', req.params.task);\r     res.send(204);\r     next();\r     }\r     });\r     }\r     // Delete all tasks.\r     function removeAll(req, res, next) {\r     Task.remove();\r     res.send(204);\r     return next();\r     }\r     // Get a specific task based on name.\r     function getTask(req, res, next) {\r     log.info('getTask was called for: ', owner);\r     Task.find({\r     owner: owner\r     }, function(err, data) {\r     if (err) {\r     req.log.warn(err, 'get: unable to read %s', owner);\r     next(err);\r     return;\r     }\r     res.json(data);\r     });\r     return next();\r     }\r     /// Returns the list of TODOs that were loaded.\r     function listTasks(req, res, next) {\r     // Resitify currently has a bug that doesn't allow you to set default headers.\r     // These headers comply with CORS, and allow us to use MongoDB Server as our response to any origin.\r     res.header(\"Access-Control-Allow-Origin\", \"*\");\r     res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\r     log.info(\"listTasks was called for: \", owner);\r     Task.find({\r     owner: owner\r     }).limit(20).sort('date').exec(function(err, data) {\r     if (err)\r     return next(err);\r     if (data.length > 0) {\r     log.info(data);\r     }\r     if (!data.length) {\r     log.warn(err, \"There are no tasks in the database. Add one!\");\r     }\r     if (!owner) {\r     log.warn(err, \"You did not pass an owner when listing tasks.\");\r     } else {\r     res.json(data);\r     }\r     });\r     return next();\r     }\r     ```\r \r ### <a name=\"add-error-handling-for-the-routes\"></a>为路由添加错误处理\r 添加一些错误处理，以便将遇到的问题传达给客户端。\r \r 添加以下代码（前面已编写这些代码）：\r \r ```Javascript\r ///--- Errors for communicating something more information back to the client.\r function MissingTaskError() {\r restify.RestError.call(this, {\r statusCode: 409,\r restCode: 'MissingTask',\r message: '\"task\" is a required parameter',\r constructorOpt: MissingTaskError\r });\r this.name = 'MissingTaskError';\r }\r util.inherits(MissingTaskError, restify.RestError);\r function TaskExistsError(owner) {\r assert.string(owner, 'owner');\r restify.RestError.call(this, {\r statusCode: 409,\r restCode: 'TaskExists',\r message: owner + ' already exists',\r constructorOpt: TaskExistsError\r });\r this.name = 'TaskExistsError';\r }\r util.inherits(TaskExistsError, restify.RestError);\r function TaskNotFoundError(owner) {\r assert.string(owner, 'owner');\r restify.RestError.call(this, {\r statusCode: 404,\r restCode: 'TaskNotFound',\r message: owner + ' was not found',\r constructorOpt: TaskNotFoundError\r });\r this.name = 'TaskNotFoundError';\r }\r util.inherits(TaskNotFoundError, restify.RestError);\r ```\r \r \r ## <a name=\"14-create-your-server\"></a>14：创建服务器\r 最后一个步骤是添加服务器实例。 服务器实例用于管理调用。\r \r Restify（和 Express）提供可对 REST API 服务器使用的深度自定义功能。 本教程使用最基本的设置。\r \r ```Javascript\r /**\r * Your server\r */\r var server = restify.createServer({\r name: \"Azure Active Directory TODO Server\",\r version: \"2.0.1\"\r });\r // Ensure that you don't drop data on uploads.\r server.pre(restify.pre.pause());\r // Clean up imprecise paths like //todo//////1//.\r server.pre(restify.pre.sanitizePath());\r // Handle annoying user agents (curl).\r server.pre(restify.pre.userAgentConnection());\r // Set a per-request Bunyan logger (with requestid filled in).\r server.use(restify.requestLogger());\r // Allow 5 requests/second by IP address, and burst to 10.\r server.use(restify.throttle({\r burst: 10,\r rate: 5,\r ip: true,\r }));\r // Use common commands, such as:\r server.use(restify.acceptParser(server.acceptable));\r server.use(restify.dateParser());\r server.use(restify.queryParser());\r server.use(restify.gzipResponse());\r server.use(restify.bodyParser({\r mapParams: true\r }));\r ```\r ## <a name=\"15-add-the-routes-without-authentication-for-now\"></a>15：添加路由（目前不包括身份验证）\r ```Javascript\r /// Use CRUD to add the real handlers.\r /**\r /*\r /* Each of these handlers is protected by your Open ID Connect Bearer strategy. Invoke 'oidc-bearer'\r /* in the pasport.authenticate() method. Because REST is stateless, set 'session: false'. You \r /* don't need to maintain session state. You can experiment with removing API protection.\r /* To do this, remove the passport.authenticate() method:\r /*\r /* server.get('/tasks', listTasks);\r /*\r **/\r server.get('/tasks', listTasks);\r server.get('/tasks', listTasks);\r server.get('/tasks/:owner', getTask);\r server.head('/tasks/:owner', getTask);\r server.post('/tasks/:owner/:task', createTask);\r server.post('/tasks', createTask);\r server.del('/tasks/:owner/:task', removeTask);\r server.del('/tasks/:owner', removeTask);\r server.del('/tasks', removeTask);\r server.del('/tasks', removeAll, function respond(req, res, next) {\r res.send(204);\r next();\r });\r // Register a default '/' handler\r server.get('/', function root(req, res, next) {\r var routes = [\r 'GET /',\r 'POST /tasks/:owner/:task',\r 'POST /tasks (for JSON body)',\r 'GET /tasks',\r 'PUT /tasks/:owner',\r 'GET /tasks/:owner',\r 'DELETE /tasks/:owner/:task'\r ];\r res.send(200, routes);\r next();\r });\r server.listen(serverPort, function() {\r var consoleMessage = '\\n Azure Active Directory Tutorial';\r consoleMessage += '\\n +++++++++++++++++++++++++++++++++++++++++++++++++++++';\r consoleMessage += '\\n %s server is listening at %s';\r consoleMessage += '\\n Open your browser to %s/tasks\\n';\r consoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n';\r consoleMessage += '\\n !!! why not try a $curl -isS %s | json to get some ideas? \\n';\r consoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n\\n';\r });\r ```\r ## <a name=\"16-run-the-server\"></a>16：运行服务器\r 添加身份验证之前最好是先测试服务器。\r \r 测试服务器的最简单方法是在命令提示符下使用 curl。 为此，需要使用一个用于分析 JSON 输出的简单实用工具。 \r \r 1.  安装要在以下示例中使用的 JSON 工具：\r \r     `$npm install -g jsontool`\r \r     这将全局安装 JSON 工具。\r \r 2.  确保 MongoDB 实例正在运行：\r \r     `$sudo mongod`\r \r 3.  将目录切换到 **azuread**，然后运行 curl：\r \r     `$ cd azuread`\r     `$ node server.js`\r \r     `$ curl -isS http://127.0.0.1:8080 | json`\r \r     ```Shell\r     HTTP/1.1 2.0OK\r     Connection: close\r     Content-Type: application/json\r     Content-Length: 171\r     Date: Tue, 14 Jul 2015 05:43:38 GMT\r     [\r     \"GET /\",\r     \"POST /tasks/:owner/:task\",\r     \"POST /tasks (for JSON body)\",\r     \"GET /tasks\",\r     \"PUT /tasks/:owner\",\r     \"GET /tasks/:owner\",\r     \"DELETE /tasks/:owner/:task\"\r     ]\r     ```\r \r 4.  添加任务：\r \r     `$ curl -isS -X POST http://127.0.0.1:8888/tasks/brandon/Hello`\r \r     响应应为：\r \r     ```Shell\r     HTTP/1.1 201 Created\r     Connection: close\r     Access-Control-Allow-Origin: *\r     Access-Control-Allow-Headers: X-Requested-With\r     Content-Type: application/x-www-form-urlencoded\r     Content-Length: 5\r     Date: Tue, 04 Feb 2014 01:02:26 GMT\r     Hello\r     ```\r \r 5.  列出 Brandon 的任务：\r \r     `$ curl -isS http://127.0.0.1:8080/tasks/brandon/`\r \r 如果运行了所有这些命令且未出错，则可以将 OAuth 添加到 REST API 服务器。\r \r *现在，已有一台装有 MongoDB 的 REST API 服务器！*\r \r ## <a name=\"17-add-authentication-to-your-rest-api-server\"></a>17：将身份验证添加到 REST API 服务器\r 运行 REST API 后，请将它设置为与 Azure AD 配合使用。\r \r 在命令行中，将目录切换到 **azuread**：\r \r `cd azuread`\r \r ### <a name=\"use-the-oidcbearerstrategy-thats-included-with-passport-azure-ad\"></a>使用 passport-azure-ad 包含的 oidcbearerstrategy\r 到目前为止，我们已构建了一个典型的 REST TODO 服务器，其中不包含任何授权种类。 现在，请添加身份验证。\r \r 首先，指出你要使用 Passport。 在前面的服务器配置后面紧接着插入以下代码：\r \r ```Javascript\r // Start using Passport.js.\r \r server.use(passport.initialize()); // Starts passport\r server.use(passport.session()); // Provides session support\r ```\r \r > [!TIP]\r > 编写 API 时，最好是始终将数据链接到用户无法证明其在令牌中是唯一的项目。 此服务器存储 TODO 项目时，会根据令牌（通过 token.sub 调用）中的用户订阅 ID 来存储它们。 token.sub 放在“owner”字段中。 这可以确保只有该用户能够访问其自己的 TODO（待办事项）。 任何人都无法访问输入的 TODO。 “owner”的 API 中不公开任何信息。 外部用户可以请求其他用户的 TODO，即使他们已经过身份验证。\r > \r > \r \r 接下来，使用 `passport-azure-ad` 中随附的 Open ID Connect Bearer 策略。 将此代码放在上面粘贴的内容后面：\r \r ```Javascript\r /**\r /*\r /* Calling the OIDCBearerStrategy and managing users.\r /*\r /* Because of the Passport pattern, you need to manage users and info tokens\r /* with a FindorCreate() method. The method must be provided by the implementor.\r /* In the following code, you autoregister any user and implement a FindById().\r /* It's a good idea to do something more advanced.\r **/\r var findById = function(id, fn) {\r for (var i = 0, len = users.length; i < len; i++) {\r var user = users[i];\r if (user.sub === id) {\r log.info('Found user: ', user);\r return fn(null, user);\r }\r }\r return fn(null, null);\r };\r var oidcStrategy = new OIDCBearerStrategy(options,\r function(token, done) {\r log.info('verifying the user');\r log.info(token, 'was the token retrieved');\r findById(token.sub, function(err, user) {\r if (err) {\r return done(err);\r }\r if (!user) {\r // \"Auto-registration\"\r log.info('User was added automatically, because they were new. Their sub is: ', token.sub);\r users.push(token);\r owner = token.sub;\r return done(null, token);\r }\r owner = token.sub;\r return done(null, user, token);\r });\r }\r );\r passport.use(oidcStrategy);\r ```\r \r Passport 对其所有策略（Twitter、Facebook 等）都使用类似的模式。 所有策略编写器都遵循该模式。 向策略传递使用令牌和 `done` 作为参数的 `function()`。 策略会在完成所有任务后返回。 存储用户和令牌，这样一来，就不需要再次请求。\r \r > [!IMPORTANT]\r > 前面的代码会将所有可以进行身份验证的用户转到服务器。 这就是所谓的自动注册。 在生产服务器上，你会希望所有人都先经历你选择的注册过程，然后才能进入服务器。 通常会在消费类应用中看到这种模式。 应用可能会允许使用 Facebook 注册，但随后会要求输入其他信息。 如果在本教程中没有使用命令行程序，可从返回的令牌对象中提取电子邮件。 然后，可以要求用户输入其他信息。 由于这是测试服务器，可以直接将用户添加到内存中数据库。\r > \r > \r \r ### <a name=\"protect-endpoints\"></a>保护终结点\r 通过结合想要使用的协议指定 **passport.authenticate()** 调用来保护终结点。\r \r 可以在服务器代码中针对更高级的选项编辑路由：\r \r ```Javascript\r server.get('/tasks', passport.authenticate('oidc-bearer', {\r session: false\r }), listTasks);\r server.get('/tasks', passport.authenticate('oidc-bearer', {\r session: false\r }), listTasks);\r server.get('/tasks/:owner', passport.authenticate('oidc-bearer', {\r session: false\r }), getTask);\r server.head('/tasks/:owner', passport.authenticate('oidc-bearer', {\r session: false\r }), getTask);\r server.post('/tasks/:owner/:task', passport.authenticate('oidc-bearer', {\r session: false\r }), createTask);\r server.post('/tasks', passport.authenticate('oidc-bearer', {\r session: false\r }), createTask);\r server.del('/tasks/:owner/:task', passport.authenticate('oidc-bearer', {\r session: false\r }), removeTask);\r server.del('/tasks/:owner', passport.authenticate('oidc-bearer', {\r session: false\r }), removeTask);\r server.del('/tasks', passport.authenticate('oidc-bearer', {\r session: false\r }), removeTask);\r server.del('/tasks', passport.authenticate('oidc-bearer', {\r session: false\r }), removeAll, function respond(req, res, next) {\r res.send(204);\r next();\r });\r ```\r \r ## <a name=\"18-run-your-server-application-again\"></a>18：再次运行服务器应用程序\r 再次使用 curl 来检查是否针对终结点提供 OAuth 2.0 保护。 请在针对此终结点运行任何客户端 SDK 之前执行此操作。 返回的标头应告知身份验证是否正常工作。\r \r 1.  确保 MongoDB 实例正在运行：\r \r     `$sudo mongod`\r \r 2.  切换到 **azuread** 目录，然后使用 curl：\r \r     `$ cd azuread`\r \r     `$ node server.js`\r \r 3.  试用基本 POST：\r \r     `$ curl -isS -X POST http://127.0.0.1:8080/tasks/brandon/Hello`\r \r     ```Shell\r     HTTP/1.1 401 Unauthorized\r     Connection: close\r     WWW-Authenticate: Bearer realm=\"Users\"\r     Date: Tue, 14 Jul 2015 05:45:03 GMT\r     Transfer-Encoding: chunked\r     ```\r \r 401 响应表明 Passport 层正在尝试重定向到授权终结点，这正是我们所希望的。\r \r *你现在已创建了一个使用 OAuth 2.0 的 REST API 服务！*\r \r 这就是在不使用 OAuth 2.0 兼容客户端的情况下，此服务器能够带来的最大优势。 相关信息，请参阅其他教程。\r \r ## <a name=\"next-steps\"></a>后续步骤\r 某个 [.zip 文件](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs/archive/complete.zip)提供了完整的示例（不包括配置值）供参考。 还可以从 GitHub 中进行克隆：\r \r ```git clone --branch complete https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs.git```\r \r 现在，可以继续学习更高级的主题。 请尝试学习[使用 v2.0 终结点保护 Node.js Web 应用](active-directory-v2-devquickstarts-node-web.md)。\r \r 下面是一些其他资源：\r \r - [Azure AD v2.0 开发人员指南](active-directory-appmodel-v2-overview.md)\r - [堆栈溢出“azure-active-directory”标记](http://stackoverflow.com/questions/tagged/azure-active-directory)\r \r ### <a name=\"get-security-updates-for-our-products\"></a>获取关于我们产品的安全更新\r 我们建议注册，以便在发生安全事件时获得通知。 在 [Microsoft 技术安全通知](https://technet.microsoft.com/security/dd252948)页上订阅安全顾问警报。\r \r \r "}