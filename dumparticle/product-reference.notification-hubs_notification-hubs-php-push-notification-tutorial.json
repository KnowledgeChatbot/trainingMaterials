{"Title":"如何结合使用通知中心与 PHP","Description":"了解如何从 PHP 后端使用 Azure 通知中心。","Content":"\r # 如何通过 PHP 使用通知中心\r [!INCLUDE [notification-hubs-backend-how-to-selector](../../includes/notification-hubs-backend-how-to-selector.md)]\r \r 如 MSDN 主题[通知中心 REST API](http://msdn.microsoft.com/zh-cn/library/dn223264.aspx) 中所述，你可以使用通知中心 REST 接口从 Java/PHP/Ruby 后端访问所有通知中心功能。\r \r 本主题中，我们将向你介绍如何：\r \r * 以 PHP 构建 REST 客户端以获取通知中心功能；\r * 请按照你选定的移动平台的[入门教程](./notification-hubs-ios-apple-push-notification-apns-get-started.md)以 PHP 实现后端部分。\r \r ## 客户端接口\r 主要的客户端接口可提供 [.NET 通知中心 SDK](http://msdn.microsoft.com/zh-cn/library/jj933431.aspx) 中提供的相同方法，这将允许你直接翻译当前此站点上提供的所有教程和示例，这些内容均来自 Internet 上的社区。\r \r 你可以在 [PHP REST 包装器示例]中找到提供的所有代码。\r \r 例如，创建客户端：\r \r ```\r $hub = new NotificationHub(\"connection string\", \"hubname\");\t\r ```\r \r 发送 iOS 本机通知：\r \r ```\r $notification = new Notification(\"apple\", '{\"aps\":{\"alert\": \"Hello!\"}}');\r $hub->sendNotification($notification, null);\r ```\r \r ## 实现\r 如果你尚未实现，请按照我们的[入门教程]学至最后一节，其中你必须实现后端。此外，如果你希望可以使用 [PHP REST 包装器示例]中的代码并直接转到[完成本教程](#complete-tutorial)部分。\r \r 有关实现完整 REST 包装器的所有详细信息，请访问 [MSDN](http://msdn.microsoft.com/zh-cn/library/dn530746.aspx)。在本部分中，我们将向你介绍访问通知中心 REST 终结点所需的主要步骤的 PHP 实现：\r \r 1. 解析连接字符串\r 2. 生成授权令牌\r 3. 执行 HTTP 调用\r \r ### 解析连接字符串\r \r 下面是实现客户端的主类，其构造函数将解析连接字符串：\r \r ```\r class NotificationHub {\r     const API_VERSION = \"?api-version=2013-10\";\r \r     private $endpoint;\r     private $hubPath;\r     private $sasKeyName;\r     private $sasKeyValue;\r \r     function __construct($connectionString, $hubPath) {\r         $this->hubPath = $hubPath;\r \r         $this->parseConnectionString($connectionString);\r     }\r \r     private function parseConnectionString($connectionString) {\r         $parts = explode(\";\", $connectionString);\r         if (sizeof($parts) != 3) {\r             throw new Exception(\"Error parsing connection string: \" . $connectionString);\r         }\r \r         foreach ($parts as $part) {\r             if (strpos($part, \"Endpoint\") === 0) {\r                 $this->endpoint = \"https\" . substr($part, 11);\r             } else if (strpos($part, \"SharedAccessKeyName\") === 0) {\r                 $this->sasKeyName = substr($part, 20);\r             } else if (strpos($part, \"SharedAccessKey\") === 0) {\r                 $this->sasKeyValue = substr($part, 16);\r             }\r         }\r     }\r }\r ```\r \r ### 创建安全令牌\r 有关安全令牌创建的详细信息，请访问[此处](http://msdn.microsoft.com/library/dn495627.aspx)。\r 以下方法必须添加到 **NotificationHub** 类，以便根据当前请求的 URI 和提取自连接字符串的凭据创建令牌。\r \r ```\r private function generateSasToken($uri) {\r     $targetUri = strtolower(rawurlencode(strtolower($uri)));\r \r     $expires = time();\r     $expiresInMins = 60;\r     $expires = $expires + $expiresInMins * 60;\r     $toSign = $targetUri . \"\\n\" . $expires;\r \r     $signature = rawurlencode(base64_encode(hash_hmac('sha256', $toSign, $this->sasKeyValue, TRUE)));\r \r     $token = \"SharedAccessSignature sr=\" . $targetUri . \"&sig=\"\r                 . $signature . \"&se=\" . $expires . \"&skn=\" . $this->sasKeyName;\r \r     return $token;\r }\r ```\r \r ### 发送通知\r 首先，让我们定义表示通知的类。\r \r ```\r class Notification {\r     public $format;\r     public $payload;\r \r     # array with keynames for headers\r     # Note: Some headers are mandatory: Windows: X-WNS-Type, WindowsPhone: X-NotificationType\r     # Note: For Apple you can set Expiry with header: ServiceBusNotification-ApnsExpiry in W3C DTF, YYYY-MM-DDThh:mmTZD (for example, 1997-07-16T19:20+01:00).\r     public $headers;\r \r     function __construct($format, $payload) {\r         if (!in_array($format, [\"template\", \"apple\", \"windows\", \"gcm\", \"windowsphone\"])) {\r             throw new Exception('Invalid format: ' . $format);\r         }\r \r         $this->format = $format;\r         $this->payload = $payload;\r     }\r }\r ```\r \r 此类是一个容器，其中包含本机通知正文或一组模板通知上的属性，以及一组包含格式（本机平台或模板）和平台特定属性（如 Apple 过期属性和 WNS 标头）的标头。\r \r 请参阅[通知中心 REST API 文档](http://msdn.microsoft.com/zh-cn/library/dn495827.aspx)和具体的通知平台格式以了解所有可用选项。\r \r 具备了此类后，我们现在可以在 **NotificationHub** 类中编写发送通知方法了。\r \r ```\r public function sendNotification($notification, $tagsOrTagExpression=\"\") {\r     if (is_array($tagsOrTagExpression)) {\r         $tagExpression = implode(\" || \", $tagsOrTagExpression);\r     } else {\r         $tagExpression = $tagsOrTagExpression;\r     }\r \r     # build uri\r     $uri = $this->endpoint . $this->hubPath . \"/messages\" . NotificationHub::API_VERSION;\r     $ch = curl_init($uri);\r \r     if (in_array($notification->format, [\"template\", \"apple\", \"gcm\"])) {\r         $contentType = \"application/json\";\r     } else {\r         $contentType = \"application/xml\";\r     }\r \r     $token = $this->generateSasToken($uri);\r \r     $headers = [\r         'Authorization: '.$token,\r         'Content-Type: '.$contentType,\r         'ServiceBusNotification-Format: '.$notification->format\r     ];\r \r     if (\"\" !== $tagExpression) {\r         $headers[] = 'ServiceBusNotification-Tags: '.$tagExpression;\r     }\r \r     # add headers for other platforms\r     if (is_array($notification->headers)) {\r         $headers = array_merge($headers, $notification->headers);\r     }\r \r     curl_setopt_array($ch, array(\r         CURLOPT_POST => TRUE,\r         CURLOPT_RETURNTRANSFER => TRUE,\r         CURLOPT_SSL_VERIFYPEER => FALSE,\r         CURLOPT_HTTPHEADER => $headers,\r         CURLOPT_POSTFIELDS => $notification->payload\r     ));\r \r     // Send the request\r     $response = curl_exec($ch);\r \r     // Check for errors\r     if($response === FALSE){\r         throw new Exception(curl_error($ch));\r     }\r \r     $info = curl_getinfo($ch);\r \r     if ($info['http_code'] <> 201) {\r         throw new Exception('Error sending notificaiton: '. $info['http_code'] . ' msg: ' . $response);\r     }\r } \r ```\r \r 以上方法将 HTTP POST 请求发送到你通知中心的 /messages 终结点，该请求具有发送通知的正确正文和标头。\r \r ##<a name=\"complete-tutorial\"></a>完成教程\r 现在，你可以通过从 PHP 后端发送通知来完成该入门教程。\r \r 初始化你的通知中心客户端（按[入门教程]中所述替换连接字符串和中心名称）：\r \r ```\r $hub = new NotificationHub(\"connection string\", \"hubname\");\t\r ```\r \r 然后，根据你的目标移动平台添加发送代码。\r \r ### Windows 应用商店和 Windows Phone 8.1（非 Silverlight）\r \r ```\r $toast = '<toast><visual><binding template=\"ToastText01\"><text id=\"1\">Hello from PHP!</text></binding></visual></toast>';\r $notification = new Notification(\"windows\", $toast);\r $notification->headers[] = 'X-WNS-Type: wns/toast';\r $hub->sendNotification($notification, null);\r ```\r \r ### iOS\r \r ```\r $alert = '{\"aps\":{\"alert\":\"Hello from PHP!\"}}';\r $notification = new Notification(\"apple\", $alert);\r $hub->sendNotification($notification, null);\r ```\r \r ### Android\r ```\r $message = '{\"data\":{\"msg\":\"Hello from PHP!\"}}';\r $notification = new Notification(\"gcm\", $message);\r $hub->sendNotification($notification, null);\r ```\r \r ### Windows Phone 8.0 和 8.1 Silverlight\r \r ```\r $toast = '<?xml version=\"1.0\" encoding=\"utf-8\"?>' .\r             '<wp:Notification xmlns:wp=\"WPNotification\">' .\r                '<wp:Toast>' .\r                     '<wp:Text1>Hello from PHP!</wp:Text1>' .\r                '</wp:Toast> ' .\r             '</wp:Notification>';\r $notification = new Notification(\"windowsphone\", $toast);\r $notification->headers[] = 'X-WindowsPhone-Target : toast';\r $notification->headers[] = 'X-NotificationClass : 2';\r $hub->sendNotification($notification, null);\r ```\r \r ### Kindle Fire\r ```\r $message = '{\"data\":{\"msg\":\"Hello from PHP!\"}}';\r $notification = new Notification(\"adm\", $message);\r $hub->sendNotification($notification, null);\r ```\r \r 运行 PHP 代码，现在应该生成显示在目标设备上的通知。\r \r ## 后续步骤\r 在本主题中，我们介绍了如何为通知中心创建简单的 Java REST 客户端。从这里你可以：\r \r * 下载完整的 [PHP REST 包装器示例]，其中包含上述所有代码。\r * 在 [突发新闻教程] 中继续学习通知中心标记功能\r * 在 [通知用户教程] 中了解如何将通知推送到单个用户\r \r 有关详细信息，另请参阅 [PHP 开发人员中心](https://www.azure.cn/develop/php/)。\r \r [PHP REST 包装器示例]: https://github.com/Azure/azure-notificationhubs-samples/tree/master/notificationhubs-rest-php\r [入门教程]: ./notification-hubs-ios-apple-push-notification-apns-get-started.md\r \r <!---HONumber=Mooncake_Quality_Review_0104_2017-->"}