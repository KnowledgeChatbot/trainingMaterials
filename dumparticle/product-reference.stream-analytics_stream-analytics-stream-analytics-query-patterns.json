{"Title":"流分析中常用使用模式的查询示例","Description":"常见的 Azure 流分析查询模式","Content":"# <a name=\"query-examples-for-common-stream-analytics-usage-patterns\"></a>常用流分析使用模式的查询示例\r ## <a name=\"introduction\"></a>介绍\r Azure 流分析中的查询以类似 SQL 的查询语言表示。 这些查询记录在[流分析查询语言参考](https://msdn.microsoft.com/library/azure/dn834998.aspx)指南中。 本文档概述了以真实情况为基础的多个常见查询模式的解决方案。 此项工作仍在进行，将继续使用新的模式不断进行更新。\r \r ## <a name=\"query-example-convert-data-types\"></a>查询示例：转换数据类型\r **说明**：定义输入流中的属性类型。\r 例如，在输入流中，车重是字符串，需要将它转换为 INT 类型才能执行 SUM 运算。\r \r **输入**：\r \r | 制造商 | 时间 | 重量 |\r | --- | --- | --- |\r | Honda |2015-01-01T00:00:01.0000000Z |“1000” |\r | Honda |2015-01-01T00:00:02.0000000Z |“2000” |\r \r **输出**：\r \r | 制造商 | 重量 |\r | --- | --- |\r | Honda |3000 |\r \r **解决方案**；\r \r     SELECT\r         Make,\r         SUM(CAST(Weight AS BIGINT)) AS Weight\r     FROM\r         Input TIMESTAMP BY Time\r     GROUP BY\r         Make,\r         TumblingWindow(second, 10)\r \r **说明**：在“重量”字段中使用 CAST 语句来指定它的数据类型。 请参阅[数据类型（Azure 流分析）](https://msdn.microsoft.com/library/azure/dn835065.aspx)中支持的数据类型列表。\r \r ## <a name=\"query-example-use-likenot-like-to-do-pattern-matching\"></a>查询示例：使用 Like/Not like 进行模式匹配\r **说明**：检查事件上的字段值是否与特定的模式相匹配。\r 例如，检查返回以 A 开头并以 9 结尾的车牌的结果。\r \r **输入**：\r \r | 制造商 | 牌照 | 时间 |\r | --- | --- | --- |\r | Honda |ABC-123 |2015-01-01T00:00:01.0000000Z |\r | Toyota |AAA-999 |2015-01-01T00:00:02.0000000Z |\r | Nissan |ABC-369 |2015-01-01T00:00:03.0000000Z |\r \r **输出**：\r \r | 制造商 | 牌照 | 时间 |\r | --- | --- | --- |\r | Toyota |AAA-999 |2015-01-01T00:00:02.0000000Z |\r | Nissan |ABC-369 |2015-01-01T00:00:03.0000000Z |\r \r **解决方案**；\r \r     SELECT\r         *\r     FROM\r         Input TIMESTAMP BY Time\r     WHERE\r         LicensePlate LIKE 'A%9'\r \r **说明**：使用 LIKE 语句检查 LicensePlate 字段的值。 它应当以 A 开头，其中包含零个或多个字符的任意字符串，并以 9 结尾。 \r \r ## <a name=\"query-example-specify-logic-for-different-casesvalues-case-statements\"></a>查询示例：指定不同案例/值的逻辑（CASE 语句）\r **说明**：根据某些特定条件对字段进行各种计算。\r 例如，同一制造商的汽车通过数量为 1 时，为这种特殊情况提供一个字符串说明。\r \r **输入**：\r \r | 制造商 | 时间 |\r | --- | --- |\r | Honda |2015-01-01T00:00:01.0000000Z |\r | Toyota |2015-01-01T00:00:02.0000000Z |\r | Toyota |2015-01-01T00:00:03.0000000Z |\r \r **输出**：\r \r | 通过的车辆 | 时间 |\r | --- | ------ |\r | 1 辆 Honda |2015-01-01T00:00:10.0000000Z |\r | 2 辆 Toyota |2015-01-01T00:00:10.0000000Z |\r \r **解决方案**；\r \r     SELECT\r         CASE\r             WHEN COUNT(*) = 1 THEN CONCAT('1 ', Make)\r             ELSE CONCAT(CAST(COUNT(*) AS NVARCHAR(MAX)), ' ', Make, 's')\r         END AS CarsPassed,\r         System.TimeStamp AS Time\r     FROM\r         Input TIMESTAMP BY Time\r     GROUP BY\r         Make,\r         TumblingWindow(second, 10)\r \r **说明**：可通过 CASE 子句根据某些条件（在此示例中为聚合窗口中车辆的计数）提供不同的计算操作。\r \r ## <a name=\"query-example-send-data-to-multiple-outputs\"></a>查询示例：将数据发送到多个输出\r **说明**：从单个作业中将数据发送到多个输出目标。\r 例如，分析基于阈值的警报数据，并将所有事件保存到 blob 存储。\r \r **输入**：\r \r | 制造商 | 时间 |\r | --- | --- |\r | Honda |2015-01-01T00:00:01.0000000Z |\r | Honda |2015-01-01T00:00:02.0000000Z |\r | Toyota |2015-01-01T00:00:01.0000000Z |\r | Toyota |2015-01-01T00:00:02.0000000Z |\r | Toyota |2015-01-01T00:00:03.0000000Z |\r \r **输出 1**：\r \r | 制造商 | 时间 |\r | --- | --- |\r | Honda |2015-01-01T00:00:01.0000000Z |\r | Honda |2015-01-01T00:00:02.0000000Z |\r | Toyota |2015-01-01T00:00:01.0000000Z |\r | Toyota |2015-01-01T00:00:02.0000000Z |\r | Toyota |2015-01-01T00:00:03.0000000Z |\r \r **输出 2**：\r \r | 制造商 | 时间 | 计数 |\r | --- | --- | --- |\r | Toyota |2015-01-01T00:00:10.0000000Z |3 |\r \r **解决方案**；\r \r     SELECT\r         *\r     INTO\r         ArchiveOutput\r     FROM\r         Input TIMESTAMP BY Time\r \r     SELECT\r         Make,\r         System.TimeStamp AS Time,\r         COUNT(*) AS [Count]\r     INTO\r         AlertOutput\r     FROM\r         Input TIMESTAMP BY Time\r     GROUP BY\r         Make,\r         TumblingWindow(second, 10)\r     HAVING\r         [Count] >= 3\r \r **说明**：INTO 子句告知流分析哪一个输出可通过此语句写入数据。\r 第一个查询将我们接收到的数据传递到名为 **ArchiveOutput** 的输出。\r 第二个查询进行了一些简单的聚合和筛选操作，并将结果发送到下游的警报系统。\r \r 请注意，还可重复使用多个输出语句中的公用表表达式 (CTE) 结果（例如 **WITH** 语句）。 此选项可提供额外权益，即在输入源打开较少的读取器。\r 例如： \r \r     WITH AllRedCars AS (\r         SELECT\r             *\r         FROM\r             Input TIMESTAMP BY Time\r         WHERE\r             Color = 'red'\r     )\r     SELECT * INTO HondaOutput FROM AllRedCars WHERE Make = 'Honda'\r     SELECT * INTO ToyotaOutput FROM AllRedCars WHERE Make = 'Toyota'\r \r ## <a name=\"query-example-count-unique-values\"></a>查询示例：对唯一值进行计算\r **说明**：计算时间范围内流中显示的唯一字段值数。\r 例如，在 2 秒的时间范围内，通过收费站的同一制造商的汽车数量是多少？\r \r **输入**：\r \r | 制造商 | 时间 |\r | --- | --- |\r | Honda |2015-01-01T00:00:01.0000000Z |\r | Honda |2015-01-01T00:00:02.0000000Z |\r | Toyota |2015-01-01T00:00:01.0000000Z |\r | Toyota |2015-01-01T00:00:02.0000000Z |\r | Toyota |2015-01-01T00:00:03.0000000Z |\r \r **输出：**\r \r | 计数 | 时间 |\r | --- | --- |\r | 2 |2015-01-01T00:00:02.000Z |\r | 1 |2015-01-01T00:00:04.000Z |\r \r **解决方案：**\r \r ```\r SELECT\r      COUNT(DISTINCT Make) AS CountMake,\r      System.TIMESTAMP AS TIME\r FROM Input TIMESTAMP BY TIME\r GROUP BY \r      TumblingWindow(second, 2)\r ```\r \r **说明：**\r COUNT(DISTINCT Make) 返回时间范围内的“制造商”列的非重复值数目。\r \r ## <a name=\"query-example-determine-if-a-value-has-changed\"></a>查询示例：确定某个值是否已更改\r **说明**：可通过查看前一个值来确定它与当前的值是否相同。\r 例如：在收费路段前一辆汽车与当前汽车的制造商是否相同？\r \r **输入**：\r \r | 制造商 | 时间 |\r | --- | --- |\r | Honda |2015-01-01T00:00:01.0000000Z |\r | Toyota |2015-01-01T00:00:02.0000000Z |\r \r **输出**：\r \r | 制造商 | 时间 |\r | --- | --- |\r | Toyota |2015-01-01T00:00:02.0000000Z |\r \r **解决方案**；\r \r     SELECT\r         Make,\r         Time\r     FROM\r         Input TIMESTAMP BY Time\r     WHERE\r         LAG(Make, 1) OVER (LIMIT DURATION(minute, 1)) <> Make\r \r **说明**：使用 LAG 来查看后退一个事件之后的输入流，并获得“制造商”字段的值。 然后，将它与当前事件的“制造商”字段进行比较，如果二者不同，则输出该事件。\r \r ## <a name=\"query-example-find-the-first-event-in-a-window\"></a>查询示例：查找时间范围内的第一个事件\r **说明**：查找每 10 分钟时间间隔内的第一辆汽车。\r \r **输入**：\r \r | 牌照 | 制造商 | 时间 |\r | --- | --- | --- |\r | DXE 5291 |Honda |2015-07-27T00:00:05.0000000Z |\r | YZK 5704 |Ford |2015-07-27T00:02:17.0000000Z |\r | RMV 8282 |Honda |2015-07-27T00:05:01.0000000Z |\r | YHN 6970 |Toyota |2015-07-27T00:06:00.0000000Z |\r | VFE 1616 |Toyota |2015-07-27T00:09:31.0000000Z |\r | QYF 9358 |Honda |2015-07-27T00:12:02.0000000Z |\r | MDR 6128 |BMW |2015-07-27T00:13:45.0000000Z |\r \r **输出**：\r \r | 牌照 | 制造商 | 时间 |\r | --- | --- | --- |\r | DXE 5291 |Honda |2015-07-27T00:00:05.0000000Z |\r | QYF 9358 |Honda |2015-07-27T00:12:02.0000000Z |\r \r **解决方案**：\r \r     SELECT \r         LicensePlate,\r         Make,\r         Time\r     FROM \r         Input TIMESTAMP BY Time\r     WHERE \r         IsFirst(minute, 10) = 1\r \r 现在，我们来变一下这个问题，查找每 10 分钟时间间隔内特定制造商的第一辆汽车。\r \r | 牌照 | 制造商 | 时间 |\r | --- | --- | --- |\r | DXE 5291 |Honda |2015-07-27T00:00:05.0000000Z |\r | YZK 5704 |Ford |2015-07-27T00:02:17.0000000Z |\r | YHN 6970 |Toyota |2015-07-27T00:06:00.0000000Z |\r | QYF 9358 |Honda |2015-07-27T00:12:02.0000000Z |\r | MDR 6128 |BMW |2015-07-27T00:13:45.0000000Z |\r \r **解决方案**；\r \r     SELECT \r         LicensePlate,\r         Make,\r         Time\r     FROM \r         Input TIMESTAMP BY Time\r     WHERE \r         IsFirst(minute, 10) OVER (PARTITION BY Make) = 1\r \r ## <a name=\"query-example-find-the-last-event-in-a-window\"></a>查询示例：查找时间范围内的最后一个事件\r **说明**：查找每 10 分钟时间间隔内的最后一辆汽车。\r \r **输入**：\r \r | 牌照 | 制造商 | 时间 |\r | --- | --- | --- |\r | DXE 5291 |Honda |2015-07-27T00:00:05.0000000Z |\r | YZK 5704 |Ford |2015-07-27T00:02:17.0000000Z |\r | RMV 8282 |Honda |2015-07-27T00:05:01.0000000Z |\r | YHN 6970 |Toyota |2015-07-27T00:06:00.0000000Z |\r | VFE 1616 |Toyota |2015-07-27T00:09:31.0000000Z |\r | QYF 9358 |Honda |2015-07-27T00:12:02.0000000Z |\r | MDR 6128 |BMW |2015-07-27T00:13:45.0000000Z |\r \r **输出**：\r \r | 牌照 | 制造商 | 时间 |\r | --- | --- | --- |\r | VFE 1616 |Toyota |2015-07-27T00:09:31.0000000Z |\r | MDR 6128 |BMW |2015-07-27T00:13:45.0000000Z |\r \r **解决方案**；\r \r     WITH LastInWindow AS\r     (\r         SELECT \r             MAX(Time) AS LastEventTime\r         FROM \r             Input TIMESTAMP BY Time\r         GROUP BY \r             TumblingWindow(minute, 10)\r     )\r     SELECT \r         Input.LicensePlate,\r         Input.Make,\r         Input.Time\r     FROM\r         Input TIMESTAMP BY Time \r         INNER JOIN LastInWindow\r         ON DATEDIFF(minute, Input, LastInWindow) BETWEEN 0 AND 10\r         AND Input.Time = LastInWindow.LastEventTime\r \r **说明**：查询中包含两个步骤。 第一个步骤是在 10 分钟的时间范围内查找最新的时间戳。 第二个步骤是将第一个查询的结果与原始流联接，查找每个时间范围内与最后一个时间戳相匹配的事件。 \r \r ## <a name=\"query-example-detect-the-absence-of-events\"></a>查询示例：检测缺少的事件\r **说明**：查看流的值是否不与某个条件相匹配。\r 例如，两辆同一制造商的汽车是否在 90 秒内先后进入收费路段？\r \r **输入**：\r \r | 制造商 | 牌照 | 时间 |\r | --- | --- | --- |\r | Honda |ABC-123 |2015-01-01T00:00:01.0000000Z |\r | Honda |AAA-999 |2015-01-01T00:00:02.0000000Z |\r | Toyota |DEF-987 |2015-01-01T00:00:03.0000000Z |\r | Honda |GHI-345 |2015-01-01T00:00:04.0000000Z |\r \r **输出**：\r \r | 制造商 | 时间 | CurrentCarLicensePlate | FirstCarLicensePlate | FirstCarTime |\r | --- | --- | --- | --- | --- |\r | Honda |2015-01-01T00:00:02.0000000Z |AAA-999 |ABC-123 |2015-01-01T00:00:01.0000000Z |\r \r **解决方案**；\r \r     SELECT\r         Make,\r         Time,\r         LicensePlate AS CurrentCarLicensePlate,\r         LAG(LicensePlate, 1) OVER (LIMIT DURATION(second, 90)) AS FirstCarLicensePlate,\r         LAG(Time, 1) OVER (LIMIT DURATION(second, 90)) AS FirstCarTime\r     FROM\r         Input TIMESTAMP BY Time\r     WHERE\r         LAG(Make, 1) OVER (LIMIT DURATION(second, 90)) = Make\r \r **说明**：使用 LAG 来查看后退一个事件之后的输入流，并获得“制造商”字段的值。 将它与当前事件的“制造商”字段进行比较，如果二者相同，则输出该事件。 还可使用 **LAG** 获取前一辆汽车的数据。\r \r ## <a name=\"query-example-detect-the-duration-between-events\"></a>查询示例：检测事件之间的持续时间\r **说明**：查找给定事件的持续时间。 例如：给定一个 Web 点击流，确定某项功能花费的时间。\r \r **输入**：  \r \r | 用户 | 功能 | 事件 | 时间 |\r | --- | --- | --- | --- |\r | user@location.com |RightMenu |开始 |2015-01-01T00:00:01.0000000Z |\r | user@location.com |RightMenu |结束 |2015-01-01T00:00:08.0000000Z |\r \r **输出**：  \r \r | 用户 | 功能 | 持续时间 |\r | --- | --- | --- |\r | user@location.com |RightMenu |7 |\r \r **解决方案**；\r \r ```\r     SELECT\r         [user], feature, DATEDIFF(second, LAST(Time) OVER (PARTITION BY [user], feature LIMIT DURATION(hour, 1) WHEN Event = 'start'), Time) as duration\r     FROM input TIMESTAMP BY Time\r     WHERE\r         Event = 'end'\r ```\r \r **说明**：使用 LAST 函数检索上次事件类型为“开始”时的时间值。 **LAST** 函数使用 **PARTITION BY [user]** 指示结果应按唯一用户计算。 该查询在“开始”和“停止”事件之间有 1 小时的最大时差阈值，但也可按需配置 **(LIMIT DURATION(hour, 1)**。\r \r ## <a name=\"query-example-detect-the-duration-of-a-condition\"></a>查询示例：检测某个条件的持续时间\r **说明**：查看某个条件的持续时间。\r 例如，假设某个 Bug 导致所有汽车的重量均不正确（超出 20000 磅）。 我们需要计算该 Bug 的持续时间。\r \r **输入**：\r \r | 制造商 | 时间 | 重量 |\r | --- | --- | --- |\r | Honda |2015-01-01T00:00:01.0000000Z |2000 |\r | Toyota |2015-01-01T00:00:02.0000000Z |25000 |\r | Honda |2015-01-01T00:00:03.0000000Z |26000 |\r | Toyota |2015-01-01T00:00:04.0000000Z |25000 |\r | Honda |2015-01-01T00:00:05.0000000Z |26000 |\r | Toyota |2015-01-01T00:00:06.0000000Z |25000 |\r | Honda |2015-01-01T00:00:07.0000000Z |26000 |\r | Toyota |2015-01-01T00:00:08.0000000Z |2000 |\r \r **输出**：\r \r | StartFault | EndFault |\r | --- | --- |\r | 2015-01-01T00:00:02.000Z |2015-01-01T00:00:07.000Z |\r \r **解决方案**；\r \r ```\r     WITH SelectPreviousEvent AS\r     (\r     SELECT\r     *,\r         LAG([time]) OVER (LIMIT DURATION(hour, 24)) as previousTime,\r         LAG([weight]) OVER (LIMIT DURATION(hour, 24)) as previousWeight\r     FROM input TIMESTAMP BY [time]\r     )\r \r     SELECT \r         LAG(time) OVER (LIMIT DURATION(hour, 24) WHEN previousWeight < 20000 ) [StartFault],\r         previousTime [EndFault]\r     FROM SelectPreviousEvent\r     WHERE\r         [weight] < 20000\r         AND previousWeight > 20000\r ```\r \r **说明**：使用 LAG 查看 24 小时内的输入流并查找因重量 < 20000 而持续的 StartFault 和 StopFault 实例。\r \r ## <a name=\"query-example-fill-missing-values\"></a>查询示例：填充缺失值\r **说明**：对于值缺失的事件流，以固定的间隔生成事件流。\r 例如，每间隔 5 秒生成一个事件，报告最新发现的数据点。\r \r **输入**：\r \r | t | value |\r | --- | --- |\r | “2014-01-01T06:01:00” |1 |\r | “2014-01-01T06:01:05” |2 |\r | “2014-01-01T06:01:10” |3 |\r | “2014-01-01T06:01:15” |4 |\r | “2014-01-01T06:01:30” |5 |\r | “2014-01-01T06:01:35” |6 |\r \r **输出（前 10 行）**：\r \r | windowend | lastevent.t | lastevent.value |\r | --- | --- | --- |\r | 2014-01-01T14:01:00.000Z |2014-01-01T14:01:00.000Z |1 |\r | 2014-01-01T14:01:05.000Z |2014-01-01T14:01:05.000Z |2 |\r | 2014-01-01T14:01:10.000Z |2014-01-01T14:01:10.000Z |3 |\r | 2014-01-01T14:01:15.000Z |2014-01-01T14:01:15.000Z |4 |\r | 2014-01-01T14:01:20.000Z |2014-01-01T14:01:15.000Z |4 |\r | 2014-01-01T14:01:25.000Z |2014-01-01T14:01:15.000Z |4 |\r | 2014-01-01T14:01:30.000Z |2014-01-01T14:01:30.000Z |5 |\r | 2014-01-01T14:01:35.000Z |2014-01-01T14:01:35.000Z |6 |\r | 2014-01-01T14:01:40.000Z |2014-01-01T14:01:35.000Z |6 |\r | 2014-01-01T14:01:45.000Z |2014-01-01T14:01:35.000Z |6 |\r \r **解决方案**；\r \r     SELECT\r         System.Timestamp AS windowEnd,\r         TopOne() OVER (ORDER BY t DESC) AS lastEvent\r     FROM\r         input TIMESTAMP BY t\r     GROUP BY HOPPINGWINDOW(second, 300, 5)\r \r **说明**：此查询每隔 5 秒生成一个事件，并输出上次收到的最后一个事件。 [跳跃窗口](https://msdn.microsoft.com/library/dn835041.aspx \"跳跃窗口 - Azure 流分析\")持续时间确定查询将查找最新事件的时间（在本例中为 300 秒）。\r \r ## <a name=\"get-help\"></a>获取帮助\r 如需进一步的帮助，请尝试我们的 [Azure 流分析论坛](https://social.msdn.microsoft.com/Forums/en-US/home?forum=AzureStreamAnalytics)。\r \r ## <a name=\"next-steps\"></a>后续步骤\r * [Azure 流分析简介](stream-analytics-introduction.md)\r * [Azure 流分析入门](stream-analytics-real-time-fraud-detection.md)\r * [缩放 Azure 流分析作业](stream-analytics-scale-jobs.md)\r * [Azure 流分析查询语言参考](https://msdn.microsoft.com/library/azure/dn834998.aspx)\r * [Azure 流分析管理 REST API 参考](https://msdn.microsoft.com/library/azure/dn835031.aspx)\r \r <!--Update_Description: update meta properties -->"}