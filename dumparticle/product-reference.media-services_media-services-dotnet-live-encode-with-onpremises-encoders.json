{"Title":"如何使用 .NET 通过本地编码器执行实时传送视频流","Description":"本主题演示如何使用 .NET 通过本地编码器执行实时编码。","Content":"# <a name=\"how-to-perform-live-streaming-with-on-premises-encoders-using-net\"></a>如何使用 .NET 通过本地编码器执行实时传送视频流\r > [!div class=\"op_single_selector\"]\r > * [门户](media-services-portal-live-passthrough-get-started.md)\r > * [.NET](media-services-dotnet-live-encode-with-onpremises-encoders.md)\r > * [REST](https://docs.microsoft.com/rest/api/media/operations/channel)\r > \r > \r \r 本教程逐步演示如何使用 Azure 媒体服务 .NET SDK 创建为实现直通传送而配置的 **频道** 。 \r \r ## <a name=\"prerequisites\"></a>先决条件\r 以下是完成本教程所需具备的条件：\r \r * 一个 Azure 帐户。\r * 一个媒体服务帐户。 若要创建媒体服务帐户，请参阅 [如何创建媒体服务帐户](media-services-portal-create-account.md)。\r * 设置开发环境。 有关详细信息，请参阅[设置环境](media-services-set-up-computer.md)。\r * 网络摄像机。 例如， [Telestream Wirecast 编码器](http://www.telestream.net/wirecast/overview.htm)。\r \r 建议阅读以下文章：\r \r * [Azure 媒体服务 RTMP 支持和实时编码器](https://azure.microsoft.com/blog/2014/09/18/azure-media-services-rtmp-support-and-live-encoders/)\r * [使用可创建多比特率流的本地编码器实时传送视频流](media-services-live-streaming-with-onprem-encoders.md)\r \r ## <a name=\"create-and-configure-a-visual-studio-project\"></a>创建和配置 Visual Studio 项目\r \r 设置开发环境，并在 app.config 文件中填充连接信息，如[使用 .NET 进行媒体服务开发](media-services-dotnet-how-to-use.md)中所述。 \r \r ## <a name=\"example\"></a>示例\r 下面的代码示例演示如何完成以下任务：\r \r * 连接到媒体服务\r * 创建频道\r * 更新频道\r * 检索频道的输入终结点。 应向本地实时编码器提供输入终结点。 实时编码器将相机的信号转换为流，以便发送到通道的输入（插入）终结点。\r * 检索频道的预览终结点\r * 创建并启动节目\r * 创建访问该节目所需的定位符\r * 创建并启动 StreamingEndpoint\r * 更新流式处理终结点\r * 关闭资源\r \r >[!IMPORTANT]\r >确保要从中流式传输内容的流式处理终结点处于“正在运行”状态。 \r     \r >[!NOTE]\r >不同 AMS 策略的策略限制为 1,000,000 个（例如，对于定位器策略或 ContentKeyAuthorizationPolicy）。 如果始终使用相同的日期/访问权限，则应使用相同的策略 ID，例如，用于要长期就地保留的定位符的策略（非上传策略）。 有关详细信息，请参阅[此](media-services-dotnet-manage-entities.md#limit-access-policies)主题。\r \r 有关如何配置实时编码器的信息，请参阅 [Azure 媒体服务 RTMP 支持和实时编码器](https://azure.microsoft.com/blog/2014/09/18/azure-media-services-rtmp-support-and-live-encoders/)。\r \r     using System;\r     using System.Collections.Generic;\r     using System.Configuration;\r     using System.Linq;\r     using System.Net;\r     using System.Security.Cryptography;\r     using Microsoft.WindowsAzure.MediaServices.Client;\r \r     namespace AMSLiveTest\r     {\r         class Program\r         {\r         private const string StreamingEndpointName = \"streamingendpoint001\";\r         private const string ChannelName = \"channel001\";\r         private const string AssetlName = \"asset001\";\r         private const string ProgramlName = \"program001\";\r \r         // Read values from the App.config file.\r         private static readonly string _AADTenantDomain =\r         ConfigurationManager.AppSettings[\"AADTenantDomain\"];\r         private static readonly string _RESTAPIEndpoint =\r         ConfigurationManager.AppSettings[\"MediaServiceRESTAPIEndpoint\"];\r \r         private static CloudMediaContext _context = null;\r \r         static void Main(string[] args)\r         {\r             var tokenCredentials = new AzureAdTokenCredentials(_AADTenantDomain, AzureEnvironments.AzureChinaCloudEnvironment);\r             var tokenProvider = new AzureAdTokenProvider(tokenCredentials);\r \r             _context = new CloudMediaContext(new Uri(_RESTAPIEndpoint), tokenProvider);\r \r             IChannel channel = CreateAndStartChannel();\r \r             // Set the Live Encoder to point to the channel's input endpoint:\r             string ingestUrl = channel.Input.Endpoints.FirstOrDefault().Url.ToString();\r \r             // Use the previewEndpoint to preview and verify\r             // that the input from the encoder is actually reaching the Channel.\r             string previewEndpoint = channel.Preview.Endpoints.FirstOrDefault().Url.ToString();\r \r             IProgram program = CreateAndStartProgram(channel);\r             ILocator locator = CreateLocatorForAsset(program.Asset, program.ArchiveWindowLength);\r             IStreamingEndpoint streamingEndpoint = CreateAndStartStreamingEndpoint(false);\r \r             // Once you are done streaming, clean up your resources.\r             Cleanup(streamingEndpoint, channel);\r         }\r \r         public static IChannel CreateAndStartChannel()\r         {\r             //If you want to change the Smooth fragments to HLS segment ratio, you would set the ChannelCreationOptions’s Output property.\r \r             IChannel channel = _context.Channels.Create(\r             new ChannelCreationOptions\r             {\r             Name = ChannelName,\r             Input = CreateChannelInput(),\r             Preview = CreateChannelPreview()\r             });\r \r             //Starting and stopping Channels can take some time to execute. To determine the state of operations after calling Start or Stop, query the IChannel.State .\r \r             channel.Start();\r \r             return channel;\r         }\r \r         private static ChannelInput CreateChannelInput()\r         {\r             return new ChannelInput\r             {\r             StreamingProtocol = StreamingProtocol.RTMP,\r             AccessControl = new ChannelAccessControl\r             {\r                 IPAllowList = new List<IPRange>\r                     {\r                     new IPRange\r                     {\r                     Name = \"TestChannelInput001\",\r                     // Setting 0.0.0.0 for Address and 0 for SubnetPrefixLength\r                     // will allow access to IP addresses.\r                     Address = IPAddress.Parse(\"0.0.0.0\"),\r                     SubnetPrefixLength = 0\r                     }\r                 }\r             }\r             };\r         }\r \r         private static ChannelPreview CreateChannelPreview()\r         {\r             return new ChannelPreview\r             {\r             AccessControl = new ChannelAccessControl\r             {\r                 IPAllowList = new List<IPRange>\r                 {\r                     new IPRange\r                     {\r                     Name = \"TestChannelPreview001\",\r                     // Setting 0.0.0.0 for Address and 0 for SubnetPrefixLength\r                     // will allow access to IP addresses.\r                     Address = IPAddress.Parse(\"0.0.0.0\"),\r                     SubnetPrefixLength = 0\r                     }\r                 }\r             }\r             };\r         }\r \r         public static void UpdateCrossSiteAccessPoliciesForChannel(IChannel channel)\r         {\r             var clientPolicy =\r             @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\r             <access-policy>\r                 <cross-domain-access>\r                 <policy>\r                     <allow-from http-request-headers=\"\"*\"\" http-methods=\"\"*\"\">\r                     <domain uri=\"\"*\"\"/>\r                     </allow-from>\r                     <grant-to>\r                        <resource path=\"\"/\"\" include-subpaths=\"\"true\"\"/>\r                     </grant-to>\r                 </policy>\r                 </cross-domain-access>\r             </access-policy>\";\r \r             var xdomainPolicy =\r             @\"<?xml version=\"\"1.0\"\" ?>\r             <cross-domain-policy>\r                 <allow-access-from domain=\"\"*\"\" />\r             </cross-domain-policy>\";\r \r             channel.CrossSiteAccessPolicies.ClientAccessPolicy = clientPolicy;\r             channel.CrossSiteAccessPolicies.CrossDomainPolicy = xdomainPolicy;\r \r             channel.Update();\r         }\r \r         public static IProgram CreateAndStartProgram(IChannel channel)\r         {\r             IAsset asset = _context.Assets.Create(AssetlName, AssetCreationOptions.None);\r \r             // Create a Program on the Channel. You can have multiple Programs that overlap or are sequential;\r             // however each Program must have a unique name within your Media Services account.\r             IProgram program = channel.Programs.Create(ProgramlName, TimeSpan.FromHours(3), asset.Id);\r             program.Start();\r \r             return program;\r         }\r \r         public static ILocator CreateLocatorForAsset(IAsset asset, TimeSpan ArchiveWindowLength)\r         {\r             // You cannot create a streaming locator using an AccessPolicy that includes write or delete permissions.            \r \r             var locator = _context.Locators.CreateLocator\r             (\r                 LocatorType.OnDemandOrigin,\r                 asset,\r                 _context.AccessPolicies.Create\r                 (\r                 \"Live Stream Policy\",\r                 ArchiveWindowLength,\r                 AccessPermissions.Read\r                 )\r             );\r \r             return locator;\r         }\r \r         public static IStreamingEndpoint CreateAndStartStreamingEndpoint(bool createNew)\r         {\r             IStreamingEndpoint streamingEndpoint = null;\r             if (createNew)\r             {\r             var options = new StreamingEndpointCreationOptions\r             {\r                 Name = StreamingEndpointName,\r                 ScaleUnits = 1,\r                 AccessControl = GetAccessControl(),\r                 CacheControl = GetCacheControl()\r             };\r \r             streamingEndpoint = _context.StreamingEndpoints.Create(options);\r             }\r             else\r             {\r             streamingEndpoint = _context.StreamingEndpoints.FirstOrDefault();\r             }\r \r \r             if (streamingEndpoint.State == StreamingEndpointState.Stopped)\r             streamingEndpoint.Start();\r \r             return streamingEndpoint;\r         }\r \r         private static StreamingEndpointAccessControl GetAccessControl()\r         {\r             return new StreamingEndpointAccessControl\r             {\r             IPAllowList = new List<IPRange>\r                 {\r                 new IPRange\r                 {\r                     Name = \"Allow all\",\r                     Address = IPAddress.Parse(\"0.0.0.0\"),\r                     SubnetPrefixLength = 0\r                 }\r                 },\r \r             AkamaiSignatureHeaderAuthenticationKeyList = new List<AkamaiSignatureHeaderAuthenticationKey>\r                 {\r                 new AkamaiSignatureHeaderAuthenticationKey\r                 {\r                     Identifier = \"My key\",\r                     Expiration = DateTime.UtcNow + TimeSpan.FromDays(365),\r                     Base64Key = Convert.ToBase64String(GenerateRandomBytes(16))\r                 }\r                 }\r             };\r         }\r \r         private static byte[] GenerateRandomBytes(int length)\r         {\r             var bytes = new byte[length];\r             using (var rng = new RNGCryptoServiceProvider())\r             {\r             rng.GetBytes(bytes);\r             }\r \r             return bytes;\r         }\r \r         private static StreamingEndpointCacheControl GetCacheControl()\r         {\r             return new StreamingEndpointCacheControl\r             {\r             MaxAge = TimeSpan.FromSeconds(1000)\r             };\r         }\r \r         public static void UpdateCrossSiteAccessPoliciesForStreamingEndpoint(IStreamingEndpoint streamingEndpoint)\r         {\r             var clientPolicy =\r             @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\r             <access-policy>\r                 <cross-domain-access>\r                 <policy>\r                     <allow-from http-request-headers=\"\"*\"\" http-methods=\"\"*\"\">\r                     <domain uri=\"\"*\"\"/>\r                     </allow-from>\r                     <grant-to>\r                        <resource path=\"\"/\"\" include-subpaths=\"\"true\"\"/>\r                     </grant-to>\r                 </policy>\r                 </cross-domain-access>\r             </access-policy>\";\r \r             var xdomainPolicy =\r             @\"<?xml version=\"\"1.0\"\" ?>\r             <cross-domain-policy>\r                 <allow-access-from domain=\"\"*\"\" />\r             </cross-domain-policy>\";\r \r             streamingEndpoint.CrossSiteAccessPolicies.ClientAccessPolicy = clientPolicy;\r             streamingEndpoint.CrossSiteAccessPolicies.CrossDomainPolicy = xdomainPolicy;\r \r             streamingEndpoint.Update();\r         }\r \r         public static void Cleanup(IStreamingEndpoint streamingEndpoint,\r                         IChannel channel)\r         {\r             if (streamingEndpoint != null)\r             {\r             streamingEndpoint.Stop();\r             if(streamingEndpoint.Name != \"default\")\r                 streamingEndpoint.Delete();\r             }\r \r             IAsset asset;\r             if (channel != null)\r             {\r \r             foreach (var program in channel.Programs)\r             {\r                 asset = _context.Assets.Where(se => se.Id == program.AssetId)\r                             .FirstOrDefault();\r \r                 program.Stop();\r                 program.Delete();\r \r                 if (asset != null)\r                 {\r                 foreach (var l in asset.Locators)\r                     l.Delete();\r \r                 asset.Delete();\r                 }\r             }\r \r             channel.Stop();\r             channel.Delete();\r             }\r         }\r         }\r     }\r \r \r <!--Update_Description: update code to use AAD token instead of ACS-->"}