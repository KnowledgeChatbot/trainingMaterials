{"Title":"构建适用于 Azure Cosmos DB 的 Node.js Web 应用","Description":"此 Node.js 教程探讨了如何使用 Azure Cosmos DB 存储和访问托管在 Azure 网站上的 Node.js Express Web 应用程序中的数据。","Content":"# <a name=\"_Toc395783175\"></a>使用 Azure Cosmos DB 生成 Node.js Web 应用程序\r > [!div class=\"op_single_selector\"]\r > * [.NET](documentdb-dotnet-application.md)\r > * [Node.js](documentdb-nodejs-application.md)\r > * [Java](documentdb-java-application.md)\r > * [Python](documentdb-python-application.md)\r > \r > \r \r 本 Node.js 教程展示了如何使用 Azure Cosmos DB 和 DocumentDB API，通过在 Azure 网站上托管的 Node.js Express 应用程序存储和访问数据。 用户会生成一个简单的基于 Web 的任务管理应用程序（ToDo 应用），用于创建、检索和完成任务。 任务存储为 Azure Cosmos DB 中的 JSON 文档。 本教程指导完成创建和部署应用的过程，并说明每个片段中发生的情况。\r \r ![在本 Node.js 教程中创建的 My Todo List 应用程序的屏幕截图](./media/documentdb-nodejs-application/cosmos-db-node-js-mytodo.png)\r \r 没有时间完成本教程且只想获取完整的解决方案？ 没有问题，可以从 [GitHub][GitHub]获得完整的示例解决方案。 只需读取[自述](https://github.com/Azure-Samples/documentdb-node-todo-app/blob/master/README.md)文件，了解如何运行该应用。\r \r ## <a name=\"_Toc395783176\"></a>先决条件\r > [!TIP]\r > 本 Node.js 教程假定你之前有使用 Node.js 和 Azure 网站的经验。\r > \r > \r \r 在按照本文中的说明操作之前，应确保已拥有下列项：\r \r * 如果没有 Azure 订阅，可在开始前创建一个[试用帐户](https://www.azure.cn/pricing/1rmb-trial/)。 \r \r   [!INCLUDE [cosmos-db-emulator-docdb-api](../../includes/cosmos-db-emulator-docdb-api.md)]\r \r * [Node.js][Node.js] 版本 v0.10.29 或更高版本。\r * [Express 生成器](http://www.expressjs.com/starter/generator.html)（可以通过 `npm install express-generator -g` 安装）\r * [Git][Git]。\r \r ## <a name=\"_Toc395637761\"></a>步骤 1：创建 Azure Cosmos DB 数据库帐户\r 首先创建一个 Azure Cosmos DB 帐户。 如果已有一个帐户，或者要在本教程中使用 Azure Cosmos DB 模拟器，可以跳到[步骤 2：创建新的 Node.js 应用程序](#_Toc395783178)。\r \r [!INCLUDE [cosmos-db-create-dbaccount](../../includes/cosmos-db-create-dbaccount.md)]\r \r [!INCLUDE [cosmos-db-keys](../../includes/cosmos-db-keys.md)]\r \r ## <a name=\"_Toc395783178\"></a>步骤 2：新建 Node.js 应用程序\r 现在让我们来了解如何使用 [Express](http://expressjs.com/) 框架创建基本的 Hello World Node.js 项目。\r \r 1. 打开首选终端，例如 Node.js 命令提示符。\r 2. 导航到要在其中存储新应用程序的目录。\r 3. 使用 Express 生成器生成名叫 **todo**的新应用程序。\r \r         express todo\r 4. 打开新的 **todo** 目录并安装依赖项。\r \r         cd todo\r         npm install\r 5. 运行新应用程序。\r \r         npm start\r 6. 在浏览器中导航到 [http://localhost:3000](http://localhost:3000) 即可查看新应用程序。\r \r     ![了解 Node.js - 浏览器窗口中 Hello World 应用程序的屏幕截图](./media/documentdb-nodejs-application/cosmos-db-node-js-express.png)\r \r     然后，如果要停止应用程序，请在终端窗口中按 CTRL + C，并单击 **y** 终止批处理作业。\r \r ## <a name=\"_Toc395783179\"></a>步骤 3：安装其他模块\r **package.json** 文件是在项目的根目录中创建的文件之一。 此文件包含一系列其他模块，它们是 Node.js 应用程序必需的。 稍后，在将此应用程序部署到 Azure 网站时，使用此文件以确定需要在 Azure 上安装哪些模块来支持应用程序。 我们仍需要为本教程多安装两个程序包。\r \r 1. 返回终端，通过 npm 安装 **async** 模块。\r \r         npm install async --save\r 2. 通过 npm 安装 **documentdb** 模块。 这是所有 Azure Cosmos DB magic 发生的模块。\r \r         npm install documentdb --save\r 3. 快速检查应用程序的 **package.json** 文件应显示其他模块。 此文件通知 Azure 当运行应用程序时要下载并安装的程序包。 它应类似于下面的示例。\r \r         {\r           \"name\": \"todo\",\r           \"version\": \"0.0.0\",\r           \"private\": true,\r           \"scripts\": {\r             \"start\": \"node ./bin/www\"\r           },\r           \"dependencies\": {\r             \"async\": \"^2.1.4\",\r             \"body-parser\": \"~1.15.2\",\r             \"cookie-parser\": \"~1.4.3\",\r             \"debug\": \"~2.2.0\",\r             \"documentdb\": \"^1.10.0\",\r             \"express\": \"~4.14.0\",\r             \"jade\": \"~1.11.0\",\r             \"morgan\": \"~1.7.0\",\r             \"serve-favicon\": \"~2.3.0\"\r           }\r         }\r \r     这会告知 Node（稍后告知 Azure），应用程序依赖于这些模块。\r \r ## <a name=\"_Toc395783180\"></a>步骤 4：在 Node 应用程序中使用 Azure Cosmos DB 服务\r 这负责处理所有的初始安装和配置，现在看看为什么要用这步，可以编写一些使用 Azure Cosmos DB 的代码。\r \r ### <a name=\"create-the-model\"></a>创建模型\r 1. 在项目目录中，在 package.json 文件所在的同一目录中创建名为 **models** 的新目录。\r 2. 在 **models** 目录中，创建一个名为 **taskDao.js** 的新文件。 此文件包含我们应用程序所创建任务的模型。\r 3. 在同一个 **models** 目录中，创建名为 **docdbUtils.js** 的另一个新文件。 此文件会包含一些可重用的有用代码，我们会在整个应用程序期间用到这些代码。 \r 4. 将以下代码复制到 **docdbUtils.js**\r \r         var DocumentDBClient = require('documentdb').DocumentClient;\r \r         var DocDBUtils = {\r             getOrCreateDatabase: function (client, databaseId, callback) {\r                 var querySpec = {\r                     query: 'SELECT * FROM root r WHERE r.id= @id',\r                     parameters: [{\r                         name: '@id',\r                         value: databaseId\r                     }]\r                 };\r \r                 client.queryDatabases(querySpec).toArray(function (err, results) {\r                     if (err) {\r                         callback(err);\r \r                     } else {\r                         if (results.length === 0) {\r                             var databaseSpec = {\r                                 id: databaseId\r                             };\r \r                             client.createDatabase(databaseSpec, function (err, created) {\r                                 callback(null, created);\r                             });\r \r                         } else {\r                             callback(null, results[0]);\r                         }\r                     }\r                 });\r             },\r \r             getOrCreateCollection: function (client, databaseLink, collectionId, callback) {\r                 var querySpec = {\r                     query: 'SELECT * FROM root r WHERE r.id=@id',\r                     parameters: [{\r                         name: '@id',\r                         value: collectionId\r                     }]\r                 };               \r \r                 client.queryCollections(databaseLink, querySpec).toArray(function (err, results) {\r                     if (err) {\r                         callback(err);\r \r                     } else {        \r                         if (results.length === 0) {\r                             var collectionSpec = {\r                                 id: collectionId\r                             };\r \r                             client.createCollection(databaseLink, collectionSpec, function (err, created) {\r                                 callback(null, created);\r                             });\r \r                         } else {\r                             callback(null, results[0]);\r                         }\r                     }\r                 });\r             }\r         };\r \r         module.exports = DocDBUtils;\r \r 5. 保存并关闭 **docdbUtils.js** 文件。\r 6. 在 **taskDao.js** 文件的开头添加以下代码，引用前面创建的 **DocumentDBClient** 和 **docdbUtils.js**：\r \r         var DocumentDBClient = require('documentdb').DocumentClient;\r         var docdbUtils = require('./docdbUtils');\r 7. 接下来，你添加代码以定义和导出 Task 对象。 这负责初始化我们的 Task 对象，并设置我们使用的数据库和文档集合。\r \r         function TaskDao(documentDBClient, databaseId, collectionId) {\r           this.client = documentDBClient;\r           this.databaseId = databaseId;\r           this.collectionId = collectionId;\r \r           this.database = null;\r           this.collection = null;\r         }\r \r         module.exports = TaskDao;\r 8. 然后添加以下代码以定义 Task 对象上的其他方法，该对象可与存储在 Azure Cosmos DB 中的数据进行交互。\r \r         TaskDao.prototype = {\r             init: function (callback) {\r                 var self = this;\r \r                 docdbUtils.getOrCreateDatabase(self.client, self.databaseId, function (err, db) {\r                     if (err) {\r                         callback(err);\r                     } else {\r                         self.database = db;\r                         docdbUtils.getOrCreateCollection(self.client, self.database._self, self.collectionId, function (err, coll) {\r                             if (err) {\r                                 callback(err);\r \r                             } else {\r                                 self.collection = coll;\r                             }\r                         });\r                     }\r                 });\r             },\r \r             find: function (querySpec, callback) {\r                 var self = this;\r \r                 self.client.queryDocuments(self.collection._self, querySpec).toArray(function (err, results) {\r                     if (err) {\r                         callback(err);\r \r                     } else {\r                         callback(null, results);\r                     }\r                 });\r             },\r \r             addItem: function (item, callback) {\r                 var self = this;\r \r                 item.date = Date.now();\r                 item.completed = false;\r \r                 self.client.createDocument(self.collection._self, item, function (err, doc) {\r                     if (err) {\r                         callback(err);\r \r                     } else {\r                         callback(null, doc);\r                     }\r                 });\r             },\r \r             updateItem: function (itemId, callback) {\r                 var self = this;\r \r                 self.getItem(itemId, function (err, doc) {\r                     if (err) {\r                         callback(err);\r \r                     } else {\r                         doc.completed = true;\r \r                         self.client.replaceDocument(doc._self, doc, function (err, replaced) {\r                             if (err) {\r                                 callback(err);\r \r                             } else {\r                                 callback(null, replaced);\r                             }\r                         });\r                     }\r                 });\r             },\r \r             getItem: function (itemId, callback) {\r                 var self = this;\r \r                 var querySpec = {\r                     query: 'SELECT * FROM root r WHERE r.id = @id',\r                     parameters: [{\r                         name: '@id',\r                         value: itemId\r                     }]\r                 };\r \r                 self.client.queryDocuments(self.collection._self, querySpec).toArray(function (err, results) {\r                     if (err) {\r                         callback(err);\r \r                     } else {\r                         callback(null, results[0]);\r                     }\r                 });\r             }\r         };\r 9. 保存并关闭 **taskDao.js** 文件。 \r \r ### <a name=\"create-the-controller\"></a>创建控制器\r 1. 在项目的 **routes** 目录中，创建一个名为 **tasklist.js** 的新文件。 \r 2. 将以下代码添加到 **tasklist.js**。 这样会加载 **tasklist.js** 使用的 DocumentDBClient 和 async 模块。 它还定义了 **TaskList** 函数，将向该函数传递我们之前定义的 **Task** 对象的一个实例：\r \r         var DocumentDBClient = require('documentdb').DocumentClient;\r         var async = require('async');\r \r         function TaskList(taskDao) {\r           this.taskDao = taskDao;\r         }\r \r         module.exports = TaskList;\r 3. 继续向 **tasklist.js** 文件添加用于 **showTasks、addTask** 和 **completeTasks** 的方法：\r \r         TaskList.prototype = {\r             showTasks: function (req, res) {\r                 var self = this;\r \r                 var querySpec = {\r                     query: 'SELECT * FROM root r WHERE r.completed=@completed',\r                     parameters: [{\r                         name: '@completed',\r                         value: false\r                     }]\r                 };\r \r                 self.taskDao.find(querySpec, function (err, items) {\r                     if (err) {\r                         throw (err);\r                     }\r \r                     res.render('index', {\r                         title: 'My ToDo List ',\r                         tasks: items\r                     });\r                 });\r             },\r \r             addTask: function (req, res) {\r                 var self = this;\r                 var item = req.body;\r \r                 self.taskDao.addItem(item, function (err) {\r                     if (err) {\r                         throw (err);\r                     }\r \r                     res.redirect('/');\r                 });\r             },\r \r             completeTask: function (req, res) {\r                 var self = this;\r                 var completedTasks = Object.keys(req.body);\r \r                 async.forEach(completedTasks, function taskIterator(completedTask, callback) {\r                     self.taskDao.updateItem(completedTask, function (err) {\r                         if (err) {\r                             callback(err);\r                         } else {\r                             callback(null);\r                         }\r                     });\r                 }, function goHome(err) {\r                     if (err) {\r                         throw err;\r                     } else {\r                         res.redirect('/');\r                     }\r                 });\r             }\r         };\r 4. 保存并关闭 **tasklist.js** 文件。\r \r ### <a name=\"add-configjs\"></a>添加 config.js\r 1. 在项目目录中创建一个名为 **config.js**的新文件。\r 2. 将以下内容添加到 **config.js**。 这会定义我们的应用程序所需的配置设置和值。\r \r         var config = {}\r \r         config.host = process.env.HOST || \"[the URI value from the Azure Cosmos DB Keys blade on http://portal.azure.cn]\";\r         config.authKey = process.env.AUTH_KEY || \"[the PRIMARY KEY value from the Azure Cosmos DB Keys blade on http://portal.azure.cn]\";\r         config.databaseId = \"ToDoList\";\r         config.collectionId = \"Items\";\r \r         module.exports = config;\r 3. 在 **config.js** 文件中，使用 [Azure 门户](https://portal.azure.cn)中 Azure Cosmos DB 帐户的“密钥”边栏选项卡中的值更新 HOST 和 AUTH_KEY 的值。\r 4. 保存并关闭 **config.js** 文件。\r \r ### <a name=\"modify-appjs\"></a>修改 app.js\r 1. 在项目目录中，打开 **app.js** 文件。 此文件早于 Express Web 应用程序创建。\r 2. 将以下代码添加到 **app.js** 顶部\r \r         var DocumentDBClient = require('documentdb').DocumentClient;\r         var config = require('./config');\r         var TaskList = require('./routes/tasklist');\r         var TaskDao = require('./models/taskDao');\r 3. 此代码定义要使用的配置文件，并继续将此文件中的值读取到不久就要使用的一些变量中。\r 4. 替换 **app.js** 文件中的以下两行：\r \r         app.use('/', index);\r         app.use('/users', users); \r \r       使用下面的代码段：\r \r         var docDbClient = new DocumentDBClient(config.host, {\r             masterKey: config.authKey\r         });\r         var taskDao = new TaskDao(docDbClient, config.databaseId, config.collectionId);\r         var taskList = new TaskList(taskDao);\r         taskDao.init();\r \r         app.get('/', taskList.showTasks.bind(taskList));\r         app.post('/addtask', taskList.addTask.bind(taskList));\r         app.post('/completetask', taskList.completeTask.bind(taskList));\r         app.set('view engine', 'jade');\r 5. 这些行（使用从 **config.js** 中读取的值）定义 **TaskDao** 对象的新实例（带有与 Azure Cosmos DB 的新连接），初始化该任务对象，然后将窗体操作与 **TaskList** 控制器上的方法绑定。 \r 6. 最后，保存并关闭 **app.js** 文件，我们就快完成了。\r \r ## <a name=\"_Toc395783181\"></a>步骤 5：构建用户界面\r 现在让我们把注意力转向生成用户界面，以便用户可以与我们的应用程序进行实际交互。 我们创建的 Express 应用程序使用 **Jade** 作为视图引擎。 有关 Jade 的详细信息，请参阅 [http://jade-lang.com/](http://jade-lang.com/)。\r \r 1. **views** 目录中的 **layout.jade** 文件用作其他 **.jade** 文件的全局模板。 在此步骤中，将对其进行修改以使用 [Twitter Bootstrap](https://github.com/twbs/bootstrap)（一个可以轻松设计美观网站的工具包）。 \r 2. 打开 **views** 文件夹中的 **layout.jade** 文件，将内容替换为以下代码：\r \r     ```\r     doctype html\r     html\r       head\r         title= title\r         link(rel='stylesheet', href='//ajax.aspnetcdn.com/ajax/bootstrap/3.3.2/css/bootstrap.min.css')\r         link(rel='stylesheet', href='/stylesheets/style.css')\r       body\r         nav.navbar.navbar-inverse.navbar-fixed-top\r           div.navbar-header\r             a.navbar-brand(href='#') My Tasks\r         block content\r         script(src='//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.11.2.min.js')\r         script(src='//ajax.aspnetcdn.com/ajax/bootstrap/3.3.2/bootstrap.min.js')\r     ```\r \r     此代码将有效地指示 **Jade** 引擎为应用程序呈现某些 HTML，并创建名为 **content** 的**块**，我们可在其中提供内容页面的布局。\r \r     保存并关闭此 **layout.jade** 文件。\r \r 3. 现在打开 **index.jade** 文件（应用程序要使用的视图），并将文件内容替换为以下代码：\r \r     ```\r     extends layout\r     block content\r       h1 #{title}\r       br\r \r       form(action=\"/completetask\", method=\"post\")\r         table.table.table-striped.table-bordered\r           tr\r             td Name\r             td Category\r             td Date\r             td Complete\r           if (typeof tasks === \"undefined\")\r             tr\r               td\r           else\r             each task in tasks\r               tr\r                 td #{task.name}\r                 td #{task.category}\r                 - var date  = new Date(task.date);\r                 - var day   = date.getDate();\r                 - var month = date.getMonth() + 1;\r                 - var year  = date.getFullYear();\r                 td #{month + \"/\" + day + \"/\" + year}\r                 td\r                   input(type=\"checkbox\", name=\"#{task.id}\", value=\"#{!task.completed}\", checked=task.completed)\r              button.btn.btn-primary(type=\"submit\") Update tasks\r       hr\r       form.well(action=\"/addtask\", method=\"post\")\r          .form-group\r            label(for=\"name\") Item Name:\r            input.form-control(name=\"name\", type=\"textbox\")\r          .form-group\r            label(for=\"category\") Item Category:\r            input.form-control(name=\"category\", type=\"textbox\")\r          br\r          button.btn(type=\"submit\") Add item\r     ```\r \r     这将扩展布局，并为先前在 **layout.jade** 文件中看到的 **content** 占位符提供内容。\r \r     在此布局中，我们创建了两个 HTML 窗体。\r \r     第一个窗体中的表包含我们的数据和按钮，该按钮允许我们通过发布控制器的 **/completetask** 方法更新项。\r \r     第二个窗体包含两个输入字段和一个按钮，该按钮允许我们通过发布控制器的 **/addtask** 方法来新建项。\r \r     这应该是应用程序工作所需的所有内容了。\r \r ## <a name=\"_Toc395783181\"></a>步骤 6：在本地运行应用程序\r 1. 若要在本地计算机上测试应用程序，请在终端中运行 `npm start` 以启动应用程序，然后刷新 [http://localhost:3000](http://localhost:3000) 浏览器页。 该页面现在应类似下图：\r \r     ![浏览器窗口中 MyTodo List 应用程序的屏幕截图](./media/documentdb-nodejs-application/cosmos-db-node-js-localhost.png)\r \r     > [!TIP]\r     > 如果收到有关 layout.jade 文件或 index.jade 文件的缩进错误，请确保这两个文件的前两行已经左对齐且没有空格。 如果前两行前面有空格，请删除空格并保存这两个文件，并刷新浏览器窗口。 \r \r 2. 使用“项”、“项名称”和“类别”字段输入新任务，并单击“添加项” 。 这会在 Azure Cosmos DB 中创建具有这些属性的文档。 \r 3. 页面应更新为在 ToDo 列表中显示新建项。\r \r     ![ToDo 列表中具有新项的应用程序的屏幕截图](./media/documentdb-nodejs-application/cosmos-db-node-js-added-task.png)\r 4. 若要完成任务，只需选中“完成”列中的复选框，然后单击“更新任务”即可。 此操作会更新已经创建的文档。\r \r 5. 如果要停止应用程序，请在终端窗口中按 CTRL + C，并单击 **Y** 终止批处理作业。\r \r ## <a name=\"_Toc395783182\"></a>步骤 7：将应用程序开发项目部署到 Azure 网站\r 1. 如果尚未部署，则启用 Azure 网站的 git 存储库。 可以在[从本地 GIT 部署到 Azure 应用服务](../app-service-web/app-service-deploy-local-git.md)主题中找到如何执行此操作的说明。\r 2. 将 Azure 网站添加为 git 远程。\r \r         git remote add azure https://username@your-azure-website.scm.chinacloudsites.cn:443/your-azure-website.git\r 3. 通过推送到远程进行部署。\r \r         git push azure master\r 4. 在几秒钟内，git 将完成 Web 应用程序发布并启动浏览器，从中可查看在 Azure 中运行的简单作品！\r \r     祝贺！ 刚才构建了第一个使用 Azure Cosmos DB 的 Node.js Express Web 应用程序并将其发布到了 Azure 网站。\r \r     如果想要下载或引用本教程的完整参考应用程序，可从 [GitHub][GitHub]下载。\r \r ## <a name=\"_Toc395637775\"></a>后续步骤\r \r * 希望使用 Azure Cosmos DB 执行规模和性能测试？ 请参阅[使用 Azure Cosmos DB 执行性能和规模测试](performance-testing.md)\r * 了解如何[监视 Azure Cosmos DB 帐户](monitor-accounts.md)。\r * 在 [Query Playground](https://www.documentdb.com/sql/demo)中对示例数据集运行查询。\r * 浏览 [Azure Cosmos DB 文档](/documentdb/)。\r \r [Node.js]: http://nodejs.org/\r [Git]: http://git-scm.com/\r [GitHub]: https://github.com/Azure-Samples/documentdb-node-todo-app\r \r <!--Update_Description: wording update-->"}