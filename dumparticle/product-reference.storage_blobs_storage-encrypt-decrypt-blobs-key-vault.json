{"Title":"教程：在 Azure 存储中使用 Azure 密钥保管库加密和解密 Blob","Description":"如何将 Azure 存储的客户端加密与 Azure Key Vault 配合使用，以便加密和解密 Blob。","Content":"# <a name=\"tutorial-encrypt-and-decrypt-blobs-in-azure-storage-using-azure-key-vault\"></a>教程：在 Azure 存储中使用 Azure Key Vault 加密和解密 blob\r ## <a name=\"introduction\"></a>介绍\r 本教程介绍如何结合使用客户端存储加密与 Azure 密钥保管库。 它会逐步演示如何使用这些技术在控制台应用程序中加密和解密 Blob。\r \r **估计完成时间：** 20 分钟。\r \r 有关 Azure Key Vault 的概述信息，请参阅[什么是 Azure Key Vault？](../../key-vault/key-vault-whatis.md)。\r \r 有关 Azure 存储客户端加密的概述信息，请参阅 [Azure 存储的客户端加密和 Azure Key Vault](../common/storage-client-side-encryption.md?toc=%2fstorage%2fblobs%2ftoc.json)。\r \r ## <a name=\"prerequisites\"></a>先决条件\r 若要完成本教程，必须具备以下项目：\r \r * Azure 存储帐户\r * Visual Studio 2013 或更高版本\r * Azure PowerShell\r \r ## <a name=\"overview-of-client-side-encryption\"></a>客户端加密概述\r 有关 Azure 存储客户端加密的概述，请参阅 [Azure 存储的客户端加密和 Azure Key Vault](../common/storage-client-side-encryption.md?toc=%2fstorage%2fblobs%2ftoc.json)\r \r 下面是客户端加密的工作原理的简要说明：\r \r 1. Azure 存储客户端 SDK 生成内容加密密钥 (CEK)，这是一次性使用对称密钥。\r 2. 使用此 CEK 对客户数据进行加密。\r 3. 然后，使用密钥加密密钥 (KEK) 对此 CEK 进行包装（加密）。 KEK 由密钥标识符标识，可以是非对称密钥对或对称密钥，还可以在本地托管或存储在 Azure 密钥保管库中。 存储空间客户端本身永远无法访问 KEK。 它只能调用密钥保管库提供的密钥包装算法。 客户可以根据需要选择使用自定义提供程序进行密钥包装/解包。\r 4. 然后，将已加密的数据上传到 Azure 存储服务。\r \r ## <a name=\"set-up-your-azure-key-vault\"></a>设置 Azure 密钥保管库\r 若要继续本教程，请执行教程 [Azure Key Vault 入门](../../key-vault/key-vault-get-started.md)中所述的以下步骤：\r \r * 创建密钥保管库。\r * 将密钥或密码添加到密钥保管库。\r * 将应用程序注册到 Azure Active Directory。\r * 授权应用程序使用密钥或密码。\r \r 记下将应用程序注册到 Azure Active Directory 时生成的 ClientID 和 ClientSecret。\r \r 在密钥保管库中创建这两个密钥。 本教程的其余部分假定使用以下名称：ContosoKeyVault 和 TestRSAKey1。\r \r ## <a name=\"create-a-console-application-with-packages-and-appsettings\"></a>使用程序包和 AppSettings 创建控制台应用程序\r 在 Visual Studio 中创建新的控制台应用程序。\r \r 在 Package Manager Console 中添加必要的 Nuget 包。\r \r ```\r Install-Package WindowsAzure.Storage\r \r // This is the latest stable release for ADAL.\r Install-Package Microsoft.IdentityModel.Clients.ActiveDirectory -Version 2.16.204221202\r \r Install-Package Microsoft.Azure.KeyVault\r Install-Package Microsoft.Azure.KeyVault.Extensions\r ```\r \r 将 AppSettings 添加到 App.Config。\r \r ```xml\r <appSettings>\r     <add key=\"accountName\" value=\"myaccount\"/>\r     <add key=\"accountKey\" value=\"theaccountkey\"/>\r     <add key=\"clientId\" value=\"theclientid\"/>\r     <add key=\"clientSecret\" value=\"theclientsecret\"/>\r     <add key=\"container\" value=\"stuff\"/>\r </appSettings>\r ```\r \r 添加以下 `using` 语句并确保将对 System.Configuration 的引用添加到项目中。\r \r ```csharp\r using Microsoft.IdentityModel.Clients.ActiveDirectory;\r using System.Configuration;\r using Microsoft.WindowsAzure.Storage.Auth;\r using Microsoft.WindowsAzure.Storage;\r using Microsoft.WindowsAzure.Storage.Blob;\r using Microsoft.Azure.KeyVault;\r using System.Threading;     \r using System.IO;\r ```\r \r ## <a name=\"add-a-method-to-get-a-token-to-your-console-application\"></a>添加方法以便为控制台应用程序获取令牌\r 以下方法由密钥保管库类使用，这些类需要进行身份验证才能访问密钥保管库。\r \r ```csharp\r private async static Task<string> GetToken(string authority, string resource, string scope)\r {\r     var authContext = new AuthenticationContext(authority);\r     ClientCredential clientCred = new ClientCredential(\r         ConfigurationManager.AppSettings[\"clientId\"],\r         ConfigurationManager.AppSettings[\"clientSecret\"]);\r     AuthenticationResult result = await authContext.AcquireTokenAsync(resource, clientCred);\r \r     if (result == null)\r         throw new InvalidOperationException(\"Failed to obtain the JWT token\");\r \r     return result.AccessToken;\r }\r ```\r \r ## <a name=\"access-storage-and-key-vault-in-your-program\"></a>在程序中访问存储和密钥保管库\r 在 Main 函数中，添加以下代码。\r \r ```csharp\r // This is standard code to interact with Blob storage.\r StorageCredentials creds = new StorageCredentials(\r     ConfigurationManager.AppSettings[\"accountName\"],\r        ConfigurationManager.AppSettings[\"accountKey\"]);\r CloudStorageAccount account = new CloudStorageAccount(creds, useHttps: true);\r CloudBlobClient client = account.CreateCloudBlobClient();\r CloudBlobContainer contain = client.GetContainerReference(ConfigurationManager.AppSettings[\"container\"]);\r contain.CreateIfNotExists();\r \r // The Resolver object is used to interact with Key Vault for Azure Storage.\r // This is where the GetToken method from above is used.\r KeyVaultKeyResolver cloudResolver = new KeyVaultKeyResolver(GetToken);\r ```\r \r > [!NOTE]\r > 密钥保管库对象模型\r > \r > 务必了解，实际上有两个 Key Vault 对象模型：一个基于 REST API（KeyVault 命名空间），另一个是客户端加密的扩展。\r > \r > 密钥保管库客户端与 REST API 进行交互，并了解密钥保管库中包含的两种模型的 JSON Web 密钥和密码。\r > \r > 密钥保管库扩展似乎是专为 Azure 存储中的客户端加密而创建的类。 根据密钥解析程序的概念，它们包含密钥 (IKey) 和类的接口。 需要了解两种 IKey 实现：RSAKey 和 SymmetricKey。 现在它们碰巧与 Key Vault 中包含的内容保持一致，但此时它们是独立的类（因此，Key Vault 客户端检索到的密钥与秘密检索未实现 IKey）。\r \r ## <a name=\"encrypt-blob-and-upload\"></a>加密 Blob 和上传\r 添加以下代码以加密 Blob 并将其上传到 Azure 存储帐户。 使用的 **ResolveKeyAsync** 方法会返回 IKey。\r \r ```csharp\r // Retrieve the key that you created previously.\r // The IKey that is returned here is an RsaKey.\r // Remember that we used the names contosokeyvault and testrsakey1.\r var rsa = cloudResolver.ResolveKeyAsync(\"https://contosokeyvault.vault.azure.cn/keys/TestRSAKey1\", CancellationToken.None).GetAwaiter().GetResult();\r \r // Now you simply use the RSA key to encrypt by setting it in the BlobEncryptionPolicy.\r BlobEncryptionPolicy policy = new BlobEncryptionPolicy(rsa, null);\r BlobRequestOptions options = new BlobRequestOptions() { EncryptionPolicy = policy };\r \r // Reference a block blob.\r CloudBlockBlob blob = contain.GetBlockBlobReference(\"MyFile.txt\");\r \r // Upload using the UploadFromStream method.\r using (var stream = System.IO.File.OpenRead(@\"C:\\data\\MyFile.txt\"))\r     blob.UploadFromStream(stream, stream.Length, null, options, null);\r ```\r \r 下面是 [Azure 经典管理门户](https://manage.windowsazure.cn)中一个 Blob 的屏幕截图，该 Blob 已使用客户端加密通过 Key Vault 中存储的密钥进行加密。 **KeyId** 属性是密钥保管库中充当 KEK 的密钥的 URI。 **EncryptedKey** 属性包含 CEK 的加密版本。\r \r ![显示包含加密元数据的 Blob 元数据的屏幕截图](./media/storage-encrypt-decrypt-blobs-key-vault/blobmetadata.png)\r \r > [!NOTE]\r > 如果查看 BlobEncryptionPolicy 构造函数，会看到它可以接受密钥和/或解析程序。 请注意，现在无法将解析程序用于加密，因为它当前不支持默认密钥。\r \r ## <a name=\"decrypt-blob-and-download\"></a>解密 Blob 并下载\r 当使用解析程序类有意义时，实际上就是解密。 用于加密的密钥的 ID 与其元数据中的 Blob 相关联，因此没有理由检索该密钥，请记住密钥与 Blob 之间的关联关系。 只需确保该密钥保留在密钥保管库中。   \r \r RSA 密钥的私钥则保留在密钥保管库中，因此，为了进行解密，来自包含 CEK 的 Blob 元数据的加密密钥会发送到密钥保管库进行解密。\r \r 添加以下代码以解密刚刚上传的 Blob。\r \r ```csharp\r // In this case, we will not pass a key and only pass the resolver because\r // this policy will only be used for downloading / decrypting.\r BlobEncryptionPolicy policy = new BlobEncryptionPolicy(null, cloudResolver);\r BlobRequestOptions options = new BlobRequestOptions() { EncryptionPolicy = policy };\r \r using (var np = File.Open(@\"C:\\data\\MyFileDecrypted.txt\", FileMode.Create))\r     blob.DownloadToStream(np, null, options, null);\r ```\r \r > [!NOTE]\r > 可以通过几个其他类型的解析程序来简化密钥管理，其中包括：AggregateKeyResolver 和 CachingKeyResolver。\r \r ## <a name=\"use-key-vault-secrets\"></a>使用密钥保管库密码\r 将密码用于客户端加密的方式是通过 SymmetricKey 类，因为密码实际上是一种对称密钥。 但是，如上所述，密钥保管库中的密码不会完全映射到 SymmetricKey。 这里要注意几个问题：\r \r * SymmetricKey 中的密钥必须是固定长度：128、192、256、384 或 512 位。\r * SymmetricKey 中的密钥应采用 Base64 编码。\r * 用作 SymmetricKey 的密钥保管库密钥需要在密钥保管库中具有“application/octet-stream”内容类型。\r \r 以下是使用 PowerShell 在密钥保管库中创建可用作 SymmetricKey 的密钥的示例。\r 请注意，硬编码值 $key 仅用于演示目的。 请在自己的代码中生成此密钥。\r \r ```csharp\r // Here we are making a 128-bit key so we have 16 characters.\r // The characters are in the ASCII range of UTF8 so they are\r // each 1 byte. 16 x 8 = 128.\r $key = \"qwertyuiopasdfgh\"\r $b = [System.Text.Encoding]::UTF8.GetBytes($key)\r $enc = [System.Convert]::ToBase64String($b)\r $secretvalue = ConvertTo-SecureString $enc -AsPlainText -Force\r \r // Substitute the VaultName and Name in this command.\r $secret = Set-AzureKeyVaultSecret -VaultName 'ContoseKeyVault' -Name 'TestSecret2' -SecretValue $secretvalue -ContentType \"application/octet-stream\"\r ```\r \r 在控制台应用程序中，可以使用与之前相同的调用将此密钥作为 SymmetricKey 进行检索。\r \r ```csharp\r SymmetricKey sec = (SymmetricKey) cloudResolver.ResolveKeyAsync(\r     \"https://contosokeyvault.vault.azure.cn/secrets/TestSecret2/\", \r     CancellationToken.None).GetAwaiter().GetResult();\r ```\r 就这么简单。 请尽情享受其中的乐趣！\r \r ## <a name=\"next-steps\"></a>后续步骤\r 若要深入了解如何将 Azure 存储与 C# 配合使用，请参阅[适用于 .NET 的 Azure 存储客户端库](https://msdn.microsoft.com/library/azure/dn261237.aspx)。\r \r 有关 Blob REST API 的详细信息，请参阅 [Blob 服务 REST API](https://msdn.microsoft.com/library/azure/dd135733.aspx)。\r \r 有关 Azure 存储的最新信息，请转到 [Azure 存储团队博客](http://blogs.msdn.com/b/windowsazurestorage/)。\r \r <!--Update_Description: update link-->"}