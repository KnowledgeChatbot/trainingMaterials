{"Title":"通过 Azure 通知中心向 iOS 发送推送通知","Description":"在本教程中，你将了解如何使用 Azure 通知中心将推送通知发送到 iOS 应用程序。","Content":"\r # 通过 Azure 通知中心向 iOS 发送推送通知\r \r [!INCLUDE [notification-hubs-selector-get-started](../../includes/notification-hubs-selector-get-started.md)]\r \r ##概述\r \r > [!NOTE]\r > 若要完成本教程，你必须有一个有效的 Azure 帐户。如果你没有帐户，可以创建一个试用帐户，只需几分钟即可完成。有关详细信息，请参阅 [Azure 1 元试用](https://www.azure.cn/pricing/1rmb-trial/)。\r \r 本教程演示如何使用 Azure 通知中心将推送通知发送到 iOS 应用程序。你将创建一个空白 iOS 应用，它使用 Apple 推送通知服务 (APNS) 接收推送通知。\r \r 完成后，你将能够使用通知中心将推送通知广播到运行你的应用的所有设备。\r \r ## 开始之前\r \r [!INCLUDE [notification-hubs-hero-slug](../../includes/notification-hubs-hero-slug.md)]\r \r 可以[在 GitHub 上](https://github.com/Azure/azure-notificationhubs-samples/tree/master/iOS/GetStartedNH/GetStarted)找到本教程的已完成代码。\r \r ## 先决条件\r \r 本教程需要的内容如下：\r \r + [移动服务 iOS SDK 版本 1.2.4]\r + 最新版本的 [Xcode]\r + 支持 iOS 8（或更高版本）的设备\r + [Apple 开发人员计划](https://developer.apple.com/programs/)成员身份。\r \r    > [!NOTE]\r    > 由于推送通知的配置要求，你必须在物理 iOS 的设备（iPhone 或 iPad）而不是在 iOS 模拟器上部署和测试推送通知。\r \r 完成本教程是学习有关 iOS 应用的所有其他通知中心教程的先决条件。\r \r [!INCLUDE [通知中心：启用 Apple 推送通知](../../includes/notification-hubs-enable-apple-push-notifications.md)]\r \r ## 针对 iOS 推送通知配置通知中心\r \r 本部分将引导你使用创建的 **.p12** 推送证书创建新的通知中心并配置 APNS 身份验证。如果你想要使用已创建的通知中心，可以跳到步骤 5。\r \r [!INCLUDE [notification-hubs-portal-create-new-hub](../../includes/notification-hubs-portal-create-new-hub.md)]\r \r <ol start=\"6\">\r <li>\r <p>单击“设置”边栏选项卡中的“通知服务”按钮，然后选择“Apple (APNS)”。<b></b><b></b><b></b>单击“上载证书”，然后选择你先前导出的 <b>.p12</b> 文件。<b></b>确保同时指定正确的密码。</p>\r <p>由于此项目用于开发，因此请务必选择“沙箱”模式。<b></b>仅当你想要将推送通知发送给从应用商店购买你应用的用户时，才使用“生产”模式。<b></b></p>\r </li>\r </ol>\r &emsp;&emsp;![在 Azure 门户中配置 APNS](./media/notification-hubs-ios-get-started/notification-hubs-apple-config.png)\r \r &emsp;&emsp;![在 Azure 门户中配置 APNS 证书](./media/notification-hubs-ios-get-started/notification-hubs-apple-config-cert.png)\r \r 你的通知中心现在已配置为使用 APNS，并且你有连接字符串用于注册你的应用和发送推送通知。\r \r ## 将你的 iOS 应用连接到通知中心\r \r 1. 在 Xcode 中，创建新的 iOS 项目，然后选择“单视图应用程序”模板。\r \r     ![Xcode — 单一视图应用程序][8]  \r \r 2. 设置新项目的选项时，请务必使用前面在 Apple 开发人员门户上设置捆绑 ID 时使用的同一**产品名称**和**组织标识符**。\r \r     ![Xcode — 项目选项][11]  \r \r 3. 在“目标”下，单击你的项目名称，单击“生成设置”选项卡，展开“代码签名标识”，然后在“调试”下设置你的代码签名标识。将“级别”从“基本”切换为“全部”，然后将“预配配置文件”设为前面创建的预配配置文件。\r \r     如果屏幕未显示在 Xcode 中创建的新预配配置文件，请尝试刷新签名标识的配置文件。单击菜单栏上的“Xcode”，再依次单击“首选项”、“帐户”选项卡、“查看详细信息”按钮、你的签名标识，然后单击右下角的刷新按钮。\r \r     ![Xcode — 预配配置文件][9]  \r \r 4. 下载[移动服务 iOS SDK 版本 1.2.4]，然后将文件解压缩。在 Xcode 中，右键单击你的项目，然后单击“将文件添加到”选项，将 **WindowsAzureMessaging.framework** 文件夹添加到 Xcode 项目。选择“需要时复制项”，然后单击“添加”。\r \r     >[!NOTE]\r     > 通知中心 SDK 目前不支持 Xcode 7 上的 Bitcode。你必须在项目的“构建选项”中将“启用 Bitcode”设置为“否”。\r \r     ![解压缩 Azure SDK][10]  \r \r 5. 将新的标头文件添加到名为 `HubInfo.h` 的项目。此文件将保存通知中心的常量。添加以下定义，然后将字符串文本占位符替换为你的 *中心名称* 以及前面记下的 *DefaultListenSharedAccessSignature*。\r \r     ```\r     #ifndef HubInfo_h\r     #define HubInfo_h\r \r         #define HUBNAME @\"<Enter the name of your hub>\"\r         #define HUBLISTENACCESS @\"<Enter your DefaultListenSharedAccess connection string\"\r \r     #endif /* HubInfo_h */\r     ```\r \r 6. 打开 `AppDelegate.h` 文件并添加以下导入指令：\r \r     ```\r      #import <WindowsAzureMessaging/WindowsAzureMessaging.h> \r      #import \"HubInfo.h\"\r     ```\r \r 7. 根据 iOS 版本，在 `AppDelegate.m file` 的 `didFinishLaunchingWithOptions` 方法中添加以下代码。此代码将向 APNs 注册设备句柄：\r \r     对于 iOS 8：\r \r     ```\r      UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeSound |\r                                             UIUserNotificationTypeAlert | UIUserNotificationTypeBadge categories:nil];\r \r     [[UIApplication sharedApplication] registerUserNotificationSettings:settings];\r     [[UIApplication sharedApplication] registerForRemoteNotifications];\r     ```\r \r     对于 iOS 8 之前的版本：\r \r     ```\r      [[UIApplication sharedApplication] registerForRemoteNotificationTypes: UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound];\r     ```\r \r 8. 在同一文件中，添加以下方法。此代码将使用你在 HubInfo.h 中指定的连接信息连接到通知中心。然后，它向通知中心提供设备令牌，使通知中心能够发送通知：\r \r     ```\r     - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *) deviceToken {\r         SBNotificationHub* hub = [[SBNotificationHub alloc] initWithConnectionString:HUBLISTENACCESS\r                                     notificationHubPath:HUBNAME];\r \r         [hub registerNativeWithDeviceToken:deviceToken tags:nil completion:^(NSError* error) {\r             if (error != nil) {\r                 NSLog(@\"Error registering for notifications: %@\", error);\r             }\r             else {\r                 [self MessageBox:@\"Registration Status\" message:@\"Registered\"];\r             }\r         }];\r     }\r \r     -(void)MessageBox:(NSString *)title message:(NSString *)messageText\r     {\r         UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title message:messageText delegate:self\r             cancelButtonTitle:@\"OK\" otherButtonTitles: nil];\r         [alert show];\r     }\r     ```\r \r 9. 在同一文件中，添加以下方法以便在应用处于活动状态时收到通知的情况下显示 **UIAlert**：\r \r     ```\r     - (void)application:(UIApplication *)application didReceiveRemoteNotification: (NSDictionary *)userInfo {\r         NSLog(@\"%@\", userInfo);\r         [self MessageBox:@\"Notification\" message:[[userInfo objectForKey:@\"aps\"] valueForKey:@\"alert\"]];\r     }\r     ```\r \r 10. 在设备上生成并运行应用，以验证是否不会失败。\r \r ## 发送测试推送通知\r \r 可以在 [Azure 门户]中通过中心边栏选项卡中的“故障排除”部分（使用“测试发送”选项）发送推送通知，以便测试应用的通知接收功能。\r \r ![Azure 门户 — 测试发送][30]  \r \r [!INCLUDE [notification-hubs-sending-notifications-from-the-portal](../../includes/notification-hubs-sending-notifications-from-the-portal.md)]\r \r ## （可选）从应用发送推送通知\r \r >[!IMPORTANT]\r > 提供这个从客户端应用发送通知查询的示例仅供学习。由于这需要将 `DefaultFullSharedAccessSignature` 呈现在客户端应用中，这使您的通知中心面临这样的风险：即用户可能会获得相应访问权限将未经授权的通知发送到您的客户端。\r \r 如果你要从应用内发送推送通知，本节提供如何使用 REST 接口执行此操作的示例。\r \r 1. 在 Xcode 中，打开 `Main.storyboard` 并从对象库添加以下 UI 组件，以允许用户在应用中发送推送通知：\r \r     - 没有标签文本的标签。该标签用于报告发送通知时发生的错误。**Lines** 属性应该设为 **0**，以便自动根据左右边距和视图顶部的限制来调整大小。\r     - 具有**占位符**文本的文本字段设为“输入通知消息”。将字段限制在标签的正下方，如下所示。将视图控制器设为容器委派。\r     - 标题为“发送通知”的按钮限制在文本字段的正下方，并在水平居中的位置。\r \r     该视图应如下所示：\r \r     ![Xcode 设计器][32]  \r \r 2. 为与视图连接的标签和文本字段[添加容器](https://developer.apple.com/library/ios/recipes/xcode_help-IB_connections/chapters/CreatingOutlet.html)，并更新 `interface` 定义，以支持 `UITextFieldDelegate` 和 `NSXMLParserDelegate`。添加如下所示的三个属性声明，以帮助调用 REST API 和分析响应。\r \r     ViewController.h 文件应如下所示：\r \r     ```\r     #import <UIKit/UIKit.h>\r \r     @interface ViewController : UIViewController <UITextFieldDelegate, NSXMLParserDelegate>\r     {\r         NSXMLParser *xmlParser;\r     }\r \r     // Make sure these outlets are connected to your UI by ctrl+dragging\r     @property (weak, nonatomic) IBOutlet UITextField *notificationMessage;\r     @property (weak, nonatomic) IBOutlet UILabel *sendResults;\r \r     @property (copy, nonatomic) NSString *statusResult;\r     @property (copy, nonatomic) NSString *currentElement;\r \r     @end\r     ```\r \r 3. 打开 `HubInfo.h` 并添加以下常量，用于向中心发送通知。将占位符字符串文本替换为实际的 *DefaultFullSharedAccessSignature* 连接字符串。\r \r     ```\r     #define API_VERSION @\"?api-version=2015-01\"\r     #define HUBFULLACCESS @\"<Enter Your DefaultFullSharedAccess Connection string>\"\r     ```\r \r 4. 向 `ViewController.h` 文件添加以下 `#import` 语句。\r \r     ```\r     #import <CommonCrypto/CommonHMAC.h>\r     #import \"HubInfo.h\"\r     ```\r \r 5. 在 `ViewController.m` 中，将以下代码添加到接口实现。此代码将会分析你的 *DefaultFullSharedAccessSignature* 连接字符串。如 [REST API 参考](http://msdn.microsoft.com/zh-cn/library/azure/dn495627.aspx)中所述，此类已分析的信息将用于生成 **Authorization** 请求标头的 SaS 令牌。\r \r     ```\r     NSString *HubEndpoint;\r     NSString *HubSasKeyName;\r     NSString *HubSasKeyValue;\r \r     -(void)ParseConnectionString\r     {\r         NSArray *parts = [HUBFULLACCESS componentsSeparatedByString:@\";\"];\r         NSString *part;\r \r         if ([parts count] != 3)\r         {\r             NSException* parseException = [NSException exceptionWithName:@\"ConnectionStringParseException\"\r                 reason:@\"Invalid full shared access connection string\" userInfo:nil];\r \r             @throw parseException;\r         }\r \r         for (part in parts)\r         {\r             if ([part hasPrefix:@\"Endpoint\"])\r             {\r                 HubEndpoint = [NSString stringWithFormat:@\"https%@\",[part substringFromIndex:11]];\r             }\r             else if ([part hasPrefix:@\"SharedAccessKeyName\"])\r             {\r                 HubSasKeyName = [part substringFromIndex:20];\r             }\r             else if ([part hasPrefix:@\"SharedAccessKey\"])\r             {\r                 HubSasKeyValue = [part substringFromIndex:16];\r             }\r         }\r     }\r     ```\r \r 6. 在 `ViewController.m` 中更新 `viewDidLoad` 方法，以便在加载视图时解析连接字符串。此外，将如下所示的实用程序方法添加到接口实现。\r \r     ```\r     - (void)viewDidLoad\r     {\r         [super viewDidLoad];\r         [self ParseConnectionString];\r         [_notificationMessage setDelegate:self];\r     }\r \r     -(NSString *)CF_URLEncodedString:(NSString *)inputString\r     {\r        return (__bridge NSString *)CFURLCreateStringByAddingPercentEscapes(NULL, (CFStringRef)inputString,\r             NULL, (CFStringRef)@\"!*'();:@&=+$,/?%#[]\", kCFStringEncodingUTF8);\r     }\r \r     -(void)MessageBox:(NSString *)title message:(NSString *)messageText\r     {\r         UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title message:messageText delegate:self\r             cancelButtonTitle:@\"OK\" otherButtonTitles: nil];\r         [alert show];\r     }\r     ```\r \r 7. 如 [REST API 参考](http://msdn.microsoft.com/zh-cn/library/azure/dn495627.aspx)中所述，在 `ViewController.m` 中，将以下代码添加到接口实现，以生成将在 **Authorization** 标头中提供的 SaS 授权令牌。\r \r     ```\r     -(NSString*) generateSasToken:(NSString*)uri\r     {\r         NSString *targetUri;\r         NSString* utf8LowercasedUri = NULL;\r         NSString *signature = NULL;\r         NSString *token = NULL;\r \r         @try\r         {\r             // Add expiration\r             uri = [uri lowercaseString];\r             utf8LowercasedUri = [self CF_URLEncodedString:uri];\r             targetUri = [utf8LowercasedUri lowercaseString];\r             NSTimeInterval expiresOnDate = [[NSDate date] timeIntervalSince1970];\r             int expiresInMins = 60; // 1 hour\r             expiresOnDate += expiresInMins * 60;\r             UInt64 expires = trunc(expiresOnDate);\r             NSString* toSign = [NSString stringWithFormat:@\"%@\\n%qu\", targetUri, expires];\r \r             // Get an hmac_sha1 Mac instance and initialize with the signing key\r             const char *cKey  = [HubSasKeyValue cStringUsingEncoding:NSUTF8StringEncoding];\r             const char *cData = [toSign cStringUsingEncoding:NSUTF8StringEncoding];\r             unsigned char cHMAC[CC_SHA256_DIGEST_LENGTH];\r             CCHmac(kCCHmacAlgSHA256, cKey, strlen(cKey), cData, strlen(cData), cHMAC);\r             NSData *rawHmac = [[NSData alloc] initWithBytes:cHMAC length:sizeof(cHMAC)];\r             signature = [self CF_URLEncodedString:[rawHmac base64EncodedStringWithOptions:0]];\r \r             // Construct authorization token string\r             token = [NSString stringWithFormat:@\"SharedAccessSignature sig=%@&se=%qu&skn=%@&sr=%@\",\r                 signature, expires, HubSasKeyName, targetUri];\r         }\r         @catch (NSException *exception)\r         {\r             [self MessageBox:@\"Exception Generating SaS Token\" message:[exception reason]];\r         }\r         @finally\r         {\r             if (utf8LowercasedUri != NULL)\r                 CFRelease((CFStringRef)utf8LowercasedUri);\r             if (signature != NULL)\r             CFRelease((CFStringRef)signature);\r         }\r \r         return token;\r     }\r     ```\r \r 8. 按住 Ctrl 并从“发送通知”按钮拖到 `ViewController.m`，为 **Touch Down** 事件添加名为 **SendNotificationMessage** 的操作。使用以下代码更新方法，以使用 REST API 发送通知。\r \r     ```\r     - (IBAction)SendNotificationMessage:(id)sender\r     {\r         self.sendResults.text = @\"\";\r         [self SendNotificationRESTAPI];\r     }\r \r     - (void)SendNotificationRESTAPI\r     {\r         NSURLSession* session = [NSURLSession\r                          sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]\r                          delegate:nil delegateQueue:nil];\r \r         // Apple Notification format of the notification message\r         NSString *json = [NSString stringWithFormat:@\"{\"aps\":{\"alert\":\"%@\"}}\",\r                             self.notificationMessage.text];\r \r         // Construct the message's REST endpoint\r         NSURL* url = [NSURL URLWithString:[NSString stringWithFormat:@\"%@%@/messages/%@\", HubEndpoint,\r                                             HUBNAME, API_VERSION]];\r \r         // Generate the token to be used in the authorization header\r         NSString* authorizationToken = [self generateSasToken:[url absoluteString]];\r \r         //Create the request to add the APNs notification message to the hub\r         NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];\r         [request setHTTPMethod:@\"POST\"];\r         [request setValue:@\"application/json;charset=utf-8\" forHTTPHeaderField:@\"Content-Type\"];\r \r         // Signify Apple notification format\r         [request setValue:@\"apple\" forHTTPHeaderField:@\"ServiceBusNotification-Format\"];\r \r         //Authenticate the notification message POST request with the SaS token\r         [request setValue:authorizationToken forHTTPHeaderField:@\"Authorization\"];\r \r         //Add the notification message body\r         [request setHTTPBody:[json dataUsingEncoding:NSUTF8StringEncoding]];\r \r         // Send the REST request\r         NSURLSessionDataTask* dataTask = [session dataTaskWithRequest:request\r             completionHandler:^(NSData *data, NSURLResponse *response, NSError *error)\r         {\r             NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*) response;\r             if (error || (httpResponse.statusCode != 200 && httpResponse.statusCode != 201))\r             {\r                 NSLog(@\"\\nError status: %d\\nError: %@\", httpResponse.statusCode, error);\r             }\r             if (data != NULL)\r             {\r                 xmlParser = [[NSXMLParser alloc] initWithData:data];\r                 [xmlParser setDelegate:self];\r                    [xmlParser parse];\r             }\r         }];\r         [dataTask resume];\r     }\r     ```\r \r 9. 在 `ViewController.m` 中，添加以下委托方法，以支持关闭文本字段的键盘。按住 Ctrl 并从文本字段拖到接口设计器中的视图控制器图标，以将视图控制器设为容器委派。\r \r     ```\r     //===[ Implement UITextFieldDelegate methods ]===\r \r     -(BOOL)textFieldShouldReturn:(UITextField *)textField\r     {\r         [textField resignFirstResponder];\r         return YES;\r     }\r     ```\r \r 10. 在 `ViewController.m` 中添加以下委托方法，以支持使用 `NSXMLParser` 解析响应。\r \r     ```\r     //===[ Implement NSXMLParserDelegate methods ]===\r \r     -(void)parserDidStartDocument:(NSXMLParser *)parser\r     {\r         self.statusResult = @\"\";\r     }\r \r     -(void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName\r         namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName\r         attributes:(NSDictionary *)attributeDict\r     {\r         NSString * element = [elementName lowercaseString];\r         NSLog(@\"*** New element parsed : %@ ***\",element);\r \r         if ([element isEqualToString:@\"code\"] | [element isEqualToString:@\"detail\"])\r         {\r             self.currentElement = element;\r         }\r     }\r \r     -(void) parser:(NSXMLParser *)parser foundCharacters:(NSString *)parsedString\r     {\r         self.statusResult = [self.statusResult stringByAppendingString:\r             [NSString stringWithFormat:@\"%@ : %@\\n\", self.currentElement, parsedString]];\r     }\r \r     -(void)parserDidEndDocument:(NSXMLParser *)parser\r     {\r         // Set the status label text on the UI thread\r         dispatch_async(dispatch_get_main_queue(),\r         ^{\r             [self.sendResults setText:self.statusResult];\r         });\r     }\r     ```\r \r 11. 生成项目并确认没有错误。\r \r > [!NOTE]\r > 如果在 Xcode7 中遇到有关 bitcode 支持的生成错误，应该在 Xcode 中将“生成设置”>“启用 Bitcode (ENABLE\\_BITCODE)”更改为“否”。通知中心 SDK 目前不支持 Bitcode。\r \r 可以在 Apple [本地和推送通知编程指南]中查看所有可能的通知负载。\r \r ## 检查你的应用能否接收推送通知\r \r 若要在 iOS 上测试推送通知，必须将应用部署到物理 iOS 设备。不能使用 iOS 模拟器发送 Apple 推送通知。\r \r 1. 运行应用并确认注册成功，然后按“确定”。\r \r     ![iOS 应用推送通知注册测试][33]  \r \r 2. 如上所述，可以从 [Azure 门户]发送测试推送通知。如果你在应用中添加了发送推送通知的代码，请触摸文本字段以输入通知消息。然后，按键盘上的“发送”按钮或视图中的“发送通知”按钮，以发送通知消息。\r \r     ![iOS 应用推送通知发送测试][34]  \r \r 3. 该推送通知会从特定通知中心发送到所有已注册为接收通知的设备。\r \r     ![iOS 应用推送通知接收测试][35]  \r \r ## 后续步骤 <a name=\"next-steps\"></a>\r \r 在这个简单的示例中，你已将推送通知广播到所有已注册的 iOS 设备。建议转到 [Azure 通知中心 - 使用 .NET 后端通知 iOS 用户]教程开始下一步的学习，该教程将引导你使用标记创建后端以发送推送通知。\r \r 如果要按兴趣组划分用户，可以进一步阅读[使用通知中心发送突发新闻]教程。\r \r 有关通知中心的常规信息，请参阅[通知中心指南]。\r \r <!-- Images. -->\r \r [6]: ./media/notification-hubs-ios-get-started/notification-hubs-configure-ios.png\r [8]: ./media/notification-hubs-ios-get-started/notification-hubs-create-ios-app.png\r [9]: ./media/notification-hubs-ios-get-started/notification-hubs-create-ios-app2.png\r [10]: ./media/notification-hubs-ios-get-started/notification-hubs-create-ios-app3.png\r [11]: ./media/notification-hubs-ios-get-started/notification-hubs-xcode-product-name.png\r \r [30]: ./media/notification-hubs-ios-get-started/notification-hubs-test-send.png\r \r [31]: ./media/notification-hubs-ios-get-started/notification-hubs-ios-ui.png\r [32]: ./media/notification-hubs-ios-get-started/notification-hubs-storyboard-view.png\r [33]: ./media/notification-hubs-ios-get-started/notification-hubs-test1.png\r [34]: ./media/notification-hubs-ios-get-started/notification-hubs-test2.png\r [35]: ./media/notification-hubs-ios-get-started/notification-hubs-test3.png\r \r <!-- URLs. -->\r \r [移动服务 iOS SDK 版本 1.2.4]: http://aka.ms/kymw2g\r [Mobile Services iOS SDK]: http://go.microsoft.com/fwLink/?LinkID=266533\r [Submit an app page]: http://go.microsoft.com/fwlink/p/?LinkID=266582\r [My Applications]: http://go.microsoft.com/fwlink/p/?LinkId=262039\r \r [Azure Classic Management Portal]: https://manage.windowsazure.cn/\r [通知中心指南]: http://msdn.microsoft.com/zh-cn/library/jj927170.aspx\r [Xcode]: https://go.microsoft.com/fwLink/p/?LinkID=266532\r [iOS Provisioning Portal]: http://go.microsoft.com/fwlink/p/?LinkId=272456\r \r [Azure 通知中心 - 使用 .NET 后端通知 iOS 用户]: ./notification-hubs-aspnet-backend-ios-apple-apns-notification.md\r [使用通知中心发送突发新闻]: ./notification-hubs-ios-xplat-segmented-apns-push-notification.md\r \r [本地和推送通知编程指南]: http://developer.apple.com/library/mac/#documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW1\r [Azure 门户]: https://portal.azure.cn\r \r <!---HONumber=Mooncake_1114_2016-->"}