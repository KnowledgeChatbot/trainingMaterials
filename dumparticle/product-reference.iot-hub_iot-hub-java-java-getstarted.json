{"Title":"Azure IoT 中心入门 (Java)","Description":"了解如何通过用于 Java 的 IoT SDK 将设备到云消息发送到 Azure IoT 中心。 创建模拟的设备和服务应用，以便通过 IoT 中心注册设备、发送消息和读取消息。","Content":"# <a name=\"connect-your-device-to-your-iot-hub-using-java\"></a>使用 Java 将设备连接到 IoT 中心\r [!INCLUDE [iot-hub-selector-get-started](../../includes/iot-hub-selector-get-started.md)]\r \r 在本教程结束时，将获得三个 Java 控制台应用：\r \r * **create-device-identity**，用于创建设备标识和关联的安全密钥以连接设备应用。\r * **read-d2c-messages**，用于显示设备应用发送的遥测数据。\r * **simulated-device**，使用前面创建的设备标识连接到 IoT 中心，并使用 MQTT 协议每秒发送一次遥测消息。\r \r > [!NOTE]\r > [Azure IoT SDK][lnk-hub-sdks] 文章介绍了一些 Azure IoT SDK，它们可用于构建在设备和解决方案后端运行的应用。\r > \r > \r \r 要完成本教程，需要以下各项：\r \r * 最新的 [Java SE 开发工具包 8](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) \r * [Maven 3](https://maven.apache.org/install.html) \r * 有效的 Azure 帐户。 如果没有帐户，可以创建一个[试用帐户][lnk-free-trial]，只需几分钟即可完成。\r \r [!INCLUDE [iot-hub-get-started-create-hub](../../includes/iot-hub-get-started-create-hub.md)]\r \r 最后，请记下“主密钥”值。 然后单击“终结点”和“事件”内置终结点。 在“属性”边栏选项卡中，记下“与事件中心兼容的名称”和“与事件中心兼容的终结点”的地址。 创建 **read-d2c-messages** 应用时，将要用到这三个值。\r \r ![Azure 门户 IoT 中心消息传递边栏选项卡][6]\r \r 现在已创建 IoT 中心。 已获取 IoT 中心主机名、IoT 中心连接字符串、IoT 中心主密钥、与事件中心兼容的名称以及与事件中心兼容的终结点，接下来需要完成本教程。\r \r ## <a name=\"create-a-device-identity\"></a>创建设备标识\r 在本部分中，会创建一个 Java 控制台应用，用于在 IoT 中心的标识注册表中创建设备标识。 设备无法连接到 IoT 中心，除非它在标识注册表中具有条目。 有关详细信息，请参阅 **IoT 中心开发人员指南** 的 [标识注册表][lnk-devguide-identity]部分。 当你运行此控制台应用时，它生成唯一的设备 ID 和密钥，当设备向 IoT 中心发送设备到云的消息时，可以用于标识设备本身。\r \r 1. 创建名为 iot-java-get-started 的空文件夹。 在 iot-java-get-started 文件夹的命令提示符处，使用以下命令创建名为 **create-device-identity** 的 Maven 项目。 请注意，这是一条很长的命令：\r \r     ```cmd/sh\r     mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=create-device-identity -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\r     ```\r 2. 在命令提示符下，浏览到 create-device-identity 文件夹。\r 3. 使用文本编辑器，打开 create-device-identity 文件夹中的 pom.xml 文件，并在 **dependencies** 节点中添加以下依赖项。 通过此依赖项可在应用中使用 iot-service-client 包：\r \r     ```xml\r     <dependency>\r       <groupId>com.microsoft.azure.sdk.iot</groupId>\r       <artifactId>iot-service-client</artifactId>\r       <version>1.7.23</version>\r     </dependency>\r     ```\r     \r     > [!NOTE]\r     > 可以使用 [Maven 搜索][lnk-maven-service-search]检查是否有最新版本的 **iot-service-client**。\r \r 4. 保存并关闭 pom.xml 文件。\r 5. 使用文本编辑器打开 create-device-identity\\src\\main\\java\\com\\mycompany\\app\\App.java 文件。\r 6. 在该文件中添加以下 **import** 语句：\r \r     ```java\r     import com.microsoft.azure.sdk.iot.service.exceptions.IotHubException;\r     import com.microsoft.azure.sdk.iot.service.Device;\r     import com.microsoft.azure.sdk.iot.service.RegistryManager;\r    \r     import java.io.IOException;\r     import java.net.URISyntaxException;\r     ```\r 7. 将以下类级变量添加到 **App** 类，并将 **{yourhubconnectionstring}** 替换为前面记录的值：\r \r     ```java\r     private static final String connectionString = \"{yourhubconnectionstring}\";\r     private static final String deviceId = \"myFirstJavaDevice\";\r    \r     ```\r [!INCLUDE [iot-hub-pii-note-naming-device](../../includes/iot-hub-pii-note-naming-device.md)]\r \r 8. 修改 **main** 方法的签名，包含如下所示的异常：\r \r     ```java\r     public static void main( String[] args ) throws IOException, URISyntaxException, Exception\r     ```\r 9. 添加以下代码作为 **main** 方法的主体。 此代码在 IoT 中心标识注册表中创建名为 *javadevice* 的设备（如果还没有该设备）。 随即显示稍后需要用到的设备 ID 和密钥：\r \r     ```java\r     RegistryManager registryManager = RegistryManager.createFromConnectionString(connectionString);\r \r     // Create a device that's enabled by default, \r     // with an autogenerated key.\r     Device device = Device.createFromId(deviceId, null, null);\r     try {\r       device = registryManager.addDevice(device);\r     } catch (IotHubException iote) {\r       // If the device already exists.\r       try {\r         device = registryManager.getDevice(deviceId);\r       } catch (IotHubException iotf) {\r         iotf.printStackTrace();\r       }\r     }\r \r     // Display information about the\r     // device you created.\r     System.out.println(\"Device Id: \" + device.getDeviceId());\r     System.out.println(\"Device key: \" + device.getPrimaryKey());\r     ```\r 10. 保存并关闭 App.java 文件。\r 11. 若要使用 Maven 生成 **create-device-identity** 应用，请在命令提示符下的 create-device-identity 文件夹中执行以下命令：\r \r     ```cmd/sh\r     mvn clean package -DskipTests\r     ```\r 12. 若要使用 Maven 运行 **create-device-identity** 应用，请在 create-device-identity 文件夹中的命令提示符下执行以下命令：\r \r     ```cmd/sh\r     mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\"\r     ```\r 13. 记下**设备 ID** 和**设备密钥**。 稍后在创建连接到作为设备的 IoT 中心的应用时需要这些值。\r \r > [!NOTE]\r > IoT 中心标识注册表仅存储用于实现 IoT 中心安全访问的设备标识。 它存储设备 ID 和密钥作为安全凭据，以及启用或禁用标志（可用于禁用对单个设备的访问）。 如果应用需要存储设备特定的其他元数据，需使用应用特定的存储。 有关详细信息，请参阅 [IoT 中心开发人员指南][lnk-devguide-identity]。\r > \r > \r \r ## <a name=\"receive-device-to-cloud-messages\"></a>接收设备到云的消息\r 在本部分中，会创建一个 Java 控制台应用程序，用于读取来自 IoT 中心的设备到云消息。 IoT 中心公开与[事件中心][lnk-event-hubs-overview]兼容的终结点，以便你可读取设备到云的消息。 为了简单起见，本教程创建的基本读取器不适用于高吞吐量部署。 [Process device-to-cloud messages][lnk-process-d2c-tutorial] （处理设备到云的消息）教程介绍了如何大规模处理设备到云的消息。 [事件中心入门][lnk-eventhubs-tutorial] 教程更详细地介绍了如何处理来自事件中心的消息，此教程也适用于与 IoT 中心事件中心兼容的终结点。\r \r > [!NOTE]\r > 与事件中心兼容的终结点始终使用 AMQP 协议读取设备到云的消息。\r > \r > \r \r 1. 在 *创建设备标识* 部分中创建的 iot-java-get-started 文件夹中，在命令提示符处使用以下命令创建名为 **read-d2c-messages** 的 Maven 项目。 请注意，这是一条很长的命令：\r \r     ```cmd/sh\r     mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=read-d2c-messages -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\r     ```\r 2. 在命令提示符下，浏览到 read-d2c-messages 文件夹。\r 3. 使用文本编辑器，打开 read-d2c-messages 文件夹中的 pom.xml 文件，并在 **dependencies** 节点中添加以下依赖项。 借助此依赖项，可使用应用中的 eventhubs-client 包，从与事件中心兼容的终结点进行读取：\r \r     ```xml\r     <dependency> \r         <groupId>com.microsoft.azure</groupId> \r         <artifactId>azure-eventhubs</artifactId> \r         <version>0.15.0</version> \r     </dependency>\r     ```\r \r 4. 保存并关闭 pom.xml 文件。\r 5. 使用文本编辑器打开 read-d2c-messages\\src\\main\\java\\com\\mycompany\\app\\App.java 文件。\r 6. 在该文件中添加以下 **import** 语句：\r \r     ```java\r     import java.io.IOException;\r     import com.microsoft.azure.eventhubs.*;\r \r     import java.nio.charset.Charset;\r     import java.time.*;\r     import java.util.function.*;\r     ```\r 7. 将下列类级变量添加到 **App** 类。 将 **{youriothubkey}**、**{youreventhubcompatibleendpoint}** 和 **{youreventhubcompatiblename}** 替换为前面记下的值：\r \r     ```java\r     private static String connStr = \"Endpoint={youreventhubcompatibleendpoint};EntityPath={youreventhubcompatiblename};SharedAccessKeyName=iothubowner;SharedAccessKey={youriothubkey}\";\r     ```\r 8. 将以下 **receiveMessages** 方法添加到 **App** 类。 此方法创建 **EventHubClient** 实例以连接到与事件中心兼容的终结点，然后以异步方式创建 **PartitionReceiver** 实例，以便从事件中心分区读取。 它持续循环并输出消息详细信息，直到应用终止。\r \r     ```java\r     // Create a receiver on a partition.\r     private static EventHubClient receiveMessages(final String partitionId) {\r       EventHubClient client = null;\r       try {\r         client = EventHubClient.createFromConnectionStringSync(connStr);\r       } catch (Exception e) {\r         System.out.println(\"Failed to create client: \" + e.getMessage());\r         System.exit(1);\r       }\r       try {\r         // Create a receiver using the\r         // default Event Hubs consumer group\r         // that listens for messages from now on.\r         client.createReceiver(EventHubClient.DEFAULT_CONSUMER_GROUP_NAME, partitionId, Instant.now())\r           .thenAccept(new Consumer<PartitionReceiver>() {\r             public void accept(PartitionReceiver receiver) {\r               System.out.println(\"** Created receiver on partition \" + partitionId);\r               try {\r                 while (true) {\r                   Iterable<EventData> receivedEvents = receiver.receive(100).get();\r                   int batchSize = 0;\r                   if (receivedEvents != null) {\r                     System.out.println(\"Got some evenst\");\r                     for (EventData receivedEvent : receivedEvents) {\r                       System.out.println(String.format(\"Offset: %s, SeqNo: %s, EnqueueTime: %s\",\r                         receivedEvent.getSystemProperties().getOffset(),\r                         receivedEvent.getSystemProperties().getSequenceNumber(),\r                         receivedEvent.getSystemProperties().getEnqueuedTime()));\r                       System.out.println(String.format(\"| Device ID: %s\",\r                         receivedEvent.getSystemProperties().get(\"iothub-connection-device-id\")));\r                       System.out.println(String.format(\"| Message Payload: %s\",\r                         new String(receivedEvent.getBytes(), Charset.defaultCharset())));\r                       batchSize++;\r                     }\r                   }\r                   System.out.println(String.format(\"Partition: %s, ReceivedBatch Size: %s\", partitionId, batchSize));\r                 }\r               } catch (Exception e) {\r                 System.out.println(\"Failed to receive messages: \" + e.getMessage());\r               }\r             }\r           });\r         } catch (Exception e) {\r           System.out.println(\"Failed to create receiver: \" + e.getMessage());\r       }\r       return client;\r     }\r     ```\r    \r    > [!NOTE]\r    > 在创建开始运行后只读取发送到 IoT 中心的消息的接收方时，此方法使用筛选器。 此方法很适合测试环境，因为这样可以看到当前的消息集。 在生产环境中，代码应确保它能处理所有消息。有关详细信息，请参阅[如何处理 IoT 中心设备到云的消息][lnk-process-d2c-tutorial]教程。\r    > \r    > \r 9. 修改 **main** 方法的签名，包含如下所示的异常：\r \r     ```java\r     public static void main( String[] args ) throws IOException\r     ```\r 10. 在 **App** 类的 **main** 方法中添加以下代码。 此代码将创建两个（**EventHubClient** 和 **PartitionReceiver**）实例并使用户可在处理完消息后关闭应用：\r \r     ```java\r     // Create receivers for partitions 0 and 1.\r     EventHubClient client0 = receiveMessages(\"0\");\r     EventHubClient client1 = receiveMessages(\"1\");\r     System.out.println(\"Press ENTER to exit.\");\r     System.in.read();\r     try {\r       client0.closeSync();\r       client1.closeSync();\r       System.exit(0);\r     } catch (Exception e) {\r       System.exit(1);\r     }\r     ```\r     \r     > [!NOTE]\r     > 此代码假设已在 F1（免费）层创建 IoT 中心。 免费 IoT 中心有“0”和“1”这两个分区。\r     > \r     > \r 11. 保存并关闭 App.java 文件。\r 12. 若要使用 Maven 生成 **read-d2c-messages** 应用，请在 read-d2c-messages 文件夹中的命令提示符下执行以下命令：\r \r     ```cmd/sh\r     mvn clean package -DskipTests\r     ```\r \r ## <a name=\"create-a-device-app\"></a>创建设备应用\r 在本部分中，会创建一个 Java 控制台应用程序，用于模拟向 IoT 中心发送设备到云消息的设备。\r \r 1. 在 *创建设备标识* 部分创建的 iot-java-get-started 文件夹中，在命令提示符处创建名为 **simulated-device** 的 Maven 项目。 请注意，这是一条很长的命令：\r \r     ```cmd/sh\r     mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=simulated-device -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\r     ```\r 2. 在命令提示符下，浏览到 simulated-device 文件夹。\r 3. 使用文本编辑器，打开 simulated-device 文件夹中的 pom.xml 文件，并在 **dependencies** 节点中添加以下依赖项。 通过此依赖项可以使用应用中的 iothub-java-client 包与 IoT 中心通信，并将 Java 对象序列化为 JSON：\r \r     ```xml\r     <dependency>\r       <groupId>com.microsoft.azure.sdk.iot</groupId>\r       <artifactId>iot-device-client</artifactId>\r       <version>1.3.32</version>\r     </dependency>\r     <dependency>\r       <groupId>com.google.code.gson</groupId>\r       <artifactId>gson</artifactId>\r       <version>2.3.1</version>\r     </dependency>\r     ```\r \r     > [!NOTE]\r     > 可以使用 [Maven 搜索][lnk-maven-device-search]检查是否有最新版本的 **iot-device-client**。\r \r 4. 保存并关闭 pom.xml 文件。\r 5. 使用文本编辑器打开 simulated-device\\src\\main\\java\\com\\mycompany\\app\\App.java 文件。\r 6. 在该文件中添加以下 **import** 语句：\r \r     ```java\r     import com.microsoft.azure.sdk.iot.device.*;\r     import com.google.gson.Gson;\r \r     import java.io.*;\r     import java.net.URISyntaxException;\r     import java.util.Random;\r     import java.util.concurrent.Executors;\r     import java.util.concurrent.ExecutorService;\r     ```\r 7. 将以下类级变量添加到 **App** 类。 将 **{youriothubname}** 替换为 IoT 中心名称，将 **{yourdevicekey}** 替换为在*创建设备标识*部分中生成的设备密钥值：\r \r     ```java\r     private static String connString = \"HostName={youriothubname}.azure-devices.cn;DeviceId=myFirstJavaDevice;SharedAccessKey={yourdevicekey}\";\r     private static IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\r     private static String deviceId = \"myFirstJavaDevice\";\r     private static DeviceClient client;\r     ```\r    \r     本示例应用在实例化 **DeviceClient** 对象时使用 **protocol** 变量。 可以使用 MQTT、AMQP 或 HTTPS 协议与 IoT 中心通信。\r \r 8. 在 **App** 类中添加以下嵌套的 **TelemetryDataPoint** 类，以指定设备要发送到 IoT 中心的遥测数据：\r \r     ```java\r     private static class TelemetryDataPoint {\r       public String deviceId;\r       public double temperature;\r       public double humidity;\r    \r       public String serialize() {\r         Gson gson = new Gson();\r         return gson.toJson(this);\r       }\r     }\r     ```\r 9. 在 **App** 类中添加以下嵌套的 **EventCallback** 类，以显示 IoT 中心在处理来自设备应用的消息时返回的确认状态。 处理消息时，此方法还会通知应用中的主线程：\r    \r     ```java\r     private static class EventCallback implements IotHubEventCallback {\r       public void execute(IotHubStatusCode status, Object context) {\r         System.out.println(\"IoT Hub responded to message with status: \" + status.name());\r    \r         if (context != null) {\r           synchronized (context) {\r             context.notify();\r           }\r         }\r       }\r     }\r     ```\r 10. 在 **App** 类中添加以下嵌套的 **MessageSender** 类。 此类中的 **run** 方法会生成要发送到 IoT 中心的示例遥测数据，并在发送下一条消息之前等待确认：\r \r     ```java\r     private static class MessageSender implements Runnable {\r     \r       public void run()  {\r         try {\r           double minTemperature = 20;\r           double minHumidity = 60;\r           Random rand = new Random();\r     \r           while (true) {\r             double currentTemperature = minTemperature + rand.nextDouble() * 15;\r             double currentHumidity = minHumidity + rand.nextDouble() * 20;\r             TelemetryDataPoint telemetryDataPoint = new TelemetryDataPoint();\r             telemetryDataPoint.deviceId = deviceId;\r             telemetryDataPoint.temperature = currentTemperature;\r             telemetryDataPoint.humidity = currentHumidity;\r     \r             String msgStr = telemetryDataPoint.serialize();\r             Message msg = new Message(msgStr);\r             msg.setProperty(\"temperatureAlert\", (currentTemperature > 30) ? \"true\" : \"false\");\r             msg.setMessageId(java.util.UUID.randomUUID().toString()); \r             System.out.println(\"Sending: \" + msgStr);\r     \r             Object lockobj = new Object();\r             EventCallback callback = new EventCallback();\r             client.sendEventAsync(msg, callback, lockobj);\r     \r             synchronized (lockobj) {\r               lockobj.wait();\r             }\r             Thread.sleep(1000);\r           }\r         } catch (InterruptedException e) {\r           System.out.println(\"Finished.\");\r         }\r       }\r     }\r     ```\r     \r     IoT 中心确认前面的消息一秒后，此方法将发送新的设备到云消息。 该消息包含一个具有设备 ID 的 JSON 序列化对象和一个随机生成的编号，用于模拟温度传感器和湿度传感器。\r 11. 将 **main** 方法替换为以下代码，该代码创建用于向 IoT 中心发送设备到云消息的线程：\r \r     ```java\r     public static void main( String[] args ) throws IOException, URISyntaxException {\r       client = new DeviceClient(connString, protocol);\r       client.open();\r     \r       MessageSender sender = new MessageSender();\r     \r       ExecutorService executor = Executors.newFixedThreadPool(1);\r       executor.execute(sender);\r     \r       System.out.println(\"Press ENTER to exit.\");\r       System.in.read();\r       executor.shutdownNow();\r       client.closeNow();\r     }\r     ```\r 12. 保存并关闭 App.java 文件。\r 13. 若要使用 Maven 构建 **simulated-device** 应用，请在 simulated-device 文件夹的命令提示符处执行以下命令：\r \r     ```cmd/sh\r     mvn clean package -DskipTests\r     ```\r \r > [!NOTE]\r > 为简单起见，本教程不实现任何重试策略。 在生产代码中，应该按 MSDN 文章 [Transient Fault Handling][lnk-transient-faults]（暂时性故障处理）中所述实施重试策略（例如指数性的回退）。\r > \r > \r \r ## <a name=\"run-the-apps\"></a>运行应用\r 现在，已准备就绪，可以运行应用。\r \r 1. 在 read-d2c 文件夹的命令提示符处，运行以下命令监视 IoT 中心的第一个分区：\r \r     ```cmd/sh\r     mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\"\r     ```\r    \r     ![用于监视设备到云的消息的 Java IoT 中心服务应用][7]\r 2. 在 simulated-device 文件夹的命令提示符处，运行以下命令将遥测数据发送到 IoT 中心：\r \r     ```cmd/sh\r     mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\" \r     ```\r    \r     ![用于发送设备到云消息的 Java IoT 中心设备应用][8]\r 3. [Azure 门户][lnk-portal]中的“使用情况”磁贴显示发送到 IoT 中心的消息数：\r    \r     ![显示发送到 IoT 中心的消息数的 Azure 门户“使用情况”磁贴][43]\r \r ## <a name=\"next-steps\"></a>后续步骤\r 在本教程中，已在 Azure 门户中配置了新的 IoT 中心，然后在 IoT 中心的标识注册表中创建了设备标识。 已使用此设备标识来让设备应用向 IoT 中心发送设备到云的消息。 还创建了一个应用，用于显示 IoT 中心接收的消息。\r \r 若要继续了解 IoT 中心入门知识并浏览其他 IoT 方案，请参阅：\r \r * \r             [连接设备][lnk-connect-device]\r * [设备管理入门][lnk-device-management]\r * [Azure IoT Edge 入门][lnk-iot-edge]\r \r 若要了解如何扩展 IoT 解决方案和如何大规模处理设备到云的消息，请参阅 [Process device-to-cloud messages][lnk-process-d2c-tutorial] （处理设备到云的消息）教程。\r [!INCLUDE [iot-hub-get-started-next-steps](../../includes/iot-hub-get-started-next-steps.md)]\r \r <!-- Images. -->\r [6]: ./media/iot-hub-java-java-getstarted/create-iot-hub6.png\r [7]: ./media/iot-hub-java-java-getstarted/runapp1.png\r [8]: ./media/iot-hub-java-java-getstarted/runapp2.png\r [43]: ./media/iot-hub-java-java-getstarted/usage.png\r \r <!-- Links -->\r [lnk-transient-faults]: https://msdn.microsoft.com/library/hh680901(v=pandp.50).aspx\r \r [lnk-eventhubs-tutorial]: ../event-hubs/event-hubs-csharp-ephcs-getstarted.md\r [lnk-devguide-identity]: ./iot-hub-devguide-identity-registry.md\r [lnk-event-hubs-overview]: ../event-hubs/event-hubs-overview.md\r [lnk-process-d2c-tutorial]: ./iot-hub-csharp-csharp-process-d2c.md\r \r [lnk-hub-sdks]: ./iot-hub-devguide-sdks.md\r [lnk-free-trial]: https://www.azure.cn/pricing/1rmb-trial/\r [lnk-portal]: https://portal.azure.cn/\r \r [lnk-device-management]: ./iot-hub-node-node-device-management-get-started.md\r [lnk-iot-edge]: iot-hub-linux-iot-edge-get-started.md\r [lnk-connect-device]: https://www.azure.cn/develop/iot/\r [lnk-maven-service-search]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22iot-service-client%22%20g%3A%22com.microsoft.azure.sdk.iot%22\r [lnk-maven-device-search]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22iot-device-client%22%20g%3A%22com.microsoft.azure.sdk.iot%22\r [lnk-maven-eventhubs-search]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22azure-eventhubs%22\r \r \r <!--Update_Description:update code and wording-->"}