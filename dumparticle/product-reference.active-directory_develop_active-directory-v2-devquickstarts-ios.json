{"Title":"Azure AD v2.0 iOS 应用","Description":"如何通过第三方库生成一个使用个人 Microsoft 帐户和工作或学校帐户来登录用户的 iOS 应用。","Content":"\r # 使用 v2.0 终结点，通过图形 API 将登录添加到使用第三方库的 iOS 应用\r Microsoft 标识平台使用开放式标准，例如 OAuth2 和 OpenID Connect。开发人员可以使用任何想要的库来与我们的服务集成。为了帮助开发人员将我们的平台与其他库结合使用，我们撰写了数篇演练（例如本演练），演示如何配置第三方库，使其连接到 Microsoft 标识平台。大部分实施 [RFC6749 OAuth2 规范](https://tools.ietf.org/html/rfc6749)的库都能连接到 Microsoft 标识平台。\r \r 借助本演练创建的应用程序，用户可以使用图形 API 登录自己的组织，然后在组织中搜索其他人。\r \r 如果你是 OAuth2 或 OpenID Connect 新手，该示例配置中的大部分内容可能较难理解。建议你阅读 [v2.0 协议 — OAuth 2.0 授权代码流](./active-directory-v2-protocols-oauth-code.md)了解背景信息。\r \r > [!NOTE]\r 我们平台中的有些功能（例如条件访问和 Intune 策略管理）采用 OAuth2 或 OpenID Connect 标准中的表达式，所以会要求使用开放源代码 Azure 标识库。\r > \r > \r \r v2.0 终结点并不支持所有 Azure Active Directory 方案和功能。\r \r > [!NOTE]\r 若要确定是否应使用 v2.0 终结点，请阅读 [v2.0 限制](./active-directory-v2-limitations.md)。\r > \r > \r \r ## 从 GitHub 下载代码\r 本教程的代码[在 GitHub 上](https://github.com/Azure-Samples/active-directory-ios-native-nxoauth2-v2)维护。若要遵照该代码，你可以[下载 .zip 格式应用骨架](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-DotNet/archive/skeleton.zip)，或克隆该骨架：\r \r ```\r git clone --branch skeleton git@github.com:Azure-Samples/active-directory-ios-native-nxoauth2-v2.git\r ```\r \r 你也可以下载以下示例，并立即开始使用：\r \r ```\r git clone git@github.com:Azure-Samples/active-directory-ios-native-nxoauth2-v2.git\r ```\r \r ## 注册应用程序\r 在[应用程序注册门户](https://apps.dev.microsoft.com)创建新的应用，或按照[如何使用 v2.0 终结点注册应用](./active-directory-v2-app-registration.md)中的详细步骤操作。请确保：\r \r - 复制分配给应用的“应用程序 ID”，因为稍后将要用到。\r - 为应用添加**移动**平台。\r - 从门户复制**重定向 URI**。必须使用默认值 `urn:ietf:wg:oauth:2.0:oob`。\r \r ## 下载 NXOAuth2 第三方库并创建工作区\r 在本演练中，你将使用 GitHub 提供的 OAuth2Client，这是适用于 Mac OS X 和 iOS 的 OAuth2 库（Cocoa 和 Cocoa Touch）。此库以 OAuth2 规范的第 10 版草稿为基础。它将实现本机应用程序配置文件，并支持用户的授权终结点。用户需要上述各项，才能与 Microsoft 标识平台集成。\r \r ### 使用 CocoaPods 将库添加到项目\r CocoaPods 是 Xcode 项目的依赖关系管理器。它会自动管理上述安装步骤。\r \r ```\r $ vi Podfile\r ```\r \r 1. 将以下内容添加到 podfile：\r \r     ```\r     platform :ios, '8.0'\r \r     target 'QuickStart' do\r \r     pod 'NXOAuth2Client'\r \r     end\r     ```\r \r 2. 使用 CocoaPods 加载 podfile。这会创建你要加载的新 Xcode 工作区。\r \r     ```\r     $ pod install\r     ...\r     $ open QuickStart.xcworkspace\r     ```\r \r ## 浏览项目结构\r 在主干中为项目设置以下结构：\r \r - 具有 UPN 搜索功能的主视图\r - 所选用户的相关数据的详细信息视图\r - 用户可登录到应用来查询图形的登录视图\r \r 我们将移至主干中的各种文件，以添加身份验证。代码的其他部分（如可视代码）虽然与标识无关，但也会提供给你。\r \r ## 设置库中的 settings.plst 文件\r - 在快速入门项目中，打开 `settings.plist` 文件。替换节中的元素值，反映你在 Azure 门户中使用的值。每当使用 Active Directory 身份验证库时，你的代码就会参考这些值。\r   - `clientId` 是从门户复制的应用程序的客户端 ID。\r   - `redirectUri` 是门户提供的重定向 URL。\r \r ## 在 LoginViewController 中设置 NXOAuth2Client 库\r NXOAuth2Client 库要求设置一些值。完成该任务之后，可以使用所获令牌来调用图形 API。因为每当需要进行身份验证时都会调用 `LoginView`，所以合理的做法是将配置值放入该文件中。\r \r - 让我们在 `LoginViewController.m` 文件中添加一些值，以便针对身份验证和授权来设置上下文。紧跟代码后面的是关于这些值的详细信息。\r \r     ```objc\r     NSString *scopes = @\"openid offline_access User.Read\";\r     NSString *authURL = @\"https://login.microsoftonline.com/common/oauth2/v2.0/authorize\";\r     NSString *loginURL = @\"https://login.microsoftonline.com/common/login\";\r     NSString *bhh = @\"urn:ietf:wg:oauth:2.0:oob?code=\";\r     NSString *tokenURL = @\"https://login.microsoftonline.com/common/oauth2/v2.0/token\";\r     NSString *keychain = @\"com.microsoft.azureactivedirectory.samples.graph.QuickStart\";\r     static NSString * const kIDMOAuth2SuccessPagePrefix = @\"session_state=\";\r     NSURL *myRequestedUrl;\r     NSURL *myLoadedUrl;\r     bool loginFlow = FALSE;\r     bool isRequestBusy;\r     NSURL *authcode;\r     ```\r \r 让我们看看关于代码的详细信息。\r \r 第一个字符串用于 `scopes`。`User.Read` 值允许读取已登录用户的基本配置文件。\r \r 你可以在 [Microsoft Graph 权限范围](https://graph.microsoft.io/docs/authorization/permission_scopes)中了解有关所有可用范围的详细信息。\r \r 对于 `authURL`、`loginURL`、`bhh` 及 `tokenURL`，你应该使用上面提供的值。如果你使用开放源代码 Azure 标识库，我们将使用元数据终结点提取此数据。我们已努力完成为你提取这些值的工作。\r \r `keychain` 值是一个容器，NXOAuth2Client 库将用来创建密钥链以存储你的令牌。如果想要跨多个应用实现单一登录 (SSO)，可以在每个应用程序中指定相同的密钥链，并请求在 Xcode 权利中使用该密钥链。这会在 Apple 文档中说明。\r \r 我们也需要其余的值，才能使用此库，才能将值应用于上下文。\r \r ### 创建 URL 缓存\r 在加载视图之后，始终会调用 `(void)viewDidLoad()`，其内部的以下代码会准备好缓存以供我们使用。\r \r 添加以下代码：\r \r ```objc\r - (void)viewDidLoad {\r     [super viewDidLoad];\r     self.loginView.delegate = self;\r     [self setupOAuth2AccountStore];\r     [self requestOAuth2Access];\r     NSURLCache *URLCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024\r                                                          diskCapacity:20 * 1024 * 1024\r                                                              diskPath:nil];\r     [NSURLCache setSharedURLCache:URLCache];\r \r }\r ```\r \r ### 创建用于登录的 Web 视图\r \r Web 视图可提示用户提供短信等附加因素（如果已配置）或向用户返回错误消息。你将在此处设置 Web 视图，然后编写代码，以从标识服务处理将会在 Web 视图中发生的回叫。\r \r ```objc\r -(void)requestOAuth2Access {\r     //to sign in to Microsoft APIs using OAuth2, we must show an embedded browser (UIWebView)\r     [[NXOAuth2AccountStore sharedStore] requestAccessToAccountWithType:@\"myGraphService\"\r                                    withPreparedAuthorizationURLHandler:^(NSURL *preparedURL) {\r                                        //navigate to the URL returned by NXOAuth2Client\r \r                                        NSURLRequest *r = [NSURLRequest requestWithURL:preparedURL];\r                                        [self.loginView loadRequest:r];\r                                    }];\r }\r ```\r \r ### 重写 Web 视图方法以处理身份验证\r \r 如先前所述，当用户需要登录时，若要告诉 Web 视图发生了什么情况，你可以粘贴以下代码。\r \r ```objc\r - (void)resolveUsingUIWebView:(NSURL *)URL {\r \r     // We get the auth token from a redirect so we need to handle that in the webview.\r \r     if (![NSThread isMainThread]) {\r         [self performSelectorOnMainThread:@selector(resolveUsingUIWebView:) withObject:URL waitUntilDone:YES];\r         return;\r     }\r \r     NSURLRequest *hostnameURLRequest = [NSURLRequest requestWithURL:URL cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0f];\r     isRequestBusy = YES;\r     [self.loginView loadRequest:hostnameURLRequest];\r \r     NSLog(@\"resolveUsingUIWebView ready (status: UNKNOWN, URL: %@)\", self.loginView.request.URL);\r }\r \r - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {\r \r     NSLog(@\"webView:shouldStartLoadWithRequest: %@ (%li)\", request.URL, (long)navigationType);\r \r     // The webview is where all the communication happens. Slightly complicated.\r \r     myLoadedUrl = [webView.request mainDocumentURL];\r     NSLog(@\"***Loaded url: %@\", myLoadedUrl);\r \r     //if the UIWebView is showing our authorization URL or consent URL, show the UIWebView control\r     if ([request.URL.absoluteString rangeOfString:authURL options:NSCaseInsensitiveSearch].location != NSNotFound) {\r         self.loginView.hidden = NO;\r     } else if ([request.URL.absoluteString rangeOfString:loginURL options:NSCaseInsensitiveSearch].location != NSNotFound) {\r         //otherwise hide the UIWebView, we've left the authorization flow\r         self.loginView.hidden = NO;\r     } else if ([request.URL.absoluteString rangeOfString:bhh options:NSCaseInsensitiveSearch].location != NSNotFound) {\r         //otherwise hide the UIWebView, we've left the authorization flow\r         self.loginView.hidden = YES;\r         [[NXOAuth2AccountStore sharedStore] handleRedirectURL:request.URL];\r     }\r     else {\r         self.loginView.hidden = NO;\r         //read the Location from the UIWebView, this is how Microsoft APIs is returning the\r         //authentication code and relation information. This is controlled by the redirect URL we chose to use from Microsoft APIs\r         //continue the OAuth2 flow\r        // [[NXOAuth2AccountStore sharedStore] handleRedirectURL:request.URL];\r     }\r \r     return YES;\r \r }\r ```\r \r ### 编写代码以处理 OAuth2 请求的结果\r \r 以下代码会处理从 Web 视图返回的 redirectURL。如果身份验证未成功，此代码将重试一次。同时，库会提供错误，让你可在控制台中查看或以异步方式处理。\r \r ```objc\r - (void)handleOAuth2AccessResult:(NSString *)accessResult {\r \r     AppData* data = [AppData getInstance];\r \r     //parse the response for success or failure\r      if (accessResult)\r     //if success, complete the OAuth2 flow by handling the redirect URL and obtaining a token\r      {\r          [[NXOAuth2AccountStore sharedStore] handleRedirectURL:accessResult];\r     } else {\r         //start over\r         [self requestOAuth2Access];\r     }\r }\r ```\r \r ### 设置 OAuth 上下文（称为帐户存储）\r \r 在这里，你可以针对希望应用程序能够访问的每个服务，在共享帐户存储上调用 `-[NXOAuth2AccountStore setClientID:secret:authorizationURL:tokenURL:redirectURL:forAccountType:]`。帐户类型是字符串，可作为特定服务的标识符。由于你正在访问图形 API，因此，代码会将其视为 `\"myGraphService\"`。接着，设置观察器，它会在令牌发生任何更改时通知你。在你获取令牌后，让用户返回到 `masterView`。\r \r ```objc\r - (void)setupOAuth2AccountStore {\r \r         AppData* data = [AppData getInstance];\r \r     [[NXOAuth2AccountStore sharedStore] setClientID:data.clientId\r                                              secret:data.secret\r                                               scope:[NSSet setWithObject:scopes]\r                                    authorizationURL:[NSURL URLWithString:authURL]\r                                            tokenURL:[NSURL URLWithString:tokenURL]\r                                         redirectURL:[NSURL URLWithString:data.redirectUriString]\r                                       keyChainGroup: keychain\r                                      forAccountType:@\"myGraphService\"];\r \r     [[NSNotificationCenter defaultCenter] addObserverForName:NXOAuth2AccountStoreAccountsDidChangeNotification\r                                                       object:[NXOAuth2AccountStore sharedStore]\r                                                        queue:nil\r                                                   usingBlock:^(NSNotification *aNotification) {\r                                                       if (aNotification.userInfo) {\r                                                           //account added, we have access\r                                                           //we can now request protected data\r                                                           NSLog(@\"Success!! We have an access token.\");\r                                                           dispatch_async(dispatch_get_main_queue(),^ {\r \r                                                               MasterViewController* masterViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"masterView\"];\r                                                               [self.navigationController pushViewController:masterViewController animated:YES];\r                                                           });\r                                                       } else {\r                                                           //account removed, we lost access\r                                                       }\r                                                   }];\r \r     [[NSNotificationCenter defaultCenter] addObserverForName:NXOAuth2AccountStoreDidFailToRequestAccessNotification\r                                                       object:[NXOAuth2AccountStore sharedStore]\r                                                        queue:nil\r                                                   usingBlock:^(NSNotification *aNotification) {\r                                                       NSError *error = [aNotification.userInfo objectForKey:NXOAuth2AccountStoreErrorKey];\r                                                       NSLog(@\"Error!! %@\", error.localizedDescription);\r                                                   }];\r }\r ```\r \r ## 设置主视图以从图形 API 搜索和显示用户\r 在网格中显示所返回数据的主视图控制器 (MVC) 应用超出了本演练的范围，而且有很多在线教程说明了如何生成该应用。此代码全都在主干文件中。不过，必须在此 MVC 应用程序中处理几件事：\r \r - 当用户在搜索字段中键入内容时进行拦截\r - 将数据的对象提供给主视图，以便在网格中显示结果\r \r 我们会在下面执行这些操作。\r \r ### 添加检查以查看你是否已经登录\r 如果用户未登录，应用程序就没什么作用，因此，检查缓存中是否已有令牌是明智之举。如果没有，则重定向到登录视图以让用户登录。如果你还记得，在视图加载时执行操作的最佳方式，就是使用 Apple 提供的 `viewDidLoad()` 方法。\r \r ```objc\r - (void)viewDidLoad {\r     [super viewDidLoad];\r \r     NXOAuth2AccountStore *store = [NXOAuth2AccountStore sharedStore];\r     NSArray *accounts = [store accountsWithAccountType:@\"myGraphService\"];\r \r         if (accounts.count == 0) {\r \r         dispatch_async(dispatch_get_main_queue(),^ {\r \r             LoginViewController* userSelectController = [self.storyboard instantiateViewControllerWithIdentifier:@\"LoginUserView\"];\r             [self.navigationController pushViewController:userSelectController animated:YES];\r         });\r         }\r ```\r \r ### 在收到数据时更新表视图\r \r 当图形 API 返回数据时，必须显示该数据。为简单起见，下面提供了用于更新表的全部代码。你可以直接在 MVC 样本代码中粘贴正确的值。\r \r ```objc\r #pragma mark - Table View\r \r - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {\r     return 1;\r }\r \r - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\r \r         return [upnArray count];\r }\r \r - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\r \r     UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"TaskPrototypeCell\" forIndexPath:indexPath];\r \r     if ( cell == nil ) {\r         cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@\"TaskPrototypeCell\"];\r     }\r \r     User *user = nil;\r      user = [upnArray objectAtIndex:indexPath.row];\r \r     // Configure the cell\r     cell.textLabel.text = user.name;\r     [cell setAccessoryType:UITableViewCellAccessoryDisclosureIndicator];\r \r     return cell;\r }\r ```\r \r ### 提供用户在搜索字段中键入内容时调用图形 API 的方法\r \r 当用户在框中键入搜索内容时，你需要将该内容塞入图形 API。你将在以下代码中生成的 `GraphAPICaller` 类会将查找功能从演示当中分离出来。现在，让我们编写会将任何搜索字符送入图形 API 的代码。我们的做法是提供称为 `lookupInGraph` 的方法，其采用我们想要搜索的字符串。\r \r ```objc\r -(void)lookupInGraph:(NSString *)searchText {\r if (searchText.length > 0) {\r \r     };\r \r         [GraphAPICaller searchUserList:searchText completionBlock:^(NSMutableArray* returnedUpns, NSError* error) {\r             if (returnedUpns) {\r \r                 upnArray = returnedUpns;\r \r             }\r             else\r             {\r                 UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:nil message:[[NSString alloc]initWithFormat:@\"Error : %@\", error.localizedDescription] delegate:nil cancelButtonTitle:@\"Retry\" otherButtonTitles:@\"Cancel\", nil];\r \r                 [alertView setDelegate:self];\r \r                 dispatch_async(dispatch_get_main_queue(),^ {\r                     [alertView show];\r                 });\r             }\r \r         }];\r \r }\r ```\r \r ## 编写帮助程序类以访问图形 API\r \r 这是我们应用程序的核心。而其余就是将代码插入 Apple 提供的默认 MVC 模式，你在这里编写的代码会在用户键入内容时查询图形，然后返回该数据。代码如下所示，后面还有其详细说明。\r \r ### 创建新的 Objective C 头文件\r \r 将文件命名为 `GraphAPICaller.h` 并添加以下代码。\r \r ```objc\r @interface GraphAPICaller : NSObject<NSURLConnectionDataDelegate>\r \r +(void) searchUserList:(NSString*)searchString\r        completionBlock:(void (^) (NSMutableArray*, NSError* error))completionBlock;\r \r @end\r ```\r \r 如你所见，指定的方法会获取字符串并返回 completionBlock。你可能已经猜到了，此 completionBlock 提供的对象会在用户搜索时实时填充数据，以此更新表。\r \r ### 新建 Objective C 文件\r 将文件命名为 `GraphAPICaller.m` 并添加以下方法。\r \r ```objc\r +(void) searchUserList:(NSString*)searchString\r        completionBlock:(void (^) (NSMutableArray* Users, NSError* error)) completionBlock\r {\r     if (!loadedApplicationSettings)\r     {\r         [self readApplicationSettings];\r     }\r \r     AppData* data = [AppData getInstance];\r \r     NSString *graphURL = [NSString stringWithFormat:@\"%@%@/users\", data.graphApiUrlString, data.apiversion];\r \r     NXOAuth2AccountStore *store = [NXOAuth2AccountStore sharedStore];\r     NSDictionary* params = [self convertParamsToDictionary:searchString];\r \r     NSArray *accounts = [store accountsWithAccountType:@\"myGraphService\"];\r     [NXOAuth2Request performMethod:@\"GET\"\r                         onResource:[NSURL URLWithString:graphURL]\r                    usingParameters:params\r                        withAccount:accounts[0]\r                sendProgressHandler:^(unsigned long long bytesSend, unsigned long long bytesTotal) {\r                    // e.g., update a progress indicator\r                }\r                    responseHandler:^(NSURLResponse *response, NSData *responseData, NSError *error) {\r                        // Process the response\r                        if (responseData) {\r                            NSError *error;\r                            NSDictionary *dataReturned = [NSJSONSerialization JSONObjectWithData:responseData options:0 error:nil];\r                            NSLog(@\"Graph Response was: %@\", dataReturned);\r \r                        // We can grab the top most JSON node to get our graph data.\r                        NSArray *graphDataArray = [dataReturned objectForKey:@\"value\"];\r \r                        // Don't be thrown off by the key name being \"value\". It really is the name of the\r                        // first node. :-)\r \r                        //each object is a key value pair\r                        NSDictionary *keyValuePairs;\r                        NSMutableArray* Users = [[NSMutableArray alloc]init];\r \r                        for(int i =0; i < graphDataArray.count; i++)\r                        {\r                            keyValuePairs = [graphDataArray objectAtIndex:i];\r \r                            User *s = [[User alloc]init];\r                            s.upn = [keyValuePairs valueForKey:@\"userPrincipalName\"];\r                            s.name =[keyValuePairs valueForKey:@\"displayName\"];\r                            s.mail =[keyValuePairs valueForKey:@\"mail\"];\r                            s.businessPhones =[keyValuePairs valueForKey:@\"businessPhones\"];\r                            s.mobilePhones =[keyValuePairs valueForKey:@\"mobilePhone\"];\r \r                            [Users addObject:s];\r                        }\r \r                        completionBlock(Users, nil);\r                    }\r                    else\r                    {\r                        completionBlock(nil, error);\r                    }\r \r                }];\r }\r ```\r \r 我们会详细解说此方法。\r \r 此代码的核心在于 `NXOAuth2Request`，该方法会采用你已经在 settings.plist 文件中定义的参数。\r \r 第一步是构造正确的图形 API 调用。由于你正在调用 `/users`，因此，你会将它追加到图形 API 资源和版本来进行指定。因为这些都会随着 API 演进而改变，所以合理的做法是将其放在外部设置文件中。\r \r ```objc\r NSString *graphURL = [NSString stringWithFormat:@\"%@%@/users\", data.graphApiUrlString, data.apiversion];\r ```\r \r 接下来，你需要指定也会提供给图形 API 调用的参数。*切记*不要将参数放在资源终结点中，因为系统会在运行时针对所有不符合 URI 的字符擦除该终结点。必须在参数中提供所有查询代码。\r \r ```objc\r NSDictionary* params = [self convertParamsToDictionary:searchString];\r ```\r \r 你可能发现这会调用你尚未编写的 `convertParamsToDictionary` 方法。在文件的最后，让我们立即编写该方法：\r \r ```objc\r +(NSDictionary*) convertParamsToDictionary:(NSString*)searchString\r {\r     NSMutableDictionary* dictionary = [[NSMutableDictionary alloc]init];\r \r         NSString *query = [NSString stringWithFormat:@\"startswith(givenName, '%@')\", searchString];\r \r            [dictionary setValue:query forKey:@\"$filter\"];\r \r     return dictionary;\r }\r ```\r \r 接下来，我们将使用 `NXOAuth2Request` 方法从 API 取回 JSON 格式的数据。\r \r ```objc\r NSArray *accounts = [store accountsWithAccountType:@\"myGraphService\"];\r     [NXOAuth2Request performMethod:@\"GET\"\r                         onResource:[NSURL URLWithString:graphURL]\r                    usingParameters:params\r                        withAccount:accounts[0]\r                sendProgressHandler:^(unsigned long long bytesSend, unsigned long long bytesTotal) {\r                    // e.g., update a progress indicator\r                }\r                    responseHandler:^(NSURLResponse *response, NSData *responseData, NSError *error) {\r                        // Process the response\r                        if (responseData) {\r                            NSError *error;\r                            NSDictionary *dataReturned = [NSJSONSerialization JSONObjectWithData:responseData options:0 error:nil];\r                            NSLog(@\"Graph Response was: %@\", dataReturned);\r \r                            // We can grab the top most JSON node to get our graph data.\r                            NSArray *graphDataArray = [dataReturned objectForKey:@\"value\"];\r ```\r \r 最后，来看看你要如何将数据返回到 MasterViewController。数据会以序列化方式返回，而且该数据必须反序列化并加载到 MainViewController 可使用的对象中。出于此目的，主干具有的 `User.m/h` 文件可以创建 User 对象。你会使用图形中的信息填充该 User 对象。\r \r ```objc\r // We can grab the top most JSON node to get our graph data.\r NSArray *graphDataArray = [dataReturned objectForKey:@\"value\"];\r \r // Don't be thrown off by the key name being \"value\". It really is the name of the\r // first node. :-)\r \r //each object is a key value pair\r NSDictionary *keyValuePairs;\r NSMutableArray* Users = [[NSMutableArray alloc]init];\r \r for(int i =0; i < graphDataArray.count; i++)\r {\r     keyValuePairs = [graphDataArray objectAtIndex:i];\r \r     User *s = [[User alloc]init];\r     s.upn = [keyValuePairs valueForKey:@\"userPrincipalName\"];\r     s.name =[keyValuePairs valueForKey:@\"displayName\"];\r     s.mail =[keyValuePairs valueForKey:@\"mail\"];\r     s.businessPhones =[keyValuePairs valueForKey:@\"businessPhones\"];\r     s.mobilePhones =[keyValuePairs valueForKey:@\"mobilePhone\"];\r \r     [Users addObject:s];\r ```\r \r ## 运行示例\r 如果你使用主干或遵循本演练，那么，你的应用程序现在应该会运行。启动模拟器，然后单击“登录”以使用应用程序。\r \r ## 获取产品的安全更新\r 建议访问[安全技术中心](https://technet.microsoft.com/security/dd252948)并订阅安全公告通知，以便在发生安全事件时获取相关通知。\r \r <!---HONumber=Mooncake_0206_2017-->\r <!--Update_Description: wording update-->"}