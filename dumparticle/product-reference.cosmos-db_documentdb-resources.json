{"Title":"Azure Cosmos DB 资源模型和概念","Description":"了解 Azure Cosmos DB 的数据库、集合、用户自定义函数 (UDF)、文档、管理资源的权限等的分层模型。","Content":"# <a name=\"azure-cosmos-db-hierarchical-resource-model-and-core-concepts\"></a>Azure Cosmos DB 分层资源模型和核心概念\r Azure Cosmos DB 管理的数据库实体被称为**资源**。 每个资源都通过逻辑 URI 进行唯一标识。 可以使用标准 HTTP 谓词、请求/响应标头和状态代码与资源进行交互。 \r \r 通过阅读本文，能够回答以下问题：\r \r * Azure Cosmos DB 资源模型是什么？\r * 对照用户定义的资源，什么是系统定义的资源？\r * 如何对资源进行寻址？\r * 如何使用集合？\r * 如何使用存储过程、触发器和用户自定义函数 (UDF)？\r \r ## <a name=\"hierarchical-resource-model\"></a>分层资源模型\r 如下面的关系图所示，Azure Cosmos DB 分层资源模型由一个数据库帐户下的多组资源构成，每个资源可通过一个稳定的逻辑 URI 进行寻址。 本文将一组资源称为一个**源** 。 \r \r > [!NOTE]\r > Azure Cosmos DB 提供高效的 TCP 协议，该协议在其通信模型中也是 RESTful，可通过 [DocumentDB .NET 客户端 API](documentdb-sdk-dotnet.md) 获得。\r > \r > \r \r ![Azure Cosmos DB 分层资源模型][1]  \r **分层资源模型**   \r \r 若要开始使用资源，必须使用 Azure 订阅[创建数据库帐户](create-documentdb-dotnet.md)。 数据库帐户可以包含的一组**数据库**、每个数据库都包含多个**集合**，每个集合又包含**存储过程、触发器、UDF、文档**及相关**附件**。 数据库也有关联的**用户**，每个用户都有一组**权限**，用于访问集合、存储过程、触发器、UDF、文档或附件。 而数据库、用户、权限和集合就是系统定义的资源，其中已知的架构、文档和附件包含用户定义的任意 JSON 内容。  \r \r | 资源 | 说明 |\r | --- | --- |\r | 数据库帐户 |每个数据库帐户都与一组数据库和一个固定大小的附件 Blob 存储相关联。 可以使用 世纪互联 Azure 订阅创建一个或多个数据库帐户。 有关详细信息，请访问[定价页](https://www.azure.cn/pricing/details/cosmos-db/)。 |\r | 数据库 |数据库是跨集合分区的文档存储的逻辑容器。 它也是一个用户容器。 |\r | 用户 |范围权限的逻辑命名空间。 |\r | 权限 |与用户关联用于访问特定资源的授权令牌。 |\r | 集合 |集合是 JSON 文档和相关联的 JavaScript 应用程序逻辑的容器。 集合是一个计费实体，其中[成本](performance-levels.md)由与集合关联的性能级别确定。 集合可以跨一个或多个分区/服务器，并且能伸缩以处理几乎无限制增长的存储或吞吐量。 |\r | 存储过程 |以 JavaScript 编写的应用程序逻辑，使用集合注册且在数据库引擎中以事务方式执行。 |\r | 触发器 |在插入、替换或删除操作之前或之后执行的以 JavaScript 编写的应用程序逻辑。 |\r | UDF |用 JavaScript 编写的应用程序逻辑。 使用 UDF 可以建立自定义查询运算符模型，从而扩展核心 DocumentDB API 查询语言。 |\r | 文档 |用户定义的（任意）JSON 内容。 默认情况下，不需要定义任何架构，也不需要为所有添加到集合的文档提供辅助索引。 |\r | 附件 |附件是一个特殊文档，包含引用和与外部 blob/媒体相关联的元数据。 开发人员可以选择由 Cosmos DB 来管理 blob 或者使用外部 blob 服务提供程序（OneDrive、Dropbox 等）来存储它。 |\r \r ## <a name=\"system-vs-user-defined-resources\"></a>系统定义的资源对比用户定义的资源\r 资源（例如数据库帐户、数据库、集合、用户、权限、存储过程、触发器和 UDF）都具有固定的架构并且都称为系统资源。 与此相反，文档和附件这一类资源的架构不受限制，这一类资源就是用户定义的资源。 在 Cosmos DB 中，系统和用户定义的资源均由符合标准的 JSON 表示并进行管理。 所有系统或用户定义的资源都具有以下公共属性。\r \r > [!NOTE]\r > 请注意，资源中所有系统生成的属性在其 JSON 表示形式中前面都加有下划线 (_)。\r > \r > \r \r <table>\r     <tbody>\r         <tr>\r             <td valign=\"top\"><p><strong>属性</strong></p></td>\r             <td valign=\"top\"><p><strong>是用户可设置的还是系统生成的？</strong></p></td>\r             <td valign=\"top\"><p><strong>用途</strong></p></td>\r         </tr>\r         <tr>\r             <td valign=\"top\"><p>_rid</p></td>\r             <td valign=\"top\"><p>系统生成的</p></td>\r             <td valign=\"top\"><p>系统生成的、资源的唯一分层标识符</p></td>\r         </tr>\r         <tr>\r             <td valign=\"top\"><p>_etag</p></td>\r             <td valign=\"top\"><p>系统生成的</p></td>\r             <td valign=\"top\"><p>乐观并发控制所需的资源的 ETag</p></td>\r         </tr>\r         <tr>\r             <td valign=\"top\"><p>_ts</p></td>\r             <td valign=\"top\"><p>系统生成的</p></td>\r             <td valign=\"top\"><p>资源上次更新的时间戳</p></td>\r         </tr>\r         <tr>\r             <td valign=\"top\"><p>_self</p></td>\r             <td valign=\"top\"><p>系统生成的</p></td>\r             <td valign=\"top\"><p>资源的唯一可寻址 URI</p></td>\r         </tr>\r         <tr>\r             <td valign=\"top\"><p>id</p></td>\r             <td valign=\"top\"><p>任一个</p></td>\r             <td valign=\"top\"><p>资源的用户定义的唯一名称（具有相同分区键值）。 如果用户未指定 ID，系统会生成 ID</p></td>\r         </tr>\r     </tbody>\r </table>\r \r ### <a name=\"wire-representation-of-resources\"></a>资源的网络表示形式\r Cosmos DB 不强制对 JSON 标准或特殊编码进行任何专有扩展；它使用符合标准的 JSON 文档。  \r \r ### <a name=\"addressing-a-resource\"></a>对资源进行寻址\r 所有资源都可通过 URI 寻址。 资源的 **_self** 属性的值表示资源的相对 URI。 URI 的格式由 /\\<feed\\>{_rid} 路径段构成：  \r \r | _self 的值 | 说明 |\r | --- | --- |\r | /dbs |数据库帐户下的数据库的源 |\r | /dbs/{dbName} |其 ID 与值 {dbName} 匹配的数据库 |\r | /dbs/{dbName}/colls/ |数据库下的集合的源 |\r | /dbs/{dbName}/colls/{collName} |其 ID 与值 {collName} 匹配的集合 |\r | /dbs/{dbName}/colls/{collName}/docs |集合下的文档的源 |\r | /dbs/{dbName}/colls/{collName}/docs/{docId} |其 ID 与值 {doc} 匹配的文档 |\r | /dbs/{dbName}/users/ |数据库下的用户的源 |\r | /dbs/{dbName}/users/{userId} |其 ID 与值 {user} 匹配的用户 |\r | /dbs/{dbName}/users/{userId}/permissions |用户下的权限的源 |\r | /dbs/{dbName}/users/{userId}/permissions/{permissionId} |其 ID 与值 {permission} 匹配的权限 |\r \r 每个资源都具有唯一的用户定义的名称，通过 ID 属性公开。 注意：对于文档，如果用户未指定 ID，支持的 SDK 自动生成文档的唯一 ID。 该 ID 是用户定义的字符串，长度为最多 256 个字符，且在特定父资源的上下文中是唯一的。 \r \r 每个资源还具有系统生成的分层资源标识符（也称为 RID），可通过 _rid 属性获得。 RID 可对给定资源的整个层次结构进行编码，它是一种简便的内部表示形式，用于以分布式方式强制引用完整性。 在数据库帐户内 RID 是唯一的，且由 Cosmos DB 在内部使用，用于进行有效路由，而无需跨分区查找。 _self 和 _rid 属性的值都是交替且规范的资源表示形式。 \r \r REST API 支持资源寻址和由 ID 和 _rid 属性提出的请求路由。\r \r ## <a name=\"database-accounts\"></a>数据库帐户\r 可以使用 Azure 订阅预配一个或多个 Cosmos DB 数据库帐户。\r \r 可以通过 Azure 门户 ([http://portal.azure.cn/](https://portal.azure.cn/)) 创建和管理 Cosmos DB 数据库帐户。 创建和管理数据库帐户需要具有管理访问权限，并且只能在 Azure 订阅下执行。 \r \r ### <a name=\"database-account-properties\"></a>数据库帐户属性\r 作为设置和管理数据库帐户的一部分，可以配置并读取以下属性：  \r \r <table border=\"0\" cellspacing=\"0\" cellpadding=\"0\">\r     <tbody>\r         <tr>\r             <td valign=\"top\"><p><strong>属性名称</strong></p></td>\r             <td valign=\"top\"><p><strong>说明</strong></p></td>\r         </tr>\r         <tr>\r             <td valign=\"top\"><p>一致性策略</p></td>\r             <td valign=\"top\"><p>设置此属性来配置数据库帐户下的所有集合的默认一致性级别。 可以使用 [x-ms-consistency-level] 请求标头重写基于每个请求的一致性级别。 <p><p>请注意，此属性仅适用于<i>用户定义的资源</i>。 所有系统定义的资源都配置为支持具有高度一致性的读取/查询。</p></td>\r         </tr>\r         <tr>\r             <td valign=\"top\"><p>授权密钥</p></td>\r             <td valign=\"top\"><p>这些是提供对所有数据库帐户下的资源的管理访问权限的主要、次要和只读密钥。</p></td>\r         </tr>\r     </tbody>\r </table>\r \r 请注意，除了从 Azure 门户预配、配置和管理数据库帐户，还可以通过使用 [Azure Cosmos DB REST API](https://docs.microsoft.com/rest/api/documentdb/) 和[客户端 SDK](documentdb-sdk-dotnet.md)，以编程方式创建和管理 Cosmos DB 数据库帐户。  \r \r ## <a name=\"databases\"></a>数据库\r Cosmos DB 数据库是一个或多个集合和用户的逻辑容器，如下面的关系图中所示。 可以使用 Cosmos DB 数据库帐户创建任意数量的数据库（取决于产品/服务限制）。  \r \r ![数据库帐户和集合分层模型][2]  \r **数据库是用户和集合的逻辑容器**\r \r 数据库可以包含集合中分布的几乎无限的文档存储。\r \r ### <a name=\"elastic-scale-of-a-azure-cosmos-db-database\"></a>弹性缩放的 Azure Cosmos DB 数据库\r Cosmos DB 数据库默认情况下是弹性的 - SSD 支持的文档存储和预配的吞吐量范围从几个 GB 到几个 PB。 \r \r 与传统的 RDBMS 中的数据库不同，Cosmos DB 中的数据库范围不限于单台计算机。 使用 Cosmos DB，随着应用程序的缩放需求的不断增长，可以创建更多集合和/或数据库。 实际上，在我们内部，各种第一方应用程序已在以使用者规模使用 Azure Cosmos DB，其方式是通过创建非常大的 Azure Cosmos DB 数据库，每个数据库均包含 TB 级文档存储的数千个集合。 可以通过添加或删除集合来扩大或收缩数据库，以满足应用程序的缩放要求。 \r \r 可以根据产品/服务在数据库内创建任意数量的集合。 每个集合都具有 SSD 支持的存储和设置的吞吐量，具体取决于所选的性能层。\r \r Azure Cosmos DB 数据库也是用户的容器。 反过来，用户是一组权限的逻辑命名空间，可提供对集合、文档和附件的精细授权和访问权限。  \r \r 与 Azure Cosmos DB 资源模型中的其他资源一样，可以使用 [REST API](https://docs.microsoft.com/rest/api/documentdb/) 或任一[客户端 SDK](documentdb-sdk-dotnet.md) 轻松创建、替换、删除、读取或枚举数据库。 Azure Cosmos DB 确保数据库资源的元数据读取或查询操作的高度一致性。 自动删除数据库，确保不能访问任何集合或它所包含的用户。   \r \r ## <a name=\"collections\"></a>集合\r Cosmos DB 集合是 JSON 文档的一个容器。 \r \r ### <a name=\"elastic-ssd-backed-document-storage\"></a>SSD 支持的弹性文档存储\r 集合本质上是弹性的 - 添加或删除文档时，它会自动扩展或收缩。 集合是逻辑资源，并且可以跨一个或多个物理分区或服务器。 Cosmos DB 基于存储大小和集合设置的吞吐量确定集合中的分区数。 Cosmos DB 中的每个分区都具有与之关联的 SSD 支持的存储且存储大小固定，可以复制分区以实现高可用性。 分区完全由 Azure Cosmos DB 进行管理，因此无需编写复杂的代码或亲自管理分区。 Cosmos DB 集合在存储和吞吐量方面是**几乎无限制**的。 \r \r ### <a name=\"automatic-indexing-of-collections\"></a>自动编制集合索引\r Azure Cosmos DB 是真正无架构的数据库系统。 无需为 JSON 文档假设或要求任何架构。 将文档添加到集合时，Azure Cosmos DB 会自动编制索引，以供查询时使用。 自动编制文档索引而无需架构或辅助索引是 Azure Cosmos DB 的关键功能，通过写优化、无锁定的日志结构化索引维护技术实现。 Azure Cosmos DB 支持持续大量的极快速写入，同时仍然保障一致的查询。 文档和索引存储都可用于计算每个集合使用的存储。 可以控制存储和性能权衡，这些权衡与通过配置集合的索引编制策略进行的索引相关联。 \r \r ### <a name=\"configuring-the-indexing-policy-of-a-collection\"></a>配置集合的索引编制策略\r 每个集合的索引编制策略都可以用于将性能和存储权衡与编制索引关联起来。 可以使用以下选项进行索引编制配置：  \r \r * 选择是否让集合自动为所有文档编制索引。 默认情况下，为所有文档自动编制索引。 可以选择关闭自动索引，并选择性地只将特定的文档添加到索引中。 反过来，也可以选择只排除特定的文档。 可以通过将集合的 indexingPolicy 上的自动属性设置为 true 或 false，并在插入、替换或删除文档的同时使用 [x-ms-indexingdirective] 请求标头，从而实现此目的。  \r * 选择是否要在索引中包括特定的路径或文档中的模式或从索引中将其排除。 可以通过分别设置集合中的 indexingPolicy 上的 includedPaths 和 excludedPaths 来实现这一点。 还可以配置用于特定路径模式的存储和性能权衡的范围和哈希查询。 \r * 在同步（一致）和异步（延迟）索引更新之间进行选择。 默认情况下，每次在集合中插入、替换或删除文档时同步更新索引。 这个行为让查询能够使用与文档读取相同的一致性级别。 虽然 Azure Cosmos DB 针对写入进行了优化，支持文档持续写入和同步索引维护，并且保障一致的查询，还是可以配置某些集合，使其索引延迟更新。 延迟索引编制可大大提高写入性能，非常适合主要具有大量读取操作的集合的批量引入方案。\r \r 可以通过对集合执行 PUT 更改索引策略。 这可以通过[客户端 SDK](documentdb-sdk-dotnet.md)、[Azure 门户](https://portal.azure.cn)或 [REST API](https://docs.microsoft.com/rest/api/documentdb/) 来实现。\r \r ### <a name=\"querying-a-collection\"></a>查询集合\r 集合中的文档可以具有任意的数据库架构，而无需提前提供任何架构或辅助索引，就可以查询集合中的文档。 可以使用 [Azure Cosmos DB DocumentDB API：SQL 语法引用](../cosmos-db/documentdb-sql-query-reference.md)查询集合，该语法通过基于 JavaScript 的 UDF 提供丰富的分层运算符、关系运算符和空间运算符以及扩展性。 JSON 语法允许将 JSON 文档建模为树，其中标签作为树节点。 DocumentDB API 的自动索引编制技术和 DocumentDB API SQL 方言都利用了此语法。 DocumetDB API 查询语言包含三个主要方面：   \r \r 1. 一小组查询操作，它自然映射到包括分层查询和投影的树结构。 \r 2. 一小部分关系操作，包括组合、筛选、投影、聚合和自联接。 \r 3. 基于纯 JavaScript 且结合 (1) 和 (2) 使用的 UDF。  \r \r Azure Cosmos DB 查询模型尝试在功能、效率和简单性之间取得平衡。 Azure Cosmos DB 数据库引擎在本机上编译和执行 SQL 查询语句。 可以使用 [REST API](https://docs.microsoft.com/rest/api/documentdb/) 或任一[客户端 SDK](documentdb-sdk-dotnet.md) 查询集合。 .NET SDK 附带了 LINQ 提供程序。\r \r > [!TIP]\r > 可以在[查询板块](https://www.documentdb.com/sql/demo)中尝试 DocumentDB API 并对数据集运行 SQL 查询。\r > \r > \r \r ## <a name=\"multi-document-transactions\"></a>多文档事务\r 数据库事务提供了一种安全且可预测的编程模型来处理数据的并发更改。 在 RDBMS 中，编写业务逻辑的传统方法是编写**存储过程**和/或**触发器**，并将它运到用于事务性执行的数据库服务器。 在 RDBMS 中，需要应用程序编程人员来处理这两种不同的编程语言： \r \r * （非事务性）应用程序编程语言（例如 JavaScript、Python、C#、Java 等。）\r * 数据库在本机上执行的事务性编程语言 T-SQL\r \r 由于 Azure Cosmos DB 致力于直接在数据库引擎中使用 JavaScript 和 JSON，因此，在存储过程和触发器方面，它为在集合上直接执行基于 JavaScript 的应用程序逻辑提供了直观编程模型。 这样就可以实现以下两点：\r \r * 有效实现直接在数据库引擎中对 JSON 对象图进行并发控制、恢复、自动编制索引\r * 直接使用 JavaScript 编程语言方面的数据库事务自然表达控制流、变量作用域、异常处理基元的分配和集成\r \r 在集合级别上注册的 JavaScript 逻辑稍后可以在给定集合的文档中发出数据库操作。 Azure Cosmos DB 跨集合中的文档使用快照隔离在周围 ACID 事务中隐式包装基于 JavaScript 的存储过程和触发器。 在其执行过程中，如果 JavaScript 引发异常，则整个事务会被中止。 生成的编程模型非常简单但功能强大。 JavaScript 开发人员在继续使用其自己熟悉的语言构造和库基元的同时，可以获得“持久”的编程模型。   \r \r 直接在与缓冲池位于相同地址空间内的数据库引擎中执行 JavaScript 的能力可实现针对集合的文档的数据库操作的高性能和事务性执行。 此外，Cosmos DB 数据库引擎还致力于针对 JSON 和 JavaScript 消除应用程序和数据库类型系统之间的任何阻抗失配。   \r \r 创建集合之后即可使用 [REST API](https://docs.microsoft.com/rest/api/documentdb/)或任一[客户端 SDK](documentdb-sdk-dotnet.md) 向集合注册存储过程、触发器和 UDF。 注册后，可以引用并执行它们。 请考虑以下完全使用 JavaScript 编写的存储过程，此代码采用两个参数（书名和作者姓名），并创建了一个新文档，对文档进行查询，并更新文档 — 所有这些操作都是在一个隐式的 ACID 事务内完成。 在执行期间的任何时刻，如果引发 JavaScript 异常，则中止整个事务。\r \r     function businessLogic(name, author) {\r         var context = getContext();\r         var collectionManager = context.getCollection();        \r         var collectionLink = collectionManager.getSelfLink()\r \r         // create a new document.\r         collectionManager.createDocument(collectionLink,\r             {id: name, author: author},\r             function(err, documentCreated) {\r                 if(err) throw new Error(err.message);\r \r                 // filter documents by author\r                 var filterQuery = \"SELECT * from root r WHERE r.author = 'George R.'\";\r                 collectionManager.queryDocuments(collectionLink,\r                     filterQuery,\r                     function(err, matchingDocuments) {\r                         if(err) throw new Error(err.message);\r \r                         context.getResponse().setBody(matchingDocuments.length);\r \r                         // Replace the author name for all documents that satisfied the query.\r                         for (var i = 0; i < matchingDocuments.length; i++) {\r                             matchingDocuments[i].author = \"George R. R. Martin\";\r                             // we don't need to execute a callback because they are in parallel\r                             collectionManager.replaceDocument(matchingDocuments[i]._self,\r                                 matchingDocuments[i]);   \r                         }\r                     })\r             })\r     };\r \r 客户端可以将以上 JavaScript 逻辑“运送”到数据库，以便通过 HTTP POST 进行事务性执行。 有关使用 HTTP 方法的详细信息，请参阅[与 Azure Cosmos DB 资源进行 RESTful 交互](https://msdn.microsoft.com/library/azure/mt622086.aspx)。 \r \r     client.createStoredProcedureAsync(collection._self, {id: \"CRUDProc\", body: businessLogic})\r        .then(function(createdStoredProcedure) {\r             return client.executeStoredProcedureAsync(createdStoredProcedure.resource._self,\r                 \"NoSQL Distilled\",\r                 \"Martin Fowler\");\r         })\r         .then(function(result) {\r             console.log(result);\r         },\r         function(error) {\r             console.log(error);\r         });\r \r 请注意，由于数据库本身能够识别 JSON 和 JavaScript，因此没有任何类型系统不匹配，也不需要“OR 映射”或代码生成幻数。   \r \r 存储过程和触发器与集合和集合中的文档通过一个明确定义的对象模型进行交互，该模型可公开当前集合的上下文。  \r \r 可以使用 [REST API](https://docs.microsoft.com/rest/api/documentdb/) 或任一[客户端 SDK](documentdb-sdk-dotnet.md) 轻松创建、删除、读取或枚举 DocumentDB API 中的集合。 DocumentDB API 始终为集合元数据的读取或查询操作提供高度一致性。 自动删除数据库，确保不能访问任何文档、附件、存储过程、触发器和其中包含的 UDF。   \r \r ## <a name=\"stored-procedures-triggers-and-user-defined-functions-udf\"></a>存储过程、触发器和用户自定义函数 (UDF)\r 如前一节中所述，可以编写应用程序逻辑以直接在数据库引擎内部的某个事务中运行。 应用程序逻辑可以完全用 JavaScript 编写，并且可以作为存储过程、触发器或 UDF 来建模。 存储过程或触发器内的 JavaScript 代码可以插入、替换、删除、读取或查询集合中的文档。 但是，UDF 中的 JavaScript 却无法插入、替换或删除文档。 UDF 可以枚举查询的结果集的文档，并生成另一个结果集。 对于多租户，Azure Cosmos DB 将强制实施严格的基于保留项的资源调控。 每个存储过程、触发器或 UDF 都可以获取固定量的操作系统资源来完成其工作。 此外，存储过程、触发器或 UDF 不能针对外部 JavaScript 库进行链接，并且如果它们超出了分配给它们的资源预算，则被列入方块列表。 可以通过使用 REST API 为集合注册存储过程、触发器或 UDF，也可以取消注册。  注册时将预编译存储过程、触发器或 UDF，并将其存储为字节代码，以供以后执行。 下一节说明如何使用 Azure Cosmos DB JavaScript SDK 注册、执行和注销存储过程、触发器和 UDF。 JavaScript SDK 是一个比 [REST API](https://docs.microsoft.com/rest/api/documentdb/) 更简单的包装器。 \r \r ### <a name=\"registering-a-stored-procedure\"></a>注册存储过程\r 注册存储过程会通过 HTTP POST 在集合上创建新的存储过程资源。  \r \r     var storedProc = {\r         id: \"validateAndCreate\",\r         body: function (documentToCreate) {\r             documentToCreate.id = documentToCreate.id.toUpperCase();\r \r             var collectionManager = getContext().getCollection();\r             collectionManager.createDocument(collectionManager.getSelfLink(),\r                 documentToCreate,\r                 function(err, documentCreated) {\r                     if(err) throw new Error('Error while creating document: ' + err.message;\r                     getContext().getResponse().setBody('success - created ' + \r                             documentCreated.name);\r                 });\r         }\r     };\r \r     client.createStoredProcedureAsync(collection._self, storedProc)\r         .then(function (createdStoredProcedure) {\r             console.log(\"Successfully created stored procedure\");\r         }, function(error) {\r             console.log(\"Error\");\r         });\r \r ### <a name=\"executing-a-stored-procedure\"></a>执行存储过程\r 执行存储过程是针对现有的存储过程资源通过将参数传递给请求正文中的过程发出 HTTP POST 而实现的。\r \r     var inputDocument = {id : \"document1\", author: \"G. G. Marquez\"};\r     client.executeStoredProcedureAsync(createdStoredProcedure.resource._self, inputDocument)\r         .then(function(executionResult) {\r             assert.equal(executionResult, \"success - created DOCUMENT1\");\r         }, function(error) {\r             console.log(\"Error\");\r         });\r \r ### <a name=\"unregistering-a-stored-procedure\"></a>取消注册存储过程\r 取消注册存储过程只需针对现有的存储过程资源发出 HTTP DELETE 即可完成。   \r \r     client.deleteStoredProcedureAsync(createdStoredProcedure.resource._self)\r         .then(function (response) {\r             return;\r         }, function(error) {\r             console.log(\"Error\");\r         });\r \r ### <a name=\"registering-a-pre-trigger\"></a>注册预触发器\r 注册触发器会通过 HTTP POST 在集合上创建新的触发器资源。 可以指定触发器是前触发还是后触发，也可以指定与之关联的操作类型（例如创建、替换、删除或全部）。   \r \r     var preTrigger = {\r         id: \"upperCaseId\",\r         body: function() {\r                 var item = getContext().getRequest().getBody();\r                 item.id = item.id.toUpperCase();\r                 getContext().getRequest().setBody(item);\r         },\r         triggerType: TriggerType.Pre,\r         triggerOperation: TriggerOperation.All\r     }\r \r     client.createTriggerAsync(collection._self, preTrigger)\r         .then(function (createdPreTrigger) {\r             console.log(\"Successfully created trigger\");\r         }, function(error) {\r             console.log(\"Error\");\r         });\r \r ### <a name=\"executing-a-pre-trigger\"></a>执行前触发\r 触发器的执行是通过在通过请求标头发出文档资源的 POST/PUT/DELETE 请求时指定现有触发器名称完成的。  \r \r     client.createDocumentAsync(collection._self, { id: \"doc1\", key: \"Love in the Time of Cholera\" }, { preTriggerInclude: \"upperCaseId\" })\r         .then(function(createdDocument) {\r             assert.equal(createdDocument.resource.id, \"DOC1\");\r         }, function(error) {\r             console.log(\"Error\");\r         });\r \r ### <a name=\"unregistering-a-pre-trigger\"></a>取消注册前触发\r 取消注册触发器只需针对现有的触发器资源发出 HTTP DELETE 即可完成。  \r \r     client.deleteTriggerAsync(createdPreTrigger._self);\r         .then(function(response) {\r             return;\r         }, function(error) {\r             console.log(\"Error\");\r         });\r \r ### <a name=\"registering-a-udf\"></a>注册 UDF\r 注册 UDF 会通过 HTTP POST 在集合上创建新的UDF 资源。  \r \r     var udf = { \r         id: \"mathSqrt\",\r         body: function(number) {\r                 return Math.sqrt(number);\r         },\r     };\r     client.createUserDefinedFunctionAsync(collection._self, udf)\r         .then(function (createdUdf) {\r             console.log(\"Successfully created stored procedure\");\r         }, function(error) {\r             console.log(\"Error\");\r         });\r \r ### <a name=\"executing-a-udf-as-part-of-the-query\"></a>执行作为查询的一部分的 UDF\r 可以将 UDF 指定为 SQL 查询的一部分，将其用作一种扩展 [DocumentDB API 的核心 SQL 查询语言](../cosmos-db/documentdb-sql-query-reference.md)的方法。\r \r     var filterQuery = \"SELECT udf.mathSqrt(r.Age) AS sqrtAge FROM root r WHERE r.FirstName='John'\";\r     client.queryDocuments(collection._self, filterQuery).toArrayAsync();\r         .then(function(queryResponse) {\r             var queryResponseDocuments = queryResponse.feed;\r         }, function(error) {\r             console.log(\"Error\");\r         });\r \r ### <a name=\"unregistering-a-udf\"></a>取消注册 UDF\r 取消注册 UDF 只需针对现有的 UDF 资源发出 HTTP DELETE 即可完成。  \r \r     client.deleteUserDefinedFunctionAsync(createdUdf._self)\r         .then(function(response) {\r             return;\r         }, function(error) {\r             console.log(\"Error\");\r         });\r \r 尽管上面的代码段演示了通过 [JavaScript SDK](https://github.com/Azure/azure-documentdb-js) 注册 (POST)、取消注册 (PUT)、读取/列出 (GET) 和执行 (POST)，但也可以使用 [REST API](https://docs.microsoft.com/rest/api/documentdb/) 或其他[客户端 SDK](documentdb-sdk-dotnet.md)。 \r \r ## <a name=\"documents\"></a>文档\r 可以插入、替换、删除、读取、枚举和查询集合中的任意 JSON 文档。 Azure Cosmos DB 不强制要求任何架构，并且对集合中的文档进行查询也不需要辅助索引的支持。 文档的最大大小为 2 MB。   \r \r 作为一种真正的开放式数据库服务，Azure Cosmos DB 不创建任何专用的数据类型（例如日期时间）或用于 JSON 文档的特定编码。 请注意，Azure Cosmos DB 不需要任何特殊的 JSON 约定来对各种文档之间的关系进行编码；Azure Cosmos DB 的 SQL 语法提供非常强大的分层和关系查询运算符以查询和投影文档，而无需任何特殊的注释，也不需要使用可分辨属性对文档间的关系进行编码。  \r \r 与所有其他资源一样，可以使用 REST API 或任一 [客户端 SDK](documentdb-sdk-dotnet.md)轻松创建、替换、删除、读取、枚举和查询文档。 删除文档立即释放与所有嵌套附件相对应的配额。 文档的读取一致性级别遵守数据库帐户中的一致性策略。 可以根据应用程序的数据一致性要求在每个请求中重写此策略。 查询文档时，读取一致性遵循集合上的索引编制模式设置。 对于“一致性”，将遵循帐户的一致性策略。 \r \r ## <a name=\"attachments-and-media\"></a>附件和媒体\r Azure Cosmos DB 可通过 Azure Cosmos DB 存储二进制 Blob/媒体（每个帐户最大 2 GB），或将其存储到远程媒体存储中。 对于被称为附件的特殊文档而言，它还可以用于表示媒体的元数据。 Azure Cosmos DB 中的附件是引用存储在其他位置的媒体/Blob 的特殊 (JSON) 文档。 附件只是捕获存储在远程媒体存储中的媒体的元数据（例如位置、作者等）的特殊文档。 \r \r 以一款社交阅读应用程序为例，它使用 Azure Cosmos DB 来存储某位用户的电子书的墨迹注释和相关元数据（包括评论、热点、书签、评分、喜欢/不喜欢，等等）。   \r \r * 此电子书本身的内容存储在媒体存储中：既可以是作为 Azure Cosmos DB 数据库帐户一部分的媒体存储，也可以是远程媒体存储。 \r * 应用程序可能会将每个用户的元数据存储为不同的文档 - 例如，Joe 的 book1 元数据存储在由 /colls/joe/docs/book1 引用的文档中。 \r * 指向用户的特定书的内容页面的附件存储在对应的文档中，如 /colls/joe/docs/book1/chapter1、/colls/joe/docs/book1/chapter2，等等。 \r \r 请注意，上面列出的示例使用易于理解的 ID 来表示资源层次结构。 通过唯一的资源 ID 和 REST API 访问资源。 \r \r 对于由 Azure Cosmos DB 管理的媒体，附件的 _media 属性将通过 URI 引用媒体。 Azure Cosmos DB 确保在删除所有未完成的引用时对媒体进行垃圾回收。 上传新的媒体并填充 _media 以指向新添加的媒体时，Azure Cosmos DB 会自动生成附件。 如果选择将媒体存储在由自己管理的远程 blob 存储区（例如 OneDrive、Azure 存储、DropBox 等），仍可以使用附件以引用媒体。 在这种情况下，将自行创建附件并填充其 _media 属性。   \r \r 至于所有其他资源，可以创建、替换、删除、读取、枚举附件，也可以轻松地使用 REST API 或任一客户端 SDK 查询附件。 至于文档，附件的读取一致性级别遵守数据库帐户中的一致性策略。 可以根据应用程序的数据一致性要求在每个请求中重写此策略。 查询附件时，读取一致性遵循集合上的索引编制模式设置。 对于“一致性”，将遵循帐户的一致性策略。 \r \r ## <a name=\"users\"></a>用户\r Azure Cosmos DB 用户是指对权限进行分组的逻辑命名空间。 Azure Cosmos DB 用户可能与标识管理系统或预定义应用程序角色中的用户相对应。 对于 Azure Cosmos DB，用户只是抽象地用来表示在数据库下对一组权限进行分组。   \r \r 为了在应用程序中实现多租户，可在 Azure Cosmos DB 中创建与实际用户或应用程序租户对应的用户。 然后，用户可以为对应针对多个集合、文档、附件等内容的访问控制的给定用户创建权限。   \r \r 由于应用程序需要随用户增加而进行扩展，因此可以采用多种方法对数据进行分片。 可以按照如下方法对每个用户进行建模：   \r \r * 将每个用户映射到数据库。\r * 将每个用户映射到集合。 \r * 将对应于多个用户的文档转到专用的集合。 \r * 将对应于多个用户的文档转到一组集合。   \r \r 无论所选择的特定分片策略是什么，都可以将实际用户建模为 Azure Cosmos DB 数据库中的用户并将细化的权限和每个用户关联起来。  \r \r ![用户集合][3]  \r **分片策略和为用户建模**\r \r 和所有其他资源一样，可以使用 REST API 或任一客户端 SDK 轻松创建、替换、删除、读取或枚举 Azure Cosmos DB 中的用户。 Azure Cosmos DB 始终为用户资源的元数据读取或查询操作提供高度一致性。 需要指出的是，自动删除用户可确保不能访问其中所包含的任何权限。 即使 Azure Cosmos DB 在后台将权限配额作为已删除用户的一部分进行了回收，也仍然可以立即恢复并使用已删除的权限。  \r \r ## <a name=\"permissions\"></a>权限\r 由于数据库帐户、数据库、用户和权限等资源需要管理权限，因此从访问控制方面而言，它们都被视为 *管理* 资源。 另一方面，集合、文档、附件、存储过程、触发器和 UDF 等资源都只局限在某个给定的数据库内，因此被视为*应用程序资源*。 授权模型定义了两种类型的*访问密钥*：*主密钥*和*资源密钥*以对应这两种类型的资源和访问它们的角色（即管理员和用户）。 主密钥是数据库帐户的一部分，并且提供给设置数据库帐户的开发人员（或管理员）。 此主密钥具有管理员语义，因为它可用于向管理和应用程序资源授予访问权限。 与此相反，资源密钥是允许访问*特定*应用程序资源的精细访问密钥。 因此，它会为特定资源（例如集合、文档、附件、存储过程、触发器或 UDF）捕获数据库的用户和用户权限之间的关系。   \r \r 获取资源密钥的唯一方法是通过创建给定用户下的权限资源。 请注意，若要创建或检索某个权限，主密钥必须呈现在授权标头中。 权限资源与资源及其访问权限和用户密切相关。 创建权限资源后，用户只需要提供关联的资源密钥就能获得相关资源的访问权限。 因此，可以将资源密钥看作权限资源的逻辑和紧凑表示形式。  \r \r 就像所有其他资源一样，可以使用 REST API 或任一客户端 SDK 轻松创建、替换、删除、读取或枚举 Azure Cosmos DB 中的权限。 Azure Cosmos DB 始终为权限元数据的读取或查询操作提供高度一致性。 \r \r ## <a name=\"next-steps\"></a>后续步骤\r 有关通过 HTTP 命令使用资源的详细信息，请参阅[与 Azure Cosmos DB 资源的 RESTful 交互](https://msdn.microsoft.com/library/azure/mt622086.aspx)。\r \r [1]: media/documentdb-resources/resources1.png\r [2]: media/documentdb-resources/resources2.png\r [3]: media/documentdb-resources/resources3.png\r \r <!--Update_Description: wording update -->"}