{"Title":"通过自定义 MES 预设执行高级编码","Description":"本主题说明如何通过自定义 Media Encoder Standard 任务预设执行高级编码。","Content":"# <a name=\"perform-advanced-encoding-by-customizing-mes-presets\"></a>通过自定义 MES 预设执行高级编码 \r \r ## <a name=\"overview\"></a>概述\r \r 本主题演示如何自定义 Media Encoder Standard 预设。 [通过使用自定义预设的 Media Encoder Standard 进行编码](media-services-custom-mes-presets-with-dotnet.md)主题演示如何使用 .NET 创建编码任务和执行此任务的作业。 自定义预设后，请将自定义预设提供给编码任务。 \r \r >[!NOTE]\r >如果使用的是 XML 预设，请务必保留元素顺序，如下面的 XML 示例所示（例如，KeyFrameInterval 应在 SceneChangeDetection 前面）。\r >\r \r 本主题演示了执行以下编码任务的自定义预设。\r \r ## <a name=\"support-for-relative-sizes\"></a>支持相对大小\r \r 生成缩略图时，不需始终以像素为单位指定输出宽度和高度。 你可以以百分比的方式在 [1%, …, 100%] 范围内对其进行指定。\r \r ### <a name=\"json-preset\"></a>JSON 预设\r     \"Width\": \"100%\",\r     \"Height\": \"100%\"\r \r ### <a name=\"xml-preset\"></a>XML 预设\r     <Width>100%</Width>\r     <Height>100%</Height>\r \r ## <a id=\"thumbnails\"></a>生成缩略图\r \r 本部分说明如何自定义生成缩略图的预设。 下面定义的预设包含有关如何对文件编码的信息，以及生成缩略图所需的信息。 可使用[此部分](media-services-mes-presets-overview.md)所述的任何 MES 预设，并添加生成缩略图的代码。  \r \r > [!NOTE]\r > 如果要编码为单比特率视频，以下预设中的 **SceneChangeDetection** 设置只能设置为 true。 如果要编码为多比特率视频并将 **SceneChangeDetection** 设置为 true，则编码器返回错误。  \r >\r >\r \r 有关架构的信息，请参阅[此](media-services-mes-schema.md)主题。\r \r 请务必仔细阅读 [注意事项](#considerations) 部分。\r \r ### <a id=\"json\"></a>JSON 预设\r     {\r       \"Version\": 1.0,\r       \"Codecs\": [\r         {\r           \"KeyFrameInterval\": \"00:00:02\",\r           \"SceneChangeDetection\": \"true\",\r           \"H264Layers\": [\r             {\r               \"Profile\": \"Auto\",\r               \"Level\": \"auto\",\r               \"Bitrate\": 4500,\r               \"MaxBitrate\": 4500,\r               \"BufferWindow\": \"00:00:05\",\r               \"Width\": 1280,\r               \"Height\": 720,\r               \"ReferenceFrames\": 3,\r               \"EntropyMode\": \"Cabac\",\r               \"AdaptiveBFrame\": true,\r               \"Type\": \"H264Layer\",\r               \"FrameRate\": \"0/1\"\r \r             }\r           ],\r           \"Type\": \"H264Video\"\r         },\r         {\r           \"JpgLayers\": [\r             {\r               \"Quality\": 90,\r               \"Type\": \"JpgLayer\",\r               \"Width\": 640,\r               \"Height\": 360\r             }\r           ],\r           \"Start\": \"{Best}\",\r           \"Type\": \"JpgImage\"\r         },\r         {\r           \"PngLayers\": [\r             {\r               \"Type\": \"PngLayer\",\r               \"Width\": 640,\r               \"Height\": 360,\r             }\r           ],\r           \"Start\": \"00:00:01\",\r           \"Step\": \"00:00:10\",\r           \"Range\": \"00:00:58\",\r           \"Type\": \"PngImage\"\r         },\r         {\r           \"BmpLayers\": [\r             {\r               \"Type\": \"BmpLayer\",\r               \"Width\": 640,\r               \"Height\": 360\r             }\r           ],\r           \"Start\": \"10%\",\r           \"Step\": \"10%\",\r           \"Range\": \"90%\",\r           \"Type\": \"BmpImage\"\r         },\r         {\r           \"Channels\": 2,\r           \"SamplingRate\": 48000,\r           \"Bitrate\": 128,\r           \"Type\": \"AACAudio\"\r         }\r       ],\r       \"Outputs\": [\r         {\r           \"FileName\": \"{Basename}_{Index}{Extension}\",\r           \"Format\": {\r             \"Type\": \"JpgFormat\"\r           }\r         },\r         {\r           \"FileName\": \"{Basename}_{Index}{Extension}\",\r           \"Format\": {\r             \"Type\": \"PngFormat\"\r           }\r         },\r         {\r           \"FileName\": \"{Basename}_{Index}{Extension}\",\r           \"Format\": {\r             \"Type\": \"BmpFormat\"\r           }\r         },\r         {\r           \"FileName\": \"{Basename}_{Width}x{Height}_{VideoBitrate}.mp4\",\r           \"Format\": {\r             \"Type\": \"MP4Format\"\r           }\r         }\r       ]\r     }\r \r ### <a id=\"xml\"></a>XML 预设\r     <?xml version=\"1.0\" encoding=\"utf-16\"?>\r     <Preset xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" Version=\"1.0\" xmlns=\"http://www.windowsazure.com/media/encoding/Preset/2014/03\">\r       <Encoding>\r         <H264Video>\r           <KeyFrameInterval>00:00:02</KeyFrameInterval>\r           <SceneChangeDetection>true</SceneChangeDetection>\r           <H264Layers>\r             <H264Layer>\r               <Bitrate>4500</Bitrate>\r               <Width>1280</Width>\r               <Height>720</Height>\r               <FrameRate>0/1</FrameRate>\r               <Profile>Auto</Profile>\r               <Level>auto</Level>\r               <BFrames>3</BFrames>\r               <ReferenceFrames>3</ReferenceFrames>\r               <Slices>0</Slices>\r               <AdaptiveBFrame>true</AdaptiveBFrame>\r               <EntropyMode>Cabac</EntropyMode>\r               <BufferWindow>00:00:05</BufferWindow>\r               <MaxBitrate>4500</MaxBitrate>\r             </H264Layer>\r           </H264Layers>\r         </H264Video>\r         <AACAudio>\r           <Profile>AACLC</Profile>\r           <Channels>2</Channels>\r           <SamplingRate>48000</SamplingRate>\r           <Bitrate>128</Bitrate>\r         </AACAudio>\r         <JpgImage Start=\"{Best}\">\r           <JpgLayers>\r             <JpgLayer>\r               <Width>640</Width>\r               <Height>360</Height>\r               <Quality>90</Quality>\r             </JpgLayer>\r           </JpgLayers>\r         </JpgImage>\r         <BmpImage Start=\"10%\" Step=\"10%\" Range=\"90%\">\r           <BmpLayers>\r             <BmpLayer>\r               <Width>640</Width>\r               <Height>360</Height>\r             </BmpLayer>\r           </BmpLayers>\r         </BmpImage>\r         <PngImage Start=\"00:00:01\" Step=\"00:00:10\" Range=\"00:00:58\">\r           <PngLayers>\r             <PngLayer>\r               <Width>640</Width>\r               <Height>360</Height>\r             </PngLayer>\r           </PngLayers>\r         </PngImage>\r       </Encoding>\r       <Outputs>\r         <Output FileName=\"{Basename}_{Width}x{Height}_{VideoBitrate}.mp4\">\r           <MP4Format />\r         </Output>\r         <Output FileName=\"{Basename}_{Index}{Extension}\">\r           <JpgFormat />\r         </Output>\r         <Output FileName=\"{Basename}_{Index}{Extension}\">\r           <BmpFormat />\r         </Output>\r         <Output FileName=\"{Basename}_{Index}{Extension}\">\r           <PngFormat />\r         </Output>\r       </Outputs>\r     </Preset>\r \r ### <a name=\"considerations\"></a>注意事项\r \r 请注意以下事项：\r \r * 为 Start/Step/Range 使用的显式时间戳假设输入源的长度至少为 1 分钟。\r * Jpg/Png/BmpImage 元素包含 Start、Step 和 Range 字符串属性 - 这些属性解释如下：\r \r   * 帧数（如果为非负整数），例如：\"Start\": \"120\"；\r   * 相对于源持续时间（如果以 % 为后缀表示），例如：\"Start\": \"15%\"，或者\r   * 时间戳（如果以 HH:MM:SS... 格式表示），例如，\"Start\" : \"00:01:00\"\r \r     可以随意混搭使用表示法。\r \r     此外，Start 还支持特殊的宏 {Best}，它会尝试确定第一个“有意义”的内容帧。注意：（Start 设置为 {Best} 时，将忽略 Step 与 Range）\r   * 默认值：Start:{Best}\r * 需要显式提供每个图像格式的输出格式：Jpg/Png/BmpFormat。 提供时，MES 会将 JpgVideo 与 JpgFormat 进行匹配，依此类推。 OutputFormat 引入了新的图像编解码器特定宏 {Index}，需要为图像输出格式提供该宏一次（且只需一次）。\r \r ## <a id=\"trim_video\"></a>剪裁视频（剪切）\r 本部分说明如何修改编码器预设，以裁剪或修剪其输入为所谓的夹层文件或按需文件的输入视频。 也可以使用编码器来剪切或剪裁从实时流捕获或存档的资产 - [此博客](https://azure.microsoft.com/blog/sub-clipping-and-live-archive-extraction-with-media-encoder-standard/)提供了详细信息。\r \r 若要裁剪视频，可以使用[此部分](media-services-mes-presets-overview.md)所述的任何 MES 预设，并修改“Sources”元素（如下所示）。 StartTime 的值需与输入视频的绝对时间戳匹配。 例如，如果输入视频第一帧的时间戳为 12:00:10.000，则 StartTime 应大于或等于 12:00:10.000。 在以下示例中，假设输入视频的起始时间戳为零。 **Sources** 应位于预设的开始处。\r \r ### <a id=\"json\"></a>JSON 预设\r     {\r       \"Version\": 1.0,\r       \"Sources\": [\r         {\r           \"StartTime\": \"00:00:04\",\r           \"Duration\": \"00:00:16\"\r         }\r       ],\r       \"Codecs\": [\r         {\r           \"KeyFrameInterval\": \"00:00:02\",\r           \"StretchMode\": \"AutoSize\",\r           \"H264Layers\": [\r             {\r               \"Profile\": \"Auto\",\r               \"Level\": \"auto\",\r               \"Bitrate\": 3400,\r               \"MaxBitrate\": 3400,\r               \"BufferWindow\": \"00:00:05\",\r               \"Width\": 1280,\r               \"Height\": 720,\r               \"BFrames\": 3,\r               \"ReferenceFrames\": 3,\r               \"AdaptiveBFrame\": true,\r               \"Type\": \"H264Layer\",\r               \"FrameRate\": \"0/1\"\r             },\r             {\r               \"Profile\": \"Auto\",\r               \"Level\": \"auto\",\r               \"Bitrate\": 2250,\r               \"MaxBitrate\": 2250,\r               \"BufferWindow\": \"00:00:05\",\r               \"Width\": 960,\r               \"Height\": 540,\r               \"BFrames\": 3,\r               \"ReferenceFrames\": 3,\r               \"AdaptiveBFrame\": true,\r               \"Type\": \"H264Layer\",\r               \"FrameRate\": \"0/1\"\r             },\r             {\r               \"Profile\": \"Auto\",\r               \"Level\": \"auto\",\r               \"Bitrate\": 1500,\r               \"MaxBitrate\": 1500,\r               \"BufferWindow\": \"00:00:05\",\r               \"Width\": 960,\r               \"Height\": 540,\r               \"BFrames\": 3,\r               \"ReferenceFrames\": 3,\r               \"AdaptiveBFrame\": true,\r               \"Type\": \"H264Layer\",\r               \"FrameRate\": \"0/1\"\r             },\r             {\r               \"Profile\": \"Auto\",\r               \"Level\": \"auto\",\r               \"Bitrate\": 1000,\r               \"MaxBitrate\": 1000,\r               \"BufferWindow\": \"00:00:05\",\r               \"Width\": 640,\r               \"Height\": 360,\r               \"BFrames\": 3,\r               \"ReferenceFrames\": 3,\r               \"AdaptiveBFrame\": true,\r               \"Type\": \"H264Layer\",\r               \"FrameRate\": \"0/1\"\r             },\r             {\r               \"Profile\": \"Auto\",\r               \"Level\": \"auto\",\r               \"Bitrate\": 650,\r               \"MaxBitrate\": 650,\r               \"BufferWindow\": \"00:00:05\",\r               \"Width\": 640,\r               \"Height\": 360,\r               \"BFrames\": 3,\r               \"ReferenceFrames\": 3,\r               \"AdaptiveBFrame\": true,\r               \"Type\": \"H264Layer\",\r               \"FrameRate\": \"0/1\"\r             },\r             {\r               \"Profile\": \"Auto\",\r               \"Level\": \"auto\",\r               \"Bitrate\": 400,\r               \"MaxBitrate\": 400,\r               \"BufferWindow\": \"00:00:05\",\r               \"Width\": 320,\r               \"Height\": 180,\r               \"BFrames\": 3,\r               \"ReferenceFrames\": 3,\r               \"AdaptiveBFrame\": true,\r               \"Type\": \"H264Layer\",\r               \"FrameRate\": \"0/1\"\r             }\r           ],\r           \"Type\": \"H264Video\"\r         },\r         {\r           \"Profile\": \"AACLC\",\r           \"Channels\": 2,\r           \"SamplingRate\": 48000,\r           \"Bitrate\": 128,\r           \"Type\": \"AACAudio\"\r         }\r       ],\r       \"Outputs\": [\r         {\r           \"FileName\": \"{Basename}_{Width}x{Height}_{VideoBitrate}.mp4\",\r           \"Format\": {\r             \"Type\": \"MP4Format\"\r           }\r         }\r       ]\r     }\r \r ### <a name=\"xml-preset\"></a>XML 预设\r 若要剪裁视频，可以使用[此处](media-services-mes-presets-overview.md)所述的任何 MES 预设，并修改“Sources”元素（如下所示）。\r \r     <?xml version=\"1.0\" encoding=\"utf-16\"?>\r     <Preset xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" Version=\"1.0\" xmlns=\"http://www.windowsazure.com/media/encoding/Preset/2014/03\">\r       <Sources>\r         <Source StartTime=\"PT4S\" Duration=\"PT14S\"/>\r       </Sources>\r       <Encoding>\r         <H264Video>\r           <KeyFrameInterval>00:00:02</KeyFrameInterval>\r           <H264Layers>\r             <H264Layer>\r               <Bitrate>3400</Bitrate>\r               <Width>1280</Width>\r               <Height>720</Height>\r               <FrameRate>0/1</FrameRate>\r               <Profile>Auto</Profile>\r               <Level>auto</Level>\r               <BFrames>3</BFrames>\r               <ReferenceFrames>3</ReferenceFrames>\r               <Slices>0</Slices>\r               <AdaptiveBFrame>true</AdaptiveBFrame>\r               <EntropyMode>Cabac</EntropyMode>\r               <BufferWindow>00:00:05</BufferWindow>\r               <MaxBitrate>3400</MaxBitrate>\r             </H264Layer>\r             <H264Layer>\r               <Bitrate>2250</Bitrate>\r               <Width>960</Width>\r               <Height>540</Height>\r               <FrameRate>0/1</FrameRate>\r               <Profile>Auto</Profile>\r               <Level>auto</Level>\r               <BFrames>3</BFrames>\r               <ReferenceFrames>3</ReferenceFrames>\r               <Slices>0</Slices>\r               <AdaptiveBFrame>true</AdaptiveBFrame>\r               <EntropyMode>Cabac</EntropyMode>\r               <BufferWindow>00:00:05</BufferWindow>\r               <MaxBitrate>2250</MaxBitrate>\r             </H264Layer>\r             <H264Layer>\r               <Bitrate>1500</Bitrate>\r               <Width>960</Width>\r               <Height>540</Height>\r               <FrameRate>0/1</FrameRate>\r               <Profile>Auto</Profile>\r               <Level>auto</Level>\r               <BFrames>3</BFrames>\r               <ReferenceFrames>3</ReferenceFrames>\r               <Slices>0</Slices>\r               <AdaptiveBFrame>true</AdaptiveBFrame>\r               <EntropyMode>Cabac</EntropyMode>\r               <BufferWindow>00:00:05</BufferWindow>\r               <MaxBitrate>1500</MaxBitrate>\r             </H264Layer>\r             <H264Layer>\r               <Bitrate>1000</Bitrate>\r               <Width>640</Width>\r               <Height>360</Height>\r               <FrameRate>0/1</FrameRate>\r               <Profile>Auto</Profile>\r               <Level>auto</Level>\r               <BFrames>3</BFrames>\r               <ReferenceFrames>3</ReferenceFrames>\r               <Slices>0</Slices>\r               <AdaptiveBFrame>true</AdaptiveBFrame>\r               <EntropyMode>Cabac</EntropyMode>\r               <BufferWindow>00:00:05</BufferWindow>\r               <MaxBitrate>1000</MaxBitrate>\r             </H264Layer>\r             <H264Layer>\r               <Bitrate>650</Bitrate>\r               <Width>640</Width>\r               <Height>360</Height>\r               <FrameRate>0/1</FrameRate>\r               <Profile>Auto</Profile>\r               <Level>auto</Level>\r               <BFrames>3</BFrames>\r               <ReferenceFrames>3</ReferenceFrames>\r               <Slices>0</Slices>\r               <AdaptiveBFrame>true</AdaptiveBFrame>\r               <EntropyMode>Cabac</EntropyMode>\r               <BufferWindow>00:00:05</BufferWindow>\r               <MaxBitrate>650</MaxBitrate>\r             </H264Layer>\r             <H264Layer>\r               <Bitrate>400</Bitrate>\r               <Width>320</Width>\r               <Height>180</Height>\r               <FrameRate>0/1</FrameRate>\r               <Profile>Auto</Profile>\r               <Level>auto</Level>\r               <BFrames>3</BFrames>\r               <ReferenceFrames>3</ReferenceFrames>\r               <Slices>0</Slices>\r               <AdaptiveBFrame>true</AdaptiveBFrame>\r               <EntropyMode>Cabac</EntropyMode>\r               <BufferWindow>00:00:05</BufferWindow>\r               <MaxBitrate>400</MaxBitrate>\r             </H264Layer>\r           </H264Layers>\r         </H264Video>\r         <AACAudio>\r           <Profile>AACLC</Profile>\r           <Channels>2</Channels>\r           <SamplingRate>48000</SamplingRate>\r           <Bitrate>128</Bitrate>\r         </AACAudio>\r       </Encoding>\r       <Outputs>\r         <Output FileName=\"{Basename}_{Width}x{Height}_{VideoBitrate}.mp4\">\r           <MP4Format />\r         </Output>\r       </Outputs>\r     </Preset>\r \r ## <a id=\"overlay\"></a>创建覆盖层\r \r Media Encoder Standard 允许在现有视频上覆盖图像。 目前支持以下格式：png、jpg、gif 和 bmp。 下面定义的预设是视频覆盖层的基本示例。\r \r 除了定义预设文件外，还必须让媒体服务知道资产中的哪个文件是覆盖层图像，哪个文件是要在其上覆盖图像的源视频。 视频文件必须是 **主** 文件。\r \r 如果要使用 .NET，请将以下两个函数添加到[此主题](media-services-custom-mes-presets-with-dotnet.md#encoding_with_dotnet) 中定义的 .NET 示例。 “UploadMediaFilesFromFolder”函数从文件夹上传文件（例如 BigBuckBunny.mp4 和 Image001.png），并将 mp4 文件设置为资产中的主文件。 “EncodeWithOverlay”函数使用传递给它的自定义预设文件（例如，下面的预设）来创建编码任务。\r \r     static public IAsset UploadMediaFilesFromFolder(string folderPath)\r     {\r         IAsset asset = _context.Assets.CreateFromFolder(folderPath, AssetCreationOptions.None);\r \r         foreach (var af in asset.AssetFiles)\r         {\r             // The following code assumes \r             // you have an input folder with one MP4 and one overlay image file.\r             if (af.Name.Contains(\".mp4\"))\r                 af.IsPrimary = true;\r             else\r                 af.IsPrimary = false;\r \r             af.Update();\r         }\r \r         return asset;\r     }\r \r     static public IAsset EncodeWithOverlay(IAsset assetSource, string customPresetFileName)\r     {\r         // Declare a new job.\r         IJob job = _context.Jobs.Create(\"Media Encoder Standard Job\");\r         // Get a media processor reference, and pass to it the name of the \r         // processor to use for the specific task.\r         IMediaProcessor processor = GetLatestMediaProcessorByName(\"Media Encoder Standard\");\r \r         // Load the XML (or JSON) from the local file.\r         string configuration = File.ReadAllText(customPresetFileName);\r \r         // Create a task\r         ITask task = job.Tasks.AddNew(\"Media Encoder Standard encoding task\",\r             processor,\r             configuration,\r             TaskOptions.None);\r \r         // Specify the input assets to be encoded.\r         // This asset contains a source file and an overlay file.\r         task.InputAssets.Add(assetSource);\r \r         // Add an output asset to contain the results of the job. \r         task.OutputAssets.AddNew(\"Output asset\",\r             AssetCreationOptions.None);\r \r         job.StateChanged += new EventHandler<JobStateChangedEventArgs>(JobStateChanged);\r         job.Submit();\r         job.GetExecutionProgressTask(CancellationToken.None).Wait();\r \r         return job.OutputMediaAssets[0];\r     }\r \r > [!NOTE]\r > 当前限制：\r >\r > 不支持覆盖层不透明度设置。\r >\r > 源视频文件和覆盖层图像文件必须位于相同的资产中，而且视频文件需要设置为此资产中的主文件。\r >\r >\r \r ### <a name=\"json-preset\"></a>JSON 预设\r     {\r       \"Version\": 1.0,\r       \"Sources\": [\r         {\r           \"Streams\": [],\r           \"Filters\": {\r             \"VideoOverlay\": {\r               \"Position\": {\r                 \"X\": 100,\r                 \"Y\": 100,\r                 \"Width\": 100,\r                 \"Height\": 50\r               },\r               \"AudioGainLevel\": 0.0,\r               \"MediaParams\": [\r                 {\r                   \"OverlayLoopCount\": 1\r                 },\r                 {\r                   \"IsOverlay\": true,\r                   \"OverlayLoopCount\": 1,\r                   \"InputLoop\": true\r                 }\r               ],\r               \"Source\": \"Image001.png\",\r               \"Clip\": {\r                 \"Duration\": \"00:00:05\"\r               },\r               \"FadeInDuration\": {\r                 \"Duration\": \"00:00:01\"\r               },\r               \"FadeOutDuration\": {\r                 \"StartTime\": \"00:00:03\",\r                 \"Duration\": \"00:00:04\"\r               }\r             }\r           },\r           \"Pad\": true\r         }\r       ],\r       \"Codecs\": [\r         {\r           \"KeyFrameInterval\": \"00:00:02\",\r           \"H264Layers\": [\r             {\r               \"Profile\": \"Auto\",\r               \"Level\": \"auto\",\r               \"Bitrate\": 1045,\r               \"MaxBitrate\": 1045,\r               \"BufferWindow\": \"00:00:05\",\r               \"ReferenceFrames\": 3,\r               \"EntropyMode\": \"Cavlc\",\r               \"AdaptiveBFrame\": true,\r               \"Type\": \"H264Layer\",\r               \"Width\": \"640\",\r               \"Height\": \"360\",\r               \"FrameRate\": \"0/1\"\r             }\r           ],\r           \"Type\": \"H264Video\"\r         },\r         {\r           \"Type\": \"CopyAudio\"\r         }\r       ],\r       \"Outputs\": [\r         {\r           \"FileName\": \"{Basename}{Extension}\",\r           \"Format\": {\r             \"Type\": \"MP4Format\"\r           }\r         }\r       ]\r     }\r \r ### <a name=\"xml-preset\"></a>XML 预设\r     <?xml version=\"1.0\" encoding=\"utf-16\"?>\r     <Preset xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" Version=\"1.0\" xmlns=\"http://www.windowsazure.com/media/encoding/Preset/2014/03\">\r       <Sources>\r         <Source>\r           <Streams />\r           <Filters>\r             <VideoOverlay>\r               <Source>Image001.png</Source>\r               <Clip Duration=\"PT5S\" />\r               <FadeInDuration Duration=\"PT1S\" />\r               <FadeOutDuration StartTime=\"PT3S\" Duration=\"PT4S\" />\r               <Position X=\"100\" Y=\"100\" Width=\"100\" Height=\"50\" />\r               <Opacity>0</Opacity>\r               <AudioGainLevel>0</AudioGainLevel>\r               <MediaParams>\r                 <MediaParam>\r                   <IsOverlay>false</IsOverlay>\r                   <OverlayLoopCount>1</OverlayLoopCount>\r                   <InputLoop>false</InputLoop>\r                 </MediaParam>\r                 <MediaParam>\r                   <IsOverlay>true</IsOverlay>\r                   <OverlayLoopCount>1</OverlayLoopCount>\r                   <InputLoop>true</InputLoop>\r                 </MediaParam>\r               </MediaParams>\r             </VideoOverlay>\r           </Filters>\r           <Pad>true</Pad>\r         </Source>\r       </Sources>\r       <Encoding>\r         <H264Video>\r           <KeyFrameInterval>00:00:02</KeyFrameInterval>\r           <H264Layers>\r             <H264Layer>\r               <Bitrate>1045</Bitrate>\r               <Width>640</Width>\r               <Height>360</Height>\r               <FrameRate>0/1</FrameRate>\r               <Profile>Auto</Profile>\r               <Level>auto</Level>\r               <BFrames>0</BFrames>\r               <ReferenceFrames>3</ReferenceFrames>\r               <Slices>0</Slices>\r               <AdaptiveBFrame>true</AdaptiveBFrame>\r               <EntropyMode>Cavlc</EntropyMode>\r               <BufferWindow>00:00:05</BufferWindow>\r               <MaxBitrate>1045</MaxBitrate>\r             </H264Layer>\r           </H264Layers>\r         </H264Video>\r         <CopyAudio />\r       </Encoding>\r       <Outputs>\r         <Output FileName=\"{Basename}{Extension}\">\r           <MP4Format />\r         </Output>\r       </Outputs>\r     </Preset>\r \r ## <a id=\"silent_audio\"></a>在输入不包含音频时插入静音曲目\r 默认情况下，如果要向编码器发送仅包含视频而不包含音频的输入，则输出资产包含仅有视频数据的文件。 某些播放器可能无法处理此类输出流。 对于这种方案，可以使用此设置来强制编码器将静音曲目添加到输出。\r \r 若要强制编码器在输入不包含音频时生成包含静音曲目的资产，请指定“InsertSilenceIfNoAudio”值。\r \r 可使用[此部分](media-services-mes-presets-overview.md)中所述的任何 MES 预设，并进行以下修改：\r \r ### <a name=\"json-preset\"></a>JSON 预设\r     {\r       \"Channels\": 2,\r       \"SamplingRate\": 44100,\r       \"Bitrate\": 96,\r       \"Type\": \"AACAudio\",\r       \"Condition\": \"InsertSilenceIfNoAudio\"\r     }\r \r ### <a name=\"xml-preset\"></a>XML 预设\r     <AACAudio Condition=\"InsertSilenceIfNoAudio\">\r       <Channels>2</Channels>\r       <SamplingRate>44100</SamplingRate>\r       <Bitrate>96</Bitrate>\r     </AACAudio>\r \r ## <a id=\"deinterlacing\"></a>禁用自动取消隔行扫描\r 如果客户想要将隔行扫描内容自动取消隔行扫描，不需要执行任何操作。 当自动取消隔行扫描打开（默认设置）时，MES 将自动检测隔行扫描帧，并且只将标记为隔行扫描的帧取消隔行扫描。\r \r 可以关闭自动取消隔行扫描。 但不建议这样做。\r \r ### <a name=\"json-preset\"></a>JSON 预设\r     \"Sources\": [\r     {\r      \"Filters\": {\r         \"Deinterlace\": {\r           \"Mode\": \"Off\"\r         }\r       },\r     }\r     ]\r \r ### <a name=\"xml-preset\"></a>XML 预设\r     <Sources>\r     <Source>\r       <Filters>\r         <Deinterlace>\r           <Mode>Off</Mode>\r         </Deinterlace>\r       </Filters>\r     </Source>\r     </Sources>\r \r ## <a id=\"audio_only\"></a>仅音频预设\r 本部分介绍两个仅音频 MES 预设：AAC 音频和 AAC 优质音频。\r \r ### <a name=\"aac-audio\"></a>AAC 音频\r     {\r       \"Version\": 1.0,\r       \"Codecs\": [\r         {\r           \"Profile\": \"AACLC\",\r           \"Channels\": 2,\r           \"SamplingRate\": 48000,\r           \"Bitrate\": 128,\r           \"Type\": \"AACAudio\"\r         }\r       ],\r       \"Outputs\": [\r         {\r           \"FileName\": \"{Basename}_AAC_{AudioBitrate}.mp4\",\r           \"Format\": {\r             \"Type\": \"MP4Format\"\r           }\r         }\r       ]\r     }\r \r ### <a name=\"aac-good-quality-audio\"></a>AAC 优质音频\r     {\r       \"Version\": 1.0,\r       \"Codecs\": [\r         {\r           \"Profile\": \"AACLC\",\r           \"Channels\": 2,\r           \"SamplingRate\": 48000,\r           \"Bitrate\": 192,\r           \"Type\": \"AACAudio\"\r         }\r       ],\r       \"Outputs\": [\r         {\r           \"FileName\": \"{Basename}_AAC_{AudioBitrate}.mp4\",\r           \"Format\": {\r             \"Type\": \"MP4Format\"\r           }\r         }\r       ]\r     }\r \r ## <a id=\"concatenate\"></a>连接两个或更多个视频文件\r \r 以下示例演示如何生成预设来连接两个或更多个视频文件。 最常见的应用场景：你想在主视频中添加标题或预告片。 预期使用场合：当一起编辑的视频文件共享属性（视频分辨率、帧速率、音频曲目计数等）时。 务必注意不要混合使用不同帧速率或不同音轨数的视频。\r \r >[!NOTE]\r >串联功能的当前设计要求输入视频剪辑在分辨率、帧率等方面保持一致。 \r \r ### <a name=\"requirements-and-considerations\"></a>要求和注意事项\r \r * 输入视频应只有一个音轨。\r * 输入视频的帧速率应该都相同。\r * 必须将视频上传到不同的资产，并将视频设置为每个资产中的主文件。\r * 需要知道视频的持续时间。\r * 以下预设示例假设所有输入视频的起始时间戳都为零。 如果视频具有不同的起始时间戳（通常是实时存档的情况），则需要修改 StartTime 值。\r * JSON 预设会显式引用输入资产的 AssetID 值。\r * 示例代码假设 JSON 预设已保存到本地文件（例如“C:\\supportFiles\\preset.json”）。 同时假设已通过上传两个视频文件创建了两个资产，并且你知道生成的 AssetID 值。\r * 代码片段和 JSON 预设显示连接两个视频文件的示例。 可以将其扩展至两个以上的视频，方法是：\r \r   1. 重复调用 task. InputAssets.Add() 以便依次添加更多视频。\r   2. 通过按相同顺序添加更多条目，对 JSON 中的“Sources”元素进行相应编辑。\r \r ### <a name=\"net-code\"></a>.NET 代码\r \r     IAsset asset1 = _context.Assets.Where(asset => asset.Id == \"nb:cid:UUID:606db602-efd7-4436-97b4-c0b867ba195b\").FirstOrDefault();\r     IAsset asset2 = _context.Assets.Where(asset => asset.Id == \"nb:cid:UUID:a7e2b90f-0565-4a94-87fe-0a9fa07b9c7e\").FirstOrDefault();\r \r     // Declare a new job.\r     IJob job = _context.Jobs.Create(\"Media Encoder Standard Job for Concatenating Videos\");\r     // Get a media processor reference, and pass to it the name of the\r     // processor to use for the specific task.\r     IMediaProcessor processor = GetLatestMediaProcessorByName(\"Media Encoder Standard\");\r \r     // Load the XML (or JSON) from the local file.\r     string configuration = File.ReadAllText(@\"c:\\supportFiles\\preset.json\");\r \r     // Create a task\r     ITask task = job.Tasks.AddNew(\"Media Encoder Standard encoding task\",\r         processor,\r         configuration,\r         TaskOptions.None);\r \r     // Specify the input videos to be concatenated (in order).\r     task.InputAssets.Add(asset1);\r     task.InputAssets.Add(asset2);\r     // Add an output asset to contain the results of the job.\r     // This output is specified as AssetCreationOptions.None, which\r     // means the output asset is not encrypted.\r     task.OutputAssets.AddNew(\"Output asset\",\r         AssetCreationOptions.None);\r \r     job.StateChanged += new EventHandler<JobStateChangedEventArgs>(JobStateChanged);\r     job.Submit();\r     job.GetExecutionProgressTask(CancellationToken.None).Wait();\r \r ### <a name=\"json-preset\"></a>JSON 预设\r \r 使用想连接的资产 ID 以及每个视频的适当时间段，更新自定义预设。\r \r     {\r       \"Version\": 1.0,\r       \"Sources\": [\r         {\r           \"AssetID\": \"606db602-efd7-4436-97b4-c0b867ba195b\",\r           \"StartTime\": \"00:00:01\",\r           \"Duration\": \"00:00:15\"\r         },\r         {\r           \"AssetID\": \"a7e2b90f-0565-4a94-87fe-0a9fa07b9c7e\",\r           \"StartTime\": \"00:00:02\",\r           \"Duration\": \"00:00:05\"\r         }\r       ],\r       \"Codecs\": [\r         {\r           \"KeyFrameInterval\": \"00:00:02\",\r           \"SceneChangeDetection\": true,\r           \"H264Layers\": [\r             {\r               \"Level\": \"auto\",\r               \"Bitrate\": 1800,\r               \"MaxBitrate\": 1800,\r               \"BufferWindow\": \"00:00:05\",\r               \"BFrames\": 3,\r               \"ReferenceFrames\": 3,\r               \"AdaptiveBFrame\": true,\r               \"Type\": \"H264Layer\",\r               \"Width\": \"640\",\r               \"Height\": \"360\",\r               \"FrameRate\": \"0/1\"\r             }\r           ],\r           \"Type\": \"H264Video\"\r         },\r         {\r           \"Channels\": 2,\r           \"SamplingRate\": 48000,\r           \"Bitrate\": 128,\r           \"Type\": \"AACAudio\"\r         }\r       ],\r       \"Outputs\": [\r         {\r           \"FileName\": \"{Basename}_{Width}x{Height}_{VideoBitrate}.mp4\",\r           \"Format\": {\r             \"Type\": \"MP4Format\"\r           }\r         }\r       ]\r     }\r \r ## <a id=\"crop\"></a>使用 Media Encoder Standard 裁剪视频\r 请参阅[使用 Media Encoder Standard 剪辑视频](media-services-crop-video.md)主题。\r \r ## <a id=\"no_video\"></a>在输入不包含视频时插入视频轨迹\r \r 默认情况下，如果要向编码器发送仅包含音频而不包含视频的输入，则输出资产包含仅有音频数据的文件。 某些播放器（包括 Azure 媒体播放器）（请参阅[此处](https://feedback.azure.com/forums/169396-azure-media-services/suggestions/8082468-audio-only-scenarios)）可能无法处理这样的流。 在该方案中，可使用此设置来强制编码器将单色视频轨道添加到输出。\r \r > [!NOTE]\r > 强制编码器插入输出视频轨迹会增加输出资产的大小，从而增加编码任务的相关成本。 应运行测试来验证此成本增加对每月费用的影响不大。\r >\r \r ### <a name=\"inserting-video-at-only-the-lowest-bitrate\"></a>仅以最低比特率插入视频\r \r 假设要使用多比特率编码预设（如 [“H264 多比特率 720p”](media-services-mes-preset-h264-multiple-bitrate-720p.md)）对整个输入目录进行编码以实现流式处理，且输入目录中混合了视频文件和仅音频文件。 在此方案中，如果输入不包含视频，用户可能想要强制编码器仅以最低比特率插入单色视频轨迹，而不是按每个输出比特率插入视频。 为此，需要使用“InsertBlackIfNoVideoBottomLayerOnly”标志。\r \r 可使用[此部分](media-services-mes-presets-overview.md)中所述的任何 MES 预设，并进行以下修改：\r \r #### <a name=\"json-preset\"></a>JSON 预设\r     {\r           \"KeyFrameInterval\": \"00:00:02\",\r           \"StretchMode\": \"AutoSize\",\r           \"Condition\": \"InsertBlackIfNoVideoBottomLayerOnly\",\r           \"H264Layers\": [\r           …\r           ]\r     }\r \r #### <a name=\"xml-preset\"></a>XML 预设\r \r 使用 XML 时，请使用 Condition=\"InsertBlackIfNoVideoBottomLayerOnly\" 作为“H264Video”元素的属性，并使用 Condition=\"InsertSilenceIfNoAudio\" 作为“AACAudio”的属性。\r \r ```\r . . .\r <Encoding>\r   <H264Video Condition=\"InsertBlackIfNoVideoBottomLayerOnly\">\r     <KeyFrameInterval>00:00:02</KeyFrameInterval>\r     <SceneChangeDetection>true</SceneChangeDetection>\r     <StretchMode>AutoSize</StretchMode>\r     <H264Layers>\r       <H264Layer>\r         . . .\r       </H264Layer>\r     </H264Layers>\r     <Chapters />\r   </H264Video>\r   <AACAudio Condition=\"InsertSilenceIfNoAudio\">\r     <Profile>AACLC</Profile>\r     <Channels>2</Channels>\r     <SamplingRate>48000</SamplingRate>\r     <Bitrate>128</Bitrate>\r   </AACAudio>\r </Encoding>\r . . .\r ```\r \r ### <a name=\"inserting-video-at-all-output-bitrates\"></a>按所有输出比特率插入视频\r 假设要使用多比特率编码预设（如 [“H264 多比特率 720p”](media-services-mes-preset-H264-Multiple-Bitrate-720p.md)）对整个输入目录进行编码以实现流式处理，且输入目录中混合了视频文件和仅音频文件。 在此方案中，如果输入不包含视频，用户可能想要强制编码器按所有输出比特率插入单色视频轨迹。 这可确保对于视频轨迹和音频曲目的数目，输出资产都是同源的。 要实现此目的，需要指定“InsertBlackIfNoVideo”标志。\r \r 可使用[此部分](media-services-mes-presets-overview.md)中所述的任何 MES 预设，并进行以下修改：\r \r #### <a name=\"json-preset\"></a>JSON 预设\r     {\r           \"KeyFrameInterval\": \"00:00:02\",\r           \"StretchMode\": \"AutoSize\",\r           \"Condition\": \"InsertBlackIfNoVideo\",\r           \"H264Layers\": [\r           …\r           ]\r     }\r \r #### <a name=\"xml-preset\"></a>XML 预设\r \r 使用 XML 时，请使用 Condition=\"InsertBlackIfNoVideo\" 作为“H264Video”元素的属性，并使用 Condition=\"InsertSilenceIfNoAudio\" 作为“AACAudio”的属性。\r \r ```\r . . .\r <Encoding>\r   <H264Video Condition=\"InsertBlackIfNoVideo\">\r     <KeyFrameInterval>00:00:02</KeyFrameInterval>\r     <SceneChangeDetection>true</SceneChangeDetection>\r     <StretchMode>AutoSize</StretchMode>\r     <H264Layers>\r       <H264Layer>\r         . . .\r       </H264Layer>\r     </H264Layers>\r     <Chapters />\r   </H264Video>\r   <AACAudio Condition=\"InsertSilenceIfNoAudio\">\r     <Profile>AACLC</Profile>\r     <Channels>2</Channels>\r     <SamplingRate>48000</SamplingRate>\r     <Bitrate>128</Bitrate>\r   </AACAudio>\r </Encoding>\r . . .  \r ```\r \r ## <a id=\"rotate_video\"></a>旋转视频\r [Media Encoder Standard](media-services-dotnet-encode-with-media-encoder-standard.md) 支持旋转的角度为 0/90/180/270。 默认行为是“自动”，即尝试在传入的视频文件中检测旋转元数据并对其进行补偿。 将以下“Sources”元素包含在[此部分](media-services-mes-presets-overview.md)定义的其中一个预设中：\r \r ### <a name=\"json-preset\"></a>JSON 预设\r     \"Sources\": [\r     {\r       \"Streams\": [],\r       \"Filters\": {\r         \"Rotation\": \"90\"\r       }\r     }\r     ],\r     \"Codecs\": [\r \r     ...\r ### <a name=\"xml-preset\"></a>XML 预设\r     <Sources>\r            <Source>\r           <Streams />\r           <Filters>\r             <Rotation>90</Rotation>\r           </Filters>\r         </Source>\r     </Sources>\r \r 另请参阅[此](media-services-mes-schema.md#PreserveResolutionAfterRotation)主题，了解有关触发旋转补偿时，编码器如何解释预设中的宽度和高度设置的信息。\r \r 可以使用值“0”指示编码器忽略输入视频中的旋转元数据（如果存在）。\r \r ## <a name=\"see-also\"></a>另请参阅\r [媒体服务编码概述](media-services-encode-asset.md)\r "}