{"Title":"Azure 服务总线中继消息 REST 代码示例","Description":"Azure 服务总线中继消息 REST 代码示例","Content":"\r # Azure 服务总线中继消息 REST 代码示例\r \r 本示例代码演示如何生成简单的服务总线主机应用程序来公开基于 REST 的接口，使得 on-premises 应用能被外部网络通过 HTTP 进行访问，并要求客户端必须提供正确 Token 以提高安全性。\r \r 本示例代码使用 Windows Communication Foundation (WCF) REST 编程模型在服务总线上构建 REST 服务。有关详细信息，请参阅 WCF 文档中的 [WCF REST 编程模型](https://msdn.microsoft.com/zh-cn/library/bb412169.aspx)和[设计和实现服务](https://msdn.microsoft.com/zh-cn/library/ms729746.aspx)。\r \r ## 服务端\r \r ### On-premises WCF REST 服务\r \r 简单的定义一个获取随机字符串的 WCF REST 服务。\r \r     [ServiceContract]\r     public interface IDataService\r     {\r         [OperationContract, WebGet(ResponseFormat = WebMessageFormat.Json)]\r         string GetRandomString();\r     }\r     public class DataService : IDataService\r     {\r         const string CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\r         const int LENGTH = 10;\r \r         public string GetRandomString()\r         {\r             var random = new Random();\r             return new string(Enumerable.Repeat(CHARS, LENGTH).Select(s => s[random.Next(s.Length)]).ToArray());\r         }\r     }\r \r ### 服务总线中继服务\r \r 这里将通过配置文件的方式来托管服务，也就是将前面创建的服务用服务总线中继出去。\r \r     // TODO: Update the values\r     var serviceBusNamespace = \"your service bus namespace\";\r     var relayServicePath = \"data\"; // you can define your own value\r \r     // For China Azure\r     var dataSvcUriString = $\"https://{serviceBusNamespace}.servicebus.chinacloudapi.cn/{relayServicePath}\";\r \r     var webServiceHost = new WebServiceHost(typeof(DataService), new Uri(dataSvcUriString));\r     webServiceHost.Open();\r \r     Console.WriteLine(\"Invoke service via Service Bus Relay with following request (require sas token): \");\r     Console.WriteLine($\"{dataSvcUriString}/GetRandomString\");\r     Console.WriteLine();\r     Console.WriteLine(\"Press [Enter] to exit\");\r     Console.ReadLine();\r \r     webServiceHost.Close();\r \r ### 配置文件\r \r 其中 webHttpRelayBinding 的 security 设置成 relayClientAuthenticationType=\"RelayAccessToken\"，这样就要求客户端提供正确 Token 才能进行访问。\r \r     <system.serviceModel>\r     <bindings>\r         <webHttpRelayBinding>\r         <binding name=\"default\">\r             <security relayClientAuthenticationType=\"RelayAccessToken\"/>\r         </binding>\r         </webHttpRelayBinding>\r     </bindings>\r     <behaviors>\r     <endpointBehaviors>\r         <behavior name=\"sbTokenProvider\">\r         <transportClientEndpointBehavior>\r             <tokenProvider>\r             <sharedAccessSignature keyName=\"service bus key name\" key=\"your key\" />\r             </tokenProvider>\r         </transportClientEndpointBehavior>\r         </behavior>\r     </endpointBehaviors>\r     </behaviors>\r     <services>\r         <service name=\"Service.DataService\">\r         <endpoint name=\"sbRelayEndpoint\"\r                     address=\"\"\r                     binding=\"webHttpRelayBinding\"\r                     bindingConfiguration=\"default\"\r                     behaviorConfiguration=\"sbTokenProvider\"\r                     contract=\"Service.IDataService\" />\r         </service>\r     </services>\r     <extensions>\r         <!—Install Microsoft Service Bus NuGet package will automatically add needed all extensions -->\r         ……\r     </extensions>\r     </system.serviceModel>\r \r ## 客户端\r \r 客户端使用一个简单 ASP.NET MVC 程序并发布到 Azure Web App。\r \r ### 生成服务总线的 Token\r \r     private string createToken(string resourceUri, string keyName, string key)\r     {\r         TimeSpan sinceEpoch = DateTime.UtcNow - new DateTime(1970, 1, 1);\r         var week = 60 * 60 * 24 * 7;\r         var expiry = Convert.ToString((int)sinceEpoch.TotalSeconds + week);\r         string stringToSign = HttpUtility.UrlEncode(resourceUri) + \"\\n\" + expiry;\r         HMACSHA256 hmac = new HMACSHA256(Encoding.UTF8.GetBytes(key));\r         var signature = Convert.ToBase64String(hmac.ComputeHash(Encoding.UTF8.GetBytes(stringToSign)));\r         var sasToken = String.Format(CultureInfo.InvariantCulture,\r             \"SharedAccessSignature sr={0}&sig={1}&se={2}&skn={3}\",\r             HttpUtility.UrlEncode(resourceUri),\r             HttpUtility.UrlEncode(signature),\r             expiry,\r             keyName);\r         return sasToken;\r     }\r \r ## 添加 Token 作为头部\r \r 使用 HttpClient 调用通过服务总线中继出来的服务，并添加生成的 Token 作为头部。\r \r     public ActionResult Index()\r     {\r         // TODO: update the values\r         var serviceBusNamespace = \"your service bus namespace\";\r         var relayServicePath = \"data\"; // you can define your own value\r         var keyName = \"your service bus key name\";\r         var key = \"your service bus key value\";\r \r         var resourceUriString = $\"https://{serviceBusNamespace}.servicebus.chinacloudapi.cn/{relayServicePath}\";\r         var token = createToken(resourceUriString, keyName, key);\r \r         try\r         {\r             using (var httpClient = new HttpClient())\r             {\r                 httpClient.DefaultRequestHeaders.Add(\"Authorization\", token);\r \r                 var requestUri = $\"{resourceUriString}/GetRandomString\";\r \r                 using (var response = httpClient.GetAsync(requestUri).Result)\r                 {\r                     response.EnsureSuccessStatusCode();\r                     var result = response.Content.ReadAsStringAsync().Result;\r                     ViewBag.Message = result;\r                 }\r             }\r         }\r         catch (Exception ex)\r         {\r             ViewBag.Message = $\"Exception happened: {ex.Message}\";\r         }\r \r     return View();\r     }\r \r [AZURE.NOTE]直接把服务总线的 Key 提供在客户端是不安全的，可以另外提供一个专门生成 Token 的服务，这样客户端就可以需要的时候就从那个服务获取 Token，而不是直接拿到 Key 自己生成。\r \r ## 运行结果\r \r ### 服务端启动\r \r ![service](./media/aog-sample-code-service-bus-relay-rest-api/service.png)\r \r ### 客户端调用\r \r ![client](./media/aog-sample-code-service-bus-relay-rest-api/client.png)\r \r ## 示例代码\r \r [WcfRelayDemo.WebApi](https://github.com/wacn/AOG-CodeSample/tree/master/ServiceBus/CSharp/WcfRelayDemo.WebApi)"}