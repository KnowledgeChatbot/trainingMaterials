{"Title":"优化 SQL 数据仓库的事务","Description":"在 Azure SQL 数据仓库中编写有效事务更新的最佳做法指南","Content":"\r # 优化 SQL 数据仓库的事务\r 本文介绍了如何在尽量降低长时间回退风险的情况下优化事务性代码的性能。\r \r ## 事务和日志记录\r 事务是关系数据库引擎的一个重要组成部分。SQL 数据仓库在数据修改期间使用事务。这些事务可以是显式或隐式。单个 `INSERT`、`UPDATE` 和 `DELETE` 语句都是隐式事务示例。显式事务由开发人员使用 `BEGIN TRAN`、`COMMIT TRAN` 或 `ROLLBACK TRAN` 进行显式编写，且通常用于多个修改语句需要绑定在单个原子单元的时候。\r \r Azure SQL 数据仓库使用事务日志将更改提交到数据库。每个分布区都具有其自己的事务日志。事务日志写入都是自动的。无需任何配置。尽管此过程可保证写入，但它确在系统中引入一项开销。编写事务性高效的代码，可以尽量减少这种影响。事务性高效的代码大致分为两类。\r \r - 尽可能利用最少日志记录构造\r - 使用限定范围的批来处理数据，避免单数形式的长时运行事务\r - 对于给定分区的大型修改，采用分区切换模式\r \r ## 最少日志记录与完整日志记录\r \r 完整记录的操作使用事务日志来跟踪每个行更改，而最少记录的操作只跟踪扩展分配和元数据更改。因此最少日志记录只涉及记录故障或显式请求事件 (`ROLLBACK TRAN`) 中回退事务所需的信息 。由于事务日志中跟踪的信息少得多，因此最少记录操作的执行性能优于同样大小的完整记录操作。此外，事务日志中写入较少，因此生成的日志数据量也更少，并且 I/O 更高效。\r \r 事务安全限制仅适用于完整记录的操作。\r \r >[!NOTE]\r > 最少记录的操作可以参与显式事务。分配结构中的所有更改都被跟踪，因此实现回滚最少记录的操作变得可能。务必理解，更改是采用“最少”记录的方式进行记录，而不是未记录。\r \r ## 最少记录的操作\r 以下操作可以实现最少记录：\r \r * CREATE TABLE AS SELECT ([CTAS][CTAS])\r * INSERT..SELECT\r * CREATE INDEX\r * ALTER INDEX REBUILD\r * DROP INDEX\r * TRUNCATE TABLE\r * DROP TABLE\r * ALTER TABLE SWITCH PARTITION\r \r <!--\r - MERGE\r - UPDATE on LOB Types .WRITE\r - SELECT..INTO\r -->\r \r >[!NOTE]\r > 内部数据移动操作（如 `BROADCAST` 和 `SHUFFLE`不受事务安全限制影响。\r \r ## 带批量加载的最少日志记录\r \r `CTAS` 和 `INSERT...SELECT` 都是批量加载操作。但两者都受目标表定义影响，并且取决于加载方案。下表说明了批量操作要使用完整记录方式还是最少记录方式进行记录：\r \r | 主索引 | 加载方案 | 日志记录模式 |\r | --- | --- | --- |\r | 堆 |任意 |**最少** |\r | 聚集索引 |空目标表 |**最少** |\r | 聚集索引 |加载的行不与目标中现有页面重叠 |**最少** |\r | 聚集索引 |加载的行与目标中现有页面重叠 |完整 |\r | 聚集列存储索引 |批大小 >= 102,400/每分区对齐的分布区 |**最少** |\r | 聚集列存储索引 |批大小 < 102,400/每分区对齐的分布区 |完整 |\r \r 值得注意的是，任何更新辅助或非聚集索引的写入都将始终是完整记录的操作。\r \r > [!IMPORTANT]\r > SQL 数据仓库具有 60 个分布区。因此，假设所有行均匀分布且处于单个分区中，你的批在写入到聚集列存储索引时将需有 6,144,000 行（或更多）要按最少记录的方式记入日志。如果对表进行分区且正插入的行跨越分区边界，则每个分区边界都需 6,144,000 行，假定数据分布很均匀。每个分布区的每个分区各自必须超过 102,400 行的阈值，从而使插入以最少记录的方式记录到分布区中。\r \r 将数据加载到含聚集索引的非空表通常可以包含完整记录和最少记录的行的组合。聚集索引是页面的平衡树 (b-tree)。如果正写入的页面已包含其他事务中的行，则这些写入操作会被完整记录。但如果该页面为空，则写入到该页面将会按最少记录的方式记录。\r \r ## 优化删除\r `DELETE` 是完整记录的操作。如果需要删除表或分区中的大量数据，`SELECT` 要保留的数据通常更有意义，其可作为最少记录的操作来运行。为此，可使用 [CTAS][CTAS] 创建新表。创建完以后，可通过 [RENAME][RENAME] 操作使用新创建的表将旧表交换出来。\r \r ```sql\r -- Delete all sales transactions for Promotions except PromotionKey 2.\r \r --Step 01. Create a new table select only the records we want to kep (PromotionKey 2)\r CREATE TABLE [dbo].[FactInternetSales_d]\r WITH\r (\tCLUSTERED COLUMNSTORE INDEX\r ,\tDISTRIBUTION = HASH([ProductKey])\r , \tPARTITION \t(\t[OrderDateKey] RANGE RIGHT \r                                     FOR VALUES\t(\t20000101, 20010101, 20020101, 20030101, 20040101, 20050101\r                                                 ,\t20060101, 20070101, 20080101, 20090101, 20100101, 20110101\r                                                 ,\t20120101, 20130101, 20140101, 20150101, 20160101, 20170101\r                                                 ,\t20180101, 20190101, 20200101, 20210101, 20220101, 20230101\r                                                 ,\t20240101, 20250101, 20260101, 20270101, 20280101, 20290101\r                                                 )\r )\r AS\r SELECT \t*\r FROM \t[dbo].[FactInternetSales]\r WHERE\t[PromotionKey] = 2\r OPTION (LABEL = 'CTAS : Delete')\r ;\r \r --Step 02. Rename the Tables to replace the \r RENAME OBJECT [dbo].[FactInternetSales]   TO [FactInternetSales_old];\r RENAME OBJECT [dbo].[FactInternetSales_d] TO [FactInternetSales];\r ```\r \r ## 优化更新\r `UPDATE` 是完整记录的操作。如果需要更新表或分区中的大量行，通常更有效的方法是使用最少记录的操作（如 [CTAS][CTAS]）来实现。\r \r 在下面的示例中，完整的表更新已转换为 `CTAS`，以便使最少日志记录成为可能。\r \r 在该案例中，我们回顾性地向表中的销售额添加折扣金额：\r \r ```sql\r --Step 01. Create a new table containing the \"Update\". \r CREATE TABLE [dbo].[FactInternetSales_u]\r WITH\r (\tCLUSTERED INDEX\r ,\tDISTRIBUTION = HASH([ProductKey])\r , \tPARTITION \t(\t[OrderDateKey] RANGE RIGHT \r                                     FOR VALUES\t(\t20000101, 20010101, 20020101, 20030101, 20040101, 20050101\r                                                 ,\t20060101, 20070101, 20080101, 20090101, 20100101, 20110101\r                                                 ,\t20120101, 20130101, 20140101, 20150101, 20160101, 20170101\r                                                 ,\t20180101, 20190101, 20200101, 20210101, 20220101, 20230101\r                                                 ,\t20240101, 20250101, 20260101, 20270101, 20280101, 20290101\r                                                 )\r                 )\r )\r AS \r SELECT\r     [ProductKey]  \r ,\t[OrderDateKey] \r ,\t[DueDateKey]  \r ,\t[ShipDateKey] \r ,\t[CustomerKey] \r ,\t[PromotionKey] \r ,\t[CurrencyKey] \r ,\t[SalesTerritoryKey]\r ,\t[SalesOrderNumber]\r ,\t[SalesOrderLineNumber]\r ,\t[RevisionNumber]\r ,\t[OrderQuantity]\r ,\t[UnitPrice]\r ,\t[ExtendedAmount]\r ,\t[UnitPriceDiscountPct]\r ,\tISNULL(CAST(5 as float),0) AS [DiscountAmount]\r ,\t[ProductStandardCost]\r ,\t[TotalProductCost]\r ,\tISNULL(CAST(CASE WHEN [SalesAmount] <=5 THEN 0\r          ELSE [SalesAmount] - 5\r          END AS MONEY),0) AS [SalesAmount]\r ,\t[TaxAmt]\r ,\t[Freight]\r ,\t[CarrierTrackingNumber] \r ,\t[CustomerPONumber]\r FROM\t[dbo].[FactInternetSales]\r OPTION (LABEL = 'CTAS : Update')\r ;\r \r --Step 02. Rename the tables\r RENAME OBJECT [dbo].[FactInternetSales]   TO [FactInternetSales_old];\r RENAME OBJECT [dbo].[FactInternetSales_u] TO [FactInternetSales];\r \r --Step 03. Drop the old table\r DROP TABLE [dbo].[FactInternetSales_old]\r ```\r \r > [!NOTE]\r > 重新创建大型表可以受益于使用 SQL 数据仓库工作负荷管理功能。有关详细信息，请参阅[并发][]文章中的工作负荷管理部分。\r \r ## 使用分区切换进行优化\r 面对[表分区][table partition]内较大规模修改时，分区切换模式非常有用。如果数据修改非常重要且跨越多个分区，只需遍历分区即可获得相同的结果。\r \r 执行分区切换的步骤如下所示：\r \r 1. 创建清空的分区\r 2. 采用 CTAS 执行“update”\r 3. 将现有数据转出到输出表\r 4. 转入新数据\r 5. 清理数据\r \r 但为帮助确定要切换的分区，我们首先需要生成一个帮助器过程，例子如下。\r \r ```\r CREATE PROCEDURE dbo.partition_data_get\r     @schema_name\t\t   NVARCHAR(128)\r ,\t@table_name\t\t\t   NVARCHAR(128)\r ,\t@boundary_value\t\t   INT\r AS\r IF OBJECT_ID('tempdb..#ptn_data') IS NOT NULL\r BEGIN\r     DROP TABLE #ptn_data\r END\r CREATE TABLE #ptn_data\r WITH\t(\tDISTRIBUTION = ROUND_ROBIN\r         ,\tHEAP\r         )\r AS\r WITH CTE\r AS\r (\r SELECT \ts.name\t\t\t\t\t\t\tAS [schema_name]\r ,\t\tt.name\t\t\t\t\t\t\tAS [table_name]\r , \t\tp.partition_number\t\t\t\tAS [ptn_nmbr]\r ,\t\tp.[rows]\t\t\t\t\t\tAS [ptn_rows]\r ,\t\tCAST(r.[value] AS INT)\t\t\tAS [boundary_value]\r FROM\t\tsys.schemas\t\t\t\t\tAS s\r JOIN\t\tsys.tables\t\t\t\t\tAS t\tON  s.[schema_id]\t\t= t.[schema_id]\r JOIN\t\tsys.indexes\t\t\t\t\tAS i\tON \tt.[object_id]\t\t= i.[object_id]\r JOIN\t\tsys.partitions\t\t\t\tAS p\tON \ti.[object_id]\t\t= p.[object_id] \r                                                 AND i.[index_id]\t\t= p.[index_id] \r JOIN\t\tsys.partition_schemes\t\tAS h\tON \ti.[data_space_id]\t= h.[data_space_id]\r JOIN\t\tsys.partition_functions\t\tAS f\tON \th.[function_id]\t\t= f.[function_id]\r LEFT JOIN\tsys.partition_range_values\tAS r \tON \tf.[function_id]\t\t= r.[function_id] \r                                                 AND r.[boundary_id]\t\t= p.[partition_number]\r WHERE i.[index_id] <= 1\r )\r SELECT\t*\r FROM\tCTE\r WHERE\t[schema_name]\t\t= @schema_name\r AND\t\t[table_name]\t\t= @table_name\r AND\t\t[boundary_value]\t= @boundary_value\r OPTION (LABEL = 'dbo.partition_data_get : CTAS : #ptn_data')\r ;\r GO\r ```\r \r 此过程可最大程度地重复使用代码，并保持分区切换示例更紧凑。\r \r 下面的代码演示上述五个步骤，讲述如何实现完整的分区切换例程。\r \r ```sql\r --Create a partitioned aligned empty table to switch out the data \r IF OBJECT_ID('[dbo].[FactInternetSales_out]') IS NOT NULL\r BEGIN\r     DROP TABLE [dbo].[FactInternetSales_out]\r END\r \r CREATE TABLE [dbo].[FactInternetSales_out]\r WITH\r (\tDISTRIBUTION = HASH([ProductKey])\r ,\tCLUSTERED COLUMNSTORE INDEX\r , \tPARTITION \t(\t[OrderDateKey] RANGE RIGHT \r                                     FOR VALUES\t(\t20020101, 20030101\r                                                 )\r                 )\r )\r AS\r SELECT *\r FROM\t[dbo].[FactInternetSales]\r WHERE 1=2\r OPTION (LABEL = 'CTAS : Partition Switch IN : UPDATE')\r ;\r \r --Create a partitioned aligned table and update the data in the select portion of the CTAS\r IF OBJECT_ID('[dbo].[FactInternetSales_in]') IS NOT NULL\r BEGIN\r     DROP TABLE [dbo].[FactInternetSales_in]\r END\r \r CREATE TABLE [dbo].[FactInternetSales_in]\r WITH\r (\tDISTRIBUTION = HASH([ProductKey])\r ,\tCLUSTERED COLUMNSTORE INDEX\r , \tPARTITION \t(\t[OrderDateKey] RANGE RIGHT \r                                     FOR VALUES\t(\t20020101, 20030101\r                                                 )\r                 )\r )\r AS \r SELECT\r     [ProductKey]  \r ,\t[OrderDateKey] \r ,\t[DueDateKey]  \r ,\t[ShipDateKey] \r ,\t[CustomerKey] \r ,\t[PromotionKey] \r ,\t[CurrencyKey] \r ,\t[SalesTerritoryKey]\r ,\t[SalesOrderNumber]\r ,\t[SalesOrderLineNumber]\r ,\t[RevisionNumber]\r ,\t[OrderQuantity]\r ,\t[UnitPrice]\r ,\t[ExtendedAmount]\r ,\t[UnitPriceDiscountPct]\r ,\tISNULL(CAST(5 as float),0) AS [DiscountAmount]\r ,\t[ProductStandardCost]\r ,\t[TotalProductCost]\r ,\tISNULL(CAST(CASE WHEN [SalesAmount] <=5 THEN 0\r          ELSE [SalesAmount] - 5\r          END AS MONEY),0) AS [SalesAmount]\r ,\t[TaxAmt]\r ,\t[Freight]\r ,\t[CarrierTrackingNumber] \r ,\t[CustomerPONumber]\r FROM\t[dbo].[FactInternetSales]\r WHERE\tOrderDateKey BETWEEN 20020101 AND 20021231\r OPTION (LABEL = 'CTAS : Partition Switch IN : UPDATE')\r ;\r \r --Use the helper procedure to identify the partitions\r --The source table\r EXEC dbo.partition_data_get 'dbo','FactInternetSales',20030101\r DECLARE @ptn_nmbr_src INT = (SELECT ptn_nmbr FROM #ptn_data)\r SELECT @ptn_nmbr_src\r \r --The \"in\" table\r EXEC dbo.partition_data_get 'dbo','FactInternetSales_in',20030101\r DECLARE @ptn_nmbr_in INT = (SELECT ptn_nmbr FROM #ptn_data)\r SELECT @ptn_nmbr_in\r \r --The \"out\" table\r EXEC dbo.partition_data_get 'dbo','FactInternetSales_out',20030101\r DECLARE @ptn_nmbr_out INT = (SELECT ptn_nmbr FROM #ptn_data)\r SELECT @ptn_nmbr_out\r \r --Switch the partitions over\r DECLARE @SQL NVARCHAR(4000) = '\r ALTER TABLE [dbo].[FactInternetSales]\tSWITCH PARTITION '+CAST(@ptn_nmbr_src AS VARCHAR(20))\t+' TO [dbo].[FactInternetSales_out] PARTITION '\t+CAST(@ptn_nmbr_out AS VARCHAR(20))+';\r ALTER TABLE [dbo].[FactInternetSales_in] SWITCH PARTITION '+CAST(@ptn_nmbr_in AS VARCHAR(20))\t+' TO [dbo].[FactInternetSales] PARTITION '\t\t+CAST(@ptn_nmbr_src AS VARCHAR(20))+';'\r EXEC sp_executesql @SQL\r \r --Perform the clean-up\r TRUNCATE TABLE dbo.FactInternetSales_out;\r TRUNCATE TABLE dbo.FactInternetSales_in;\r \r DROP TABLE dbo.FactInternetSales_out\r DROP TABLE dbo.FactInternetSales_in\r DROP TABLE #ptn_data\r ```\r \r ## 使用小批量尽量减少日志记录\r 对于大型数据修改操作，将操作划分为区块或批次来界定工作单元很有效。\r \r 下面提供了可用示例。批大小已设置为一个简单的数字来突显该方法。实际中批大小会变得非常大。\r \r ```sql\r SET NO_COUNT ON;\r IF OBJECT_ID('tempdb..#t') IS NOT NULL\r BEGIN\r     DROP TABLE #t;\r     PRINT '#t dropped';\r END\r \r CREATE TABLE #t\r WITH\t(\tDISTRIBUTION = ROUND_ROBIN\r         ,\tHEAP\r         )\r AS\r SELECT\tROW_NUMBER() OVER(ORDER BY (SELECT NULL)) AS seq_nmbr\r ,\t\tSalesOrderNumber\r ,\t\tSalesOrderLineNumber\r FROM\tdbo.FactInternetSales\r WHERE\t[OrderDateKey] BETWEEN 20010101 and 20011231\r ;\r \r DECLARE\t@seq_start\t\tINT = 1\r ,\t\t@batch_iterator\tINT = 1\r ,\t\t@batch_size\t\tINT = 50\r ,\t\t@max_seq_nmbr\tINT = (SELECT MAX(seq_nmbr) FROM dbo.#t)\r ;\r \r DECLARE\t@batch_count\tINT = (SELECT CEILING((@max_seq_nmbr*1.0)/@batch_size))\r ,\t\t@seq_end\t\tINT = @batch_size\r ;\r \r SELECT COUNT(*)\r FROM\tdbo.FactInternetSales f\r \r PRINT 'MAX_seq_nmbr '+CAST(@max_seq_nmbr AS VARCHAR(20))\r PRINT 'MAX_Batch_count '+CAST(@batch_count AS VARCHAR(20))\r \r WHILE\t@batch_iterator <= @batch_count\r BEGIN\r     DELETE\r     FROM\tdbo.FactInternetSales\r     WHERE EXISTS\r     (\r             SELECT\t1\r             FROM\t#t t\r             WHERE\tseq_nmbr BETWEEN  @seq_start AND @seq_end\r             AND\t\tFactInternetSales.SalesOrderNumber\t\t= t.SalesOrderNumber\r             AND\t\tFactInternetSales.SalesOrderLineNumber\t= t.SalesOrderLineNumber\r     )\r     ;\r \r     SET @seq_start = @seq_end\r     SET @seq_end = (@seq_start+@batch_size);\r     SET @batch_iterator +=1;\r END\r ```\r \r ## 暂停和缩放指南\r 借助 Azure SQL 数据仓库，你可以根据需要暂停、恢复和缩放数据仓库。暂停或缩放 SQL 数据仓库时，一定要了解会立即终止任何正提交的事务；导致回滚所有未决事务。如果你的工作负荷在暂停或缩放操作前已发出数据修改在长时间运行之后仍未完成的指示，则需要撤消此项工作。这可能会影响暂停或缩放 Azure SQL 数据仓库数据库所花费的时间。\r \r > [!IMPORTANT]\r > `UPDATE` 和 `DELETE` 都是完整记录的操作，因此这些撤消/重做操作相比同等最少记录的操作可能要花费更长的时间。\r \r 最佳方案是在暂停或缩放 SQL 数据仓库前就完成正提交的数据修改事务。但这不一定始终可行。若要降低长时间回退的风险，请考虑以下选项之一：\r \r * 使用 [CTAS][CTAS] 重新编写长时间运行的操作\r * 将该操作分解为多个块；针对行的子集进行操作\r \r ## 后续步骤\r 参阅 [SQL 数据仓库中的事务][Transactions in SQL Data Warehouse]，以便详细了解隔离级别和事务限制。有关其他最佳实践的概述，请参阅 [SQL 数据仓库最佳实践][SQL Data Warehouse Best Practices]。\r \r <!--Image references-->\r \r <!--Article references-->\r [Transactions in SQL Data Warehouse]: ./sql-data-warehouse-develop-transactions.md\r [table partition]: ./sql-data-warehouse-tables-partition.md\r [并发]: ./sql-data-warehouse-develop-concurrency.md\r [CTAS]: ./sql-data-warehouse-develop-ctas.md\r [SQL Data Warehouse Best Practices]: ./sql-data-warehouse-best-practices.md\r \r <!--MSDN references-->\r [alter index]: https://msdn.microsoft.com/zh-cn/library/ms188388.aspx\r [RENAME]: https://msdn.microsoft.com/zh-cn/library/mt631611.aspx\r \r <!-- Other web references -->\r \r <!---HONumber=Mooncake_Quality_Review_0117_2017-->"}