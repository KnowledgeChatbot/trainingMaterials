{"Title":"使用 Azure 队列存储通过 .NET 监视媒体服务作业通知","Description":"了解如何使用 Azure 队列存储监视媒体服务作业通知。 代码示例用 C# 编写，并使用用于 .NET 的媒体服务 SDK。","Content":"# <a name=\"use-azure-queue-storage-to-monitor-media-services-job-notifications-with-net\"></a>使用 Azure 队列存储通过 .NET 监视媒体服务作业通知\r 运行编码作业时，通常需要采用某种方式来跟踪作业进度。 可以配置媒体服务将通知传送到 [Azure 队列存储](../storage/storage-dotnet-how-to-use-queues.md)。 然后可以通过从队列存储获取通知来监视作业进度。 \r \r 用户可以从任何位置访问已传给到队列存储中的消息。 队列存储消息体系结构十分可靠，且伸缩性极高。 建议使用其他方法轮询消息的队列存储。\r \r 一种常见的媒体服务通知侦听方案是：正在开发一个内容管理系统，完成编码作业后，该系统需要执行一些其他任务（例如触发工作流的下一步骤或者发布内容）。\r \r 本主题说明如何从队列存储获取通知消息。  \r \r ## <a name=\"considerations\"></a>注意事项\r 开发使用队列存储的媒体服务应用程序时，请注意以下几点：\r \r * 队列存储不保证按照先进先出 (FIFO) 的顺序传递消息。 有关详细信息，请参阅 [Azure 队列和 Azure 服务总线队列比较与对照](https://msdn.microsoft.com/library/azure/hh767287.aspx)。\r * 队列存储不是推送服务。 必须轮询队列。\r * 可以有任意数目的队列。 有关详细信息，请参阅 [队列服务 REST API](https://docs.microsoft.com/rest/api/storageservices/Queue-Service-REST-API)。\r * 队列存储存在一些需注意的限制和细节问题。 相关说明请参阅 [Azure 队列和 Azure 服务总线队列比较与对照](/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted)。\r \r ## <a name=\"net-code-example\"></a>.NET 代码示例\r \r 本部分中的代码示例执行以下操作：\r \r 1. 定义一个映射为通知消息格式的 **EncodingJobMessage** 类。 代码将从队列接收到的消息反序列化为 **EncodingJobMessage** 类型的对象。\r 2. 从 app.config 文件中加载媒体服务和存储帐户信息。 本代码示例使用此信息创建 **CloudMediaContext** 和 **CloudQueue** 对象。\r 3. 创建接收编码作业相关通知消息的队列。\r 4. 创建一个映射到队列的通知终结点。\r 5. 将通知终结点附加到作业，并提交编码作业。 可以将多个通知终结点附加到一个作业。\r 6. 将 **NotificationJobState.FinalStatesOnly** 传递到 **AddNew** 方法。 （本例中，只想了解作业处理的最终状态。）\r \r     ```\r     job.JobNotificationSubscriptions.AddNew(NotificationJobState.FinalStatesOnly, _notificationEndPoint);\r     ```\r 7. 如果传递 **NotificationJobState.All**，则会收到以下所有状态更改通知：已排队、已计划、处理中和已完成。 但如前所述，队列存储不保证按顺序传递。 若要对消息排序，请使用 **Timestamp** 属性（在以下示例的 **EncodingJobMessage** 类型中定义）。 可能出现重复消息。 若要检查重复项，请使用 **ETag 属性**（在 **EncodingJobMessage** 类型中定义）。 此外，可能会跳过某些状态更改通知。\r 8. 每 10 秒检查一次队列，等待作业进入已完成状态。 处理消息后删除消息。\r 9. 删除队列和通知终结点。\r \r > [!NOTE]\r > 监视作业状态的建议方法是侦听通知消息，如以下示例所示。\r >\r > 或者，可以使用 IJob.State 属性检查作业状态。  在 **IJob** 的状态设置为“已完成”之前，可能会先收到一条指示作业已完成的通知消息。 IJob.State 属性在延迟片刻之后反映正确的状态。\r >\r >\r \r ### <a name=\"create-and-configure-a-visual-studio-project\"></a>创建和配置 Visual Studio 项目\r \r 1. 设置开发环境，并在 app.config 文件中填充连接信息，如[使用 .NET 进行媒体服务开发](media-services-dotnet-how-to-use.md)中所述。 \r 2. 创建新的文件夹（文件夹可以位于本地驱动器上的任何位置），然后复制需要编码和流式处理或渐进式下载的 .mp4 文件。 在此示例中，我们使用了“C:\\Media”路径。\r \r ### <a name=\"code\"></a>代码\r \r ```\r using System;\r using System.Linq;\r using System.Configuration;\r using System.IO;\r using System.Threading;\r using System.Collections.Generic;\r using Microsoft.WindowsAzure.MediaServices.Client;\r using Microsoft.WindowsAzure.Storage;\r using Microsoft.WindowsAzure.Storage.Queue;\r using System.Runtime.Serialization.Json;\r \r namespace JobNotification\r {\r     public class EncodingJobMessage\r     {\r         // MessageVersion is used for version control.\r         public String MessageVersion { get; set; }\r \r         // Type of the event. Valid values are\r         // JobStateChange and NotificationEndpointRegistration.\r         public String EventType { get; set; }\r \r         // ETag is used to help the customer detect if\r         // the message is a duplicate of another message previously sent.\r         public String ETag { get; set; }\r \r         // Time of occurrence of the event.\r         public String TimeStamp { get; set; }\r \r         // Collection of values specific to the event.\r \r         // For the JobStateChange event the values are:\r         //     JobId - Id of the Job that triggered the notification.\r         //     NewState- The new state of the Job. Valid values are:\r         //          Scheduled, Processing, Canceling, Cancelled, Error, Finished\r         //     OldState- The old state of the Job. Valid values are:\r         //          Scheduled, Processing, Canceling, Cancelled, Error, Finished\r \r         // For the NotificationEndpointRegistration event the values are:\r         //     NotificationEndpointId- Id of the NotificationEndpoint\r         //          that triggered the notification.\r         //     State- The state of the Endpoint.\r         //          Valid values are: Registered and Unregistered.\r \r         public IDictionary<string, object> Properties { get; set; }\r     }\r \r     class Program\r     {\r \r         // Read values from the App.config file.\r         private static readonly string _AADTenantDomain =\r             ConfigurationManager.AppSettings[\"AADTenantDomain\"];\r         private static readonly string _RESTAPIEndpoint =\r             ConfigurationManager.AppSettings[\"MediaServiceRESTAPIEndpoint\"];\r         private static readonly string _StorageConnectionString = \r             ConfigurationManager.AppSettings[\"StorageConnectionString\"];\r \r         private static CloudMediaContext _context = null;\r         private static CloudQueue _queue = null;\r         private static INotificationEndPoint _notificationEndPoint = null;\r \r         private static readonly string _singleInputMp4Path =\r             Path.GetFullPath(@\"C:\\Media\\BigBuckBunny.mp4\");\r \r         static void Main(string[] args)\r         {\r             string endPointAddress = Guid.NewGuid().ToString();\r \r             // Create the context.\r             var tokenCredentials = new AzureAdTokenCredentials(_AADTenantDomain, AzureEnvironments.AzureChinaCloudEnvironment);\r             var tokenProvider = new AzureAdTokenProvider(tokenCredentials);\r \r             _context = new CloudMediaContext(new Uri(_RESTAPIEndpoint), tokenProvider);\r \r             // Create the queue that will be receiving the notification messages.\r             _queue = CreateQueue(_StorageConnectionString, endPointAddress);\r \r             // Create the notification point that is mapped to the queue.\r             _notificationEndPoint =\r                     _context.NotificationEndPoints.Create(\r                     Guid.NewGuid().ToString(), NotificationEndPointType.AzureQueue, endPointAddress);\r \r \r             if (_notificationEndPoint != null)\r             {\r                 IJob job = SubmitEncodingJobWithNotificationEndPoint(_singleInputMp4Path);\r                 WaitForJobToReachedFinishedState(job.Id);\r             }\r \r             // Clean up.\r             _queue.Delete();\r             _notificationEndPoint.Delete();\r         }\r \r \r         static public CloudQueue CreateQueue(string storageAccountConnectionString, string endPointAddress)\r         {\r             CloudStorageAccount storageAccount = CloudStorageAccount.Parse(storageAccountConnectionString);\r \r             // Create the queue client\r             CloudQueueClient queueClient = storageAccount.CreateCloudQueueClient();\r \r             // Retrieve a reference to a queue\r             CloudQueue queue = queueClient.GetQueueReference(endPointAddress);\r \r             // Create the queue if it doesn't already exist\r             queue.CreateIfNotExists();\r \r             return queue;\r         }\r \r \r         public static IJob SubmitEncodingJobWithNotificationEndPoint(string inputMediaFilePath)\r         {\r             // Declare a new job.\r             IJob job = _context.Jobs.Create(\"My MP4 to Smooth Streaming encoding job\");\r \r             //Create an encrypted asset and upload the mp4.\r             IAsset asset = CreateAssetAndUploadSingleFile(AssetCreationOptions.StorageEncrypted,\r                 inputMediaFilePath);\r \r             // Get a media processor reference, and pass to it the name of the\r             // processor to use for the specific task.\r             IMediaProcessor processor = GetLatestMediaProcessorByName(\"Media Encoder Standard\");\r \r             // Create a task with the conversion details, using a configuration file.\r             ITask task = job.Tasks.AddNew(\"My encoding Task\",\r                 processor,\r                 \"Adaptive Streaming\",\r                 Microsoft.WindowsAzure.MediaServices.Client.TaskOptions.None);\r \r             // Specify the input asset to be encoded.\r             task.InputAssets.Add(asset);\r \r             // Add an output asset to contain the results of the job.\r             task.OutputAssets.AddNew(\"Output asset\",\r                 AssetCreationOptions.None);\r \r             // Add a notification point to the job. You can add multiple notification points.  \r             job.JobNotificationSubscriptions.AddNew(NotificationJobState.FinalStatesOnly,\r                 _notificationEndPoint);\r \r             job.Submit();\r \r             return job;\r         }\r \r         public static void WaitForJobToReachedFinishedState(string jobId)\r         {\r             int expectedState = (int)JobState.Finished;\r             int timeOutInSeconds = 600;\r \r             bool jobReachedExpectedState = false;\r             DateTime startTime = DateTime.Now;\r             int jobState = -1;\r \r             while (!jobReachedExpectedState)\r             {\r                 // Specify how often you want to get messages from the queue.\r                 Thread.Sleep(TimeSpan.FromSeconds(10));\r \r                 foreach (var message in _queue.GetMessages(10))\r                 {\r                     using (Stream stream = new MemoryStream(message.AsBytes))\r                     {\r                         DataContractJsonSerializerSettings settings = new DataContractJsonSerializerSettings();\r                         settings.UseSimpleDictionaryFormat = true;\r                         DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(EncodingJobMessage), settings);\r                         EncodingJobMessage encodingJobMsg = (EncodingJobMessage)ser.ReadObject(stream);\r \r                         Console.WriteLine();\r \r                         // Display the message information.\r                         Console.WriteLine(\"EventType: {0}\", encodingJobMsg.EventType);\r                         Console.WriteLine(\"MessageVersion: {0}\", encodingJobMsg.MessageVersion);\r                         Console.WriteLine(\"ETag: {0}\", encodingJobMsg.ETag);\r                         Console.WriteLine(\"TimeStamp: {0}\", encodingJobMsg.TimeStamp);\r                         foreach (var property in encodingJobMsg.Properties)\r                         {\r                             Console.WriteLine(\"    {0}: {1}\", property.Key, property.Value);\r                         }\r \r                         // We are only interested in messages\r                         // where EventType is \"JobStateChange\".\r                         if (encodingJobMsg.EventType == \"JobStateChange\")\r                         {\r                             string JobId = (String)encodingJobMsg.Properties.Where(j => j.Key == \"JobId\").FirstOrDefault().Value;\r                             if (JobId == jobId)\r                             {\r                                 string oldJobStateStr = (String)encodingJobMsg.Properties.\r                                                             Where(j => j.Key == \"OldState\").FirstOrDefault().Value;\r                                 string newJobStateStr = (String)encodingJobMsg.Properties.\r                                                             Where(j => j.Key == \"NewState\").FirstOrDefault().Value;\r \r                                 JobState oldJobState = (JobState)Enum.Parse(typeof(JobState), oldJobStateStr);\r                                 JobState newJobState = (JobState)Enum.Parse(typeof(JobState), newJobStateStr);\r \r                                 if (newJobState == (JobState)expectedState)\r                                 {\r                                     Console.WriteLine(\"job with Id: {0} reached expected state: {1}\",\r                                         jobId, newJobState);\r                                     jobReachedExpectedState = true;\r                                     break;\r                                 }\r                             }\r                         }\r                     }\r                     // Delete the message after we've read it.\r                     _queue.DeleteMessage(message);\r                 }\r \r                 // Wait until timeout\r                 TimeSpan timeDiff = DateTime.Now - startTime;\r                 bool timedOut = (timeDiff.TotalSeconds > timeOutInSeconds);\r                 if (timedOut)\r                 {\r                     Console.WriteLine(@\"Timeout for checking job notification messages,\r                                         latest found state ='{0}', wait time = {1} secs\",\r                         jobState,\r                         timeDiff.TotalSeconds);\r \r                     throw new TimeoutException();\r                 }\r             }\r         }\r \r         static private IAsset CreateAssetAndUploadSingleFile(AssetCreationOptions assetCreationOptions, string singleFilePath)\r         {\r             var asset = _context.Assets.Create(\"UploadSingleFile_\" + DateTime.UtcNow.ToString(),\r                 assetCreationOptions);\r \r             var fileName = Path.GetFileName(singleFilePath);\r \r             var assetFile = asset.AssetFiles.Create(fileName);\r \r             Console.WriteLine(\"Created assetFile {0}\", assetFile.Name);\r             Console.WriteLine(\"Upload {0}\", assetFile.Name);\r \r             assetFile.Upload(singleFilePath);\r             Console.WriteLine(\"Done uploading of {0}\", assetFile.Name);\r \r             return asset;\r         }\r \r         static private IMediaProcessor GetLatestMediaProcessorByName(string mediaProcessorName)\r         {\r             var processor = _context.MediaProcessors.Where(p => p.Name == mediaProcessorName).\r                 ToList().OrderBy(p => new Version(p.Version)).LastOrDefault();\r \r             if (processor == null)\r                 throw new ArgumentException(string.Format(\"Unknown media processor\", mediaProcessorName));\r \r             return processor;\r         }\r     }\r }\r ```\r 以上示例生成了以下输出。 值会有所变化。\r \r     Created assetFile BigBuckBunny.mp4\r     Upload BigBuckBunny.mp4\r     Done uploading of BigBuckBunny.mp4\r \r     EventType: NotificationEndPointRegistration\r     MessageVersion: 1.0\r     ETag: e0238957a9b25bdf3351a88e57978d6a81a84527fad03bc23861dbe28ab293f6\r     TimeStamp: 2013-05-14T20:22:37\r         NotificationEndPointId: nb:nepid:UUID:d6af9412-2488-45b2-ba1f-6e0ade6dbc27\r         State: Registered\r         Name: dde957b2-006e-41f2-9869-a978870ac620\r         Created: 2013-05-14T20:22:35\r \r     EventType: JobStateChange\r     MessageVersion: 1.0\r     ETag: 4e381f37c2d844bde06ace650310284d6928b1e50101d82d1b56220cfcb6076c\r     TimeStamp: 2013-05-14T20:24:40\r         JobId: nb:jid:UUID:526291de-f166-be47-b62a-11ffe6d4be54\r         JobName: My MP4 to Smooth Streaming encoding job\r         NewState: Finished\r         OldState: Processing\r         AccountName: westeuropewamsaccount\r     job with Id: nb:jid:UUID:526291de-f166-be47-b62a-11ffe6d4be54 reached expected\r     State: Finished\r \r <!--Update_Description: update code to use AAD token instead of ACS-->"}