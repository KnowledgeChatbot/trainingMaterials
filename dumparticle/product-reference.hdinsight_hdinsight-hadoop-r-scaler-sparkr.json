{"Title":"将 ScaleR 和 SparkR 与 Azure HDInsight 配合使用","Description":"将 ScaleR 和 SparkR 与 R Server 和 HDInsight 配合使用","Content":"# <a name=\"combine-scaler-and-sparkr-in-hdinsight\"></a>在 HDInsight 中将 ScaleR 和 SparkR 配合使用\r \r 本文展示了如何使用 **ScaleR** 逻辑回归模型基于通过 **SparkR** 联接的航班延迟和天气数据来预测航班抵达延迟。 本方案演示了如何将用于在 Spark 中处理数据的 ScaleR 功能与 Microsoft R Server 配合使用来进行分析。 使用这些技术组合，可以在分布式处理中应用最新功能。\r \r 虽然这两个程序包都在 Hadoop 的 Spark 执行引擎上运行，但是会阻止它们共享内存中数据，因为它们各自需要使用其自己的 Spark 会话。 在此问题在将来的 R Server 版本中得到解决之前，解决方法是保留非重叠的 Spark 会话，并通过中间文件交换数据。 此处的说明表明这些要求很容易实现。\r \r 此处，我们使用最初由 Mario Inchiosa 和 Roni Burd 在 Strata 2016 研讨会中分享的一个示例，网络研讨会 [Building a Scalable Data Science Platform with R](http://event.on24.com/eventRegistration/console/EventConsoleNG.jsp?uimode=nextgeneration&eventid=1160288&sessionid=1&key=8F8FB9E2EB1AEE867287CD6757D5BD40&contenttype=A&eventuserid=305999&playerwidth=1000&playerheight=650&caller=previewLobby&text_language_id=en&format=fhaudio)（使用 R 构建可缩放的数据科研平台）中也提供了此示例。该示例使用 SparkR 来将知名航班的抵达延迟数据集与起飞机场和降落机场的天气数据联接起来。 然后，它将联接后的数据用作 ScaleR 逻辑回归模型的输入来预测航班抵达延迟。\r \r 我们演练的代码最初是针对在 Azure 上的 HDInsight 群集中的 Spark 上运行的 R Server 编写的。 但是，在本地环境的上下文中，在同一脚本中混合使用 SparkR 和 ScaleR 的概念仍然有效。 下面，我们假设读者对 R 以及 R Server 的 [ScaleR](https://msdn.microsoft.com/microsoft-r/scaler-user-guide-introduction) 库有一个中等水平的了解。 在演练本方案时，我们还使用了 [SparkR](https://spark.apache.org/docs/2.1.0/sparkr.html)。\r \r ## <a name=\"the-airline-and-weather-datasets\"></a>航班和天气数据集\r \r **AirOnTime08to12CSV** 航空公司公用数据集包含美国境内从 1987 年 10 月到 2012 年 12 月所有商务航班的抵达和出发详细信息。 这是一个大型数据集：总共有大约 1.5 亿条记录， 解压缩后略小于 4 GB。 可从[美国政府存档](http://www.transtats.bts.gov/DL_SelectFields.asp?Table_ID=236)获取该数据集。 为了方便使用，它以 zip 文件的形式 (AirOnTimeCSV.zip) 提供，其中包含 [Revolution Analytics 数据集存储库](http://packages.revolutionanalytics.com/datasets/AirOnTime87to12/)中的 303 个单独的每月 CSV 文件\r \r 为了查看天气对航班延迟的影响，我们还需要获取每个机场的天气数据。 可以从[美国海洋与大气管理存储库](http://www.ncdc.noaa.gov/orders/qclcd/)下载原始格式的该数据的 zip 文件。 为了演示此示例，我们提取了 2007 年 5 月到 2012 年 12 月的天气数据，并使用了 68 个月的 zip 天气数据文件中，每个文件内的每小时数据文件。 每月 zip 文件还包含气象台 ID (WBAN)、关联的机场 (CallSign) 与机场时区与 UTC 的偏差 (TimeZone) 之间的映射 (YYYYMMstation.txt)。 联接航班延迟和天气数据时需要用到所有这些信息。\r \r ## <a name=\"setting-up-the-spark-environment\"></a>设置 Spark 环境\r \r 第一步是设置 Spark 环境。 首先，我们指向包含输入数据目录的目录，创建 Spark 计算上下文，并创建一个日志记录函数用于在控制台上记录参考信息：\r \r ```\r workDir        <- '~'  \r myNameNode     <- 'default' \r myPort         <- 0\r inputDataDir   <- 'wasb://hdfs@myAzureAcccount.blob.core.chinacloudapi.cn'\r hdfsFS         <- RxHdfsFileSystem(hostName=myNameNode, port=myPort)\r \r # create a persistent Spark session to reduce startup times \r #   (remember to stop it later!)\r \r sparkCC        <- RxSpark(consoleOutput=TRUE, nameNode=myNameNode, port=myPort, persistentRun=TRUE)\r \r # create working directories \r \r rxHadoopMakeDir('/user')\r rxHadoopMakeDir('user/RevoShare')\r rxHadoopMakeDir('user/RevoShare/remoteuser')\r \r (dataDir <- '/share')\r rxHadoopMakeDir(dataDir)\r rxHadoopListFiles(dataDir) \r \r setwd(workDir)\r getwd()\r \r # version of rxRoc that runs in a local CC \r rxRoc <- function(...){\r   rxSetComputeContext(RxLocalSeq())\r   roc <- RevoScaleR::rxRoc(...)\r   rxSetComputeContext(sparkCC)\r   return(roc)\r }\r \r logmsg <- function(msg) { cat(format(Sys.time(), \"%Y-%m-%d %H:%M:%S\"),':',msg,'\\n') } \r t0 <- proc.time() \r \r #..start \r \r logmsg('Start') \r (trackers <- system(\"mapred job -list-active-trackers\", intern = TRUE))\r logmsg(paste('Number of task nodes=',length(trackers)))\r ```\r \r 接下来，将“Spark_Home”添加到 R 包的搜索路径以便可以使用 SparkR，并初始化 SparkR 会话：\r \r ```\r #..setup for use of SparkR  \r \r logmsg('Initialize SparkR') \r \r .libPaths(c(file.path(Sys.getenv(\"SPARK_HOME\"), \"R\", \"lib\"), .libPaths()))\r library(SparkR)\r \r sparkEnvir <- list(spark.executor.instances = '10',\r                    spark.yarn.executor.memoryOverhead = '8000')\r \r sc <- sparkR.init(\r   sparkEnvir = sparkEnvir,\r   sparkPackages = \"com.databricks:spark-csv_2.10:1.3.0\"\r )\r \r sqlContext <- sparkRSQL.init(sc)\r ```\r \r ## <a name=\"preparing-the-weather-data\"></a>准备天气数据\r \r 为了准备天气数据，我们将其集合到建模所需的各个列中： \r \r - “Visibility”\r - “DryBulbCelsius”\r - “DewPointCelsius”\r - “RelativeHumidity”\r - “WindSpeed”\r - “Altimeter”\r \r 然后，我们添加一个与气象站关联的机场代码，并将测量值从本地时间转换为 UTC。\r \r 先创建一个文件，用于将气象站 (WBAN) 信息映射到机场代码。 我们可以从随天气数据包括的映射文件中获取此关联。 通过将天气数据文件中的 *CallSign*（例如 LAX）字段映射到航班数据中的 *Origin*。 不过，我们手头恰好有另一个映射，它将 *WBAN* 映射到 *AirportID*（例如，代表 LAX 的 12892）并包括了已保存到我们可以使用的名为“wban-to-airport-id-tz.CSV” CSV 文件中的 *TimeZone*。 例如：\r \r | AirportID | WBAN | TimeZone\r |-----------|------|---------\r | 10685 | 54831 | -6\r | 14871 | 24232 | -8\r | .. | .. | ..\r \r 以下代码将读取每小时原始天气数据文件、将文件放入我们需要的列、合并气象站映射文件、将测量值的日期时间调整为 UTC，并写出文件的新版本：\r \r ```\r # Look up AirportID and Timezone for WBAN (weather station ID) and adjust time\r \r adjustTime <- function(dataList)\r {\r   dataset0 <- as.data.frame(dataList)\r \r   dataset1 <- base::merge(dataset0, wbanToAirIDAndTZDF1, by = \"WBAN\")\r \r   if(nrow(dataset1) == 0) {\r     dataset1 <- data.frame(\r       Visibility = numeric(0),\r       DryBulbCelsius = numeric(0),\r       DewPointCelsius = numeric(0),\r       RelativeHumidity = numeric(0),\r       WindSpeed = numeric(0),\r       Altimeter = numeric(0),\r       AdjustedYear = numeric(0),\r       AdjustedMonth = numeric(0),\r       AdjustedDay = integer(0),\r       AdjustedHour = integer(0),\r       AirportID = integer(0)\r     )\r \r     return(dataset1)\r   }\r \r   Year <- as.integer(substr(dataset1$Date, 1, 4))\r   Month <- as.integer(substr(dataset1$Date, 5, 6))\r   Day <- as.integer(substr(dataset1$Date, 7, 8))\r \r   Time <- dataset1$Time\r   Hour <- ceiling(Time/100)\r \r   Timezone <- as.integer(dataset1$TimeZone)\r \r   adjustdate = as.POSIXlt(sprintf(\"%4d-%02d-%02d %02d:00:00\", Year, Month, Day, Hour), tz = \"UTC\") + Timezone * 3600\r \r   AdjustedYear = as.POSIXlt(adjustdate)$year + 1900\r   AdjustedMonth = as.POSIXlt(adjustdate)$mon + 1\r   AdjustedDay   = as.POSIXlt(adjustdate)$mday\r   AdjustedHour  = as.POSIXlt(adjustdate)$hour\r \r   AirportID = dataset1$AirportID\r   Weather = dataset1[,c(\"Visibility\", \"DryBulbCelsius\", \"DewPointCelsius\", \"RelativeHumidity\", \"WindSpeed\", \"Altimeter\")]\r \r   data.set = data.frame(cbind(AdjustedYear, AdjustedMonth, AdjustedDay, AdjustedHour, AirportID, Weather))\r \r   return(data.set)\r }\r \r wbanToAirIDAndTZDF <- read.csv(\"wban-to-airport-id-tz.csv\")\r \r colInfo <- list(\r   WBAN = list(type=\"integer\"),\r   Date = list(type=\"character\"),\r   Time = list(type=\"integer\"),\r   Visibility = list(type=\"numeric\"),\r   DryBulbCelsius = list(type=\"numeric\"),\r   DewPointCelsius = list(type=\"numeric\"),\r   RelativeHumidity = list(type=\"numeric\"),\r   WindSpeed = list(type=\"numeric\"),\r   Altimeter = list(type=\"numeric\")\r )\r \r weatherDF <- RxTextData(file.path(inputDataDir, \"WeatherRaw\"), colInfo = colInfo)\r \r weatherDF1 <- RxTextData(file.path(inputDataDir, \"Weather\"), colInfo = colInfo,\r                 filesystem=hdfsFS)\r \r rxSetComputeContext(\"localpar\")\r rxDataStep(weatherDF, outFile = weatherDF1, rowsPerRead = 50000, overwrite = T,\r            transformFunc = adjustTime,\r            transformObjects = list(wbanToAirIDAndTZDF1 = wbanToAirIDAndTZDF))\r ```\r \r ## <a name=\"importing-the-airline-and-weather-data-to-spark-dataframes\"></a>将航班和天气数据导入 Spark DataFrames\r \r 现在，使用 SparkR [read.df()](https://docs.databricks.com/spark/latest/sparkr/functions/read.df.html) 函数将天气和航班数据导入 Spark DataFrame。 与其他许多 Spark 方法一样，此函数是惰式执行的，也就是说，它会排入执行队列，但只在需要时才会执行。\r \r ```\r airPath     <- file.path(inputDataDir, \"AirOnTime08to12CSV\")\r weatherPath <- file.path(inputDataDir, \"Weather\") # pre-processed weather data\r rxHadoopListFiles(airPath) \r rxHadoopListFiles(weatherPath) \r \r # create a SparkR DataFrame for the airline data\r \r logmsg('create a SparkR DataFrame for the airline data') \r # use inferSchema = \"false\" for more robust parsing\r airDF <- read.df(sqlContext, airPath, source = \"com.databricks.spark.csv\", \r                  header = \"true\", inferSchema = \"false\")\r \r # Create a SparkR DataFrame for the weather data\r \r logmsg('create a SparkR DataFrame for the weather data') \r weatherDF <- read.df(sqlContext, weatherPath, source = \"com.databricks.spark.csv\", \r                      header = \"true\", inferSchema = \"true\")\r ```\r \r ## <a name=\"data-cleansing-and-transformation\"></a>数据清理和和转换\r \r 接下来，我们对航班数据执行一些清理，然后重命名列。 我们仅保留所需的变量，并将计划的起飞时间向下舍入到最近的小时，以便与起飞时的最新天气数据合并：\r \r ```\r logmsg('clean the airline data') \r airDF <- rename(airDF,\r                 ArrDel15 = airDF$ARR_DEL15,\r                 Year = airDF$YEAR,\r                 Month = airDF$MONTH,\r                 DayofMonth = airDF$DAY_OF_MONTH,\r                 DayOfWeek = airDF$DAY_OF_WEEK,\r                 Carrier = airDF$UNIQUE_CARRIER,\r                 OriginAirportID = airDF$ORIGIN_AIRPORT_ID,\r                 DestAirportID = airDF$DEST_AIRPORT_ID,\r                 CRSDepTime = airDF$CRS_DEP_TIME,\r                 CRSArrTime =  airDF$CRS_ARR_TIME\r )\r \r # Select desired columns from the flight data. \r varsToKeep <- c(\"ArrDel15\", \"Year\", \"Month\", \"DayofMonth\", \"DayOfWeek\", \"Carrier\", \"OriginAirportID\", \"DestAirportID\", \"CRSDepTime\", \"CRSArrTime\")\r airDF <- select(airDF, varsToKeep)\r \r # Apply schema\r coltypes(airDF) <- c(\"character\", \"integer\", \"integer\", \"integer\", \"integer\", \"character\", \"integer\", \"integer\", \"integer\", \"integer\")\r \r # Round down scheduled departure time to full hour.\r airDF$CRSDepTime <- floor(airDF$CRSDepTime / 100)\r ```\r \r 现在，我们对天气数据执行类似的操作：\r \r ```\r # Average weather readings by hour\r logmsg('clean the weather data') \r weatherDF <- agg(groupBy(weatherDF, \"AdjustedYear\", \"AdjustedMonth\", \"AdjustedDay\", \"AdjustedHour\", \"AirportID\"), Visibility=\"avg\",\r                   DryBulbCelsius=\"avg\", DewPointCelsius=\"avg\", RelativeHumidity=\"avg\", WindSpeed=\"avg\", Altimeter=\"avg\"\r                   )\r \r weatherDF <- rename(weatherDF,\r                     Visibility = weatherDF$'avg(Visibility)',\r                     DryBulbCelsius = weatherDF$'avg(DryBulbCelsius)',\r                     DewPointCelsius = weatherDF$'avg(DewPointCelsius)',\r                     RelativeHumidity = weatherDF$'avg(RelativeHumidity)',\r                     WindSpeed = weatherDF$'avg(WindSpeed)',\r                     Altimeter = weatherDF$'avg(Altimeter)'\r )\r ```\r \r ## <a name=\"joining-the-weather-and-airline-data\"></a>联接天气和航班数据\r \r 现在，我们使用 SparkR [join()](https://docs.databricks.com/spark/latest/sparkr/functions/join.html) 函数根据出发地 AirportID 和日期时间，针对航班和天气数据执行左外部联接。 使用外部联接可以保留所有航班数据记录，即使没有匹配的天气数据。 通过此联接，我们删除了一些多余的列，并将保留的列重命名以删除联接时传入的 DataFrame 前缀。\r \r ```\r logmsg('Join airline data with weather at Origin Airport')\r joinedDF <- SparkR::join(\r   airDF,\r   weatherDF,\r   airDF$OriginAirportID == weatherDF$AirportID &\r     airDF$Year == weatherDF$AdjustedYear &\r     airDF$Month == weatherDF$AdjustedMonth &\r     airDF$DayofMonth == weatherDF$AdjustedDay &\r     airDF$CRSDepTime == weatherDF$AdjustedHour,\r   joinType = \"left_outer\"\r )\r \r # Remove redundant columns\r vars <- names(joinedDF)\r varsToDrop <- c('AdjustedYear', 'AdjustedMonth', 'AdjustedDay', 'AdjustedHour', 'AirportID')\r varsToKeep <- vars[!(vars %in% varsToDrop)]\r joinedDF1 <- select(joinedDF, varsToKeep)\r \r joinedDF2 <- rename(joinedDF1,\r                     VisibilityOrigin = joinedDF1$Visibility,\r                     DryBulbCelsiusOrigin = joinedDF1$DryBulbCelsius,\r                     DewPointCelsiusOrigin = joinedDF1$DewPointCelsius,\r                     RelativeHumidityOrigin = joinedDF1$RelativeHumidity,\r                     WindSpeedOrigin = joinedDF1$WindSpeed,\r                     AltimeterOrigin = joinedDF1$Altimeter\r )\r ```\r \r 以类似的方式，我们基于目的地 AirportID 和日期时间联接天气和航班数据。\r \r ```\r logmsg('Join airline data with weather at Destination Airport')\r joinedDF3 <- SparkR::join(\r   joinedDF2,\r   weatherDF,\r   airDF$DestAirportID == weatherDF$AirportID &\r     airDF$Year == weatherDF$AdjustedYear &\r     airDF$Month == weatherDF$AdjustedMonth &\r     airDF$DayofMonth == weatherDF$AdjustedDay &\r     airDF$CRSDepTime == weatherDF$AdjustedHour,\r   joinType = \"left_outer\"\r )\r \r # Remove redundant columns\r vars <- names(joinedDF3)\r varsToDrop <- c('AdjustedYear', 'AdjustedMonth', 'AdjustedDay', 'AdjustedHour', 'AirportID')\r varsToKeep <- vars[!(vars %in% varsToDrop)]\r joinedDF4 <- select(joinedDF3, varsToKeep)\r \r joinedDF5 <- rename(joinedDF4,\r                     VisibilityDest = joinedDF4$Visibility,\r                     DryBulbCelsiusDest = joinedDF4$DryBulbCelsius,\r                     DewPointCelsiusDest = joinedDF4$DewPointCelsius,\r                     RelativeHumidityDest = joinedDF4$RelativeHumidity,\r                     WindSpeedDest = joinedDF4$WindSpeed,\r                     AltimeterDest = joinedDF4$Altimeter\r                     )\r ```\r \r ## <a name=\"save-results-to-csv-for-exchange-with-scaler\"></a>将结果保存到 CSV 以便与 ScaleR 交换\r \r 至此，我们已完成了需要通过 SparkR 执行的联接。 将数据从最终的 Spark DataFrame“joinedDF5”保存到 CSV 以便输入到 ScaleR，并关闭 SparkR 会话。 需要明确告知 SparkR 要在 80 个不同的分区中保存生成的 CSV，以便在 ScaleR 处理过程中实现足够的并行度：\r \r ```\r logmsg('output the joined data from Spark to CSV') \r joinedDF5 <- repartition(joinedDF5, 80) # write.df below will produce this many CSVs\r \r # write result to directory of CSVs\r write.df(joinedDF5, file.path(dataDir, \"joined5Csv\"), \"com.databricks.spark.csv\", \"overwrite\", header = \"true\")\r \r # We can shut down the SparkR Spark context now\r sparkR.stop()\r \r # remove non-data files\r rxHadoopRemove(file.path(dataDir, \"joined5Csv/_SUCCESS\"))\r ```\r \r ## <a name=\"import-to-xdf-for-use-by-scaler\"></a>导入到 XDF 供 ScaleR 使用\r \r 我们本可以按现样将联接后的航班和天气数据的 CSV 文件用于通过 ScaleR 文本数据源的进行建模。 但是，我们首先将其导入到 XDF 中，因为对数据集运行多个操作时，它更为高效：\r \r ```\r logmsg('Import the CSV to compressed, binary XDF format') \r \r # set the Spark compute context for R Server \r rxSetComputeContext(sparkCC)\r rxGetComputeContext()\r \r colInfo <- list(\r   ArrDel15 = list(type=\"numeric\"),\r   Year = list(type=\"factor\"),\r   Month = list(type=\"factor\"),\r   DayofMonth = list(type=\"factor\"),\r   DayOfWeek = list(type=\"factor\"),\r   Carrier = list(type=\"factor\"),\r   OriginAirportID = list(type=\"factor\"),\r   DestAirportID = list(type=\"factor\"),\r   RelativeHumidityOrigin = list(type=\"numeric\"),\r   AltimeterOrigin = list(type=\"numeric\"),\r   DryBulbCelsiusOrigin = list(type=\"numeric\"),\r   WindSpeedOrigin = list(type=\"numeric\"),\r   VisibilityOrigin = list(type=\"numeric\"),\r   DewPointCelsiusOrigin = list(type=\"numeric\"),\r   RelativeHumidityDest = list(type=\"numeric\"),\r   AltimeterDest = list(type=\"numeric\"),\r   DryBulbCelsiusDest = list(type=\"numeric\"),\r   WindSpeedDest = list(type=\"numeric\"),\r   VisibilityDest = list(type=\"numeric\"),\r   DewPointCelsiusDest = list(type=\"numeric\")\r )\r \r joinedDF5Txt <- RxTextData(file.path(dataDir, \"joined5Csv\"),\r                            colInfo = colInfo, fileSystem = hdfsFS)\r rxGetInfo(joinedDF5Txt) \r \r destData <- RxXdfData(file.path(dataDir, \"joined5XDF\"), fileSystem = hdfsFS)\r \r rxImport(inData = joinedDF5Txt, destData, overwrite = TRUE)\r \r rxGetInfo(destData, getVarInfo = T)\r \r # File name: /user/RevoShare/dev/delayDataLarge/joined5XDF \r # Number of composite data files: 80 \r # Number of observations: 148619655 \r # Number of variables: 22 \r # Number of blocks: 320 \r # Compression type: zlib \r # Variable information: \r #   Var 1: ArrDel15, Type: numeric, Low/High: (0.0000, 1.0000)\r # Var 2: Year\r # 26 factor levels: 1987 1988 1989 1990 1991 ... 2008 2009 2010 2011 2012\r # Var 3: Month\r # 12 factor levels: 10 11 12 1 2 ... 5 6 7 8 9\r # Var 4: DayofMonth\r # 31 factor levels: 1 3 4 5 7 ... 29 30 2 18 31\r # Var 5: DayOfWeek\r # 7 factor levels: 4 6 7 1 3 2 5\r # Var 6: Carrier\r # 30 factor levels: PI UA US AA DL ... HA F9 YV 9E VX\r # Var 7: OriginAirportID\r # 374 factor levels: 15249 12264 11042 15412 13930 ... 13341 10559 14314 11711 10558\r # Var 8: DestAirportID\r # 378 factor levels: 13303 14492 10721 11057 13198 ... 14802 11711 11931 12899 10559\r # Var 9: CRSDepTime, Type: integer, Low/High: (0, 24)\r # Var 10: CRSArrTime, Type: integer, Low/High: (0, 2400)\r # Var 11: RelativeHumidityOrigin, Type: numeric, Low/High: (0.0000, 100.0000)\r # Var 12: AltimeterOrigin, Type: numeric, Low/High: (28.1700, 31.1600)\r # Var 13: DryBulbCelsiusOrigin, Type: numeric, Low/High: (-46.1000, 47.8000)\r # Var 14: WindSpeedOrigin, Type: numeric, Low/High: (0.0000, 81.0000)\r # Var 15: VisibilityOrigin, Type: numeric, Low/High: (0.0000, 90.0000)\r # Var 16: DewPointCelsiusOrigin, Type: numeric, Low/High: (-41.7000, 29.0000)\r # Var 17: RelativeHumidityDest, Type: numeric, Low/High: (0.0000, 100.0000)\r # Var 18: AltimeterDest, Type: numeric, Low/High: (28.1700, 31.1600)\r # Var 19: DryBulbCelsiusDest, Type: numeric, Low/High: (-46.1000, 53.9000)\r # Var 20: WindSpeedDest, Type: numeric, Low/High: (0.0000, 136.0000)\r # Var 21: VisibilityDest, Type: numeric, Low/High: (0.0000, 88.0000)\r # Var 22: DewPointCelsiusDest, Type: numeric, Low/High: (-43.0000, 29.0000)\r \r finalData <- RxXdfData(file.path(dataDir, \"joined5XDF\"), fileSystem = hdfsFS)\r \r ```\r \r ## <a name=\"splitting-data-for-training-and-test\"></a>拆分数据以供训练和测试\r \r 使用 rxDataStep 拆分 2012 年的数据以供测试，保留剩余的数据以供训练：\r \r ```\r # split out the training data\r \r logmsg('split out training data as all data except year 2012')\r trainDS <- RxXdfData( file.path(dataDir, \"finalDataTrain\" ),fileSystem = hdfsFS)\r \r rxDataStep( inData = finalData, outFile = trainDS,\r             rowSelection = ( Year != 2012 ), overwrite = T )\r \r # split out the testing data\r \r logmsg('split out the test data for year 2012') \r testDS <- RxXdfData( file.path(dataDir, \"finalDataTest\" ), fileSystem = hdfsFS)\r \r rxDataStep( inData = finalData, outFile = testDS,\r             rowSelection = ( Year == 2012 ), overwrite = T )\r \r rxGetInfo(trainDS)\r rxGetInfo(testDS)\r ```\r \r ## <a name=\"train-and-test-a-logistic-regression-model\"></a>训练并测试逻辑回归模型\r \r 现在可以构建模型了。 为了查看天气数据对抵达时间延迟的影响，我们使用了 ScaleR 的逻辑回归例程。 我们使用它来针对大于 15 分钟的抵达延迟是否受起飞和降落机场的天气影响进行建模：\r \r ```\r logmsg('train a logistic regression model for Arrival Delay > 15 minutes') \r formula <- as.formula(ArrDel15 ~ Year + Month + DayofMonth + DayOfWeek + Carrier +\r                      OriginAirportID + DestAirportID + CRSDepTime + CRSArrTime + \r                      RelativeHumidityOrigin + AltimeterOrigin + DryBulbCelsiusOrigin +\r                      WindSpeedOrigin + VisibilityOrigin + DewPointCelsiusOrigin + \r                      RelativeHumidityDest + AltimeterDest + DryBulbCelsiusDest +\r                      WindSpeedDest + VisibilityDest + DewPointCelsiusDest\r                    )\r \r # Use the scalable rxLogit() function but set max iterations to 3 for the purposes of \r # this exercise \r \r logitModel <- rxLogit(formula, data = trainDS, maxIterations = 3)\r \r base::summary(logitModel)\r ```\r \r 现在，让我们做出一些预测并查看 ROC 和 AUC，了解模型如何处理测试数据。\r \r ```\r # Predict over test data (Logistic Regression).\r \r logmsg('predict over the test data') \r logitPredict <- RxXdfData(file.path(dataDir, \"logitPredict\"), fileSystem = hdfsFS)\r \r # Use the scalable rxPredict() function\r \r rxPredict(logitModel, data = testDS, outData = logitPredict,\r           extraVarsToWrite = c(\"ArrDel15\"), \r           type = 'response', overwrite = TRUE)\r \r # Calculate ROC and Area Under the Curve (AUC).\r \r logmsg('calculate the roc and auc') \r logitRoc <- rxRoc(\"ArrDel15\", \"ArrDel15_Pred\", logitPredict)\r logitAuc <- rxAuc(logitRoc)\r head(logitAuc)\r logitAuc\r \r plot(logitRoc)\r ```\r \r ## <a name=\"scoring-elsewhere\"></a>在其他位置评分\r \r 我们还可以使用该模型在其他平台上为数据评分。 可以将数据保存到 RDS 文件，并将该 RDS 传输并导入到 SQL Server R Services 等目标评分环境。 请务必确保要评分的数据的系数级别与构建的模型上的级别匹配。 为实现此匹配，可以通过 ScaleR 的 `rxCreateColInfo()` 函数来提取并保存与建模数据关联的列信息，并将该列信息应用到输入数据源用于预测。 下面，我们将保存测试数据集的一些行，并在预测脚本中使用此示例中的列信息：\r \r ```\r # save the model and a sample of the test dataset \r \r logmsg('save serialized version of the model and a sample of the test data')\r rxSetComputeContext('localpar') \r saveRDS(logitModel, file = \"logitModel.rds\")\r testDF <- head(testDS, 1000)  \r saveRDS(testDF    , file = \"testDF.rds\"    )\r list.files()\r \r rxHadoopListFiles(file.path(inputDataDir,''))\r rxHadoopListFiles(dataDir)\r \r # stop the spark engine \r rxStopEngine(sparkCC) \r \r logmsg('Done.')\r elapsed <- (proc.time() - t0)[3]\r logmsg(paste('Elapsed time=',sprintf('%6.2f',elapsed),'(sec)\\n\\n'))\r ```\r \r ## <a name=\"summary\"></a>摘要\r \r 在本文中，我们展示了如何在 Hadoop Spark 中将用于数据操作的 SparkR 和用于模型开发的 ScaleR 配合使用。 本方案要求你维护单独的 Spark 会话（一次仅运行一个会话），并通过 CSV 文件交换数据。 尽管此过程现已相当简单直接，但在将来的 R Server 版本中将会更加简单，因为到时 SparkR 和 ScaleR 可以共享 Spark 会话，因而也能共享 Spark DataFrames。\r \r ## <a name=\"next-steps-and-more-information\"></a>后续步骤和详细信息\r \r - 有关使用 Spark 上的 R Server 的详细信息，请参阅 [MSDN 上的入门指南](https://msdn.microsoft.com/microsoft-r/scaler-spark-getting-started)\r \r - 有关 R Server 的一般信息，请参阅 [Get started with R](https://msdn.microsoft.com/microsoft-r/microsoft-r-get-started-node)（R 入门）一文。\r \r 有关 SparkR 的用法的详细信息，请参阅：\r \r - [Apache SparkR 文档](https://spark.apache.org/docs/2.1.0/sparkr.html)\r \r - [SparkR Overview](https://docs.databricks.com/spark/latest/sparkr/overview.html) （SparkR 概述）\r \r <!--Update_Description: update wording and link references-->"}