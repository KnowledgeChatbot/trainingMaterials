{"Title":"使用 C 将事件发送到 Azure 事件中心","Description":"使用 C 将事件发送到 Azure 事件中心","Content":"# <a name=\"send-events-to-azure-event-hubs-using-c\"></a>使用 C 将事件发送到 Azure 事件中心\r \r ## <a name=\"introduction\"></a>介绍\r 事件中心是一个高度可缩放的引入系统，每秒可引入数百万事件，从而使应用程序能够处理和分析连接的设备和应用程序所产生的海量数据。 将数据采集到事件中心后，可以使用任何实时分析提供程序或存储群集来转换和存储数据。\r \r 有关详细信息，请参阅 [事件中心概述][事件中心概述]。\r \r 在本教程中，将学习如何使用用 C 编写的控制台应用程序将事件发送到事件中心。若要接收事件，请单击左侧目录中的相应接收语言。\r \r 若要完成本教程，需要满足以下条件：\r \r * C 语言开发环境。 对于本教程，我们假定 gcc 堆栈在使用 Ubuntu 14.04 的 Azure Linux 虚拟机上。\r * [Microsoft Visual Studio](https://www.visualstudio.com/)。\r * 有效的 Azure 帐户。 如果没有帐户，可以创建一个试用帐户，只需几分钟即可完成。 有关详细信息，请参阅 [Azure 试用](https://www.azure.cn/pricing/1rmb-trial/)。\r \r ## <a name=\"send-messages-to-event-hubs\"></a>将消息发送到事件中心\r 在本部分中，我们将编写用于将事件发送到事件中心的 C 应用。 此代码使用 [Apache Qpid 项目](http://qpid.apache.org/)中的 Proton AMQP 库。 这类似于通过 C 将服务总线队列和主题与 AMQP 配合使用，如[此处](https://code.msdn.microsoft.com/Using-Apache-Qpid-Proton-C-afd76504)所示。 有关详细信息，请参阅 [Qpid Proton 文档](http://qpid.apache.org/proton/index.html)。\r \r 1. 在 [Qpid AMQP Messenger 页](https://qpid.apache.org/proton/messenger.html)中，根据具体的环境，按照说明安装 Qpid Proton。\r 2. 若要编译 Proton 库，请安装以下程序包：\r \r     ```shell\r     sudo apt-get install build-essential cmake uuid-dev openssl libssl-dev\r     ```\r 3. 下载 [Qpid Proton 库](http://qpid.apache.org/proton/index.html)并提取它，例如：\r \r     ```shell\r     wget http://archive.apache.org/dist/qpid/proton/0.7/qpid-proton-0.7.tar.gz\r     tar xvfz qpid-proton-0.7.tar.gz\r     ```\r 4. 创建生成目录、编译和安装：\r \r     ```shell\r     cd qpid-proton-0.7\r     mkdir build\r     cd build\r     cmake -DCMAKE_INSTALL_PREFIX=/usr ..\r     sudo make install\r     ```\r 5. 在工作目录中，创建一个包含以下代码的名为 sender.c 的新文件。 请记得替换事件中心名称和命名空间名称的值。 还必须用密钥的 URL 编码版本替换之前创建的 **SendRule**。 可以在 [此处](http://www.w3schools.com/tags/ref_urlencode.asp)对它进行 URL 编码。\r \r     ```c\r     #include \"proton/message.h\"\r     #include \"proton/messenger.h\"\r \r     #include <getopt.h>\r     #include <proton/util.h>\r     #include <sys/time.h>\r     #include <stddef.h>\r     #include <stdio.h>\r     #include <string.h>\r     #include <unistd.h>\r     #include <stdlib.h>\r \r     #define check(messenger)\r       {\r         if(pn_messenger_errno(messenger))\r         {\r           printf(\"check\\n\");\r           die(__FILE__, __LINE__, pn_error_text(pn_messenger_error(messenger)));\r         }\r       }\r \r     pn_timestamp_t time_now(void)\r     {\r       struct timeval now;\r       if (gettimeofday(&now, NULL)) pn_fatal(\"gettimeofday failed\\n\");\r       return ((pn_timestamp_t)now.tv_sec) * 1000 + (now.tv_usec / 1000);\r     }  \r \r     void die(const char *file, int line, const char *message)\r     {\r       printf(\"Dead\\n\");\r       fprintf(stderr, \"%s:%i: %s\\n\", file, line, message);\r       exit(1);\r     }\r \r     int sendMessage(pn_messenger_t * messenger) {\r         char * address = (char *) \"amqps://{SAS Key Name}:{SAS key}@{namespace name}.servicebus.chinacloudapi.cn/{event hub name}\";\r         char * msgtext = (char *) \"Hello from C!\";\r \r         pn_message_t * message;\r         pn_data_t * body;\r         message = pn_message();\r \r         pn_message_set_address(message, address);\r         pn_message_set_content_type(message, (char*) \"application/octect-stream\");\r         pn_message_set_inferred(message, true);\r \r         body = pn_message_body(message);\r         pn_data_put_binary(body, pn_bytes(strlen(msgtext), msgtext));\r \r         pn_messenger_put(messenger, message);\r         check(messenger);\r         pn_messenger_send(messenger, 1);\r         check(messenger);\r \r         pn_message_free(message);\r     }\r \r     int main(int argc, char** argv) {\r         printf(\"Press Ctrl-C to stop the sender process\\n\");\r \r         pn_messenger_t *messenger = pn_messenger(NULL);\r         pn_messenger_set_outgoing_window(messenger, 1);\r         pn_messenger_start(messenger);\r \r         while(true) {\r             sendMessage(messenger);\r             printf(\"Sent message\\n\");\r             sleep(1);\r         }\r \r         // release messenger resources\r         pn_messenger_stop(messenger);\r         pn_messenger_free(messenger);\r \r         return 0;\r     }\r     ```\r 6. 使用 **gcc**编译该文件：\r \r     ```\r     gcc sender.c -o sender -lqpid-proton\r     ```\r \r     > [!NOTE]\r     > 在此代码中，我们使用传出窗口 1 以强制尽快发出消息。 通常，应用程序应尝试批处理消息，以提高吞吐量。 请参阅 [Qpid AMQP Messenger 页](https://qpid.apache.org/proton/messenger.html)，了解如何在此环境及其他环境中以及从为其提供了绑定的平台（目前为 Perl、PHP、Python 和 Ruby）中使用 Qpid Proton 库。\r \r ## <a name=\"next-steps\"></a>后续步骤\r 访问以下链接可以了解有关事件中心的详细信息：\r \r * [事件中心概述](event-hubs-what-is-event-hubs.md)\r * [创建事件中心](event-hubs-create.md)\r * [事件中心常见问题](event-hubs-faq.md)\r \r <!-- Images. -->\r [21]: ./media/event-hubs-c-ephcs-getstarted/run-csharp-ephcs1.png\r [24]: ./media/event-hubs-c-ephcs-getstarted/receive-eph-c.png\r \r <!--Update_Description: update meta properties, wording update -->"}