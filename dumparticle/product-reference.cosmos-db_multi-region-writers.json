{"Title":"使用 Azure Cosmos DB 的多主数据库体系结构","Description":"了解如何使用 Azure Cosmos DB 来设计可实现跨多个地理区域进行本地读取和写入的应用程序结构。","Content":"# 使用 Azure Cosmos DB 多主机全局复制数据库体系结构\r <a name=\"multi-master-globally-replicated-database-architectures-with-azure-cosmos-db\" ></a>\r Azure Cosmos DB 支持统包的[全局复制](distribute-data-globally.md)，允许在工作负荷中的任意位置以低延迟的访问将数据分布到多个区域。 此模型常用于发布者/使用者工作负荷。在这些工作负荷中，单个地理区域包含一个作者，其他（读取）区域包含分布于多个区域的读者。 \r <!-- Notice: 全球 to 多个区域 -->\r \r 还可以使用 Azure Cosmos DB 的全局复制支持来构建作者和读者分布于多个区域的应用程序。 本文档概述一种使用 Azure Cosmos DB 为多个区域分布的作者实现本地写入和本地读取访问的模式。\r <!-- Notice: 全球 to 多个区域 -->\r \r ## <a name=\"ExampleScenario\"></a>内容发布 - 示例方案\r 让我们借助一个真实的方案，介绍如何在 Azure Cosmos DB 中使用全局分布式多区域/多主读写模式。 假设已在 Azure Cosmos DB 上构建一个内容发布平台。 为了向发布者和使用者提供良好的用户体验，此平台必须满足一些要求。\r \r * 作者和订户遍布各个区域\r * 作者必须将文章发布（写入）到本地（最近的）区域\r * 作者的文章拥有遍布各个区域的读者/订户。 \r * 新文章发布时，订户应会收到通知。\r * 订户必须能从本地区域阅读文章。 订户还应能对这些文章添加评论。 \r * 包括文章作者在内的任何人都应能在本地区域查看文章所附的所有评论。 \r <!-- Notice: 全球 to 各个区域 -->\r \r 假设存在数百万的使用者和发布者以及数十亿篇文章，我们很快就必须面对扩展以及保证访问位置的问题。 与大多数可伸缩性问题一样，解决方案在于良好的分区策略。 接下来，让我们看看如何将文章、评论和通知作为文档建模、配置 Azure Cosmos DB 帐户以及实现数据访问层。 \r \r 若要了解有关分区和分区键的详细信息，请参阅 [Azure Cosmos DB 中的分区和缩放](partition-data.md)。\r \r ## <a name=\"ModelingNotifications\"></a>为通知建模\r 通知是特定于用户的数据馈送。 因此，通知文档的访问模式始终发生在单个用户的上下文中。 例如，可以“向某个用户发布通知”或“为某个给定用户获取所有通知”。 因此，对于此类型，分区键的最佳选择是 `UserId`。\r \r     class Notification \r     { \r         // Unique ID for Notification. \r         public string Id { get; set; }\r \r         // The user Id for which notification is addressed to. \r         public string UserId { get; set; }\r \r         // The partition Key for the resource. \r         public string PartitionKey \r         { \r             get \r             { \r                 return this.UserId; \r             }\r         }\r \r         // Subscription for which this notification is raised. \r         public string SubscriptionFilter { get; set; }\r \r         // Subject of the notification. \r         public string ArticleId { get; set; } \r     }\r \r ## <a name=\"ModelingSubscriptions\"></a>为订阅建模\r 订阅可以根据各种标准创建，如感兴趣的特定类别的文章或特定的发布者。 因此， `SubscriptionFilter` 是很好的分区键选择。\r \r     class Subscriptions \r     { \r         // Unique ID for Subscription \r         public string Id { get; set; }\r \r         // Subscription source. Could be Author | Category etc. \r         public string SubscriptionFilter { get; set; }\r \r         // subscribing User. \r         public string UserId { get; set; }\r \r         public string PartitionKey \r         { \r             get \r             { \r                 return this.SubscriptionFilter; \r             } \r         } \r     }\r \r ## <a name=\"ModelingArticles\"></a>为文章建模\r 通过通知标识一篇文章后，后续查询通常基于 `Article.Id`。 选择 `Article.Id` 作为分区键将为在 Azure Cosmos DB 集合内存储文章提供最佳分布。 \r \r     class Article \r     { \r         // Unique ID for Article \r         public string Id { get; set; }\r \r         public string PartitionKey \r         { \r             get \r             { \r                 return this.Id; \r             } \r         }\r \r         // Author of the article\r         public string Author { get; set; }\r \r         // Category/genre of the article\r         public string Category { get; set; }\r \r         // Tags associated with the article\r         public string[] Tags { get; set; }\r \r         // Title of the article\r         public string Title { get; set; }\r \r         //... \r     }\r \r ## <a name=\"ModelingReviews\"></a>为评论建模\r 和文章一样，评论通常在文章上下文中写入和读取。 选择 `ArticleId` 作为分区键将为与文章相关的评论提供最佳分布和高效访问。 \r \r     class Review \r     { \r         // Unique ID for Review \r         public string Id { get; set; }\r \r         // Article Id of the review \r         public string ArticleId { get; set; }\r \r         public string PartitionKey \r         { \r             get \r             { \r                 return this.ArticleId; \r             } \r         }\r \r         //Reviewer Id \r         public string UserId { get; set; }\r         public string ReviewText { get; set; }\r \r         public int Rating { get; set; } }\r     }\r \r ## <a name=\"DataAccessMethods\"></a>数据访问层方法\r 现在让我们看看需要实现的主要数据访问方法。 以下是 `ContentPublishDatabase` 需要的方法列表：\r \r     class ContentPublishDatabase \r     { \r         public async Task CreateSubscriptionAsync(string userId, string category);\r \r         public async Task<IEnumerable<Notification>> ReadNotificationFeedAsync(string userId);\r \r         public async Task<Article> ReadArticleAsync(string articleId);\r \r         public async Task WriteReviewAsync(string articleId, string userId, string reviewText, int rating);\r \r         public async Task<IEnumerable<Review>> ReadReviewsAsync(string articleId); \r     }\r \r ## <a name=\"Architecture\"></a>Azure Cosmos DB 帐户配置\r 若要保证本地读取和写入，数据分区不仅要基于分区键，还要基于不同区域的地理访问模式。 该模型依赖于每个区域具有异地复制的 Azure Cosmos DB 数据库帐户。 例如，对于两个区域，具有针对多区域写入的设置：\r \r | 帐户名 | 写入区域 | 读取区域 |\r | --- | --- | --- |\r | `contentpubdatabase-usa.documents.azure.cn` | `China North` |`China North` |\r | `contentpubdatabase-europe.documents.azure.cn` | `China North` |`China North` |\r \r 下图显示如何在使用此设置的典型应用程序中执行读取和写入：\r \r ![Azure Cosmos DB 多主体系结构](./media/multi-region-writers/multi-master.png)\r \r 以下代码片段演示如何在 `China North` 区域中运行的 DAL 中初始化客户端。\r \r     ConnectionPolicy writeClientPolicy = new ConnectionPolicy { ConnectionMode = ConnectionMode.Direct, ConnectionProtocol = Protocol.Tcp };\r     writeClientPolicy.PreferredLocations.Add(LocationNames.ChinaNorth);\r     writeClientPolicy.PreferredLocations.Add(LocationNames.NorthEurope);\r \r     DocumentClient writeClient = new DocumentClient(\r         new Uri(\"https://contentpubdatabase-usa.documents.azure.cn\"), \r         writeRegionAuthKey,\r         writeClientPolicy);\r \r     ConnectionPolicy readClientPolicy = new ConnectionPolicy { ConnectionMode = ConnectionMode.Direct, ConnectionProtocol = Protocol.Tcp };\r     readClientPolicy.PreferredLocations.Add(LocationNames.NorthEurope);\r     readClientPolicy.PreferredLocations.Add(LocationNames.ChinaNorth);\r \r     DocumentClient readClient = new DocumentClient(\r         new Uri(\"https://contentpubdatabase-europe.documents.azure.cn\"),\r         readRegionAuthKey,\r         readClientPolicy);\r \r 通过上述设置，数据访问层可以根据其部署位置将所有写入转发到本地帐户。 通过从两个帐户读取来执行读取以获得数据的全局视图。 这种方法可以扩展到所需的任意多个区域。 例如，以下是三个地理区域的设置：\r \r | 帐户名 | 写入区域 | 读取区域 1 | 读取区域 2 |\r | --- | --- | --- | --- |\r | `contentpubdatabase-usa.documents.azure.cn` | `China North` |`China North` |`China North` |\r | `contentpubdatabase-europe.documents.azure.cn` | `China North` |`China North` |`China North` |\r | `contentpubdatabase-asia.documents.azure.cn` | `China North` |`China North` |`China North` |\r \r ## <a name=\"DataAccessImplementation\"></a>数据访问层实现\r 现在让我们看一下如何实现具有两个可写区域的应用程序的数据访问层 (DAL)。 DAL 必须执行以下步骤：\r \r * 为每个帐户创建多个 `DocumentClient` 实例。 在两个区域的情况下，每个 DAL 实例具有 1 个 `writeClient` 和 1 个 `readClient`。 \r * 根据应用程序的部署区域来配置 `writeclient` 和 `readClient` 的终结点。 例如，部署在 `China North` 中的 DAL 使用 `contentpubdatabase-usa.documents.azure.cn` 进行写入。 部署在 `NorthEurope` 中的 DAL 使用 `contentpubdatabase-europ.documents.azure.cn` 进行写入。\r \r 通过上述设置，可以实现数据访问方法。 写入操作将写入转发到相应的 `writeClient`。\r \r     public async Task CreateSubscriptionAsync(string userId, string category)\r     {\r         await this.writeClient.CreateDocumentAsync(this.contentCollection, new Subscriptions\r         {\r             UserId = userId,\r             SubscriptionFilter = category\r         });\r     }\r \r     public async Task WriteReviewAsync(string articleId, string userId, string reviewText, int rating)\r     {\r         await this.writeClient.CreateDocumentAsync(this.contentCollection, new Review\r         {\r             UserId = userId,\r             ArticleId = articleId,\r             ReviewText = reviewText,\r             Rating = rating\r         });\r     }\r \r 若要读取通知和评论，必须从两个区域读取并合并结果，如以下代码片段所示：\r \r     public async Task<IEnumerable<Notification>> ReadNotificationFeedAsync(string userId)\r     {\r         IDocumentQuery<Notification> writeAccountNotification = (\r             from notification in this.writeClient.CreateDocumentQuery<Notification>(this.contentCollection) \r             where notification.UserId == userId \r             select notification).AsDocumentQuery();\r \r         IDocumentQuery<Notification> readAccountNotification = (\r             from notification in this.readClient.CreateDocumentQuery<Notification>(this.contentCollection) \r             where notification.UserId == userId \r             select notification).AsDocumentQuery();\r \r         List<Notification> notifications = new List<Notification>();\r \r         while (writeAccountNotification.HasMoreResults || readAccountNotification.HasMoreResults)\r         {\r             IList<Task<FeedResponse<Notification>>> results = new List<Task<FeedResponse<Notification>>>();\r \r             if (writeAccountNotification.HasMoreResults)\r             {\r                 results.Add(writeAccountNotification.ExecuteNextAsync<Notification>());\r             }\r \r             if (readAccountNotification.HasMoreResults)\r             {\r                 results.Add(readAccountNotification.ExecuteNextAsync<Notification>());\r             }\r \r             IList<FeedResponse<Notification>> notificationFeedResult = await Task.WhenAll(results);\r \r             foreach (FeedResponse<Notification> feed in notificationFeedResult)\r             {\r                 notifications.AddRange(feed);\r             }\r         }\r         return notifications;\r     }\r \r     public async Task<IEnumerable<Review>> ReadReviewsAsync(string articleId)\r     {\r         IDocumentQuery<Review> writeAccountReviews = (\r             from review in this.writeClient.CreateDocumentQuery<Review>(this.contentCollection) \r             where review.ArticleId == articleId \r             select review).AsDocumentQuery();\r \r         IDocumentQuery<Review> readAccountReviews = (\r             from review in this.readClient.CreateDocumentQuery<Review>(this.contentCollection) \r             where review.ArticleId == articleId \r             select review).AsDocumentQuery();\r \r         List<Review> reviews = new List<Review>();\r \r         while (writeAccountReviews.HasMoreResults || readAccountReviews.HasMoreResults)\r         {\r             IList<Task<FeedResponse<Review>>> results = new List<Task<FeedResponse<Review>>>();\r \r             if (writeAccountReviews.HasMoreResults)\r             {\r                 results.Add(writeAccountReviews.ExecuteNextAsync<Review>());\r             }\r \r             if (readAccountReviews.HasMoreResults)\r             {\r                 results.Add(readAccountReviews.ExecuteNextAsync<Review>());\r             }\r \r             IList<FeedResponse<Review>> notificationFeedResult = await Task.WhenAll(results);\r \r             foreach (FeedResponse<Review> feed in notificationFeedResult)\r             {\r                 reviews.AddRange(feed);\r             }\r         }\r \r         return reviews;\r     }\r \r 因此，通过选择合适的分区键和静态的基于帐户的分区，可以使用 Azure Cosmos DB 实现多区域本地写入和读取。\r \r ## <a name=\"NextSteps\"></a>后续步骤\r 本文以内容发布作为示例方案，介绍如何通过 Azure Cosmos DB 使用全局分布式多区域读写模式。\r \r * 了解 Azure Cosmos DB 如何支持 [全局分布](distribute-data-globally.md)\r * 了解 [Azure Cosmos DB 中的自动和手动故障转移](regional-failover.md)\r * 了解 [Azure Cosmos DB 的全局一致性](consistency-levels.md)\r * 使用 [Azure Cosmos DB - DocumentDB API](tutorial-global-distribution-documentdb.md) 通过多个区域进行开发\r * 使用 [Azure Cosmos DB - MongoDB API](tutorial-global-distribution-MongoDB.md) 通过多个区域进行开发\r * 使用 [Azure Cosmos DB - 表 API](tutorial-global-distribution-table.md) 通过多个区域进行开发"}