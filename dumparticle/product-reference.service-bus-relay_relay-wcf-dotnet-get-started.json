{"Title":".NET 中的 Azure Relay WCF 中继入门","Description":"了解如何使用 Azure Relay WCF 中继连接两个托管于不同位置的应用程序。","Content":"# <a name=\"how-to-use-azure-relay-wcf-relays-with-net\"></a>如何将 Azure Relay WCF 中继与 .NET 配合使用\r 本文介绍如何使用服务总线中继服务。 相关示例用 C# 编写并使用服务总线程序集中包含的 Windows Communication Foundation (WCF) API 及扩展。 有关服务总线中继的详细信息，请参阅 [Azure 中继概述](./relay-what-is-it.md)。\r \r [!INCLUDE [create-account-note](../../includes/create-account-note.md)]\r \r ## <a name=\"what-is-service-bus-wcf-relay\"></a>什么是服务总线 WCF 中继？\r 通过 Azure 服务总线 WCF [中继](./relay-what-is-it.md)服务，可构建在 Azure 数据中心和自己的本地企业环境中运行的混合应用程序。 服务总线中继可简化这一过程，它允许你安全地向公有云公开位于企业网络内的 Windows Communication Foundation (WCF) 服务，而无需打开防火墙连接，也无需对企业网络基础结构进行彻底的更改。\r \r ![WCF 中继概念](./media/service-bus-dotnet-how-to-use-relay/sb-relay-01.png)\r \r 服务总线中继可用于在现有企业环境中托管 WCF 服务。 然后，你可以将侦听传入会话和请求这些 WCF 服务的任务委托给在 Azure 内运行的服务总线服务。 这使你能够向 Azure 中运行的应用程序代码或者向移动工作者或 Extranet 合作伙伴环境公开这些服务。 服务总线允许你精确、安全地控制谁可以访问这些服务。 它提供了一种强大且安全的方式，从你的现有企业解决方案公开应用程序功能和数据并从云中利用这些功能和数据。\r \r 本文探讨如何使用服务总线中继创建 WCF Web 服务，并使用可实现双方之间安全对话的 TCP 通道绑定公开该服务。\r \r [!INCLUDE [service-bus-create-namespace-portal](../../includes/service-bus-create-namespace-portal.md)]\r \r ## <a name=\"get-the-service-bus-nuget-package\"></a>获取服务总线 NuGet 包\r [服务总线 NuGet 包](https://www.nuget.org/packages/WindowsAzure.ServiceBus) 是获取服务总线 API 并为应用程序配置所有服务总线依赖项的最简单的方法。 若要在项目中安装 NuGet 包，请执行以下操作：\r \r 1. 在“解决方案资源管理器”中，右键单击“引用”，然后单击“管理 NuGet 包”。\r 2. 搜索“服务总线”并选择“Microsoft Azure 服务总线”项。 **安装** ”以完成安装，然后关闭以下对话框：\r    \r    ![](./media/service-bus-dotnet-how-to-use-relay/getting-started-multi-tier-13.png)\r \r ## <a name=\"use-service-bus-to-expose-and-consume-a-soap-web-service-with-tcp\"></a>使用服务总线通过 TCP 公开和使用 SOAP Web 服务\r 若要公开现有 WCF SOAP Web 服务以供外部使用，你必须更改服务绑定和地址。 这可能需要更改你的配置文件或者可能需要更改代码，具体取决于你如何设置和配置 WCF 服务。 请注意，WCF 允许你对同一服务使用多个网络终结点，因此你可以在添加服务总线终结点以便进行外部访问的同时保留现有内部终结点。\r \r 在此任务中，你将构建一个简单的 WCF 服务并向其添加服务总线侦听程序。 此练习假定你熟悉 Visual Studio，因此不演练创建项目的所有详细信息， 而是侧重于代码。\r \r 在开始执行这些步骤之前，请完成以下过程以设置你的环境：\r \r 1. 在 Visual Studio 中，在解决方案内创建一个包含以下两个项目的控制台应用程序：“客户端”和“服务”。\r 2. 向这两个项目添加 Microsoft Azure Service Bus NuGet 包。 此程序包将向项目添加所有必需的程序集引用。\r \r ### <a name=\"how-to-create-the-service\"></a>如何创建服务\r 首先，创建该服务本身。 任何 WCF 服务都包含至少三个不同部分：\r \r * 描述交换哪些信息以及将调用哪些操作的协定的定义。\r * 上述协定的实施方案。\r * 托管 WCF 服务并公开多个终结点的主机。\r \r 本部分中的代码示例涵盖了其中的每个组成部分。\r \r 协定定义用于添加两个数字并返回相应结果的单个操作 `AddNumbers`。 `IProblemSolverChannel` 接口使客户端能够更轻松地管理代理生存期。 创建这样一个接口被认为是最佳实践。 最好将此协定定义放入单独的文件中，以便可从你的“客户端”和“服务”两个项目中引用该文件，但也可以将代码复制到这两个项目中。\r \r ```csharp\r using System.ServiceModel;\r \r [ServiceContract(Namespace = \"urn:ps\")]\r interface IProblemSolver\r {\r     [OperationContract]\r     int AddNumbers(int a, int b);\r }\r \r interface IProblemSolverChannel : IProblemSolver, IClientChannel {}\r ```\r \r 协定到位后，实施起来就很简单了。\r \r ```csharp\r class ProblemSolver : IProblemSolver\r {\r     public int AddNumbers(int a, int b)\r     {\r         return a + b;\r     }\r }\r ```\r \r ### <a name=\"configure-a-service-host-programmatically\"></a>以编程方式配置服务主机\r 协定和实施完成后，你现在就可以托管服务了。 托管发生在 [System.ServiceModel.ServiceHost](https://msdn.microsoft.com/library/system.servicemodel.servicehost.aspx) 对象内，该对象负责管理服务实例并托管侦听消息的终结点。 以下代码使用常规的本地终结点和服务总线终结点配置服务，以便并列展示内部和外部终结点的外观。 将字符串 namespace 替换为命名空间名称，并将 yourKey 替换为前面的设置步骤中获取的 SAS 密钥。\r \r ```csharp\r ServiceHost sh = new ServiceHost(typeof(ProblemSolver));\r \r sh.AddServiceEndpoint(\r    typeof (IProblemSolver), new NetTcpBinding(),\r    \"net.tcp://localhost:9358/solver\");\r \r sh.AddServiceEndpoint(\r    typeof(IProblemSolver), new NetTcpRelayBinding(),\r    ServiceBusEnvironment.CreateServiceUri(\"sb\", \"namespace\", \"solver\"))\r     .Behaviors.Add(new TransportClientEndpointBehavior {\r           TokenProvider = TokenProvider.CreateSharedAccessSignatureTokenProvider(\"RootManageSharedAccessKey\", \"<yourKey>\")});\r \r sh.Open();\r \r Console.WriteLine(\"Press ENTER to close\");\r Console.ReadLine();\r \r sh.Close();\r ```\r \r 在本示例中，你将创建两个位于同一协定实施中的终结点。 一个是本地的，一个通过服务总线进行投影。 两者之间的主要区别是绑定；本地终结点使用 [NetTcpBinding](https://msdn.microsoft.com/library/system.servicemodel.nettcpbinding.aspx)，而服务总线终结点和地址使用 [NetTcpRelayBinding](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.nettcprelaybinding#microsoft_servicebus_nettcprelaybinding)。 本地终结点有一个使用不同端口的本地网络地址。 服务总线终结点有一个由字符串 `sb`、你的命名空间名称、路径“solver”组成的终结点地址。 这将生成 URI `sb://[serviceNamespace].servicebus.chinacloudapi.cn/solver`，将服务终结点标识为具有完全限定的外部 DNS 名称的服务总线 TCP 终结点。 如果将替换占位符的代码放入`Main`服务**应用程序的**  函数中，则会获得功能服务。 如果你希望你的服务专门侦听服务总线，请删除本地终结点声明。\r \r ### <a name=\"configure-a-service-host-in-the-appconfig-file\"></a>在 App.config 文件中配置服务主机\r 你还可以使用 App.config 文件配置主机。 在此情况下，服务托管代码如以下示例所示。\r \r ```csharp\r ServiceHost sh = new ServiceHost(typeof(ProblemSolver));\r sh.Open();\r Console.WriteLine(\"Press ENTER to close\");\r Console.ReadLine();\r sh.Close();\r ```\r \r 终结点定义将移到 App.config 文件中。 NuGet 包已向 App.config 文件添加一系列定义，这些定义是服务总线必需的配置扩展。 以下示例（与前面的代码完全等效）应该紧靠在 **system.serviceModel** 元素的下面。 此代码示例假设项目 C# 命名空间名命名为“Service”。\r 将占位符替换为你的服务总线服务命名空间和密钥。\r \r ```xml\r <services>\r     <service name=\"Service.ProblemSolver\">\r         <endpoint contract=\"Service.IProblemSolver\"\r                   binding=\"netTcpBinding\"\r                   address=\"net.tcp://localhost:9358/solver\"/>\r         <endpoint contract=\"Service.IProblemSolver\"\r                   binding=\"netTcpRelayBinding\"\r                   address=\"sb://namespace.servicebus.chinacloudapi.cn/solver\"\r                   behaviorConfiguration=\"sbTokenProvider\"/>\r     </service>\r </services>\r <behaviors>\r     <endpointBehaviors>\r         <behavior name=\"sbTokenProvider\">\r             <transportClientEndpointBehavior>\r                 <tokenProvider>\r                     <sharedAccessSignature keyName=\"RootManageSharedAccessKey\" key=\"<yourKey>\" />\r                 </tokenProvider>\r             </transportClientEndpointBehavior>\r         </behavior>\r     </endpointBehaviors>\r </behaviors>\r ```\r \r 进行这些更改后，该服务将像以前一样启动，但具有两个活动终结点：一个位于本地，一个在云中侦听。\r \r ### <a name=\"create-the-client\"></a>创建客户端\r #### <a name=\"configure-a-client-programmatically\"></a>以编程方式配置客户端\r 若要使用该服务，你可以使用 [ChannelFactory](https://msdn.microsoft.com/library/system.servicemodel.channelfactory.aspx) 对象构造 WCF 客户端。 服务总线使用通过 ACS 实现的基于令牌的安全模型。 [TokenProvider](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.tokenprovider) 类代表具有内置工厂方法的安全令牌提供程序，这些方法可返回一些众所周知的令牌提供程序。 以下示例使用 [CreateSharedAccessSignatureTokenProvider](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) 方法处理相应 SAS 令牌的获取。 名称和密钥是根据上一部分所述从门户获取的凭据。\r \r 首先，在你的客户端项目中引用服务中的 `IProblemSolver` 约定代码或将其复制到你的客户端项目中。\r \r 然后，替换客户端的 `Main` 方法中的代码，再次将占位符文本替换为服务总线命名空间和 SAS 密钥。\r \r ```csharp\r var cf = new ChannelFactory<IProblemSolverChannel>(\r     new NetTcpRelayBinding(),\r     new EndpointAddress(ServiceBusEnvironment.CreateServiceUri(\"sb\", \"namespace\", \"solver\")));\r \r cf.Endpoint.Behaviors.Add(new TransportClientEndpointBehavior\r             { TokenProvider = TokenProvider.CreateSharedAccessSignatureTokenProvider(\"RootManageSharedAccessKey\",\"<yourKey>\") });\r \r using (var ch = cf.CreateChannel())\r {\r     Console.WriteLine(ch.AddNumbers(4, 5));\r }\r ```\r \r 现在可以生成客户端和服务，运行它们（首先运行服务），客户端将调用该服务并输出 **9**。 你可以在不同计算机上，甚至跨网络运行客户端和服务器，通信仍将进行。 客户端代码还可以在云中或在本地运行。\r \r #### <a name=\"configure-a-client-in-the-appconfig-file\"></a>在 App.config 文件中配置客户端\r 以下代码介绍了如何使用 App.config 文件配置客户端。\r \r ```csharp\r var cf = new ChannelFactory<IProblemSolverChannel>(\"solver\");\r using (var ch = cf.CreateChannel())\r {\r     Console.WriteLine(ch.AddNumbers(4, 5));\r }\r ```\r \r 终结点定义将移到 App.config 文件中。 以下示例（与前面列出的代码相同）应紧接在 `<system.serviceModel>` 元素下面。 在此，与之前一样，你必须将占位符替换为服务总线命名空间和 SAS 密钥。\r \r ```xml\r <client>\r     <endpoint name=\"solver\" contract=\"Service.IProblemSolver\"\r               binding=\"netTcpRelayBinding\"\r               address=\"sb://namespace.servicebus.chinacloudapi.cn/solver\"\r               behaviorConfiguration=\"sbTokenProvider\"/>\r </client>\r <behaviors>\r     <endpointBehaviors>\r         <behavior name=\"sbTokenProvider\">\r             <transportClientEndpointBehavior>\r                 <tokenProvider>\r                     <sharedAccessSignature keyName=\"RootManageSharedAccessKey\" key=\"<yourKey>\" />\r                 </tokenProvider>\r             </transportClientEndpointBehavior>\r         </behavior>\r     </endpointBehaviors>\r </behaviors>\r ```\r \r ## <a name=\"next-steps\"></a>后续步骤\r 现已了解有关服务总线中继的基础知识，请单击以下链接了解详细信息。\r \r * [什么是 Azure 中继？](./relay-what-is-it.md)\r * [Azure 服务总线体系结构概述](../service-bus-messaging/service-bus-fundamentals-hybrid-solutions.md)\r * 从 [Azure 示例][Azure samples]下载服务总线示例，或参阅[服务总线示例概述][overview of Service Bus samples]。\r \r [Azure samples]: https://code.msdn.microsoft.com/site/search?query=service%20bus&f%5B0%5D.Value=service%20bus&f%5B0%5D.Type=SearchText&ac=2\r [overview of Service Bus samples]: ../service-bus-messaging/service-bus-samples.md\r "}