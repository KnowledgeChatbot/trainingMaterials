{"Title":"Azure 服务总线消息会话","Description":"使用会话处理一系列 Azure 服务总线消息。","Content":"# <a name=\"message-sessions--first-in-first-out-fifo\"></a>消息会话/先进先出 (FIFO) \r \r 使用服务总线会话，可以连贯有序的方式处理一系列无限多的相关消息。 若要在服务总线中实现 FIFO 保证，必须使用会话。 服务总线没有规定消息之间的关系性质，也没有定义用于确定消息序列开始或结束位置的特定模型。\r \r 任何发送程序都可以在将消息提交到主题或队列时创建会话，方法是将 [SessionId](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId) 中转站属性设置为会话专属的由应用程序定义的某标识符。 在 AMQP 1.0 协议一级，此值映射到 group-id 属性。\r \r 在会话感知队列或订阅中，如果有至少一个消息包含会话的 [SessionId](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId)，会话就诞生了。 一旦会话诞生，就没有规定会话何时过期或消失的已定义时间或 API。 理论上讲，服务总线认为，今天可以针对会话接收的消息，与一年时间内 SessionId 相同的下一个消息使用的会话是相同的。\r \r 然而，通常情况下，应用程序都会明确指明一组相关消息的开始和结束位置；但服务总线没有设置任何具体规则。\r \r 例如，若要有意设置文件的传输序列，请将第一个、中间一个和最后一个消息的 Label 属性分别设置为 start、content 和 end。 content 消息相对位置的计算方式为，当前消息的 SequenceNumber 与 start 消息的 SequenceNumber 的增量值。\r \r 借助服务总线中的会话功能，可以 C# 和 Java API 编写的 [MessageSession](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.messagesession) 形式执行特定接收操作。 可以通过 Azure 资源管理器或在门户中设置标志，为队列或订阅设置 [requiresSession](https://docs.microsoft.com/en-us/azure/templates/microsoft.servicebus/namespaces/queues#property-values) 属性，从而启用此功能。 若要尝试执行相关 API 操作，必须启用此功能。\r \r 在门户中，选中下图中展示的复选框，即可设置标志：\r \r ![][2]\r \r 会话 API 存在于队列和订阅客户端上。 可以使用一个命令性模型，控制会话和消息的接收时间；还可以使用一个基于处理程序的模型（类似于 OnMessage），此模型简化了接收循环的管理操作。\r \r ## <a name=\"session-features\"></a>会话功能\r \r 会话支持对交错消息流进行并发解多路复用，同时保留和保证有序传递。\r \r ![][1]\r \r [MessageSession](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.messagesession) 接收程序是由接受会话的客户端创建。 客户端以命令性方式调用 C# 编写的 [QueueClient.AcceptMessageSession](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesession#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSession) 或 [QueueClient.AcceptMessageSessionAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesessionasync#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSessionAsync)。 在反应回调模型中，它会注册会话处理程序，如后面所述。\r \r 当 [MessageSession](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.messagesession) 被接受同时由客户端保留时，此客户端会对队列或订阅中包含相应会话的 [SessionId](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.messagesession.sessionid?view=azureservicebus-4.1.1#Microsoft_ServiceBus_Messaging_MessageSession_SessionId) 的所有消息，以及在会话保留期间仍在到达且包含相应 SessionId 的所有消息一直施加排他锁。\r \r 调用 Close 或 CloseAsync 时，或当锁定期满导致应用程序无法这样做时，将会解除锁定。 应将会话锁定视为对文件施加的排他锁。也就是说，应用程序应在不再需要它时和/或不需要再处理其他任何消息时关闭会话。\r \r 当多个并发接收程序从队列中拉取消息时，属于特定会话的消息会被分派到当前让相应会话一直处于锁定状态的特定接收程序。 通过此操作，驻留在一个队列或订阅中的交错消息流可以明确解多路复用到各个接收程序，这些接收程序也可以驻留在不同的客户端计算机上，因为锁定管理是在服务总线内的服务端执行。\r \r 不过，队列仍是队列，无法进行随机访问。 如果多个并发接收程序等待接受特定会话，或等待来自特定会话的消息，并且队列顶部有一个消息属于尚未声明接收程序的会话，那么只有在会话接收程序声明相应会话后，才会开始传递。\r \r 上图展示了三个并发会话接收程序，它们全都必须主动从每个接收程序的队列中拉取消息，才能取得进展。 上图中 SessionId=4 的会话无有效的负责客户端。也就是说，在新建的负责会话接收程序接收此消息前，不会向任何一方传递任何消息。\r \r 虽然这看起来可能有所约束，但一个接收程序进程可以轻松处理多个并发会话，特别是当它们采用严格的异步代码编写时；借助回调模型，同时处理几十个并发会话实际上是自动完成的。\r \r 处理多个并发会话的策略（据此每个会话只能零星接收消息）是，让处理程序在一段空闲时间后删除会话，并在下一个会话到达时继续处理接受的会话。\r \r 会话接收程序保留的会话锁定是速览锁定安排模式使用的消息锁的保护伞。 接收程序不能同时有两个消息“在传输”，而必须依序处理消息。 只有在上一个消息已完成或成为死信时，才可以获取新消息。 如果放弃消息，则会在下一次执行接收操作时再次处理相同的消息。\r \r ## <a name=\"message-session-state\"></a>消息会话状态\r \r 在高度可缩放、高度可用的云系统中处理工作流时，与特定会话相关的工作流处理程序不仅必须能够从意外故障中恢复，还必须能够在不同的进程或计算机中从工作开始位置恢复部分完成的工作。\r \r 借助会话状态工具，可以在中转站内为消息会话添加应用程序定义的注释。这样一来，当会话被新处理程序获取时，相对于此会话的已记录处理状态就会立即可用。\r \r 从服务总线的角度来看，消息会话状态是一个不透明的二进制对象，可以保留一个消息大小的数据（对于服务总线标准版，大小为 256KB；对于服务总线高级版，大小为 1MB）。 相对于会话的处理状态可以保留在会话状态中，会话状态也可以指向保留此类信息的某存储位置或数据库记录。\r \r 用于管理会话状态的 API [SetState](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_) 和 [GetState](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate#Microsoft_ServiceBus_Messaging_MessageSession_GetState) 存在于 C# 和 Java API 的 [MessageSession](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.messagesession) 对象中。 之前没有设置会话状态的会话将对 GetState 返回空引用。 可以使用 [SetState(null)](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_) 清除之前设置的会话状态。\r \r 可以使用 Java API 中的 SessionBrowser 方法、[QueueClient](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.queueclient) 上的 [GetMessageSessions](https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicebus.messaging.queueclient.getmessagesessions#Microsoft_ServiceBus_Messaging_QueueClient_GetMessageSessions) 以及 .NET 客户端中的 [SubscriptionClient](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.subscriptionclient)，枚举队列或订阅中的所有现有会话。\r \r 队列或订阅中保留的会话状态计入相应实体的存储配额。 因此，当应用程序完成会话时，建议应用程序清理保留的状态，以杜绝外部管理成本。\r \r ## <a name=\"next-steps\"></a>后续步骤\r \r - [示例](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/Sessions)展示了如何使用 .NET Framework 客户端处理会话感知消息。 \r \r 若要了解有关服务总线消息传送的详细信息，请参阅以下主题：\r \r * [服务总线基础知识](service-bus-fundamentals-hybrid-solutions.md)\r * [服务总线队列、主题和订阅](service-bus-queues-topics-subscriptions.md)\r * [服务总线队列入门](service-bus-dotnet-get-started-with-queues.md)\r * [如何使用服务总线主题和订阅](service-bus-dotnet-how-to-use-topics-subscriptions.md)\r \r [1]: ./media/message-sessions/sessions.png\r [2]: ./media/message-sessions/queue-sessions.png"}