{"Title":"始终加密：SQL 数据库 - Azure Key Vault","Description":"本文演示如何使用 SQL Server Management Studio 中的始终加密向导，通过数据加密来保护 SQL 数据库中的敏感数据。","Content":"# <a name=\"always-encrypted-protect-sensitive-data-in-sql-database-and-store-your-encryption-keys-in-azure-key-vault\"></a>始终加密：保护 SQL 数据库中的敏感数据并将加密密钥存储在 Azure 密钥保管库中\r \r 本文演示如何使用 [SQL Server Management Studio (SSMS)](https://msdn.microsoft.com/library/mt459280.aspx) 中的[始终加密向导](https://msdn.microsoft.com/library/hh213248.aspx)，通过数据加密来保护 SQL 数据库中的敏感数据。 它还包括如何将每个加密密钥存储在 Azure 密钥保管库的说明。\r \r 始终加密是 Azure SQL 数据库和 SQL Server 中一项新的数据加密技术，用于保护服务器上的敏感静态数据、在客户端和服务器之间进行移动的敏感数据，以及正在使用中的数据。 始终加密可以确保敏感数据永远不会在数据库系统中以明文形式显示。 配置数据加密之后，仅客户端应用程序或应用服务器（具有密钥访问权限）能够访问明文数据。 有关详细信息，请参阅[始终加密（数据库引擎）](https://msdn.microsoft.com/library/mt163865.aspx)。\r \r 将数据库配置为使用始终加密后，会通过 Visual Studio 在 C# 中创建一个客户端应用程序，以便处理加密的数据。\r \r 按本文所述步骤进行操作，了解如何为 Azure SQL 数据库设置始终加密。 在本文中，可以学习如何执行以下任务：\r \r * 在 SSMS 中使用始终加密向导创建[始终加密密钥](https://msdn.microsoft.com/library/mt163865.aspx#Anchor_3)。\r   * 创建[列主密钥 (CMK)](https://msdn.microsoft.com/library/mt146393.aspx)。\r   * 创建[列加密密钥 (CEK)](https://msdn.microsoft.com/library/mt146372.aspx)。\r * 创建一个数据库表并加密列。\r * 创建一个可以从已加密列插入、选择和显示数据的应用程序。\r \r ## <a name=\"prerequisites\"></a>先决条件\r 在本教程中，需要：\r \r * Azure 帐户和订阅。 如果没有，请注册[试用版](https://www.azure.cn/pricing/1rmb-trial/)。\r * [SQL Server Management Studio](https://msdn.microsoft.com/library/mt238290.aspx) 版本 13.0.700.242 或更高版本。\r * [.NET Framework 4.6](https://msdn.microsoft.com/library/w0x726c2.aspx) 或更高版本（在客户端计算机上）。\r * [Visual Studio](https://www.visualstudio.com/downloads/download-visual-studio-vs.aspx)。\r * [Azure PowerShell](https://docs.microsoft.com/powershell/azure/overview)，版本 1.0 或更高版本。 键入 **(Get-Module azure -ListAvailable).Version** 可查看所运行的 PowerShell 版本。\r \r ## <a name=\"enable-your-client-application-to-access-the-sql-database-service\"></a>使客户端应用程序可以访问 SQL 数据库服务\r 首先必须通过设置所需的身份验证并获取在下面的代码中对应用程序进行身份验证所需的 *ClientId* 和 *Secret*，使客户端应用程序可以访问 SQL 数据库服务。\r \r 1. 打开 [Azure 经典管理门户](http://manage.windowsazure.cn)。\r 2. 选择“Active Directory”，然后单击应用程序将使用的 Active Directory。\r 3. 单击“应用程序”，并单击“添加”。\r 4. 键入应用程序的名称（例如：*myClientApp*），选择“WEB 应用程序”，并单击箭头以继续。\r 5. 对于“登录 URL”和“应用 ID URI”，可以键入一个有效 URL（例如：*http://myClientApp*），并继续。\r 6. 单击“配置”。\r 7. 复制“客户端 ID”。 （稍后在代码中需要此值。）\r 8. 在“密钥”部分中，从“选择持续时间”下拉列表选择“1 年”。 （在步骤 13 中保存后将复制该密钥。）\r 9. 向下滚动并单击“添加应用程序”。\r 10. 保留“显示”设置为“Microsoft 应用”，并选择“Microsoft Azure 服务管理 API”。 单击复选标记以继续。\r 11. 从“委派权限”下拉列表选择“访问 Azure 服务管理...”。\r 12. 单击“保存”。\r 13. 在保存完成后，将密钥值复制到“密钥”部分。 （稍后在代码中需要此值。）\r \r ## <a name=\"create-a-key-vault-to-store-your-keys\"></a>创建密钥保管库以存储密钥\r 现在客户端应用已配置并且你获得了客户端 ID，便可以创建密钥保管库并配置其访问策略以允许你和应用程序访问保管库的密码（始终加密密钥）。 *create*、*get*、*list*、*sign*、*verify*、*wrapKey* 和 *unwrapKey* 权限是用于创建新的列主密钥以及通过 SQL Server Management Studio 设置加密所必需的。\r \r 通过运行以下脚本，可以快速创建密钥保管库。 有关这些 cmdlet 的详细说明以及有关创建和配置密钥保管库的详细信息，请参阅 [Azure 密钥保管库入门](../key-vault/key-vault-get-started.md)。\r \r ```\r $subscriptionName = '<your Azure subscription name>'\r $userPrincipalName = '<username@domain.com>'\r $clientId = '<client ID that you copied in step 7 above>'\r $resourceGroupName = '<resource group name>'\r $location = '<datacenter location>'\r $vaultName = 'AeKeyVault'\r \r Login-AzureRmAccount -EnvironmentName AzureChinaCloud\r $subscriptionId = (Get-AzureRmSubscription -SubscriptionName $subscriptionName).Id\r Set-AzureRmContext -SubscriptionId $subscriptionId\r \r New-AzureRmResourceGroup -Name $resourceGroupName –Location $location\r New-AzureRmKeyVault -VaultName $vaultName -ResourceGroupName $resourceGroupName -Location $location\r \r Set-AzureRmKeyVaultAccessPolicy -VaultName $vaultName -ResourceGroupName $resourceGroupName -PermissionsToKeys create,get,wrapKey,unwrapKey,sign,verify,list -UserPrincipalName $userPrincipalName\r Set-AzureRmKeyVaultAccessPolicy  -VaultName $vaultName  -ResourceGroupName $resourceGroupName -ServicePrincipalName $clientId -PermissionsToKeys get,wrapKey,unwrapKey,sign,verify,list\r ```\r \r \r \r ## <a name=\"create-a-blank-sql-database\"></a>创建空的 SQL 数据库\r 1. 登录到 [Azure 门户](https://portal.azure.cn/)。\r 2. 转到“新建” > “数据 + 存储” > “SQL 数据库”。\r 3. 在新服务器或现有服务器上创建名为 **Clinic** 的**空**数据库。 若要深入了解如何在 Azure 门户中创建数据库，请参阅[第一个 Azure SQL 数据库](sql-database-get-started-portal.md)。\r    \r     ![创建空数据库](./media/sql-database-always-encrypted-azure-key-vault/create-database.png)\r \r 在本教程中稍后需要连接字符串，因此在创建数据库后，浏览到新的 Clinic 数据库并复制连接字符串。 可以在任何时候获取连接字符串，但在 Azure 门户中很容易对其进行复制。\r \r 1. 转到“SQL 数据库” > “Clinic” > “显示数据库连接字符串”。\r 2. 复制 **ADO.NET** 的连接字符串。\r    \r     ![复制连接字符串](./media/sql-database-always-encrypted-azure-key-vault/connection-strings.png)\r \r ## <a name=\"connect-to-the-database-with-ssms\"></a>使用 SSMS 连接到数据库\r 打开 SSMS，连接到包含 Clinic 数据库的服务器。\r \r 1. 打开 SSMS。 （转到“连接” > “数据库引擎”以打开“连接到服务器”窗口）（如果它未打开。）\r 2. 输入服务器名称和凭据。 服务器名称可以在 SQL 数据库边栏选项卡以及此前复制的连接字符串中找到。 键入完整的服务器名称，包括 *database.chinacloudapi.cn*。\r    \r     ![复制连接字符串](./media/sql-database-always-encrypted-azure-key-vault/ssms-connect.png)\r \r 如果“新建防火墙规则”窗口打开，请登录到 Azure，让 SSMS 创建新的防火墙规则。\r \r ## <a name=\"create-a-table\"></a>创建表\r 在本部分中，需要创建一个表以保存患者数据。 它最初尚未加密 - 可在下一部分配置加密。\r \r 1. 展开“数据库”。\r 2. 右键单击“Clinic”数据库，并单击“新建查询”。\r 3. 将以下 Transact-SQL (T-SQL) 粘贴到新查询窗口中，然后“执行”它。\r \r     ```\r     CREATE TABLE [dbo].[Patients](\r      [PatientId] [int] IDENTITY(1,1), \r      [SSN] [char](11) NOT NULL,\r      [FirstName] [nvarchar](50) NULL,\r      [LastName] [nvarchar](50) NULL, \r      [MiddleName] [nvarchar](50) NULL,\r      [StreetAddress] [nvarchar](50) NULL,\r      [City] [nvarchar](50) NULL,\r      [ZipCode] [char](5) NULL,\r      [State] [char](2) NULL,\r      [BirthDate] [date] NOT NULL\r      PRIMARY KEY CLUSTERED ([PatientId] ASC) ON [PRIMARY] );\r      GO\r     ```\r \r ## <a name=\"encrypt-columns-configure-always-encrypted\"></a>加密列（配置始终加密）\r SSMS 提供了一个向导，通过设置列主密钥、列加密密钥和已加密列即可轻松地配置始终加密。\r \r 1. 展开“数据库” > “Clinic” > “表”。\r 2. 右键单击“患者”表，并选择“加密列”以打开始终加密向导：\r    \r     ![加密列](./media/sql-database-always-encrypted-azure-key-vault/encrypt-columns.png)\r \r 始终加密向导包括以下部分：**列选择**、**主密钥配置**、**验证**和**摘要**。\r \r ### <a name=\"column-selection\"></a>列选择\r 单击“简介”页上的“下一步”，可以打开“列选择”页。 在此页上，选择想要加密的列，[加密类型和要使用的列加密密钥 (CEK)](https://msdn.microsoft.com/library/mt459280.aspx#Anchor_2)。\r \r 加密每位患者的“SSN”和“出生日期”信息。 SSN 列将使用确定性加密，该加密支持相等性查找、联接和分组方式。 BirthDate 列会使用随机加密，该加密不支持操作。\r \r 将 SSN 列的“加密类型”设置为“确定”，并将 BirthDate 列设置为“随机”。 单击“下一步” 。\r \r ![加密列](./media/sql-database-always-encrypted-azure-key-vault/column-selection.png)\r \r ### <a name=\"master-key-configuration\"></a>主密钥配置\r **主密钥配置**页是设置 CMK 和选择密钥存储提供程序（在其中存储 CMK）的地方。 目前，可以将 CMK 存储在 Windows 证书存储、Azure 密钥保管库或硬件安全模块 (HSM) 中。\r \r 本教程演示如何将密钥存储在 Azure 密钥保管库中。\r \r 1. 选择“Azure 密钥保管库”。\r 2. 从下拉列表中选择所需密钥保管库。\r 3. 单击“下一步” 。\r \r ![主密钥配置](./media/sql-database-always-encrypted-azure-key-vault/master-key-configuration.png)\r \r ### <a name=\"validation\"></a>验证\r 可以现在就加密这些列，也可以保存 PowerShell 脚本供以后运行。 对于本教程，请选择“现在完成”，并单击“下一步”。\r \r ### <a name=\"summary\"></a>摘要\r 验证设置是否全都正确，并单击“完成”以完成“始终加密”的设置。\r \r ![摘要](./media/sql-database-always-encrypted-azure-key-vault/summary.png)\r \r ### <a name=\"verify-the-wizards-actions\"></a>验证向导的操作\r 向导完成后，数据库就会设置为始终加密。 该向导执行以下操作：\r \r * 创建列主密钥并将其存储在 Azure 密钥保管库中。\r * 创建列加密密钥并将其存储在 Azure 密钥保管库中。\r * 配置了所选列的加密。 “患者”表目前尚无数据，但所选列中的任何现有数据都会进行加密。\r \r 可以验证 SSMS 中密钥的创建，只需展开“Clinic” > “安全” > “始终加密密钥”即可。\r \r ## <a name=\"create-a-client-application-that-works-with-the-encrypted-data\"></a>创建处理已加密数据的客户端应用程序\r 现在已设置始终加密，可以生成一个应用程序，用其在已加密列上执行某些 *inserts* 操作和 *selects* 操作。  \r \r > [!IMPORTANT]\r > 通过始终加密列将明文数据传递到服务器时，应用程序必须使用 [SqlParameter](https://msdn.microsoft.com/library/system.data.sqlclient.sqlparameter.aspx) 对象。 在不使用 SqlParameter 对象的情况下传递文本值会导致异常。\r > \r > \r \r 1. 打开 Visual Studio 并创建新的 C# **控制台应用程序**（Visual Studio 2015 和更低版本）或**控制台应用 (.NET Framework)**（Visual Studio 2017 和更高版本）。 确保将项目设置为 **.NET Framework 4.6** 或更高版本。\r 2. 将项目命名为 **AlwaysEncryptedConsoleAKVApp**，然后单击“确定”。\r 3. 通过转到“工具” > “NuGet 包管理器” > “包管理器控制台”来安装以下 NuGet 包。\r \r 在包管理器控制台中运行以下 2 行代码。\r \r ```\r Install-Package Microsoft.SqlServer.Management.AlwaysEncrypted.AzureKeyVaultProvider\r Install-Package Microsoft.IdentityModel.Clients.ActiveDirectory\r ```\r \r ## <a name=\"modify-your-connection-string-to-enable-always-encrypted\"></a>修改连接字符串以启用始终加密\r 本节介绍如何在数据库连接字符串中启用始终加密。\r \r 要启用“始终加密”，需要将“列加密设置”关键字添加到连接字符串中，并将其设置为“启用”。\r \r 可以在连接字符串中直接进行该设置，也可以使用 [SqlConnectionStringBuilder](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnectionstringbuilder.aspx) 进行设置。 下一节中的示例应用程序演示如何使用 **SqlConnectionStringBuilder**。\r \r ### <a name=\"enable-always-encrypted-in-the-connection-string\"></a>在连接字符串中启用始终加密\r 将以下关键字添加到连接字符串中。\r \r ```\r Column Encryption Setting=Enabled\r ```\r \r ### <a name=\"enable-always-encrypted-with-sqlconnectionstringbuilder\"></a>通过 SqlConnectionStringBuilder 启用始终加密\r 以下代码显示了如何通过将 [SqlConnectionStringBuilder.ColumnEncryptionSetting](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnectionstringbuilder.columnencryptionsetting.aspx) 设置为[启用](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnectioncolumnencryptionsetting.aspx)来启用“始终加密”。\r \r ```\r // Instantiate a SqlConnectionStringBuilder.\r SqlConnectionStringBuilder connStringBuilder = \r    new SqlConnectionStringBuilder(\"replace with your connection string\");\r \r // Enable Always Encrypted.\r connStringBuilder.ColumnEncryptionSetting = \r    SqlConnectionColumnEncryptionSetting.Enabled;\r ```\r \r ## <a name=\"register-the-azure-key-vault-provider\"></a>注册 Azure 密钥保管库提供程序\r 下面的代码演示如何使用 ADO.NET 驱动程序注册 Azure 密钥保管库提供程序。\r \r ```\r private static ClientCredential _clientCredential;\r \r static void InitializeAzureKeyVaultProvider()\r {\r    _clientCredential = new ClientCredential(clientId, clientSecret);\r \r    SqlColumnEncryptionAzureKeyVaultProvider azureKeyVaultProvider =\r       new SqlColumnEncryptionAzureKeyVaultProvider(GetToken);\r \r    Dictionary<string, SqlColumnEncryptionKeyStoreProvider> providers =\r       new Dictionary<string, SqlColumnEncryptionKeyStoreProvider>();\r \r    providers.Add(SqlColumnEncryptionAzureKeyVaultProvider.ProviderName, azureKeyVaultProvider);\r    SqlConnection.RegisterColumnEncryptionKeyStoreProviders(providers);\r }\r ```\r \r ## <a name=\"always-encrypted-sample-console-application\"></a>始终加密示例控制台应用程序\r 此示例演示了如何执行以下操作：\r \r * 修改连接字符串以启用始终加密。\r * 将 Azure 密钥保管库注册为应用程序的密钥存储提供程序。  \r * 将数据插入已加密列。\r * 通过在已加密列中筛选出特定的值来选择记录。\r \r 将 **Program.cs** 的内容替换为以下代码。 将 Main 方法前一行中全局 connectionString 变量的连接字符串替换为 Azure 门户中的有效连接字符串。 这是需要对此代码进行的唯一更改。\r \r 运行该应用以在操作中查看始终加密。\r \r ```\r using System;\r using System.Collections.Generic;\r using System.Linq;\r using System.Text;\r using System.Threading.Tasks;\r using System.Data;\r using System.Data.SqlClient;\r using Microsoft.IdentityModel.Clients.ActiveDirectory;\r using Microsoft.SqlServer.Management.AlwaysEncrypted.AzureKeyVaultProvider;\r \r namespace AlwaysEncryptedConsoleAKVApp\r {\r class Program\r {\r     // Update this line with your Clinic database connection string from the Azure Portal.\r     static string connectionString = @\"<connection string from the portal>\";\r     static string clientId = @\"<client id from step 7 above>\";\r     static string clientSecret = \"<key from step 13 above>\";\r \r     static void Main(string[] args)\r     {\r         InitializeAzureKeyVaultProvider();\r \r         Console.WriteLine(\"Signed in as: \" + _clientCredential.ClientId);\r \r         Console.WriteLine(\"Original connection string copied from the Azure portal:\");\r         Console.WriteLine(connectionString);\r \r         // Create a SqlConnectionStringBuilder.\r         SqlConnectionStringBuilder connStringBuilder =\r             new SqlConnectionStringBuilder(connectionString);\r \r         // Enable Always Encrypted for the connection.\r         // This is the only change specific to Always Encrypted \r         connStringBuilder.ColumnEncryptionSetting =\r             SqlConnectionColumnEncryptionSetting.Enabled;\r \r         Console.WriteLine(Environment.NewLine + \"Updated connection string with Always Encrypted enabled:\");\r         Console.WriteLine(connStringBuilder.ConnectionString);\r \r         // Update the connection string with a password supplied at runtime.\r         Console.WriteLine(Environment.NewLine + \"Enter server password:\");\r         connStringBuilder.Password = Console.ReadLine();\r \r         // Assign the updated connection string to our global variable.\r         connectionString = connStringBuilder.ConnectionString;\r \r         // Delete all records to restart this demo app.\r         ResetPatientsTable();\r \r         // Add sample data to the Patients table.\r         Console.Write(Environment.NewLine + \"Adding sample patient data to the database...\");\r \r         InsertPatient(new Patient()\r         {\r             SSN = \"999-99-0001\",\r             FirstName = \"Orlando\",\r             LastName = \"Gee\",\r             BirthDate = DateTime.Parse(\"01/04/1964\")\r         });\r         InsertPatient(new Patient()\r         {\r             SSN = \"999-99-0002\",\r             FirstName = \"Keith\",\r             LastName = \"Harris\",\r             BirthDate = DateTime.Parse(\"06/20/1977\")\r         });\r         InsertPatient(new Patient()\r         {\r             SSN = \"999-99-0003\",\r             FirstName = \"Donna\",\r             LastName = \"Carreras\",\r             BirthDate = DateTime.Parse(\"02/09/1973\")\r         });\r         InsertPatient(new Patient()\r         {\r             SSN = \"999-99-0004\",\r             FirstName = \"Janet\",\r             LastName = \"Gates\",\r             BirthDate = DateTime.Parse(\"08/31/1985\")\r         });\r         InsertPatient(new Patient()\r         {\r             SSN = \"999-99-0005\",\r             FirstName = \"Lucy\",\r             LastName = \"Harrington\",\r             BirthDate = DateTime.Parse(\"05/06/1993\")\r         });\r \r         // Fetch and display all patients.\r         Console.WriteLine(Environment.NewLine + \"All the records currently in the Patients table:\");\r \r         foreach (Patient patient in SelectAllPatients())\r         {\r             Console.WriteLine(patient.FirstName + \" \" + patient.LastName + \"\\tSSN: \" + patient.SSN + \"\\tBirthdate: \" + patient.BirthDate);\r         }\r \r         // Get patients by SSN.\r         Console.WriteLine(Environment.NewLine + \"Now lets locate records by searching the encrypted SSN column.\");\r \r         string ssn;\r \r         // This very simple validation only checks that the user entered 11 characters.\r         // In production be sure to check all user input and use the best validation for your specific application.\r         do\r         {\r             Console.WriteLine(\"Please enter a valid SSN (ex. 999-99-0003):\");\r             ssn = Console.ReadLine();\r         } while (ssn.Length != 11);\r \r         // The example allows duplicate SSN entries so we will return all records\r         // that match the provided value and store the results in selectedPatients.\r         Patient selectedPatient = SelectPatientBySSN(ssn);\r \r         // Check if any records were returned and display our query results.\r         if (selectedPatient != null)\r         {\r             Console.WriteLine(\"Patient found with SSN = \" + ssn);\r             Console.WriteLine(selectedPatient.FirstName + \" \" + selectedPatient.LastName + \"\\tSSN: \"\r                 + selectedPatient.SSN + \"\\tBirthdate: \" + selectedPatient.BirthDate);\r         }\r         else\r         {\r             Console.WriteLine(\"No patients found with SSN = \" + ssn);\r         }\r \r         Console.WriteLine(\"Press Enter to exit...\");\r         Console.ReadLine();\r     }\r \r     private static ClientCredential _clientCredential;\r \r     static void InitializeAzureKeyVaultProvider()\r     {\r \r         _clientCredential = new ClientCredential(clientId, clientSecret);\r \r         SqlColumnEncryptionAzureKeyVaultProvider azureKeyVaultProvider =\r           new SqlColumnEncryptionAzureKeyVaultProvider(GetToken);\r \r         Dictionary<string, SqlColumnEncryptionKeyStoreProvider> providers =\r           new Dictionary<string, SqlColumnEncryptionKeyStoreProvider>();\r \r         providers.Add(SqlColumnEncryptionAzureKeyVaultProvider.ProviderName, azureKeyVaultProvider);\r         SqlConnection.RegisterColumnEncryptionKeyStoreProviders(providers);\r     }\r \r     public async static Task<string> GetToken(string authority, string resource, string scope)\r     {\r         var authContext = new AuthenticationContext(authority);\r         AuthenticationResult result = await authContext.AcquireTokenAsync(resource, _clientCredential);\r \r         if (result == null)\r             throw new InvalidOperationException(\"Failed to obtain the access token\");\r         return result.AccessToken;\r     }\r \r     static int InsertPatient(Patient newPatient)\r     {\r         int returnValue = 0;\r \r         string sqlCmdText = @\"INSERT INTO [dbo].[Patients] ([SSN], [FirstName], [LastName], [BirthDate])\r  VALUES (@SSN, @FirstName, @LastName, @BirthDate);\";\r \r         SqlCommand sqlCmd = new SqlCommand(sqlCmdText);\r \r         SqlParameter paramSSN = new SqlParameter(@\"@SSN\", newPatient.SSN);\r         paramSSN.DbType = DbType.AnsiStringFixedLength;\r         paramSSN.Direction = ParameterDirection.Input;\r         paramSSN.Size = 11;\r \r         SqlParameter paramFirstName = new SqlParameter(@\"@FirstName\", newPatient.FirstName);\r         paramFirstName.DbType = DbType.String;\r         paramFirstName.Direction = ParameterDirection.Input;\r \r         SqlParameter paramLastName = new SqlParameter(@\"@LastName\", newPatient.LastName);\r         paramLastName.DbType = DbType.String;\r         paramLastName.Direction = ParameterDirection.Input;\r \r         SqlParameter paramBirthDate = new SqlParameter(@\"@BirthDate\", newPatient.BirthDate);\r         paramBirthDate.SqlDbType = SqlDbType.Date;\r         paramBirthDate.Direction = ParameterDirection.Input;\r \r         sqlCmd.Parameters.Add(paramSSN);\r         sqlCmd.Parameters.Add(paramFirstName);\r         sqlCmd.Parameters.Add(paramLastName);\r         sqlCmd.Parameters.Add(paramBirthDate);\r \r         using (sqlCmd.Connection = new SqlConnection(connectionString))\r         {\r             try\r             {\r                 sqlCmd.Connection.Open();\r                 sqlCmd.ExecuteNonQuery();\r             }\r             catch (Exception ex)\r             {\r                 returnValue = 1;\r                 Console.WriteLine(\"The following error was encountered: \");\r                 Console.WriteLine(ex.Message);\r                 Console.WriteLine(Environment.NewLine + \"Press Enter key to exit\");\r                 Console.ReadLine();\r                 Environment.Exit(0);\r             }\r         }\r         return returnValue;\r     }\r \r     static List<Patient> SelectAllPatients()\r     {\r         List<Patient> patients = new List<Patient>();\r \r         SqlCommand sqlCmd = new SqlCommand(\r           \"SELECT [SSN], [FirstName], [LastName], [BirthDate] FROM [dbo].[Patients]\",\r             new SqlConnection(connectionString));\r \r         using (sqlCmd.Connection = new SqlConnection(connectionString))\r \r         using (sqlCmd.Connection = new SqlConnection(connectionString))\r         {\r             try\r             {\r                 sqlCmd.Connection.Open();\r                 SqlDataReader reader = sqlCmd.ExecuteReader();\r \r                 if (reader.HasRows)\r                 {\r                     while (reader.Read())\r                     {\r                         patients.Add(new Patient()\r                         {\r                             SSN = reader[0].ToString(),\r                             FirstName = reader[1].ToString(),\r                             LastName = reader[\"LastName\"].ToString(),\r                             BirthDate = (DateTime)reader[\"BirthDate\"]\r                         });\r                     }\r                 }\r             }\r             catch (Exception ex)\r             {\r                 throw;\r             }\r         }\r \r         return patients;\r     }\r \r     static Patient SelectPatientBySSN(string ssn)\r     {\r         Patient patient = new Patient();\r \r         SqlCommand sqlCmd = new SqlCommand(\r             \"SELECT [SSN], [FirstName], [LastName], [BirthDate] FROM [dbo].[Patients] WHERE [SSN]=@SSN\",\r             new SqlConnection(connectionString));\r \r         SqlParameter paramSSN = new SqlParameter(@\"@SSN\", ssn);\r         paramSSN.DbType = DbType.AnsiStringFixedLength;\r         paramSSN.Direction = ParameterDirection.Input;\r         paramSSN.Size = 11;\r \r         sqlCmd.Parameters.Add(paramSSN);\r \r         using (sqlCmd.Connection = new SqlConnection(connectionString))\r         {\r             try\r             {\r                 sqlCmd.Connection.Open();\r                 SqlDataReader reader = sqlCmd.ExecuteReader();\r \r                 if (reader.HasRows)\r                 {\r                     while (reader.Read())\r                     {\r                         patient = new Patient()\r                         {\r                             SSN = reader[0].ToString(),\r                             FirstName = reader[1].ToString(),\r                             LastName = reader[\"LastName\"].ToString(),\r                             BirthDate = (DateTime)reader[\"BirthDate\"]\r                         };\r                     }\r                 }\r                 else\r                 {\r                     patient = null;\r                 }\r             }\r             catch (Exception ex)\r             {\r                 throw;\r             }\r         }\r         return patient;\r     }\r \r     // This method simply deletes all records in the Patients table to reset our demo.\r     static int ResetPatientsTable()\r     {\r         int returnValue = 0;\r \r         SqlCommand sqlCmd = new SqlCommand(\"DELETE FROM Patients\");\r         using (sqlCmd.Connection = new SqlConnection(connectionString))\r         {\r             try\r             {\r                 sqlCmd.Connection.Open();\r                 sqlCmd.ExecuteNonQuery();\r \r             }\r             catch (Exception ex)\r             {\r                 returnValue = 1;\r             }\r         }\r         return returnValue;\r     }\r }\r \r class Patient\r {\r     public string SSN { get; set; }\r     public string FirstName { get; set; }\r     public string LastName { get; set; }\r     public DateTime BirthDate { get; set; }\r }\r }\r ```\r \r \r ## <a name=\"verify-that-the-data-is-encrypted\"></a>确保数据已加密\r 通过 SSMS 对患者数据进行查询（使用当前的连接，其中，**列加密设置**尚未启用），可以快速查看服务器上的实际数据是否已加密。\r \r 针对 Clinic 数据库运行以下查询。\r \r ```\r SELECT FirstName, LastName, SSN, BirthDate FROM Patients;\r ```\r \r 可以看到，加密的列不包含任何明文数据。\r \r    ![新建控制台应用程序](./media/sql-database-always-encrypted-azure-key-vault/ssms-encrypted.png)\r \r 要使用 SSMS 来访问明文数据，可将 *Column Encryption Setting=enabled* 参数添加到连接中。\r \r 1. 在 SSMS 中，右键单击“对象资源管理器”中的服务器，并选择“断开连接”。\r 2. 单击“连接” > “数据库引擎”打开“连接到服务器”窗口，并单击“选项”。\r 3. 单击“其他连接参数”，并键入 **Column Encryption Setting=enabled**。\r    \r     ![新建控制台应用程序](./media/sql-database-always-encrypted-azure-key-vault/ssms-connection-parameter.png)\r 4. 针对 Clinic 数据库运行以下查询。\r \r     ```\r     SELECT FirstName, LastName, SSN, BirthDate FROM Patients;\r     ```\r \r      现在，可以看到已加密列中的明文数据。\r \r     ![新建控制台应用程序](./media/sql-database-always-encrypted-azure-key-vault/ssms-plaintext.png)\r \r \r ## <a name=\"next-steps\"></a>后续步骤\r 创建使用始终加密的数据库以后，可能需要执行以下操作：\r \r * [轮换使用和清除密钥](https://msdn.microsoft.com/library/mt607048.aspx)。\r * [迁移已使用始终加密加密的数据](https://msdn.microsoft.com/library/mt621539.aspx)。\r \r ## <a name=\"related-information\"></a>相关信息\r * [始终加密（客户端开发）](https://msdn.microsoft.com/library/mt147923.aspx)\r * [透明数据加密](https://msdn.microsoft.com/library/bb934049.aspx)\r * [SQL Server 加密](https://msdn.microsoft.com/library/bb510663.aspx)\r * [始终加密向导](https://msdn.microsoft.com/library/mt459280.aspx)\r * [始终加密博客](http://blogs.msdn.com/b/sqlsecurity/archive/tags/always-encrypted/)\r <!--Update_Description: update script-->\r "}