{"Title":"SQL 数据库的 XEvent 环形缓冲区代码","Description":"提供一个 Transact-SQL 代码示例，以帮助你快速轻松地在 Azure SQL 数据库中使用环形缓存区目标。","Content":"# <a name=\"ring-buffer-target-code-for-extended-events-in-sql-database\"></a>SQL 数据库中扩展事件的环形缓冲区目标代码\r \r [!INCLUDE [sql-database-xevents-selectors-1-include](../../includes/sql-database-xevents-selectors-1-include.md)]\r \r 需要完整的代码示例以最简单快速的方式在测试期间捕获和报告扩展事件的信息。 扩展事件数据最简单的目标是[环形缓冲区目标](http://msdn.microsoft.com/library/ff878182.aspx)。\r \r 本主题演示一个 Transact-SQL 代码示例：\r \r 1. 创建一个包含要演示的数据的表。\r 2. 创建现有扩展事件的会话，即 **sqlserver.sql_statement_starting**。\r \r    * 此事件仅限于包含特定 Update 字符串的 SQL 语句： **statement LIKE '%UPDATE tabEmployee%'**。\r    * 选择要将事件的输出发送给环形缓冲区类型的目标，即 **package0.ring_buffer**。\r 3. 启动事件会话。\r 4. 发出几个简单的 SQL UPDATE 语句。\r 5. 发出 SQL SELECT 语句，从环形缓冲区检索事件输出。\r \r    * 将 **sys.dm_xe_database_session_targets** 和其他动态管理视图 (DMV) 联接在一起。\r 6. 停止事件会话。\r 7. 删除环形缓冲区目标以释放其资源。\r 8. 删除事件会话和演示表。\r \r ## <a name=\"prerequisites\"></a>先决条件\r \r * Azure 帐户和订阅。 可以注册[试用版](https://www.azure.cn/pricing/1rmb-trial/)。\r * 可在其中创建表的任何数据库。\r \r   * 或者，也可以在几分钟内[创建一个 **AdventureWorksLT** 演示数据库](sql-database-get-started.md)。\r * SQL Server Management Studio (ssms.exe)，最好是每月最新更新版。 \r   可从以下位置下载最新的 ssms.exe：\r \r   * 标题为[下载 SQL Server Management Studio](http://msdn.microsoft.com/library/mt238290.aspx) 的主题。\r   * [直接指向下载位置的链接。](http://go.microsoft.com/fwlink/?linkid=616025)\r \r ## <a name=\"code-sample\"></a>代码示例\r \r 只要稍加修改，就可以在 Azure SQL 数据库或 Microsoft SQL Server 上运行以下环形缓冲区的代码示例。 不同之处在于步骤 5 的 FROM 子句中使用的某些动态管理视图 (DMV) 的名称中出现了节点“_database”。 例如：\r \r * sys.dm_xe**_database**_session_targets\r * sys.dm_xe_session_targets\r \r &nbsp;\r \r ```sql\r GO\r ----  Transact-SQL.\r ---- Step set 1.\r \r SET NOCOUNT ON;\r GO\r \r IF EXISTS\r     (SELECT * FROM sys.objects\r         WHERE type = 'U' and name = 'tabEmployee')\r BEGIN\r     DROP TABLE tabEmployee;\r END\r GO\r \r CREATE TABLE tabEmployee\r (\r     EmployeeGuid         uniqueIdentifier   not null  default newid()  primary key,\r     EmployeeId           int                not null  identity(1,1),\r     EmployeeKudosCount   int                not null  default 0,\r     EmployeeDescr        nvarchar(256)          null\r );\r GO\r \r INSERT INTO tabEmployee ( EmployeeDescr )\r     VALUES ( 'Jane Doe' );\r GO\r \r ---- Step set 2.\r \r IF EXISTS\r     (SELECT * from sys.database_event_sessions\r         WHERE name = 'eventsession_gm_azuresqldb51')\r BEGIN\r     DROP EVENT SESSION eventsession_gm_azuresqldb51\r         ON DATABASE;\r END\r GO\r \r CREATE\r     EVENT SESSION eventsession_gm_azuresqldb51\r     ON DATABASE\r     ADD EVENT\r         sqlserver.sql_statement_starting\r             (\r             ACTION (sqlserver.sql_text)\r             WHERE statement LIKE '%UPDATE tabEmployee%'\r             )\r     ADD TARGET\r         package0.ring_buffer\r             (SET\r                 max_memory = 500   -- Units of KB.\r             );\r GO\r \r ---- Step set 3.\r \r ALTER EVENT SESSION eventsession_gm_azuresqldb51\r     ON DATABASE\r     STATE = START;\r GO\r \r ---- Step set 4.\r \r SELECT 'BEFORE_Updates', EmployeeKudosCount, * FROM tabEmployee;\r \r UPDATE tabEmployee\r     SET EmployeeKudosCount = EmployeeKudosCount + 102;\r \r UPDATE tabEmployee\r     SET EmployeeKudosCount = EmployeeKudosCount + 1015;\r \r SELECT 'AFTER__Updates', EmployeeKudosCount, * FROM tabEmployee;\r GO\r \r ---- Step set 5.\r \r SELECT\r     se.name                      AS [session-name],\r     ev.event_name,\r     ac.action_name,\r     st.target_name,\r     se.session_source,\r     st.target_data,\r     CAST(st.target_data AS XML)  AS [target_data_XML]\r FROM\r                sys.dm_xe_database_session_event_actions  AS ac\r \r     INNER JOIN sys.dm_xe_database_session_events         AS ev  ON ev.event_name = ac.event_name\r         AND CAST(ev.event_session_address AS BINARY(8)) = CAST(ac.event_session_address AS BINARY(8))\r \r     INNER JOIN sys.dm_xe_database_session_object_columns AS oc\r          ON CAST(oc.event_session_address AS BINARY(8)) = CAST(ac.event_session_address AS BINARY(8))\r \r     INNER JOIN sys.dm_xe_database_session_targets        AS st\r          ON CAST(st.event_session_address AS BINARY(8)) = CAST(ac.event_session_address AS BINARY(8))\r \r     INNER JOIN sys.dm_xe_database_sessions               AS se\r          ON CAST(ac.event_session_address AS BINARY(8)) = CAST(se.address AS BINARY(8))\r WHERE\r         oc.column_name = 'occurrence_number'\r     AND\r         se.name        = 'eventsession_gm_azuresqldb51'\r     AND\r         ac.action_name = 'sql_text'\r ORDER BY\r     se.name,\r     ev.event_name,\r     ac.action_name,\r     st.target_name,\r     se.session_source\r ;\r GO\r \r ---- Step set 6.\r \r ALTER EVENT SESSION eventsession_gm_azuresqldb51\r     ON DATABASE\r     STATE = STOP;\r GO\r \r ---- Step set 7.\r \r ALTER EVENT SESSION eventsession_gm_azuresqldb51\r     ON DATABASE\r     DROP TARGET package0.ring_buffer;\r GO\r \r ---- Step set 8.\r \r DROP EVENT SESSION eventsession_gm_azuresqldb51\r     ON DATABASE;\r GO\r \r DROP TABLE tabEmployee;\r GO\r ```\r \r &nbsp;\r \r ## <a name=\"ring-buffer-contents\"></a>环形缓冲区内容\r \r 我们使用了 ssms.exe 来运行该代码示例。\r \r 为了查看结果，我们单击了 **target_data_XML** 列标题下的单元格。\r \r 然后，在结果窗格中，我们单击了 **target_data_XML** 列标题下的单元格。 这个单击动作在 ssms.exe 中按结果单元格内容显示的顺序，以 XML 格式创建了另一个文件选项卡。\r \r 输出显示在以下块中。 结果看起来很长，但其实只是两个 **<event>** 元素。\r \r &nbsp;\r \r ```\r <RingBufferTarget truncated=\"0\" processingTime=\"0\" totalEventsProcessed=\"2\" eventCount=\"2\" droppedCount=\"0\" memoryUsed=\"1728\">\r   <event name=\"sql_statement_starting\" package=\"sqlserver\" timestamp=\"2015-09-22T15:29:31.317Z\">\r     <data name=\"state\">\r       <type name=\"statement_starting_state\" package=\"sqlserver\" />\r       <value>0</value>\r       <text>Normal</text>\r     </data>\r     <data name=\"line_number\">\r       <type name=\"int32\" package=\"package0\" />\r       <value>7</value>\r     </data>\r     <data name=\"offset\">\r       <type name=\"int32\" package=\"package0\" />\r       <value>184</value>\r     </data>\r     <data name=\"offset_end\">\r       <type name=\"int32\" package=\"package0\" />\r       <value>328</value>\r     </data>\r     <data name=\"statement\">\r       <type name=\"unicode_string\" package=\"package0\" />\r       <value>UPDATE tabEmployee\r     SET EmployeeKudosCount = EmployeeKudosCount + 102</value>\r     </data>\r     <action name=\"sql_text\" package=\"sqlserver\">\r       <type name=\"unicode_string\" package=\"package0\" />\r       <value>\r ---- Step set 4.\r \r SELECT 'BEFORE_Updates', EmployeeKudosCount, * FROM tabEmployee;\r \r UPDATE tabEmployee\r     SET EmployeeKudosCount = EmployeeKudosCount + 102;\r \r UPDATE tabEmployee\r     SET EmployeeKudosCount = EmployeeKudosCount + 1015;\r \r SELECT 'AFTER__Updates', EmployeeKudosCount, * FROM tabEmployee;\r </value>\r     </action>\r   </event>\r   <event name=\"sql_statement_starting\" package=\"sqlserver\" timestamp=\"2015-09-22T15:29:31.327Z\">\r     <data name=\"state\">\r       <type name=\"statement_starting_state\" package=\"sqlserver\" />\r       <value>0</value>\r       <text>Normal</text>\r     </data>\r     <data name=\"line_number\">\r       <type name=\"int32\" package=\"package0\" />\r       <value>10</value>\r     </data>\r     <data name=\"offset\">\r       <type name=\"int32\" package=\"package0\" />\r       <value>340</value>\r     </data>\r     <data name=\"offset_end\">\r       <type name=\"int32\" package=\"package0\" />\r       <value>486</value>\r     </data>\r     <data name=\"statement\">\r       <type name=\"unicode_string\" package=\"package0\" />\r       <value>UPDATE tabEmployee\r     SET EmployeeKudosCount = EmployeeKudosCount + 1015</value>\r     </data>\r     <action name=\"sql_text\" package=\"sqlserver\">\r       <type name=\"unicode_string\" package=\"package0\" />\r       <value>\r ---- Step set 4.\r \r SELECT 'BEFORE_Updates', EmployeeKudosCount, * FROM tabEmployee;\r \r UPDATE tabEmployee\r     SET EmployeeKudosCount = EmployeeKudosCount + 102;\r \r UPDATE tabEmployee\r     SET EmployeeKudosCount = EmployeeKudosCount + 1015;\r \r SELECT 'AFTER__Updates', EmployeeKudosCount, * FROM tabEmployee;\r </value>\r     </action>\r   </event>\r </RingBufferTarget>\r ```\r \r #### <a name=\"release-resources-held-by-your-ring-buffer\"></a>释放环形缓冲区占用的资源\r \r 处理完环形缓冲区后，可以发出 **ALTER** 将它删除并释放其资源，如下所示：\r \r ```sql\r ALTER EVENT SESSION eventsession_gm_azuresqldb51\r     ON DATABASE\r     DROP TARGET package0.ring_buffer;\r GO\r ```\r \r 事件会话的定义会更新，但不会删除。 然后可以将环形缓冲区的另一个实例添加到事件会话：\r \r ```sql\r ALTER EVENT SESSION eventsession_gm_azuresqldb51\r     ON DATABASE\r     ADD TARGET\r         package0.ring_buffer\r             (SET\r                 max_memory = 500   -- Units of KB.\r             );\r ```\r \r ## <a name=\"more-information\"></a>详细信息\r \r 有关 Azure SQL 数据库中扩展事件的主要主题是：\r \r * [SQL 数据库中扩展事件的注意事项](sql-database-xevent-db-diff-from-svr.md)，对比了 Azure SQL 数据库与 Microsoft SQL Server 之间存在差异的扩展事件的某些方面。\r \r 可通过以下链接访问有关扩展事件的其他代码示例主题。 不过，必须定期检查所有示例，以确定这些示例是针对 Microsoft SQL Server 还是 Azure SQL 数据库。 然后，用户可以在运行示例时确定是否要做出细微的更改。\r \r * Azure SQL 数据库的代码示例： [SQL 数据库中扩展事件的事件文件目标代码](sql-database-xevent-code-event-file.md)\r \r <!--\r ('lock_acquired' event.)\r \r - Code sample for SQL Server: [Determine Which Queries Are Holding Locks](http://msdn.microsoft.com/library/bb677357.aspx)\r - Code sample for SQL Server: [Find the Objects That Have the Most Locks Taken on Them](http://msdn.microsoft.com/library/bb630355.aspx)\r -->\r \r <!--Update_Description: wording update (tsql->sql)-->"}