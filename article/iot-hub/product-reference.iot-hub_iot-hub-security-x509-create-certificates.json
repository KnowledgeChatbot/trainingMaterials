{"Title":"如何使用 PowerShell 创建 X.509 证书","Description":"如何使用 PowerShell 在本地创建 X.509 证书，以及在模拟环境下在 Azure IoT 中心启用基于 X.509 的安全性。","Content":"# <a name=\"powershell-scripts-to-manage-ca-signed-x509-certificates\"></a>用于管理 CA 签名的 X.509 证书的 PowerShell 脚本\r\n\r\nIoT 中心基于 X.509 证书的安全性需从 [X.509 证书链](https://en.wikipedia.org/wiki/X.509#Certificate_chains_and_cross-certification)开始，其中包括根证书、任何中间证书，及至叶证书。 此操作说明指南演示使用 [OpenSSL](https://www.openssl.org/) 创建 X.509 证书并对其进行签名的示例 PowerShell 脚本。 建议仅将本指南用于试验环境，因为其中很多步骤将发生于现实生活中的生产过程。 可以使用这些证书通过 X.509 证书身份验证在 Azure IoT 中心模拟安全性。 本指南中的步骤在 Windows 计算机上本地创建证书。 \r\n\r\n## <a name=\"prerequisites\"></a>先决条件\r\n本教程假定你已获取 OpenSSL 二进制文件。 你还可\r\n    - 下载 OpenSSL 源代码并在计算机上生成二进制文件，或者 \r\n    - 下载并安装任何[第三方 OpenSSL 二进制文件](https://wiki.openssl.org/index.php/Binaries)，例如从 [SourceForge 上的此项目](https://sourceforge.net/projects/openssl/)下载并安装。\r\n\r\n<a id=\"createcerts\"></a>\r\n\r\n## <a name=\"create-x509-certificates\"></a>创建 X.509 证书\r\n以下步骤显示如何在本地创建 X.509 根证书的示例。 \r\n\r\n1. 以管理员身份打开 PowerShell 窗口。 \r\n2. 导航到工作目录。 运行以下脚本以设置全局变量。 \r\n\r\n    ```PowerShell\r\n    $openSSLBinSource = \"<full_path_to_the_binaries>\\OpenSSL\\bin\"\r\n    $errorActionPreference    = \"stop\"\r\n\r\n    # Note that these values are for test purpose only\r\n    $_rootCertSubject         = \"CN=Azure IoT Root CA\"\r\n    $_intermediateCertSubject = \"CN=Azure IoT Intermediate {0} CA\"\r\n    $_privateKeyPassword      = \"123\"\r\n\r\n    $rootCACerFileName          = \"./RootCA.cer\"\r\n    $rootCAPemFileName          = \"./RootCA.pem\"\r\n    $intermediate1CAPemFileName = \"./Intermediate1.pem\"\r\n    $intermediate2CAPemFileName = \"./Intermediate2.pem\"\r\n    $intermediate3CAPemFileName = \"./Intermediate3.pem\"\r\n\r\n    $openSSLBinDir              = Join-Path $ENV:TEMP \"openssl-bin\"\r\n\r\n    # Whether to use ECC or RSA.\r\n    $useEcc                     = $true\r\n    ```\r\n    \r\n3. 运行以下脚本，将 OpenSSL 二进制文件复制到工作目录并设置环境变量：\r\n\r\n    ```PowerShell\r\n    function Initialize-CAOpenSSL()\r\n    {\r\n        Write-Host (\"Beginning copy of openssl binaries to {0} (and setting up env variables...)\" -f $openSSLBinDir)\r\n        if (-not (Test-Path $openSSLBinDir))\r\n        {\r\n            mkdir $openSSLBinDir | Out-Null\r\n        }\r\n\r\n        robocopy $openSSLBinSource $openSSLBinDir * /s \r\n        robocopy $openSSLBinSource . * /s \r\n\r\n        Write-Host \"Setting up PATH and other environment variables.\"\r\n        $ENV:PATH += \"; $openSSLBinDir\"\r\n        $ENV:OPENSSL_CONF = Join-Path $openSSLBinDir \"openssl.cnf\"\r\n\r\n        Write-Host \"Success\"\r\n    }\r\n    Initialize-CAOpenSSL\r\n    ```\r\n    \r\n4. 接下来运行以下脚本，搜索是否已安装指定的使用者名称的证书，以及是否在计算机上正确配置 OpenSSL：\r\n\r\n    ```PowerShell\r\n    function Get-CACertBySubjectName([string]$subjectName)\r\n    {\r\n        $certificates = gci -Recurse Cert:\\LocalMachine\\ |? { $_.gettype().name -eq \"X509Certificate2\" }\r\n        $cert = $certificates |? { $_.subject -eq $subjectName -and $_.PSParentPath -eq \"Microsoft.PowerShell.Security\\Certificate::LocalMachine\\My\" }\r\n        if ($NULL -eq $cert)\r\n        {\r\n            throw (\"Unable to find certificate with subjectName {0}\" -f $subjectName)\r\n        }\r\n    \r\n        write $cert\r\n    }\r\n    function Test-CAPrerequisites()\r\n    {\r\n        $certInstalled = $null\r\n        try\r\n        {\r\n            $certInstalled = Get-CACertBySubjectName $_rootCertSubject\r\n        }\r\n        catch {}\r\n\r\n        if ($NULL -ne $certInstalled)\r\n        {\r\n            throw (\"Certificate {0} already installed.  Cleanup CA certs 1st\" -f $_rootCertSubject)\r\n        }\r\n\r\n        if ($NULL -eq $ENV:OPENSSL_CONF)\r\n        {\r\n            throw (\"OpenSSL not configured on this system.  Run 'Initialize-CAOpenSSL' (even if you've already done so) to set everything up.\")\r\n        }\r\n        Write-Host \"Success\"\r\n    }\r\n    Test-CAPrerequisites\r\n    ```\r\n    \r\n    正确配置所有内容后，将显示“成功”消息。 \r\n\r\n<a id=\"createcertchain\"></a>\r\n\r\n## <a name=\"create-x509-certificate-chain\"></a>创建 X.509 证书链\r\n通过运行以下 PowerShell 脚本创建包含根 CA 的证书链，例如此示例使用的“CN=Azure IoT Root CA”。 此脚本还更新 Windows 操作系统证书存储，并在工作目录中创建证书文件。 \r\n    1. 以下脚本创建 PowerShell 函数，为给定使用者名称和签名机构创建自签名证书。 \r\n    \r\n    ```PowerShell\r\n    function New-CASelfsignedCertificate([string]$subjectName, [object]$signingCert, [bool]$isASigner=$true)\r\n    {\r\n        # Build up argument list\r\n        $selfSignedArgs =@{\"-DnsName\"=$subjectName; \r\n                           \"-CertStoreLocation\"=\"cert:\\LocalMachine\\My\";\r\n                           \"-NotAfter\"=(get-date).AddDays(30); \r\n                          }\r\n\r\n        if ($isASigner -eq $true)\r\n        {\r\n            $selfSignedArgs += @{\"-KeyUsage\"=\"CertSign\"; }\r\n            $selfSignedArgs += @{\"-TextExtension\"= @((\"2.5.29.19={text}ca=TRUE&pathlength=12\")); }\r\n        }\r\n        else\r\n        {\r\n            $selfSignedArgs += @{\"-TextExtension\"= @(\"2.5.29.37={text}1.3.6.1.5.5.7.3.2,1.3.6.1.5.5.7.3.1\", \"2.5.29.19={text}ca=FALSE&pathlength=0\")  }\r\n        }\r\n\r\n        if ($signingCert -ne $null)\r\n        {\r\n            $selfSignedArgs += @{\"-Signer\"=$signingCert }\r\n        }\r\n\r\n        if ($useEcc -eq $true)\r\n        {\r\n            $selfSignedArgs += @{\"-KeyAlgorithm\"=\"ECDSA_nistP256\";\r\n                             \"-CurveExport\"=\"CurveName\" }\r\n        }\r\n\r\n        # Now use splatting to process this\r\n        Write-Host (\"Generating certificate {0} which is for prototyping, NOT PRODUCTION.  It will expire in 30 days.\" -f $subjectName)\r\n        write (New-SelfSignedCertificate @selfSignedArgs)\r\n    }\r\n    ``` \r\n    \r\n    2. 以下 PowerShell 函数使用前面的函数以及 OpenSSL 二进制文件创建 X.509 中间证书。\r\n     \r\n    ```PowerShell\r\n    function New-CAIntermediateCert([string]$subjectName, [Microsoft.CertificateServices.Commands.Certificate]$signingCert, [string]$pemFileName)\r\n    {\r\n        $certFileName = ($subjectName + \".cer\")\r\n        $newCert = New-CASelfsignedCertificate $subjectName $signingCert\r\n        Export-Certificate -Cert $newCert -FilePath $certFileName -Type CERT | Out-Null\r\n        Import-Certificate -CertStoreLocation \"cert:\\LocalMachine\\CA\" -FilePath $certFileName | Out-Null\r\n\r\n        # Store public PEM for later chaining\r\n        openssl x509 -inform deer -in $certFileName -out $pemFileName\r\n\r\n        del $certFileName\r\n   \r\n        write $newCert\r\n    }  \r\n    ```\r\n    \r\n    3. 以下 PowerShell 函数创建 X.509 证书链。 阅读[证书链](https://en.wikipedia.org/wiki/X.509#Certificate_chains_and_cross-certification)，了解详细信息。\r\n    \r\n    ```PowerShell\r\n    function New-CACertChain()\r\n    {\r\n        Write-Host \"Beginning to install certificate chain to your LocalMachine\\My store\"\r\n        $rootCACert =  New-CASelfsignedCertificate $_rootCertSubject $null\r\n    \r\n        Export-Certificate -Cert $rootCACert -FilePath $rootCACerFileName  -Type CERT\r\n        Import-Certificate -CertStoreLocation \"cert:\\LocalMachine\\Root\" -FilePath $rootCACerFileName\r\n\r\n        openssl x509 -inform der -in $rootCACerFileName -out $rootCAPemFileName\r\n\r\n        $intermediateCert1 = New-CAIntermediateCert ($_intermediateCertSubject -f \"1\") $rootCACert $intermediate1CAPemFileName\r\n        $intermediateCert2 = New-CAIntermediateCert ($_intermediateCertSubject -f \"2\") $intermediateCert1 $intermediate2CAPemFileName\r\n        $intermediateCert3 = New-CAIntermediateCert ($_intermediateCertSubject -f \"3\") $intermediateCert2 $intermediate3CAPemFileName\r\n        Write-Host \"Success\"\r\n    }    \r\n    ```\r\n    \r\n    此脚本在工作目录创建名为 RootCA.cer 的文件。 \r\n    \r\n    4. 最后，通过在 PowerShell 窗口中运行命令 `New-CACertChain`，使用上述 PowerShell 函数创建 X.509 证书链。 \r\n\r\n\r\n<a id=\"signverificationcode\"></a>\r\n\r\n## <a name=\"proof-of-possession-of-your-x509-ca-certificate\"></a>X.509 CA 证书的所有权证明\r\n\r\n此脚本执行 X.509 证书的所有权证明流程。 \r\n\r\n在桌面上的 PowerShell 窗口中运行以下代码：\r\n\r\n    ```PowerShell\r\n    function New-CAVerificationCert([string]$requestedSubjectName)\r\n    {\r\n        $cnRequestedSubjectName = (\"CN={0}\" -f $requestedSubjectName)\r\n        $verifyRequestedFileName = \".\\verifyCert4.cer\"\r\n        $rootCACert = Get-CACertBySubjectName $_rootCertSubject\r\n        Write-Host \"Using Signing Cert:::\" \r\n        Write-Host $rootCACert\r\n    \r\n        $verifyCert = New-CASelfsignedCertificate $cnRequestedSubjectName $rootCACert $false\r\n\r\n        Export-Certificate -cert $verifyCert -filePath $verifyRequestedFileName -Type Cert\r\n        if (-not (Test-Path $verifyRequestedFileName))\r\n        {\r\n            throw (\"Error: CERT file {0} doesn't exist\" -f $verifyRequestedFileName)\r\n        }\r\n    \r\n        Write-Host (\"Certificate with subject {0} has been output to {1}\" -f $cnRequestedSubjectName, (Join-Path (get-location).path $verifyRequestedFileName)) \r\n    }\r\n    New-CAVerificationCert \"<your verification code>\"\r\n    ```\r\n    \r\n   这将以名为 VerifyCert4.cer 的文件在工作目录中创建具有给定使用者名称且由 CA 签名的证书。 此证书文件有助于向 IoT 中心验证你是否具有此 CA 的签名权限（即私钥）。\r\n\r\n\r\n<a id=\"createx509device\"></a>\r\n\r\n## <a name=\"create-leaf-x509-certificate-for-your-device\"></a>创建设备的 X.509 叶证书\r\n\r\n本部分介绍可以使用 PowerShell 脚本创建叶设备证书及相应证书链。 \r\n\r\n在本地计算机上的 PowerShell 窗口中，运行以下脚本创建此设备的 CA 签名的 X.509 证书：\r\n\r\n    ```PowerShell\r\n    function New-CADevice([string]$deviceName, [string]$signingCertSubject=$_rootCertSubject)\r\n    {\r\n        $cnNewDeviceSubjectName = (\"CN={0}\" -f $deviceName)\r\n        $newDevicePfxFileName = (\"./{0}.pfx\" -f $deviceName)\r\n        $newDevicePemAllFileName      = (\"./{0}-all.pem\" -f $deviceName)\r\n        $newDevicePemPrivateFileName  = (\"./{0}-private.pem\" -f $deviceName)\r\n        $newDevicePemPublicFileName   = (\"./{0}-public.pem\" -f $deviceName)\r\n    \r\n        $signingCert = Get-CACertBySubjectName $signingCertSubject ## \"CN=Azure IoT CA Intermediate 1 CA\"\r\n\r\n        $newDeviceCertPfx = New-CASelfSignedCertificate $cnNewDeviceSubjectName $signingCert $false\r\n    \r\n        $certSecureStringPwd = ConvertTo-SecureString -String $_privateKeyPassword -Force -AsPlainText\r\n\r\n        # Export the PFX of the cert we've just created.  The PFX is a format that contains both public and private keys.\r\n        Export-PFXCertificate -cert $newDeviceCertPfx -filePath $newDevicePfxFileName -password $certSecureStringPwd\r\n        if (-not (Test-Path $newDevicePfxFileName))\r\n        {\r\n            throw (\"Error: CERT file {0} doesn't exist\" -f $newDevicePfxFileName)\r\n        }\r\n\r\n        # Begin the massaging.  First, turn the PFX into a PEM file which contains public key, private key, and other attributes.\r\n        Write-Host (\"When prompted for password by openssl, enter the password as {0}\" -f $_privateKeyPassword)\r\n        openssl pkcs12 -in $newDevicePfxFileName -out $newDevicePemAllFileName -nodes\r\n\r\n        # Convert the PEM to get formats we can process\r\n        if ($useEcc -eq $true)\r\n        {\r\n            openssl ec -in $newDevicePemAllFileName -out $newDevicePemPrivateFileName\r\n        }\r\n        else\r\n        {\r\n            openssl rsa -in $newDevicePemAllFileName -out $newDevicePemPrivateFileName\r\n        }\r\n        openssl x509 -in $newDevicePemAllFileName -out $newDevicePemPublicFileName\r\n \r\n        Write-Host (\"Certificate with subject {0} has been output to {1}\" -f $cnNewDeviceSubjectName, (Join-Path (get-location).path $newDevicePemPublicFileName)) \r\n    }\r\n    ```\r\n    \r\n   然后使用用于创建设备的友好名称在 PowerShell 窗口中运行 `New-CADevice \"<yourTestDevice>\"`。 当系统提示输入 CA 私钥的密码时，请输入“123”。 这将在工作目录中创建 <yourTestDevice>.pfx 文件。\r\n\r\n"}