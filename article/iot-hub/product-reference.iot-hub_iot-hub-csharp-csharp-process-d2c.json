{"Title":"使用 Azure IoT 中心路由消息 (.Net)","Description":"如何使用路由规则和自定义终结点将消息发送到其他后端服务，从而处理 Azure IoT 中心的设备到云消息。","Content":"# <a name=\"routing-messages-with-iot-hub-net\"></a>使用 IoT 中心路由消息 (.NET)\r\n\r\n[!INCLUDE [iot-hub-selector-process-d2c](../../includes/iot-hub-selector-process-d2c.md)]\r\n\r\n本教程是在 [IoT 中心入门]教程的基础上制作的。 本教程：\r\n\r\n* 介绍如何以基于配置的轻松方式，使用路由规则发送设备到云的消息。\r\n* 介绍如何隔离需要解决方案后端立即执行操作以进行进一步处理的交互式消息。 例如，设备可能将发送一条警报消息，触发在 CRM 系统中插入票证。 与此相反，数据点消息（例如温度遥测）则送入分析引擎。\r\n\r\n在本教程结束时，会运行三个 .NET 控制台应用：\r\n\r\n* **SimulatedDevice**，（在 [IoT 中心入门]教程中创建的应用的修改版本）每秒发送一次设备到云的数据点消息，每 10 秒发送一次设备到云的交互式消息。\r\n* **ReadDeviceToCloudMessages**，显示设备应用发送的非关键遥测数据。\r\n* **ReadCriticalQueue**，从服务总线队列取消设备应用发送的关键消息的排队。 此队列附加到 IoT 中心。\r\n\r\n> [!NOTE]\r\n> IoT 中心对许多设备平台和语言（包括 C、Java 和 JavaScript）提供 SDK 支持。 若要了解如何将本教程中的模拟设备替换为物理设备，请参阅 [Azure IoT 开发人员中心]。\r\n\r\n要完成本教程，需要以下各项：\r\n\r\n* Visual Studio 2015 或 Visual Studio 2017。\r\n* 有效的 Azure 帐户。<br/>如果没有帐户，只需花费几分钟就能创建一个[试用帐户](https://www.azure.cn/pricing/1rmb-trial/)。\r\n\r\n我们还建议阅读 [Azure 存储]和 [Azure 服务总线]。\r\n\r\n## <a name=\"send-interactive-messages\"></a>发送交互式消息\r\n\r\n修改在 [IoT 中心入门]教程中创建的设备应用，以不定期发送交互式消息。\r\n\r\n在 Visual Studio 的 **SimulatedDevice** 项目中，将 `SendDeviceToCloudMessagesAsync` 方法替换为以下代码：\r\n\r\n```csharp\r\nprivate static async void SendDeviceToCloudMessagesAsync()\r\n{\r\n    double minTemperature = 20;\r\n    double minHumidity = 60;\r\n    Random rand = new Random();\r\n\r\n    while (true)\r\n    {\r\n        double currentTemperature = minTemperature + rand.NextDouble() * 15;\r\n        double currentHumidity = minHumidity + rand.NextDouble() * 20;\r\n\r\n        var telemetryDataPoint = new\r\n        {\r\n            deviceId = \"myFirstDevice\",\r\n            temperature = currentTemperature,\r\n            humidity = currentHumidity\r\n        };\r\n        var messageString = JsonConvert.SerializeObject(telemetryDataPoint);\r\n        string levelValue;\r\n\r\n        if (rand.NextDouble() > 0.7)\r\n        {\r\n            if (rand.NextDouble() > 0.5)\r\n            {\r\n                messageString = \"This is a critical message\";\r\n                levelValue = \"critical\";\r\n            }\r\n            else \r\n            {\r\n                messageString = \"This is a storage message\";\r\n                levelValue = \"storage\";\r\n            }\r\n        }\r\n        else\r\n        {\r\n            levelValue = \"normal\";\r\n        }\r\n        \r\n        var message = new Message(Encoding.ASCII.GetBytes(messageString));\r\n        message.Properties.Add(\"level\", levelValue);\r\n        \r\n        await deviceClient.SendEventAsync(message);\r\n        Console.WriteLine(\"{0} > Sent message: {1}\", DateTime.Now, messageString);\r\n\r\n        await Task.Delay(1000);\r\n    }\r\n}\r\n```\r\n\r\n此方法会将 `\"level\": \"critical\"` 和 `\"level\": \"storage\"` 属性随机添加到设备发送的消息，以模拟需要应用程序后端立即执行操作的消息或需要永久存储的消息。 应用程序会在消息属性（而非消息正文）中传递此信息，因此 IoT 中心可将消息路由到适当的消息目标。\r\n\r\n   > [!NOTE]\r\n   > 可使用消息属性根据各种方案路由消息，包括冷路径处理和此处所示的热路径示例。\r\n   > \r\n   > \r\n\r\n> [!NOTE]\r\n> 强烈建议按 MSDN 文章 [Transient Fault Handling]（暂时性故障处理）中所述实施指数退让等重试策略。\r\n\r\n## <a name=\"route-messages-to-a-queue-in-your-iot-hub\"></a>将消息路由到 IoT 中心中的队列\r\n\r\n本部分的操作：\r\n\r\n* 创建服务总线队列。\r\n* 将其连接到 IoT 中心。\r\n* 配置 IoT 中心，以根据是否存在某个消息属性将消息发送到队列。\r\n\r\n若要深入了解如何处理来自服务总线队列的消息，请参阅 [队列入门][Service Bus queue]教程。\r\n\r\n1. 按 [队列入门][Service Bus queue]中所述，创建服务总线队列。 队列必须与 IoT 中心位于同一订阅和区域中。 记下命名空间和队列名称。\r\n\r\n    > [!NOTE]\r\n    > 用作 IoT 中心终结点的服务总线队列和主题不能启用“会话”或“重复项检测”。 如果启用了其中任一选项，该终结点将在 Azure 门户中显示为“无法访问”。\r\n\r\n2. 在 Azure 门户中，打开 IoT 中心并单击“终结点” 。\r\n\r\n    ![IoT 中心的终结点][30]\r\n\r\n3. 在“终结点”边栏选项卡中，单击顶部的“添加”，将队列添加到 IoT 中心。 将终结点命名为“CriticalQueue”，并使用下拉列表选择“服务总线队列”、队列所在的服务总线命名空间和队列名称。 完成后，单击底部的“**保存**”。\r\n\r\n    ![添加终结点][31]\r\n\r\n4. 现在单击 IoT 中心的“路由”  。 单击边栏选项卡顶部的“添加” ，创建将消息路由到刚添加的队列的路由规则。 选择“DeviceTelemetry”  作为数据源。 输入 `level=\"critical\"` 作为条件，并选择刚添加为自定义终结点的队列作为路由规则终结点。  。\r\n\r\n    ![添加路由][32]\r\n\r\n    请确保回退路由设为“开” 。 此值是 IoT 中心的默认配置。\r\n\r\n    ![回退路由][33]\r\n\r\n## <a name=\"read-from-the-queue-endpoint\"></a>从队列终结点读取\r\n在本部分中，会从队列终结点读取消息。\r\n\r\n1. 在 Visual Studio 中，使用“控制台应用(.NET Framework)”项目模板将 Visual C# Windows 经典桌面项目添加到当前解决方案。 将项目命名为 **ReadCriticalQueue**。\r\n\r\n2. 在解决方案资源管理器中，右键单击 **ReadCriticalQueue** 项目，并单击“管理 NuGet 包”。 此操作会显示“**NuGet 包管理器**”窗口。\r\n\r\n3. 搜索“**WindowsAzure.ServiceBus**”，单击“**安装**”，并接受使用条款。 此操作会下载和安装 Azure 服务总线及其所有依赖项，并添加对它的引用。\r\n\r\n4. 在 **Program.cs** 文件顶部添加以下 **using** 语句：\r\n   \r\n    ```csharp\r\n    using System.IO;\r\n    using Microsoft.ServiceBus.Messaging;\r\n    ```\r\n\r\n5. 最后，在 **Main** 方法中添加以下行。 将连接字符串替换为队列的 **Listen** 权限：\r\n   \r\n    ```csharp\r\n    Console.WriteLine(\"Receive critical messages. Ctrl-C to exit.\\n\");\r\n    var connectionString = \"{service bus listen string}\";\r\n    var queueName = \"{queue name}\";\r\n\r\n    var client = QueueClient.CreateFromConnectionString(connectionString, queueName);\r\n\r\n    client.OnMessage(message =>\r\n        {\r\n            Stream stream = message.GetBody<Stream>();\r\n            StreamReader reader = new StreamReader(stream, Encoding.ASCII);\r\n            string s = reader.ReadToEnd();\r\n            Console.WriteLine(String.Format(\"Message body: {0}\", s));\r\n        });\r\n\r\n    Console.ReadLine();\r\n    ```\r\n\r\n## <a name=\"run-the-applications\"></a>运行应用程序\r\n现在，已准备就绪，可以运行应用程序了。\r\n\r\n1. 在 Visual Studio 的解决方案资源管理器中，右键单击解决方案并选择“**设置启动项目**”。 选择“多个启动项目”，并为 **ReadDeviceToCloudMessages**、**SimulatedDevice** 和 **ReadCriticalQueue** 项目选择“启动”作为操作。\r\n2. 按 **F5** 启动三个控制台应用。 **ReadDeviceToCloudMessages** 应用仅拥有 **SimulatedDevice** 应用程序发送的非关键消息，而 **ReadCriticalQueue** 应用仅拥有关键消息。\r\n\r\n   ![3 个控制台应用][50]\r\n\r\n## <a name=\"next-steps\"></a>后续步骤\r\n在本教程中，介绍了如何使用 IoT 中心的消息路由功能可靠地分派设备到云的消息。\r\n\r\n通过 [如何使用 IoT 中心发送云到设备的消息][lnk-c2d] ，了解如何将消息从解决方案后端发送到设备。\r\n\r\n若要查看使用 IoT 中心完成端到端解决方案的示例，请参阅 [Azure IoT 套件][lnk-suite]。\r\n\r\n若要深入了解如何使用 IoT 中心开发解决方案，请参阅 [IoT 中心开发人员指南]。\r\n\r\n若要详细了解 IoT 中心的消息路由，请参阅[使用 IoT 中心发送和接收消息][lnk-devguide-messaging]。\r\n\r\n<!-- Images. -->\r\n[50]: ./media/iot-hub-csharp-csharp-process-d2c/run1.png\r\n[30]: ./media/iot-hub-csharp-csharp-process-d2c/click-endpoints.png\r\n[31]: ./media/iot-hub-csharp-csharp-process-d2c/endpoint-creation.png\r\n[32]: ./media/iot-hub-csharp-csharp-process-d2c/route-creation.png\r\n[33]: ./media/iot-hub-csharp-csharp-process-d2c/fallback-route.png\r\n\r\n<!-- Links -->\r\n[Service Bus queue]: ../service-bus-messaging/service-bus-dotnet-get-started-with-queues.md\r\n[Azure 存储]: /storage/\r\n[Azure 服务总线]: /service-bus/\r\n[IoT 中心开发人员指南]: iot-hub-devguide.md\r\n[IoT 中心入门]: iot-hub-csharp-csharp-getstarted.md\r\n[lnk-devguide-messaging]: iot-hub-devguide-messaging.md\r\n[Azure IoT 开发人员中心]: https://docs.azure.cn/develop/iot\r\n[Transient Fault Handling]: https://msdn.microsoft.com/library/hh680901(v=pandp.50).aspx\r\n[lnk-c2d]: iot-hub-csharp-csharp-c2d.md\r\n[lnk-suite]: /iot-suite/\r\n\r\n\r\n<!--Update_Description: update wording and code-->"}