{"Title":"Azure IoT 中心入门 (Java)","Description":"了解如何通过用于 Java 的 IoT SDK 将设备到云消息发送到 Azure IoT 中心。 创建模拟的设备和服务应用，以便通过 IoT 中心注册设备、发送消息和读取消息。","Content":"# <a name=\"connect-your-device-to-your-iot-hub-using-java\"></a>使用 Java 将设备连接到 IoT 中心\r\n[!INCLUDE [iot-hub-selector-get-started](../../includes/iot-hub-selector-get-started.md)]\r\n\r\n在本教程结束时，将获得三个 Java 控制台应用：\r\n\r\n* **create-device-identity**，用于创建设备标识和关联的安全密钥以连接设备应用。\r\n* **read-d2c-messages**，用于显示设备应用发送的遥测数据。\r\n* **simulated-device**，使用前面创建的设备标识连接到 IoT 中心，并使用 MQTT 协议每秒发送一次遥测消息。\r\n\r\n> [!NOTE]\r\n> [Azure IoT SDK][lnk-hub-sdks] 文章介绍了一些 Azure IoT SDK，它们可用于构建在设备和解决方案后端运行的应用。\r\n> \r\n> \r\n\r\n要完成本教程，需要以下各项：\r\n\r\n* 最新的 [Java SE 开发工具包 8](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) \r\n* [Maven 3](https://maven.apache.org/install.html) \r\n* 有效的 Azure 帐户。 如果没有帐户，可以创建一个[试用帐户][lnk-free-trial]，只需几分钟即可完成。\r\n\r\n[!INCLUDE [iot-hub-get-started-create-hub](../../includes/iot-hub-get-started-create-hub.md)]\r\n\r\n最后，请记下“主密钥”值。 然后单击“终结点”和“事件”内置终结点。 在“属性”边栏选项卡中，记下“与事件中心兼容的名称”和“与事件中心兼容的终结点”的地址。 创建 **read-d2c-messages** 应用时，将要用到这三个值。\r\n\r\n![Azure 门户 IoT 中心消息传递边栏选项卡][6]\r\n\r\n现在已创建 IoT 中心。 已获取 IoT 中心主机名、IoT 中心连接字符串、IoT 中心主密钥、与事件中心兼容的名称以及与事件中心兼容的终结点，接下来需要完成本教程。\r\n\r\n## <a name=\"create-a-device-identity\"></a>创建设备标识\r\n在本部分中，会创建一个 Java 控制台应用，用于在 IoT 中心的标识注册表中创建设备标识。 设备无法连接到 IoT 中心，除非它在标识注册表中具有条目。 有关详细信息，请参阅 **IoT 中心开发人员指南** 的 [标识注册表][lnk-devguide-identity]部分。 当你运行此控制台应用时，它生成唯一的设备 ID 和密钥，当设备向 IoT 中心发送设备到云的消息时，可以用于标识设备本身。\r\n\r\n1. 创建名为 iot-java-get-started 的空文件夹。 在 iot-java-get-started 文件夹的命令提示符处，使用以下命令创建名为 **create-device-identity** 的 Maven 项目。 请注意，这是一条很长的命令：\r\n\r\n    ```cmd/sh\r\n    mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=create-device-identity -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\r\n    ```\r\n2. 在命令提示符下，浏览到 create-device-identity 文件夹。\r\n3. 使用文本编辑器，打开 create-device-identity 文件夹中的 pom.xml 文件，并在 **dependencies** 节点中添加以下依赖项。 通过此依赖项可在应用中使用 iot-service-client 包：\r\n\r\n    ```xml\r\n    <dependency>\r\n      <groupId>com.microsoft.azure.sdk.iot</groupId>\r\n      <artifactId>iot-service-client</artifactId>\r\n      <version>1.7.23</version>\r\n    </dependency>\r\n    ```\r\n    \r\n    > [!NOTE]\r\n    > 可以使用 [Maven 搜索][lnk-maven-service-search]检查是否有最新版本的 **iot-service-client**。\r\n\r\n4. 保存并关闭 pom.xml 文件。\r\n5. 使用文本编辑器打开 create-device-identity\\src\\main\\java\\com\\mycompany\\app\\App.java 文件。\r\n6. 在该文件中添加以下 **import** 语句：\r\n\r\n    ```java\r\n    import com.microsoft.azure.sdk.iot.service.exceptions.IotHubException;\r\n    import com.microsoft.azure.sdk.iot.service.Device;\r\n    import com.microsoft.azure.sdk.iot.service.RegistryManager;\r\n   \r\n    import java.io.IOException;\r\n    import java.net.URISyntaxException;\r\n    ```\r\n7. 将以下类级变量添加到 **App** 类，并将 **{yourhubconnectionstring}** 替换为前面记录的值：\r\n\r\n    ```java\r\n    private static final String connectionString = \"{yourhubconnectionstring}\";\r\n    private static final String deviceId = \"myFirstJavaDevice\";\r\n   \r\n    ```\r\n[!INCLUDE [iot-hub-pii-note-naming-device](../../includes/iot-hub-pii-note-naming-device.md)]\r\n\r\n8. 修改 **main** 方法的签名，包含如下所示的异常：\r\n\r\n    ```java\r\n    public static void main( String[] args ) throws IOException, URISyntaxException, Exception\r\n    ```\r\n9. 添加以下代码作为 **main** 方法的主体。 此代码在 IoT 中心标识注册表中创建名为 *javadevice* 的设备（如果还没有该设备）。 随即显示稍后需要用到的设备 ID 和密钥：\r\n\r\n    ```java\r\n    RegistryManager registryManager = RegistryManager.createFromConnectionString(connectionString);\r\n\r\n    // Create a device that's enabled by default, \r\n    // with an autogenerated key.\r\n    Device device = Device.createFromId(deviceId, null, null);\r\n    try {\r\n      device = registryManager.addDevice(device);\r\n    } catch (IotHubException iote) {\r\n      // If the device already exists.\r\n      try {\r\n        device = registryManager.getDevice(deviceId);\r\n      } catch (IotHubException iotf) {\r\n        iotf.printStackTrace();\r\n      }\r\n    }\r\n\r\n    // Display information about the\r\n    // device you created.\r\n    System.out.println(\"Device Id: \" + device.getDeviceId());\r\n    System.out.println(\"Device key: \" + device.getPrimaryKey());\r\n    ```\r\n10. 保存并关闭 App.java 文件。\r\n11. 若要使用 Maven 生成 **create-device-identity** 应用，请在命令提示符下的 create-device-identity 文件夹中执行以下命令：\r\n\r\n    ```cmd/sh\r\n    mvn clean package -DskipTests\r\n    ```\r\n12. 若要使用 Maven 运行 **create-device-identity** 应用，请在 create-device-identity 文件夹中的命令提示符下执行以下命令：\r\n\r\n    ```cmd/sh\r\n    mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\"\r\n    ```\r\n13. 记下**设备 ID** 和**设备密钥**。 稍后在创建连接到作为设备的 IoT 中心的应用时需要这些值。\r\n\r\n> [!NOTE]\r\n> IoT 中心标识注册表仅存储用于实现 IoT 中心安全访问的设备标识。 它存储设备 ID 和密钥作为安全凭据，以及启用或禁用标志（可用于禁用对单个设备的访问）。 如果应用需要存储设备特定的其他元数据，需使用应用特定的存储。 有关详细信息，请参阅 [IoT 中心开发人员指南][lnk-devguide-identity]。\r\n> \r\n> \r\n\r\n## <a name=\"receive-device-to-cloud-messages\"></a>接收设备到云的消息\r\n在本部分中，会创建一个 Java 控制台应用程序，用于读取来自 IoT 中心的设备到云消息。 IoT 中心公开与[事件中心][lnk-event-hubs-overview]兼容的终结点，以便你可读取设备到云的消息。 为了简单起见，本教程创建的基本读取器不适用于高吞吐量部署。 [Process device-to-cloud messages][lnk-process-d2c-tutorial] （处理设备到云的消息）教程介绍了如何大规模处理设备到云的消息。 [事件中心入门][lnk-eventhubs-tutorial] 教程更详细地介绍了如何处理来自事件中心的消息，此教程也适用于与 IoT 中心事件中心兼容的终结点。\r\n\r\n> [!NOTE]\r\n> 与事件中心兼容的终结点始终使用 AMQP 协议读取设备到云的消息。\r\n> \r\n> \r\n\r\n1. 在 *创建设备标识* 部分中创建的 iot-java-get-started 文件夹中，在命令提示符处使用以下命令创建名为 **read-d2c-messages** 的 Maven 项目。 请注意，这是一条很长的命令：\r\n\r\n    ```cmd/sh\r\n    mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=read-d2c-messages -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\r\n    ```\r\n2. 在命令提示符下，浏览到 read-d2c-messages 文件夹。\r\n3. 使用文本编辑器，打开 read-d2c-messages 文件夹中的 pom.xml 文件，并在 **dependencies** 节点中添加以下依赖项。 借助此依赖项，可使用应用中的 eventhubs-client 包，从与事件中心兼容的终结点进行读取：\r\n\r\n    ```xml\r\n    <dependency> \r\n        <groupId>com.microsoft.azure</groupId> \r\n        <artifactId>azure-eventhubs</artifactId> \r\n        <version>0.15.0</version> \r\n    </dependency>\r\n    ```\r\n\r\n4. 保存并关闭 pom.xml 文件。\r\n5. 使用文本编辑器打开 read-d2c-messages\\src\\main\\java\\com\\mycompany\\app\\App.java 文件。\r\n6. 在该文件中添加以下 **import** 语句：\r\n\r\n    ```java\r\n    import java.io.IOException;\r\n    import com.microsoft.azure.eventhubs.*;\r\n\r\n    import java.nio.charset.Charset;\r\n    import java.time.*;\r\n    import java.util.function.*;\r\n    ```\r\n7. 将下列类级变量添加到 **App** 类。 将 **{youriothubkey}**、**{youreventhubcompatibleendpoint}** 和 **{youreventhubcompatiblename}** 替换为前面记下的值：\r\n\r\n    ```java\r\n    private static String connStr = \"Endpoint={youreventhubcompatibleendpoint};EntityPath={youreventhubcompatiblename};SharedAccessKeyName=iothubowner;SharedAccessKey={youriothubkey}\";\r\n    ```\r\n8. 将以下 **receiveMessages** 方法添加到 **App** 类。 此方法创建 **EventHubClient** 实例以连接到与事件中心兼容的终结点，然后以异步方式创建 **PartitionReceiver** 实例，以便从事件中心分区读取。 它持续循环并输出消息详细信息，直到应用终止。\r\n\r\n    ```java\r\n    // Create a receiver on a partition.\r\n    private static EventHubClient receiveMessages(final String partitionId) {\r\n      EventHubClient client = null;\r\n      try {\r\n        client = EventHubClient.createFromConnectionStringSync(connStr);\r\n      } catch (Exception e) {\r\n        System.out.println(\"Failed to create client: \" + e.getMessage());\r\n        System.exit(1);\r\n      }\r\n      try {\r\n        // Create a receiver using the\r\n        // default Event Hubs consumer group\r\n        // that listens for messages from now on.\r\n        client.createReceiver(EventHubClient.DEFAULT_CONSUMER_GROUP_NAME, partitionId, Instant.now())\r\n          .thenAccept(new Consumer<PartitionReceiver>() {\r\n            public void accept(PartitionReceiver receiver) {\r\n              System.out.println(\"** Created receiver on partition \" + partitionId);\r\n              try {\r\n                while (true) {\r\n                  Iterable<EventData> receivedEvents = receiver.receive(100).get();\r\n                  int batchSize = 0;\r\n                  if (receivedEvents != null) {\r\n                    System.out.println(\"Got some evenst\");\r\n                    for (EventData receivedEvent : receivedEvents) {\r\n                      System.out.println(String.format(\"Offset: %s, SeqNo: %s, EnqueueTime: %s\",\r\n                        receivedEvent.getSystemProperties().getOffset(),\r\n                        receivedEvent.getSystemProperties().getSequenceNumber(),\r\n                        receivedEvent.getSystemProperties().getEnqueuedTime()));\r\n                      System.out.println(String.format(\"| Device ID: %s\",\r\n                        receivedEvent.getSystemProperties().get(\"iothub-connection-device-id\")));\r\n                      System.out.println(String.format(\"| Message Payload: %s\",\r\n                        new String(receivedEvent.getBytes(), Charset.defaultCharset())));\r\n                      batchSize++;\r\n                    }\r\n                  }\r\n                  System.out.println(String.format(\"Partition: %s, ReceivedBatch Size: %s\", partitionId, batchSize));\r\n                }\r\n              } catch (Exception e) {\r\n                System.out.println(\"Failed to receive messages: \" + e.getMessage());\r\n              }\r\n            }\r\n          });\r\n        } catch (Exception e) {\r\n          System.out.println(\"Failed to create receiver: \" + e.getMessage());\r\n      }\r\n      return client;\r\n    }\r\n    ```\r\n   \r\n   > [!NOTE]\r\n   > 在创建开始运行后只读取发送到 IoT 中心的消息的接收方时，此方法使用筛选器。 此方法很适合测试环境，因为这样可以看到当前的消息集。 在生产环境中，代码应确保它能处理所有消息。有关详细信息，请参阅[如何处理 IoT 中心设备到云的消息][lnk-process-d2c-tutorial]教程。\r\n   > \r\n   > \r\n9. 修改 **main** 方法的签名，包含如下所示的异常：\r\n\r\n    ```java\r\n    public static void main( String[] args ) throws IOException\r\n    ```\r\n10. 在 **App** 类的 **main** 方法中添加以下代码。 此代码将创建两个（**EventHubClient** 和 **PartitionReceiver**）实例并使用户可在处理完消息后关闭应用：\r\n\r\n    ```java\r\n    // Create receivers for partitions 0 and 1.\r\n    EventHubClient client0 = receiveMessages(\"0\");\r\n    EventHubClient client1 = receiveMessages(\"1\");\r\n    System.out.println(\"Press ENTER to exit.\");\r\n    System.in.read();\r\n    try {\r\n      client0.closeSync();\r\n      client1.closeSync();\r\n      System.exit(0);\r\n    } catch (Exception e) {\r\n      System.exit(1);\r\n    }\r\n    ```\r\n    \r\n    > [!NOTE]\r\n    > 此代码假设已在 F1（免费）层创建 IoT 中心。 免费 IoT 中心有“0”和“1”这两个分区。\r\n    > \r\n    > \r\n11. 保存并关闭 App.java 文件。\r\n12. 若要使用 Maven 生成 **read-d2c-messages** 应用，请在 read-d2c-messages 文件夹中的命令提示符下执行以下命令：\r\n\r\n    ```cmd/sh\r\n    mvn clean package -DskipTests\r\n    ```\r\n\r\n## <a name=\"create-a-device-app\"></a>创建设备应用\r\n在本部分中，会创建一个 Java 控制台应用程序，用于模拟向 IoT 中心发送设备到云消息的设备。\r\n\r\n1. 在 *创建设备标识* 部分创建的 iot-java-get-started 文件夹中，在命令提示符处创建名为 **simulated-device** 的 Maven 项目。 请注意，这是一条很长的命令：\r\n\r\n    ```cmd/sh\r\n    mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=simulated-device -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\r\n    ```\r\n2. 在命令提示符下，浏览到 simulated-device 文件夹。\r\n3. 使用文本编辑器，打开 simulated-device 文件夹中的 pom.xml 文件，并在 **dependencies** 节点中添加以下依赖项。 通过此依赖项可以使用应用中的 iothub-java-client 包与 IoT 中心通信，并将 Java 对象序列化为 JSON：\r\n\r\n    ```xml\r\n    <dependency>\r\n      <groupId>com.microsoft.azure.sdk.iot</groupId>\r\n      <artifactId>iot-device-client</artifactId>\r\n      <version>1.3.32</version>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>com.google.code.gson</groupId>\r\n      <artifactId>gson</artifactId>\r\n      <version>2.3.1</version>\r\n    </dependency>\r\n    ```\r\n\r\n    > [!NOTE]\r\n    > 可以使用 [Maven 搜索][lnk-maven-device-search]检查是否有最新版本的 **iot-device-client**。\r\n\r\n4. 保存并关闭 pom.xml 文件。\r\n5. 使用文本编辑器打开 simulated-device\\src\\main\\java\\com\\mycompany\\app\\App.java 文件。\r\n6. 在该文件中添加以下 **import** 语句：\r\n\r\n    ```java\r\n    import com.microsoft.azure.sdk.iot.device.*;\r\n    import com.google.gson.Gson;\r\n\r\n    import java.io.*;\r\n    import java.net.URISyntaxException;\r\n    import java.util.Random;\r\n    import java.util.concurrent.Executors;\r\n    import java.util.concurrent.ExecutorService;\r\n    ```\r\n7. 将以下类级变量添加到 **App** 类。 将 **{youriothubname}** 替换为 IoT 中心名称，将 **{yourdevicekey}** 替换为在*创建设备标识*部分中生成的设备密钥值：\r\n\r\n    ```java\r\n    private static String connString = \"HostName={youriothubname}.azure-devices.cn;DeviceId=myFirstJavaDevice;SharedAccessKey={yourdevicekey}\";\r\n    private static IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\r\n    private static String deviceId = \"myFirstJavaDevice\";\r\n    private static DeviceClient client;\r\n    ```\r\n   \r\n    本示例应用在实例化 **DeviceClient** 对象时使用 **protocol** 变量。 可以使用 MQTT、AMQP 或 HTTPS 协议与 IoT 中心通信。\r\n\r\n8. 在 **App** 类中添加以下嵌套的 **TelemetryDataPoint** 类，以指定设备要发送到 IoT 中心的遥测数据：\r\n\r\n    ```java\r\n    private static class TelemetryDataPoint {\r\n      public String deviceId;\r\n      public double temperature;\r\n      public double humidity;\r\n   \r\n      public String serialize() {\r\n        Gson gson = new Gson();\r\n        return gson.toJson(this);\r\n      }\r\n    }\r\n    ```\r\n9. 在 **App** 类中添加以下嵌套的 **EventCallback** 类，以显示 IoT 中心在处理来自设备应用的消息时返回的确认状态。 处理消息时，此方法还会通知应用中的主线程：\r\n   \r\n    ```java\r\n    private static class EventCallback implements IotHubEventCallback {\r\n      public void execute(IotHubStatusCode status, Object context) {\r\n        System.out.println(\"IoT Hub responded to message with status: \" + status.name());\r\n   \r\n        if (context != null) {\r\n          synchronized (context) {\r\n            context.notify();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    ```\r\n10. 在 **App** 类中添加以下嵌套的 **MessageSender** 类。 此类中的 **run** 方法会生成要发送到 IoT 中心的示例遥测数据，并在发送下一条消息之前等待确认：\r\n\r\n    ```java\r\n    private static class MessageSender implements Runnable {\r\n    \r\n      public void run()  {\r\n        try {\r\n          double minTemperature = 20;\r\n          double minHumidity = 60;\r\n          Random rand = new Random();\r\n    \r\n          while (true) {\r\n            double currentTemperature = minTemperature + rand.nextDouble() * 15;\r\n            double currentHumidity = minHumidity + rand.nextDouble() * 20;\r\n            TelemetryDataPoint telemetryDataPoint = new TelemetryDataPoint();\r\n            telemetryDataPoint.deviceId = deviceId;\r\n            telemetryDataPoint.temperature = currentTemperature;\r\n            telemetryDataPoint.humidity = currentHumidity;\r\n    \r\n            String msgStr = telemetryDataPoint.serialize();\r\n            Message msg = new Message(msgStr);\r\n            msg.setProperty(\"temperatureAlert\", (currentTemperature > 30) ? \"true\" : \"false\");\r\n            msg.setMessageId(java.util.UUID.randomUUID().toString()); \r\n            System.out.println(\"Sending: \" + msgStr);\r\n    \r\n            Object lockobj = new Object();\r\n            EventCallback callback = new EventCallback();\r\n            client.sendEventAsync(msg, callback, lockobj);\r\n    \r\n            synchronized (lockobj) {\r\n              lockobj.wait();\r\n            }\r\n            Thread.sleep(1000);\r\n          }\r\n        } catch (InterruptedException e) {\r\n          System.out.println(\"Finished.\");\r\n        }\r\n      }\r\n    }\r\n    ```\r\n    \r\n    IoT 中心确认前面的消息一秒后，此方法将发送新的设备到云消息。 该消息包含一个具有设备 ID 的 JSON 序列化对象和一个随机生成的编号，用于模拟温度传感器和湿度传感器。\r\n11. 将 **main** 方法替换为以下代码，该代码创建用于向 IoT 中心发送设备到云消息的线程：\r\n\r\n    ```java\r\n    public static void main( String[] args ) throws IOException, URISyntaxException {\r\n      client = new DeviceClient(connString, protocol);\r\n      client.open();\r\n    \r\n      MessageSender sender = new MessageSender();\r\n    \r\n      ExecutorService executor = Executors.newFixedThreadPool(1);\r\n      executor.execute(sender);\r\n    \r\n      System.out.println(\"Press ENTER to exit.\");\r\n      System.in.read();\r\n      executor.shutdownNow();\r\n      client.closeNow();\r\n    }\r\n    ```\r\n12. 保存并关闭 App.java 文件。\r\n13. 若要使用 Maven 构建 **simulated-device** 应用，请在 simulated-device 文件夹的命令提示符处执行以下命令：\r\n\r\n    ```cmd/sh\r\n    mvn clean package -DskipTests\r\n    ```\r\n\r\n> [!NOTE]\r\n> 为简单起见，本教程不实现任何重试策略。 在生产代码中，应该按 MSDN 文章 [Transient Fault Handling][lnk-transient-faults]（暂时性故障处理）中所述实施重试策略（例如指数性的回退）。\r\n> \r\n> \r\n\r\n## <a name=\"run-the-apps\"></a>运行应用\r\n现在，已准备就绪，可以运行应用。\r\n\r\n1. 在 read-d2c 文件夹的命令提示符处，运行以下命令监视 IoT 中心的第一个分区：\r\n\r\n    ```cmd/sh\r\n    mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\"\r\n    ```\r\n   \r\n    ![用于监视设备到云的消息的 Java IoT 中心服务应用][7]\r\n2. 在 simulated-device 文件夹的命令提示符处，运行以下命令将遥测数据发送到 IoT 中心：\r\n\r\n    ```cmd/sh\r\n    mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\" \r\n    ```\r\n   \r\n    ![用于发送设备到云消息的 Java IoT 中心设备应用][8]\r\n3. [Azure 门户][lnk-portal]中的“使用情况”磁贴显示发送到 IoT 中心的消息数：\r\n   \r\n    ![显示发送到 IoT 中心的消息数的 Azure 门户“使用情况”磁贴][43]\r\n\r\n## <a name=\"next-steps\"></a>后续步骤\r\n在本教程中，已在 Azure 门户中配置了新的 IoT 中心，然后在 IoT 中心的标识注册表中创建了设备标识。 已使用此设备标识来让设备应用向 IoT 中心发送设备到云的消息。 还创建了一个应用，用于显示 IoT 中心接收的消息。\r\n\r\n若要继续了解 IoT 中心入门知识并浏览其他 IoT 方案，请参阅：\r\n\r\n* \r\n            [连接设备][lnk-connect-device]\r\n* [设备管理入门][lnk-device-management]\r\n* [Azure IoT Edge 入门][lnk-iot-edge]\r\n\r\n若要了解如何扩展 IoT 解决方案和如何大规模处理设备到云的消息，请参阅 [Process device-to-cloud messages][lnk-process-d2c-tutorial] （处理设备到云的消息）教程。\r\n[!INCLUDE [iot-hub-get-started-next-steps](../../includes/iot-hub-get-started-next-steps.md)]\r\n\r\n<!-- Images. -->\r\n[6]: ./media/iot-hub-java-java-getstarted/create-iot-hub6.png\r\n[7]: ./media/iot-hub-java-java-getstarted/runapp1.png\r\n[8]: ./media/iot-hub-java-java-getstarted/runapp2.png\r\n[43]: ./media/iot-hub-java-java-getstarted/usage.png\r\n\r\n<!-- Links -->\r\n[lnk-transient-faults]: https://msdn.microsoft.com/library/hh680901(v=pandp.50).aspx\r\n\r\n[lnk-eventhubs-tutorial]: ../event-hubs/event-hubs-csharp-ephcs-getstarted.md\r\n[lnk-devguide-identity]: ./iot-hub-devguide-identity-registry.md\r\n[lnk-event-hubs-overview]: ../event-hubs/event-hubs-overview.md\r\n[lnk-process-d2c-tutorial]: ./iot-hub-csharp-csharp-process-d2c.md\r\n\r\n[lnk-hub-sdks]: ./iot-hub-devguide-sdks.md\r\n[lnk-free-trial]: https://www.azure.cn/pricing/1rmb-trial/\r\n[lnk-portal]: https://portal.azure.cn/\r\n\r\n[lnk-device-management]: ./iot-hub-node-node-device-management-get-started.md\r\n[lnk-iot-edge]: iot-hub-linux-iot-edge-get-started.md\r\n[lnk-connect-device]: https://www.azure.cn/develop/iot/\r\n[lnk-maven-service-search]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22iot-service-client%22%20g%3A%22com.microsoft.azure.sdk.iot%22\r\n[lnk-maven-device-search]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22iot-device-client%22%20g%3A%22com.microsoft.azure.sdk.iot%22\r\n[lnk-maven-eventhubs-search]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22azure-eventhubs%22\r\n\r\n\r\n<!--Update_Description:update code and wording-->"}