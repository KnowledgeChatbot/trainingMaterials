{"Title":"使用 Azure IoT 中心安排作业 (Java)","Description":"如何安排 Azure IoT 中心作业对多台设备调用直接方法并设置必需属性。 使用适用于 Java 的 Azure IoT 设备 SDK 实现模拟设备应用，并使用适用于 Java 的 Azure IoT 服务 SDK 实现用于运行作业的服务应用。","Content":"# <a name=\"schedule-and-broadcast-jobs-java\"></a>计划和广播作业 (Java)\r\n\r\n[!INCLUDE [iot-hub-selector-schedule-jobs](../../includes/iot-hub-selector-schedule-jobs.md)]\r\n\r\n使用 Azure IoT 中心来计划和跟踪可更新数百万台设备的作业。 使用作业可以：\r\n\r\n* 更新所需属性\r\n* 更新标记\r\n* 调用直接方法\r\n\r\n作业包装上述一项操作，并跟踪一组设备中的执行情况。 设备孪生查询定义作业执行的一组设备。 例如，后端应用可以使用作业在 10,000 台设备上调用直接方法来重启设备。 使用设备孪生查询指定设备集，并将作业计划为在以后运行。 每个设备接收和执行 reboot 直接方法时，该作业会跟踪进度。\r\n\r\n若要详细了解其中的每项功能，请参阅：\r\n\r\n* 设备孪生和属性：[设备孪生入门](iot-hub-java-java-twin-getstarted.md)\r\n* 直接方法：[IoT 中心开发人员指南 - 直接方法](iot-hub-devguide-direct-methods.md)和[教程：使用直接方法](iot-hub-java-java-direct-methods.md)\r\n\r\n本教程演示如何：\r\n\r\n* 创建设备应用，用于实现名为 lockDoor 的直接方法。 该设备应用还从后端应用接收所需的属性更改。\r\n* 创建一个后端应用，该应用创建一个作业以在多台设备上调用 **lockDoor** 直接方法。 另一个作业将所需的属性更新发送到多个设备。\r\n\r\n本教程结束时，将有一个 java 控制台设备应用，以及一个 java 控制台后端应用：\r\n\r\nsimulated-device：连接到 IoT 中心、实现 lockDoor 直接方法，并处理所需的属性更改。\r\n\r\nschedule-jobs：使用作业来调用 lockDoor 直接方法，并在多个设备上更新设备孪生的必需属性。\r\n\r\n> [!NOTE]\r\n> [Azure IoT SDK](iot-hub-devguide-sdks.md) 一文介绍了可用于构建设备和后端应用的 Azure IoT SDK。\r\n\r\n## <a name=\"prerequisites\"></a>先决条件\r\n\r\n要完成本教程，需要：\r\n\r\n* 最新的 [Java SE 开发工具包 8](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)\r\n* [Maven 3](https://maven.apache.org/install.html)\r\n* 有效的 Azure 帐户。 （如果没有帐户，只需几分钟即可创建一个[试用帐户](http://www.azure.cn/pricing/1rmb-trial/)。）\r\n\r\n[!INCLUDE [iot-hub-get-started-create-hub](../../includes/iot-hub-get-started-create-hub.md)]\r\n\r\n[!INCLUDE [iot-hub-get-started-create-device-identity-portal](../../includes/iot-hub-get-started-create-device-identity-portal.md)]\r\n\r\n若要以编程方式创建设备标识，请参阅[使用 Java 将设备连接到 IoT 中心](iot-hub-java-java-getstarted.md#create-a-device-identity)一文中的相应部分。 还可使用 [iothub-explorer](https://github.com/Azure/iothub-explorer) 工具向 IoT 中心添加设备。\r\n\r\n## <a name=\"create-the-service-app\"></a>创建服务应用\r\n\r\n本部分中将创建一个使用作业进行如下操作的 Java 控制台应用：\r\n\r\n* 在多台设备上调用 lockDoor 直接方法。\r\n* 向多台设备发送必需属性。\r\n\r\n创建应用：\r\n\r\n1. 在开发计算机上，创建名为 `iot-java-schedule-jobs` 的空文件夹。\r\n\r\n1. 在 `iot-java-schedule-jobs` 文件夹中，通过命令提示符使用以下命令创建名为 schedule-jobs 的 Maven 项目。 请注意，这是一条很长的命令：\r\n\r\n    `mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=schedule-jobs -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false`\r\n\r\n1. 在命令提示符下，导航到 `schedule-jobs` 文件夹。\r\n\r\n1. 使用文本编辑器打开 `schedule-jobs` 文件夹中的 `pom.xml` 文件，在 **dependencies** 节点中添加以下依赖项。 通过此依赖项可以使用应用中的 **iot-service-client** 包来与 IoT 中心通信：\r\n\r\n    ```xml\r\n    <dependency>\r\n      <groupId>com.microsoft.azure.sdk.iot</groupId>\r\n      <artifactId>iot-service-client</artifactId>\r\n      <version>1.7.23</version>\r\n      <type>jar</type>\r\n    </dependency>\r\n    ```\r\n\r\n    > [!NOTE]\r\n    > 可以使用 [Maven 搜索](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22iot-service-client%22%20g%3A%22com.microsoft.azure.sdk.iot%22)检查是否有最新版本的 **iot-service-client**。\r\n\r\n1. 在 **dependencies** 节点后添加以下 **build** 节点。 此配置指示 Maven 使用 Java 1.8 来生成应用：\r\n\r\n    ```xml\r\n    <build>\r\n      <plugins>\r\n        <plugin>\r\n          <groupId>org.apache.maven.plugins</groupId>\r\n          <artifactId>maven-compiler-plugin</artifactId>\r\n          <version>3.3</version>\r\n          <configuration>\r\n            <source>1.8</source>\r\n            <target>1.8</target>\r\n          </configuration>\r\n        </plugin>\r\n      </plugins>\r\n    </build>\r\n    ```\r\n\r\n1. 保存并关闭 `pom.xml` 文件。\r\n\r\n1. 使用文本编辑器打开 `schedule-jobs\\src\\main\\java\\com\\mycompany\\app\\App.java` 文件。\r\n\r\n1. 在该文件中添加以下 **import** 语句：\r\n\r\n    ```java\r\n    import com.microsoft.azure.sdk.iot.service.devicetwin.DeviceTwinDevice;\r\n    import com.microsoft.azure.sdk.iot.service.devicetwin.Pair;\r\n    import com.microsoft.azure.sdk.iot.service.devicetwin.Query;\r\n    import com.microsoft.azure.sdk.iot.service.devicetwin.SqlQuery;\r\n    import com.microsoft.azure.sdk.iot.service.jobs.JobClient;\r\n    import com.microsoft.azure.sdk.iot.service.jobs.JobResult;\r\n    import com.microsoft.azure.sdk.iot.service.jobs.JobStatus;\r\n\r\n    import java.util.Date;\r\n    import java.time.Instant;\r\n    import java.util.HashSet;\r\n    import java.util.Set;\r\n    import java.util.UUID;\r\n    ```\r\n\r\n1. 将以下类级变量添加到 **App** 类。 将 `{youriothubconnectionstring}` 替换为在“创建 IoT 中心”部分记下的 IoT 中心连接字符串：\r\n\r\n    ```java\r\n    public static final String iotHubConnectionString = \"{youriothubconnectionstring}\";\r\n    public static final String deviceId = \"myDeviceId\";\r\n\r\n    // How long the job is permitted to run without\r\n    // completing its work on the set of devices\r\n    private static final long maxExecutionTimeInSeconds = 30;\r\n    ```\r\n\r\n1. 向 App 类添加以下方法，以安排作业更新设备孪生中的 Building 和 Floor 必需属性：\r\n\r\n    ```java\r\n    private static JobResult scheduleJobSetDesiredProperties(JobClient jobClient, String jobId) {\r\n      DeviceTwinDevice twin = new DeviceTwinDevice(deviceId);\r\n      Set<Pair> desiredProperties = new HashSet<Pair>();\r\n      desiredProperties.add(new Pair(\"Building\", 43));\r\n      desiredProperties.add(new Pair(\"Floor\", 3));\r\n      twin.setDesiredProperties(desiredProperties);\r\n      // Optimistic concurrency control\r\n      twin.setETag(\"*\");\r\n\r\n      // Schedule the update twin job to run now\r\n      // against a single device\r\n      System.out.println(\"Schedule job \" + jobId + \" for device \" + deviceId);\r\n      try {\r\n        JobResult jobResult = jobClient.scheduleUpdateTwin(jobId, \r\n          \"deviceId='\" + deviceId + \"'\",\r\n          twin,\r\n          new Date(),\r\n          maxExecutionTimeInSeconds);\r\n        return jobResult;\r\n      } catch (Exception e) {\r\n        System.out.println(\"Exception scheduling desired properties job: \" + jobId);\r\n        System.out.println(e.getMessage());\r\n        return null;\r\n      }\r\n    }\r\n    ```\r\n\r\n1. 若要安排作业调用 lockDoor 方法，请向 App 类添加以下方法：\r\n\r\n    ```java\r\n    private static JobResult scheduleJobCallDirectMethod(JobClient jobClient, String jobId) {\r\n      // Schedule a job now to call the lockDoor direct method\r\n      // against a single device. Response and connection\r\n      // timeouts are set to 5 seconds.\r\n      System.out.println(\"Schedule job \" + jobId + \" for device \" + deviceId);\r\n      try {\r\n        JobResult jobResult = jobClient.scheduleDeviceMethod(jobId,\r\n          \"deviceId='\" + deviceId + \"'\",\r\n          \"lockDoor\",\r\n          5L, 5L, null,\r\n          new Date(),\r\n          maxExecutionTimeInSeconds);\r\n        return jobResult;\r\n      } catch (Exception e) {\r\n        System.out.println(\"Exception scheduling direct method job: \" + jobId);\r\n        System.out.println(e.getMessage());\r\n        return null;\r\n      }\r\n    };\r\n    ```\r\n\r\n1. 若要监视作业，请向 App 类添加以下方法：\r\n\r\n    ```java\r\n    private static void monitorJob(JobClient jobClient, String jobId) {\r\n      try {\r\n        JobResult jobResult = jobClient.getJob(jobId);\r\n        if(jobResult == null)\r\n        {\r\n          System.out.println(\"No JobResult for: \" + jobId);\r\n          return;\r\n        }\r\n        // Check the job result until it's completed\r\n        while(jobResult.getJobStatus() != JobStatus.completed)\r\n        {\r\n          Thread.sleep(100);\r\n          jobResult = jobClient.getJob(jobId);\r\n          System.out.println(\"Status \" + jobResult.getJobStatus() + \" for job \" + jobId);\r\n        }\r\n        System.out.println(\"Final status \" + jobResult.getJobStatus() + \" for job \" + jobId);\r\n      } catch (Exception e) {\r\n        System.out.println(\"Exception monitoring job: \" + jobId);\r\n        System.out.println(e.getMessage());\r\n        return;\r\n      }\r\n    }\r\n    ```\r\n\r\n1. 若要查询已运行作业的详细信息，请添加以下方法：\r\n\r\n    ```java\r\n    private static void queryDeviceJobs(JobClient jobClient, String start) throws Exception {\r\n      System.out.println(\"\\nQuery device jobs since \" + start);\r\n\r\n      // Create a jobs query using the time the jobs started\r\n      Query deviceJobQuery = jobClient\r\n          .queryDeviceJob(SqlQuery.createSqlQuery(\"*\", SqlQuery.FromType.JOBS, \"devices.jobs.startTimeUtc > '\" + start + \"'\", null).getQuery());\r\n\r\n      // Iterate over the list of jobs and print the details\r\n      while (jobClient.hasNextJob(deviceJobQuery)) {\r\n        System.out.println(jobClient.getNextJob(deviceJobQuery));\r\n      }\r\n    }\r\n    ```\r\n\r\n1. 更新 **main** 方法签名，以包含以下 `throws` 子句：\r\n\r\n    ```java\r\n    public static void main( String[] args ) throws Exception\r\n    ```\r\n\r\n1. 若要依次运行和监视两个作业，请向 main 方法添加以下代码：\r\n\r\n    ```java\r\n    // Record the start time\r\n    String start = Instant.now().toString();\r\n\r\n    // Create JobClient\r\n    JobClient jobClient = JobClient.createFromConnectionString(iotHubConnectionString);\r\n    System.out.println(\"JobClient created with success\");\r\n\r\n    // Schedule twin job desired properties\r\n    // Maximum concurrent jobs is 1 for Free and S1 tiers\r\n    String desiredPropertiesJobId = \"DPCMD\" + UUID.randomUUID();\r\n    scheduleJobSetDesiredProperties(jobClient, desiredPropertiesJobId);\r\n    monitorJob(jobClient, desiredPropertiesJobId);\r\n\r\n    // Schedule twin job direct method\r\n    String directMethodJobId = \"DMCMD\" + UUID.randomUUID();\r\n    scheduleJobCallDirectMethod(jobClient, directMethodJobId);\r\n    monitorJob(jobClient, directMethodJobId);\r\n\r\n    // Run a query to show the job detail\r\n    queryDeviceJobs(jobClient, start);\r\n\r\n    System.out.println(\"Shutting down schedule-jobs app\");\r\n    ```\r\n\r\n1. 保存并关闭 `schedule-jobs\\src\\main\\java\\com\\mycompany\\app\\App.java` 文件\r\n\r\n1. 生成 schedule-jobs 应用并更正任何错误。 在命令提示符下，导航到 `schedule-jobs` 文件夹并运行以下命令：\r\n\r\n    `mvn clean package -DskipTests`\r\n\r\n## <a name=\"create-a-device-app\"></a>创建设备应用\r\n\r\n本部分中将创建一个 Java 控制台应用，处理从 IoT 中心发送的必需属性并实现直接方法调用。\r\n\r\n1. 在命令提示符下使用以下命令，在 `iot-java-schedule-jobs` 文件夹中创建名为 **simulated-device** 的 Maven 项目。 请注意，这是一条很长的命令：\r\n\r\n    `mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=simulated-device -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false`\r\n\r\n1. 在命令提示符下，导航到 `simulated-device` 文件夹。\r\n\r\n1. 使用文本编辑器打开 `simulated-device` 文件夹中的 `pom.xml` 文件，在 **dependencies** 节点中添加以下依赖项。 通过此依赖项可以使用应用中的 **iot-device-client** 包来与 IoT 中心进行通信：\r\n\r\n    ```xml\r\n    <dependency>\r\n      <groupId>com.microsoft.azure.sdk.iot</groupId>\r\n      <artifactId>iot-device-client</artifactId>\r\n      <version>1.3.32</version>\r\n    </dependency>\r\n    ```\r\n\r\n    > [!NOTE]\r\n    > 可以使用 [Maven 搜索](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22iot-device-client%22%20g%3A%22com.microsoft.azure.sdk.iot%22)检查是否有最新版本的 **iot-device-client**。\r\n\r\n1. 在 **dependencies** 节点后添加以下 **build** 节点。 此配置指示 Maven 使用 Java 1.8 来生成应用：\r\n\r\n    ```xml\r\n    <build>\r\n      <plugins>\r\n        <plugin>\r\n          <groupId>org.apache.maven.plugins</groupId>\r\n          <artifactId>maven-compiler-plugin</artifactId>\r\n          <version>3.3</version>\r\n          <configuration>\r\n            <source>1.8</source>\r\n            <target>1.8</target>\r\n          </configuration>\r\n        </plugin>\r\n      </plugins>\r\n    </build>\r\n    ```\r\n\r\n1. 保存并关闭 `pom.xml` 文件。\r\n\r\n1. 使用文本编辑器打开 `simulated-device\\src\\main\\java\\com\\mycompany\\app\\App.java` 文件。\r\n\r\n1. 在该文件中添加以下 **import** 语句：\r\n\r\n    ```java\r\n    import com.microsoft.azure.sdk.iot.device.*;\r\n    import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\r\n\r\n    import java.io.IOException;\r\n    import java.net.URISyntaxException;\r\n    import java.util.Scanner;\r\n    ```\r\n\r\n1. 将以下类级变量添加到 **App** 类。 将 `{youriothubname}` 替换为 IoT 中心名称，将 `{yourdevicekey}` 替换为在“创建设备标识”部分中生成的设备密钥值：\r\n\r\n    ```java\r\n    private static String connString = \"HostName={youriothubname}.azure-devices.cn;DeviceId=myDeviceID;SharedAccessKey={yourdevicekey}\";\r\n    private static IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\r\n    private static final int METHOD_SUCCESS = 200;\r\n    private static final int METHOD_NOT_DEFINED = 404;\r\n    ```\r\n\r\n    本示例应用在实例化 **DeviceClient** 对象时使用 **protocol** 变量。\r\n\r\n1. 若要在控制台中列显设备孪生通知，请向 App 类添加以下嵌套类：\r\n\r\n    ```java\r\n    // Handler for device twin operation notifications from IoT Hub\r\n    protected static class DeviceTwinStatusCallBack implements IotHubEventCallback {\r\n      public void execute(IotHubStatusCode status, Object context) {\r\n        System.out.println(\"IoT Hub responded to device twin operation with status \" + status.name());\r\n      }\r\n    }\r\n    ```\r\n\r\n1. 若要在控制台中列显直接方法通知，请向 App 类添加以下嵌套类：\r\n\r\n    ```java\r\n    // Handler for direct method notifications from IoT Hub\r\n    protected static class DirectMethodStatusCallback implements IotHubEventCallback {\r\n      public void execute(IotHubStatusCode status, Object context) {\r\n        System.out.println(\"IoT Hub responded to direct method operation with status \" + status.name());\r\n      }\r\n    }\r\n    ```\r\n\r\n1. 若要处理 IoT 中心的直接方法调用，请向 App 类添加以下嵌套类：\r\n\r\n    ```java\r\n    // Handler for direct method calls from IoT Hub\r\n    protected static class DirectMethodCallback\r\n        implements DeviceMethodCallback {\r\n      @Override\r\n      public DeviceMethodData call(String methodName, Object methodData, Object context) {\r\n        DeviceMethodData deviceMethodData;\r\n        switch (methodName) {\r\n          case \"lockDoor\": {\r\n            System.out.println(\"Executing direct method: \" + methodName);\r\n            deviceMethodData = new DeviceMethodData(METHOD_SUCCESS, \"Executed direct method \" + methodName);\r\n            break;\r\n          }\r\n          default: {\r\n            deviceMethodData = new DeviceMethodData(METHOD_NOT_DEFINED, \"Not defined direct method \" + methodName);\r\n          }\r\n        }\r\n        // Notify IoT Hub of result\r\n        return deviceMethodData;\r\n      }\r\n    }\r\n    ```\r\n\r\n1. 更新 **main** 方法签名，以包含以下 `throws` 子句：\r\n\r\n    ```java\r\n    public static void main( String[] args ) throws IOException, URISyntaxException\r\n    ```\r\n\r\n1. 将以下代码添加到 **main** 方法，以便：\r\n    * 创建用来与 IoT 中心通信的设备客户端。\r\n    * 创建一个 **Device** 对象用于存储设备孪生属性。\r\n\r\n    ```java\r\n    // Create a device client\r\n    DeviceClient client = new DeviceClient(connString, protocol);\r\n\r\n    // An object to manage device twin desired and reported properties\r\n    Device dataCollector = new Device() {\r\n      @Override\r\n      public void PropertyCall(String propertyKey, Object propertyValue, Object context)\r\n      {\r\n        System.out.println(\"Received desired property change: \" + propertyKey + \" \" + propertyValue);\r\n      }\r\n    };\r\n    ```\r\n\r\n1. 若要启动设备客户端服务，请向 main 方法添加以下代码：\r\n\r\n    ```java\r\n    try {\r\n      // Open the DeviceClient\r\n      // Start the device twin services\r\n      // Subscribe to direct method calls\r\n      client.open();\r\n      client.startDeviceTwin(new DeviceTwinStatusCallBack(), null, dataCollector, null);\r\n      client.subscribeToDeviceMethod(new DirectMethodCallback(), null, new DirectMethodStatusCallback(), null);\r\n    } catch (Exception e) {\r\n      System.out.println(\"Exception, shutting down \\n\" + \" Cause: \" + e.getCause() + \" \\n\" + e.getMessage());\r\n      dataCollector.clean();\r\n      client.closeNow();\r\n      System.out.println(\"Shutting down...\");\r\n    }\r\n    ```\r\n\r\n1. 若要在关闭前等待用户按 Enter 键，请向 main 方法末尾添加以下代码：\r\n\r\n    ```java\r\n    // Close the app\r\n    System.out.println(\"Press any key to exit...\");\r\n    Scanner scanner = new Scanner(System.in);\r\n    scanner.nextLine();\r\n    dataCollector.clean();\r\n    client.closeNow();\r\n    scanner.close();\r\n    ```\r\n\r\n1. 保存并关闭 `simulated-device\\src\\main\\java\\com\\mycompany\\app\\App.java` 文件。\r\n\r\n1. 生成 **simulated-device** 应用并更正任何错误。 在命令提示符下，导航到 `simulated-device` 文件夹并运行以下命令：\r\n\r\n    `mvn clean package -DskipTests`\r\n\r\n## <a name=\"run-the-apps\"></a>运行应用\r\n\r\n现在可以运行控制台应用了。\r\n\r\n1. 在 `simulated-device` 文件夹中的命令提示符处，运行以下命令启动设备应用用于侦听所需属性更改和直接方法调用：\r\n\r\n    `mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\"`\r\n\r\n    ![设备客户端启动](./media/iot-hub-java-java-schedule-jobs/device-app-1.png)\r\n\r\n1. 在 `schedule-jobs` 文件夹中的命令提示符处，运行以下命令以运行 schedule-jobs 服务应用，从而运行两个作业。 第一个作业设置所需的属性值，第二个作业调用直接方法：\r\n\r\n    `mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\"`\r\n\r\n    ![Java IoT 中心服务应用创建两个作业](./media/iot-hub-java-java-schedule-jobs/service-app-1.png)\r\n\r\n1. 设备应用处理所需的属性更改和直接方法调用：\r\n\r\n    ![设备客户端对更改作出响应](./media/iot-hub-java-java-schedule-jobs/device-app-2.png)\r\n\r\n## <a name=\"next-steps\"></a>后续步骤\r\n\r\n本教程中，在 Azure 门户中配置了新的 IoT 中心，并在 IoT 中心的标识注册表中创建了设备标识。 创建了运行两个作业的后端应用。 第一个作业设置了所需的属性值，第二个作业调用了直接方法。\r\n\r\n使用下列资源了解如何执行以下操作：\r\n\r\n* 通过 [IoT 中心入门](iot-hub-java-java-getstarted.md)教程学习如何从设备发送遥测数据。\r\n* 通过[使用直接方法](iot-hub-java-java-direct-methods.md)教程学习如何以交互方式控制设备（例如从用户控制的应用打开风扇）。\r\n"}