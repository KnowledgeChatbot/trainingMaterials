{"Title":"使用 Azure IoT 中心设备孪生属性 (Java)","Description":"如何使用 Azure IoT 中心设备孪生配置设备。 使用用于 Java 的 Azure IoT 设备 SDK 实现模拟设备应用，并使用用于 Java 的 Azure IoT 服务 SDK 实现可使用设备孪生更改设备配置的服务应用。","Content":"# <a name=\"use-desired-properties-to-configure-devices\"></a>使用所需属性配置设备\r\n\r\n[!INCLUDE [iot-hub-selector-twin-how-to-configure](../../includes/iot-hub-selector-twin-how-to-configure.md)]\r\n\r\n本教程结束时，可获得两个 Java 控制台应用：\r\n\r\n* **simulated-device**，一个模拟设备应用，它等待所需配置更新并报告模拟配置更新过程的状态。\r\n* **set-configuration**，一个后端应用，用于在设备上设置所需配置并查询配置更新过程。\r\n\r\n> [!NOTE]\r\n> [Azure IoT SDK][lnk-hub-sdks] 文章介绍了可用于构建设备和后端应用的 Azure IoT SDK。\r\n> \r\n> \r\n\r\n要完成本教程，需要以下各项：\r\n\r\n* 最新的 [Java SE 开发工具包 8](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) \r\n* [Maven 3](https://maven.apache.org/install.html) \r\n* 有效的 Azure 帐户。 如果没有帐户，可以创建一个[试用帐户][lnk-free-trial]，只需几分钟即可完成。\r\n\r\n如果已按照[设备孪生入门][lnk-twin-tutorial]教程执行了操作，则现在已有一个 IoT 中心和一个名为 **myDeviceId** 的设备标识。 在这种情况下，可以跳到[创建模拟设备应用][lnk-how-to-configure-createapp]部分。\r\n\r\n[!INCLUDE [iot-hub-get-started-create-hub](../../includes/iot-hub-get-started-create-hub.md)]\r\n\r\n[!INCLUDE [iot-hub-get-started-create-device-identity](../../includes/iot-hub-get-started-create-device-identity-portal.md)]\r\n\r\n<a id=\"#create-the-simulated-device-app\"></a>\r\n## <a name=\"create-the-simulated-device-app\"></a>创建模拟设备应用\r\n在此部分中，会创建一个 Java 控制台应用，它作为 **myDeviceId** 连接到中心，等待所需配置更新，然后对模拟配置更新过程报告更新。\r\n\r\n1. 创建一个名为 dt-get-started 的空文件夹。\r\n\r\n1. 在命令提示符下使用以下命令，在 dt-get-started 文件夹中创建一个名为 **simulated-device** 的 Maven 项目。 请注意，这是一条很长的命令：\r\n\r\n    `mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=simulated-device -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false`\r\n\r\n1. 在命令提示符下，浏览到 simulated-device 文件夹。\r\n\r\n1. 使用文本编辑器，打开 simulated-device 文件夹中的 pom.xml 文件，并在 dependencies 节点中添加以下依赖项。 此依赖项使得你可以使用应用中的 iot-service-client 包来与 IoT 中心进行通信：\r\n\r\n    ```xml\r\n    <dependency>\r\n      <groupId>com.microsoft.azure.sdk.iot</groupId>\r\n      <artifactId>iot-device-client</artifactId>\r\n      <version>1.3.30</version>\r\n    </dependency>\r\n    ```\r\n\r\n    > [!NOTE]\r\n    > 可以使用 [Maven search][lnk-maven-device-search] 检查是否有最新版本的 **iot-device-client**。\r\n\r\n1. 在 **dependencies** 节点后添加以下 **build** 节点。 此配置指示 Maven 使用 Java 1.8 来生成应用：\r\n\r\n    ```xml\r\n    <build>\r\n      <plugins>\r\n        <plugin>\r\n          <groupId>org.apache.maven.plugins</groupId>\r\n          <artifactId>maven-compiler-plugin</artifactId>\r\n          <version>3.3</version>\r\n          <configuration>\r\n            <source>1.8</source>\r\n            <target>1.8</target>\r\n          </configuration>\r\n        </plugin>\r\n      </plugins>\r\n    </build>\r\n    ```\r\n\r\n1. 保存并关闭 pom.xml 文件。\r\n\r\n1. 使用文本编辑器打开 simulated-device\\src\\main\\java\\com\\mycompany\\app\\App.java 源文件。\r\n\r\n1. 在该文件中添加以下 **import** 语句：\r\n\r\n    ```java\r\n    import com.microsoft.azure.sdk.iot.device.*;\r\n    import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\r\n\r\n    import java.io.IOException;\r\n    import java.net.URISyntaxException;\r\n    import java.util.Scanner;\r\n    ```\r\n\r\n1. 将以下类级变量添加到 **App** 类。 将 {yourdeviceconnectionstring} 替换为在“创建设备标识”部分记下的设备连接字符串：\r\n\r\n    ```java\r\n    private static String deviceId = \"myDeviceId\";\r\n    private static IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\r\n    private static String connString = \"{yourdeviceconnectionstring}\";\r\n    private static DeviceClient client;\r\n    private static TelemetryConfig telemetryConfig;\r\n    ```\r\n\r\n1. 若要为设备孪生状态事件实现回调处理程序（用于调试），请将以下嵌套类添加到 **App** 类：\r\n\r\n    ```java\r\n    protected static class DeviceTwinStatusCallBack implements IotHubEventCallback \r\n    {\r\n        public void execute(IotHubStatusCode status, Object context) \r\n        {\r\n            //System.out.println(\"IoT Hub responded to device twin operation with status \" + status.name());\r\n        }\r\n    }\r\n    ```\r\n\r\n1. 将以下嵌套类添加到 **App** 类：\r\n\r\n    ```java\r\n    private static class TelemetryConfig extends Device \r\n    {\r\n        private String configId = \"0000\";\r\n        private String sendFrequency = \"45m\";\r\n\r\n        private Boolean initialRun = true;\r\n        \r\n        private Property telemetryConfig = new Property(\"telemetryConfig\", \"{configId=\" + configId + \", sendFrequency=\" + sendFrequency + \"}\");\r\n\r\n        public void InitTelemetry() throws IOException \r\n        {\r\n            System.out.println(\"Report initial telemetry config:\");\r\n            System.out.println(this.telemetryConfig);\r\n\r\n            this.setReportedProp(this.telemetryConfig);\r\n\r\n            client.sendReportedProperties(this.getReportedProp());\r\n        }\r\n\r\n        private void UpdateReportedConfiguration() \r\n        {\r\n            try {\r\n                System.out.println(\"Initiating config change\");\r\n                    \r\n                this.setReportedProp(this.telemetryConfig);\r\n                client.sendReportedProperties(this.getReportedProp());\r\n                    \r\n                System.out.println(\"Simulating device reset\");\r\n                \r\n                Thread.sleep(10000);\r\n                \r\n                System.out.println(\"Completing config change\");\r\n                System.out.println(\"Config change complete\");\r\n            } catch (Exception e) {\r\n                System.out.println(\"Exception \\n\" + \" Cause: \" + e.getCause() + \" \\n\" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void PropertyCall(String propertyKey, Object propertyValue, Object context) \r\n        {\r\n            if (propertyKey.equals(\"telemetryConfig\")) {\r\n                if (!(initialRun)) {\r\n                    System.out.println(\"Desired property change:\");\r\n                    System.out.println(propertyKey + \":\" + propertyValue);\r\n\r\n                    telemetryConfig.setValue(propertyValue);\r\n\r\n                    UpdateReportedConfiguration();\r\n                } else {\r\n                    initialRun = false;\r\n                }\r\n            } \r\n        }\r\n    }\r\n    ```\r\n\r\n    > [!NOTE]\r\n    > TelemetryConfig 类扩展了 [Device 类][lnk-java-device-class]来获取对所需属性回调的访问权限。\r\n    >\r\n    >\r\n\r\n1. 修改 main 方法的签名，引发以下异常：\r\n\r\n    ```java\r\n    public static void main(String[] args) throws IOException, URISyntaxException\r\n    ```\r\n\r\n1. 将以下代码添加到 **main** 方法以实例化 **DeviceClient** 和 **TelemetryConfig**：\r\n\r\n    ```java\r\n    client = new DeviceClient(connString, protocol);\r\n\r\n    telemetryConfig = new TelemetryConfig();\r\n    ```\r\n\r\n1. 将以下代码添加到 **main** 方法以启动设备孪生服务：\r\n\r\n    ```java\r\n    try \r\n    {\r\n    System.out.println(\"Connecting to hub\");\r\n    client.open();\r\n    client.startDeviceTwin(new DeviceTwinStatusCallBack(), null, telemetryConfig, null);\r\n\r\n    telemetryConfig.InitTelemetry();\r\n\r\n        System.out.println(\"Wait for desired telemetry...\");\r\n        client.subscribeToDesiredProperties(telemetryConfig.getDesiredProp());\r\n    }\r\n    catch (Exception e) \r\n        {\r\n        System.out.println(\"On exception, shutting down \\n\" + \" Cause: \" + e.getCause() + \" \\n\" + e.getMessage());\r\n        telemetryConfig.clean();\r\n        client.close();\r\n        System.out.println(\"Shutting down...\");\r\n    }\r\n    ```\r\n\r\n1. 将以下代码添加到 **main** 方法以在必要时关闭设备模拟器：\r\n\r\n    ```java\r\n    System.out.println(\"Press enter to exit...\");\r\n    Scanner scanner = new Scanner(System.in);\r\n    scanner.nextLine();\r\n\r\n    telemetryConfig.clean();\r\n    client.close();\r\n    ```\r\n\r\n1. 保存并关闭 simulated-device\\src\\main\\java\\com\\mycompany\\app\\App.java 文件。\r\n\r\n1. 生成 simulated-device 后端应用并更正任何错误。 在命令提示符下，导航到 simulated-device 文件夹并运行以下命令：\r\n\r\n    `mvn clean package -DskipTests`\r\n\r\n   > [!NOTE]\r\n   > 本教程不模拟并发配置更新的任何行为。 某些配置更新进程在更新运行过程中可能能够适应目标配置的更改，某些配置更新进程则可能必须将它们排队，某些配置更新进程会拒绝它们并显示错误情况。 请确保考虑特定配置过程所需的行为，并在开始配置更改之前添加相应的逻辑。\r\n   > \r\n   > \r\n\r\n## <a name=\"create-the-service-app\"></a>创建服务应用\r\n在本部分中，将创建一个 Java 控制台应用，该应用通过新的遥测配置对象更新与 **myDeviceId** 关联的设备孪生的所需属性。 该应用随后会查询存储在 IoT 中心的设备孪生，并显示设备的所需配置与报告配置之间的差异。\r\n\r\n1. 在命令提示符下使用以下命令，在 dt-get-started 文件夹中创建一个名为 **set-configuration** 的 Maven 项目。 请注意，这是一条很长的命令：\r\n\r\n    `mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=set-configuration -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false`\r\n\r\n1. 在命令提示符下，导航到 set-configuration 文件夹。\r\n\r\n1. 使用文本编辑器，打开 trigger-reboot 文件夹中的 pom.xml 文件，并在 dependencies 节点中添加以下依赖项。 此依赖项使得你可以使用应用中的 iot-service-client 包来与 IoT 中心进行通信：\r\n\r\n    ```xml\r\n    <dependency>\r\n      <groupId>com.microsoft.azure.sdk.iot</groupId>\r\n      <artifactId>iot-service-client</artifactId>\r\n      <version>1.5.22</version>\r\n      <type>jar</type>\r\n    </dependency>\r\n    ```\r\n\r\n    > [!NOTE]\r\n    > 可以使用 [Maven search][lnk-maven-service-search] 检查是否有最新版本的 **iot-service-client**。\r\n    >\r\n    >\r\n\r\n1. 在 **dependencies** 节点后添加以下 **build** 节点。 此配置指示 Maven 使用 Java 1.8 来生成应用：\r\n\r\n    ```xml\r\n    <build>\r\n      <plugins>\r\n        <plugin>\r\n          <groupId>org.apache.maven.plugins</groupId>\r\n          <artifactId>maven-compiler-plugin</artifactId>\r\n          <version>3.3</version>\r\n          <configuration>\r\n            <source>1.8</source>\r\n            <target>1.8</target>\r\n          </configuration>\r\n        </plugin>\r\n      </plugins>\r\n    </build>\r\n    ```\r\n\r\n1. 保存并关闭 pom.xml 文件。\r\n\r\n1. 使用文本编辑器打开 set-configuration\\src\\main\\java\\com\\mycompany\\app\\App.java 源文件。\r\n\r\n1. 在该文件中添加以下 **import** 语句：\r\n\r\n    ```java\r\n        import com.microsoft.azure.sdk.iot.service.devicetwin.*;\r\n    import com.microsoft.azure.sdk.iot.service.exceptions.IotHubException;\r\n\r\n    import java.io.IOException;\r\n    import java.util.HashSet;\r\n    import java.util.Set;\r\n    ```\r\n\r\n1. 将以下类级变量添加到 **App** 类。 将 {youriothubconnectionstring} 替换为在“创建 IoT 中心”部分记下的 IoT 中心连接字符串：\r\n\r\n    ```java\r\n    public static final String iotHubConnectionString = \"{youriothubconnectionstring}\";\r\n    public static final String deviceId = \"myDeviceId\";\r\n    ```\r\n\r\n1. 若要查询并更新模拟设备上的设备孪生，请将以下代码添加到 **main** 方法中：\r\n\r\n    ```java\r\n        DeviceTwin twinClient = DeviceTwin.createFromConnectionString(iotHubConnectionString);\r\n    DeviceTwinDevice device = new DeviceTwinDevice(deviceId);\r\n\r\n    String sendFrequency= \"12h\";\r\n\r\n    try {\r\n        twinClient.getTwin(device);\r\n\r\n        // make sure a differing value exists before calling the updateTwin() method, else a null device exception will be thrown\r\n        // this allows the program to be run multiple times for demonstration purposes\r\n        String desiredProperties = device.desiredPropertiesToString();\r\n        if (desiredProperties.contains(\"sendFrequency=\" + sendFrequency))\r\n        {\r\n            sendFrequency = \"8h\";\r\n        }\r\n            \r\n        Set<Pair> tags = new HashSet<Pair>();\r\n        tags.add(new Pair(\"telemetryConfig\", \"{configId=0001, sendFrequency=\" + sendFrequency + \"}\"));\r\n\r\n        twinClient.getTwin(device);\r\n        device.setDesiredProperties(tags);\r\n\r\n        System.out.println(\"Config report for: \" + deviceId);   \r\n        System.out.println(device);\r\n\r\n        twinClient.updateTwin(device);\r\n\r\n        String reportedProperties = device.reportedPropertiesToString();\r\n        Boolean waitFlag = true;\r\n\r\n        while (waitFlag) {\r\n            if (!reportedProperties.contains(\"sendFrequency=\" + sendFrequency)) {\r\n                Thread.sleep(10000);\r\n            }\r\n            else \r\n                    {\r\n                waitFlag = false;\r\n            }\r\n\r\n            twinClient.getTwin(device);\r\n            reportedProperties = device.reportedPropertiesToString();\r\n        }\r\n            \r\n        SqlQuery sqlQuery = SqlQuery.createSqlQuery(\"*\", SqlQuery.FromType.DEVICES, \"properties.reported.telemetryConfig='{configId=0001, sendFrequency=\" + sendFrequency + \"}'\", null);\r\n\r\n        Query twinQuery = twinClient.queryTwin(sqlQuery.getQuery(), 100);\r\n        while (twinClient.hasNextDeviceTwin(twinQuery)) {\r\n            DeviceTwinDevice d = twinClient.getNextDeviceTwin(twinQuery);\r\n            System.out.println(d.getDeviceId() + \" found with changed telemetryConfig\");\r\n        }\r\n\r\n        System.out.println(\"Config report for: \" + deviceId);\r\n        twinClient.getTwin(device);\r\n        System.out.println(device);\r\n\r\n        } catch (IotHubException e) {\r\n            System.out.println(e.getMessage());\r\n        } catch (IOException e) {\r\n            System.out.println(e.getMessage());\r\n        } catch (InterruptedException e) {\r\n            System.out.println(e.getMessage());\r\n        }\r\n    ```\r\n\r\n1. 保存并关闭 set-desired-configuration\\src\\main\\java\\com\\mycompany\\app\\App.java 文件。\r\n\r\n1. 生成 **set-configuration** 后端应用并更正任何错误。 在命令提示符下，导航到 set-configuration 文件夹并运行以下命令：\r\n\r\n    `mvn clean package -DskipTests`\r\n   \r\n    此代码检索 **myDeviceId** 的设备孪生，并使用新的遥测配置对象更新其所需属性。\r\n    然后，该代码会每隔 10 秒钟查询一次存储在 IoT 中心的设备孪生，并打印所需遥测配置和报告遥测配置。 请参阅 [IoT 中心查询语言][lnk-query] 以了解如何跨所有设备生成丰富的报告。\r\n   \r\n   > [!IMPORTANT]\r\n   > 此应用程序每 10 秒查询一次 IoT 中心以用于说明目的，直至设备完成更新。 使用查询跨多个设备生成面向用户的报表，而不检测更改。 如果解决方案需要设备事件的实时通知，请使用[孪生通知][lnk-twin-notifications]。\r\n   > \r\n\r\n   > [!IMPORTANT]\r\n   > 设备报告操作与查询结果之间最多存在一分钟的延迟。 这是为了使查询基础结构可以采用非常大的规模来工作。  若要检索单个设备孪生的一致视图，请使用 **DeviceTwin** 类中的 **getDeviceTwin** 方法。\r\n   > \r\n   > \r\n\r\n## <a name=\"run-the-apps\"></a>运行应用\r\n\r\n现在，已准备就绪，可以运行应用。\r\n\r\n1. 在命令提示符下，在 simulated-device 文件夹中运行以下命令，以开始侦听来自 IoT 中心的设备孪生调用：\r\n\r\n    `mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\"`\r\n\r\n1. 在命令提示符下，在 set-configuration 文件夹中运行以下命令，从 IoT 中心查询并更新模拟设备上的设备孪生：\r\n\r\n    `mvn exec:java -Dexec.mainClass=\"com.mycompany.app.App\"`\r\n\r\n1. 模拟设备对重新启动直接方法调用做出响应：\r\n\r\n    ![Java IoT 中心模拟设备应用对设备孪生调用做出响应][img-deviceconfigured]\r\n\r\n## <a name=\"next-steps\"></a>后续步骤\r\n在本教程中，已从解决方案后端将所需配置设置为“所需属性”，此外还编写了一个设备应用以检测该更改并模拟多步骤更新过程（通过报告属性报告其状态）。\r\n\r\n充分利用以下资源：\r\n\r\n* 通过 [Get started with IoT Hub][lnk-iothub-getstarted] （IoT 中心入门）教程学习如何从设备发送遥测；\r\n* 关于对大型设备集进行计划或执行操作，请参阅 [计划和广播作业][lnk-schedule-jobs] 教程。\r\n* 通过[使用直接方法][lnk-methods-tutorial]教程学习如何以交互方式控制设备（例如从用户控制的应用打开风扇）。\r\n\r\n<!-- images -->\r\n[img-deviceconfigured]: media/iot-hub-java-java-twin-how-to-configure/deviceconfigured.png\r\n\r\n\r\n<!-- links -->\r\n[lnk-hub-sdks]: iot-hub-devguide-sdks.md\r\n[lnk-free-trial]: http://www.azure.cn/pricing/1rmb-trial/\r\n[lnk-java-device-class]: https://docs.azure.cn/zh-cn/java/api/com.microsoft.azure.sdk.iot.device._device_twin._device\r\n\r\n[lnk-query]: iot-hub-devguide-query-language.md\r\n[lnk-twin-notifications]: iot-hub-devguide-device-twins.md#back-end-operations\r\n[lnk-twin-tutorial]: iot-hub-csharp-csharp-twin-getstarted.md\r\n[lnk-schedule-jobs]: iot-hub-node-node-schedule-jobs.md\r\n[lnk-iothub-getstarted]: iot-hub-csharp-csharp-getstarted.md\r\n[lnk-methods-tutorial]: iot-hub-node-node-direct-methods.md\r\n[lnk-how-to-configure-createapp]: iot-hub-csharp-csharp-twin-how-to-configure.md#create-the-simulated-device-app\r\n"}