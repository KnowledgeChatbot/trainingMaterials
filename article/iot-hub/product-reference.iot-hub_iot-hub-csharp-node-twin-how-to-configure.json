{"Title":"使用 Azure IoT 中心设备孪生属性 (.NET/Node)","Description":"如何使用 Azure IoT 中心设备孪生配置设备。 使用适用于 Node.js 的 Azure IoT 设备 SDK 实现模拟设备应用，并使用适用于 .NET 的 Azure IoT 服务 SDK 实现可使用设备孪生更改设备配置的服务应用。","Content":"# <a name=\"use-desired-properties-to-configure-devices\"></a>使用所需属性配置设备\r\n[!INCLUDE [iot-hub-selector-twin-how-to-configure](../../includes/iot-hub-selector-twin-how-to-configure.md)]\r\n\r\n在本教程结束时，会创建两个控制台应用：\r\n\r\n* **SimulateDeviceConfiguration.js**，一个模拟设备应用，它等待所需配置更新并报告模拟配置更新过程的状态。\r\n* **SetDesiredConfigurationAndQuery**，一个 .NET 后端应用，用于在设备上设置所需配置并查询配置更新过程。\r\n\r\n> [!NOTE]\r\n> [Azure IoT SDK][lnk-hub-sdks] 文章介绍了可用于构建设备和后端应用的 Azure IoT SDK。\r\n> \r\n> \r\n\r\n若要完成本教程，需要满足以下条件：\r\n\r\n+ Visual Studio 2015 或 Visual Studio 2017。\r\n\r\n+ Node.js 版本 4.0.x 或更高版本。\r\n\r\n+ 有效的 Azure 帐户。 如果没有帐户，可以创建一个[试用帐户][lnk-free-trial]，只需几分钟即可完成。\r\n\r\n如果已按照 [设备孪生入门][lnk-twin-tutorial] 教程执行了操作，则现在已有一个 IoT 中心和一个名为 **myDeviceId** 的设备标识。 在这种情况下，可以跳到 [创建模拟设备应用][lnk-how-to-configure-createapp] 部分。\r\n\r\n[!INCLUDE [iot-hub-get-started-create-hub](../../includes/iot-hub-get-started-create-hub.md)]\r\n\r\n[!INCLUDE [iot-hub-get-started-create-device-identity](../../includes/iot-hub-get-started-create-device-identity.md)]\r\n\r\n<a id=\"#create-the-simulated-device-app\"></a>\r\n## <a name=\"create-the-simulated-device-app\"></a>创建模拟设备应用\r\n\r\n在此部分，用户需创建一个 Node.js 控制台应用，该应用可作为 **myDeviceId**连接到中心并等待所需配置更新，并针对模拟配置更新过程报告更新。\r\n\r\n1. 新建名为 **simulatedeviceconfiguration**的空文件夹。 在命令提示符下的 **simulatedeviceconfiguration** 文件夹中，使用以下命令创建新的 package.json 文件。 接受所有默认值。\r\n   \r\n    ```\r\n    npm init\r\n    ```\r\n1. 在 **simulatedeviceconfiguration** 文件夹的命令提示符处，运行下述命令以安装 **azure-iot-device** 和 **azure-iot-device-mqtt** 包：\r\n   \r\n    ```\r\n    npm install azure-iot-device azure-iot-device-mqtt --save\r\n    ```\r\n3. 使用文本编辑器，在 **simulatedeviceconfiguration** 文件夹中创建新的 **SimulateDeviceConfiguration.js** 文件。\r\n4. 将以下代码添加到 **SimulateDeviceConfiguration.js** 文件，并将 **{device connection string}** 占位符替换为创建 **myDeviceId** 设备标识时复制的设备连接字符串：\r\n\r\n        'use strict';\r\n        var Client = require('azure-iot-device').Client;\r\n        var Protocol = require('azure-iot-device-mqtt').Mqtt;\r\n   \r\n        var connectionString = '{device connection string}';\r\n        var client = Client.fromConnectionString(connectionString, Protocol);\r\n   \r\n        client.open(function(err) {\r\n            if (err) {\r\n                console.error('could not open IotHub client');\r\n            } else {\r\n                client.getTwin(function(err, twin) {\r\n                    if (err) {\r\n                        console.error('could not get twin');\r\n                    } else {\r\n                        console.log('retrieved device twin');\r\n                        twin.properties.reported.telemetryConfig = {\r\n                            configId: \"0\",\r\n                            sendFrequency: \"24h\"\r\n                        }\r\n                        twin.on('properties.desired', function(desiredChange) {\r\n                            console.log(\"received change: \"+JSON.stringify(desiredChange));\r\n                            var currentTelemetryConfig = twin.properties.reported.telemetryConfig;\r\n                            if (desiredChange.telemetryConfig &&desiredChange.telemetryConfig.configId !== currentTelemetryConfig.configId) {\r\n                                initConfigChange(twin);\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n   \r\n    **客户端**对象公开从设备与设备孪生进行交互所需的所有方法。 此代码将初始化 **Client** 对象，检索 **myDeviceId** 的设备孪生，并在所需属性上附加用于更新的处理程序。 该处理程序通过比较 configId 来验证是否存在实际配置更改请求，并调用启动配置更改的方法。\r\n   \r\n    请注意，为了简单起见，此代码使用初始配置的硬编码默认值。 实际的应用可能会从本地存储加载该配置。\r\n   \r\n   > [!IMPORTANT]\r\n   > 连接设备时，始终发出一次所需的属性更改事件。 执行任何操作之前，请确保检查所需属性是否进行过实际更改。\r\n   > \r\n   > \r\n   \r\n   \r\n1. 在 `client.open()` 调用前添加以下方法：\r\n\r\n    ```\r\n    var initConfigChange = function(twin) {\r\n        var currentTelemetryConfig = twin.properties.reported.telemetryConfig;\r\n        currentTelemetryConfig.pendingConfig = twin.properties.desired.telemetryConfig;\r\n        currentTelemetryConfig.status = \"Pending\";\r\n\r\n        var patch = {\r\n        telemetryConfig: currentTelemetryConfig\r\n        };\r\n        twin.properties.reported.update(patch, function(err) {\r\n            if (err) {\r\n                console.log('Could not report properties');\r\n            } else {\r\n                console.log('Reported pending config change: ' + JSON.stringify(patch));\r\n                setTimeout(function() {completeConfigChange(twin);}, 60000);\r\n            }\r\n        });\r\n    }\r\n\r\n    var completeConfigChange =  function(twin) {\r\n        var currentTelemetryConfig = twin.properties.reported.telemetryConfig;\r\n        currentTelemetryConfig.configId = currentTelemetryConfig.pendingConfig.configId;\r\n        currentTelemetryConfig.sendFrequency = currentTelemetryConfig.pendingConfig.sendFrequency;\r\n        currentTelemetryConfig.status = \"Success\";\r\n        delete currentTelemetryConfig.pendingConfig;\r\n\r\n        var patch = {\r\n            telemetryConfig: currentTelemetryConfig\r\n        };\r\n        patch.telemetryConfig.pendingConfig = null;\r\n\r\n        twin.properties.reported.update(patch, function(err) {\r\n            if (err) {\r\n                console.error('Error reporting properties: ' + err);\r\n            } else {\r\n                console.log('Reported completed config change: ' + JSON.stringify(patch));\r\n            }\r\n        });\r\n    };\r\n    ```\r\n\r\n    \r\n   **initConfigChange** 方法使用配置更新请求更新本地设备孪生对象的报告属性，并将状态设置为“等待中”****，并更新服务的设备孪生。 成功更新设备孪生后，它会模拟在执行 **completeConfigChange** 期间终止的长时间运行的进程。 此方法更新本地报告属性，将状态设置为“成功”并删除 **pendingConfig** 对象。 然后，它会更新服务的设备孪生。\r\n\r\n   请注意，为了节省带宽，仅通过指定要修改的属性（在上述代码中名为 **patch**）而不是替换整个文档来更新报告属性。\r\n\r\n    > [!NOTE]\r\n    > 本教程不模拟并发配置更新的任何行为。 某些配置更新进程在更新运行过程中可能能够适应目标配置的更改，某些配置更新进程则可能必须将它们排队，某些配置更新进程会拒绝它们并显示错误情况。 请确保考虑特定配置过程所需的行为，并在开始配置更改之前添加相应的逻辑。\r\n    > \r\n    > \r\n   \r\n6. 运行设备应用：\r\n\r\n    ```\r\n    node SimulateDeviceConfiguration.js\r\n    ```\r\n\r\n    此时会显示消息 `retrieved device twin`。 使应用保持运行状态。\r\n\r\n## <a name=\"create-the-service-app\"></a>创建服务应用\r\n在本节中，用户需创建一个 .NET 控制台应用，以便通过新的遥测配置对象在与 *myDeviceId* 关联的设备孪生上更新 **所需属性** 。 该应用随后会查询存储在 IoT 中心的设备孪生，并显示设备的所需配置与报告配置之间的差异。\r\n\r\n1. 在 Visual Studio 中，使用“ **控制台应用程序** ”项目模板将 Visual C# Windows 经典桌面项目添加到当前解决方案。 **SetDesiredConfigurationAndQuery**。\r\n\r\n    ![新的 Visual C# Windows 经典桌面项目][img-createapp]\r\n    \r\n2. 在“解决方案资源管理器”中，右键单击“**SetDesiredConfigurationAndQuery**”项目，并单击“**管理 NuGet 包**”。\r\n1. 在“NuGet 包管理器”窗口中，选择“浏览”，搜索 **microsoft.azure.devices**，选择“安装”以安装 **Microsoft.Azure.Devices** 包，并接受使用条款。 此过程会下载、安装 [Azure IoT 服务 SDK][lnk-nuget-service-sdk] NuGet 包及其依赖项并添加对它的引用。\r\n\r\n    ![“NuGet 包管理器”窗口][img-servicenuget]\r\n    \r\n4. 在 **Program.cs** 文件顶部添加以下 `using` 语句：\r\n\r\n    ```\r\n    using Microsoft.Azure.Devices;\r\n    using System.Threading;\r\n    using Newtonsoft.Json;\r\n    ```\r\n5. 将以下字段添加到 **Program** 类。 将占位符值替换为在上一部分中为中心创建的 IoT 中心连接字符串。\r\n\r\n    ```\r\n    static RegistryManager registryManager;\r\n    static string connectionString = \"{iot hub connection string}\";\r\n    ```\r\n6. 将以下方法添加到 **Program** 类：\r\n\r\n    ```\r\n    static private async Task SetDesiredConfigurationAndQuery()\r\n    {\r\n        var twin = await registryManager.GetTwinAsync(\"myDeviceId\");\r\n        var patch = new {\r\n                properties = new {\r\n                    desired = new {\r\n                        telemetryConfig = new {\r\n                            configId = Guid.NewGuid().ToString(),\r\n                            sendFrequency = \"5m\"\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n        await registryManager.UpdateTwinAsync(twin.DeviceId, JsonConvert.SerializeObject(patch), twin.ETag);\r\n        Console.WriteLine(\"Updated desired configuration\");\r\n\r\n        try\r\n        {\r\n         while (true)\r\n         {\r\n            var query = registryManager.CreateQuery(\"SELECT * FROM devices WHERE deviceId = 'myDeviceId'\");\r\n            var results = await query.GetNextAsTwinAsync();\r\n            foreach (var result in results)\r\n            {\r\n                Console.WriteLine(\"Config report for: {0}\", result.DeviceId);\r\n                Console.WriteLine(\"Desired telemetryConfig: {0}\", JsonConvert.SerializeObject(result.Properties.Desired[\"telemetryConfig\"], Formatting.Indented));\r\n                Console.WriteLine(\"Reported telemetryConfig: {0}\", JsonConvert.SerializeObject(result.Properties.Reported[\"telemetryConfig\"], Formatting.Indented));\r\n                Console.WriteLine();\r\n            }\r\n            Thread.Sleep(10000);\r\n         }\r\n       }\r\n       catch (Exception ex)\r\n       {\r\n            Console.WriteLine($\"Exception: {ex.Message}\");\r\n       }\r\n    }\r\n    ```\r\n\r\n    **Registry** 对象公开从服务与设备孪生进行交互所需的所有方法。 此代码将初始化 **Registry** 对象，然后检索 **myDeviceId** 的设备孪生，并使用新的遥测配置对象更新其所需属性。\r\n    然后，该代码会每隔 10 秒钟查询一次存储在 IoT 中心的设备孪生，并打印所需遥测配置和报告遥测配置。 若要了解如何在所有设备中生成丰富的报告，请参阅 [IoT 中心查询语言][lnk-query]。\r\n   \r\n   > [!IMPORTANT]\r\n   > 为进行说明，此应用程序每 10 秒查询 IoT 中心一次。 使用查询跨多个设备生成面向用户的报表，而不检测更改。 如果解决方案需要设备事件的实时通知，请使用[孪生通知][lnk-twin-notifications]。\r\n   > \r\n   > \r\n   \r\n7. 最后，在 **Main** 方法中添加以下行：\r\n\r\n    ```\r\n    registryManager = RegistryManager.CreateFromConnectionString(connectionString);\r\n    SetDesiredConfigurationAndQuery();\r\n    Console.WriteLine(\"Press any key to quit.\");\r\n    Console.ReadLine();\r\n    ```\r\n            \r\n1. 在“解决方案资源管理器”中，打开“设置启动项目...”，并确保 **SetDesiredConfigurationAndQuery** 项目的“操作”为“启动”。 生成解决方案。\r\n8. 在 **SimulateDeviceConfiguration.js** 运行时，使用 **F5** 从 Visual Studio 运行 .NET 应用程序，应看到报告的配置以五分钟（而不是 24 小时）的新活动发送频率从 **Success** 更改为 **Pending**，然后再次更改为 **Success**。\r\n\r\n ![已成功配置设备][img-deviceconfigured]\r\n   \r\n > [!IMPORTANT]\r\n > 设备报告操作与查询结果之间最多存在一分钟的延迟。这是为了使查询基础结构可以采用非常大的规模来工作。若要检索单个设备孪生的一致视图，请使用 **Registry** 类中的 **getDeviceTwin** 方法。\r\n > \r\n > \r\n\r\n## <a name=\"next-steps\"></a>后续步骤\r\n在本教程中，已从解决方案后端将所需配置设置为“所需属性”，此外还编写了一个设备应用以检测该更改并模拟多步骤更新过程（通过报告属性报告其状态）。\r\n\r\n充分利用以下资源：\r\n\r\n* 通过 [Get started with IoT Hub][lnk-iothub-getstarted] （IoT 中心入门）教程学习如何从设备发送遥测；\r\n* 关于对大型设备集进行计划或执行操作，请参阅 [计划和广播作业][lnk-schedule-jobs] 教程。\r\n* 通过[使用直接方法][lnk-methods-tutorial]教程学习如何以交互方式控制设备（例如从用户控制的应用打开风扇）。\r\n\r\n<!-- images -->\r\n[img-servicenuget]: ./media/iot-hub-csharp-node-twin-how-to-configure/servicesdknuget.png\r\n[img-createapp]: ./media/iot-hub-csharp-node-twin-how-to-configure/createnetapp.png\r\n[img-deviceconfigured]: ./media/iot-hub-csharp-node-twin-how-to-configure/deviceconfigured.png\r\n\r\n<!-- links -->\r\n[lnk-hub-sdks]: ./iot-hub-devguide-sdks.md\r\n[lnk-free-trial]: https://www.azure.cn/pricing/1rmb-trial/\r\n[lnk-nuget-service-sdk]: https://www.nuget.org/packages/Microsoft.Azure.Devices/1.1.0/\r\n\r\n[lnk-devguide-jobs]: ./iot-hub-devguide-jobs.md\r\n[lnk-query]: ./iot-hub-devguide-query-language.md\r\n[lnk-twin-notifications]: ./iot-hub-devguide-device-twins.md#back-end-operations\r\n[lnk-methods]: ./iot-hub-devguide-direct-methods.md\r\n[lnk-dm-overview]: ./iot-hub-device-management-overview.md\r\n[lnk-twin-tutorial]: ./iot-hub-node-node-twin-getstarted.md\r\n[lnk-schedule-jobs]: ./iot-hub-node-node-schedule-jobs.md\r\n[lnk-dev-setup]: https://github.com/Azure/azure-iot-sdk-node/blob/master/doc/node-devbox-setup.md\r\n[lnk-connect-device]: https://www.azure.cn/develop/iot/\r\n[lnk-device-management]: ./iot-hub-node-node-device-management-get-started.md\r\n[lnk-iothub-getstarted]: ./iot-hub-node-node-getstarted.md\r\n[lnk-methods-tutorial]: ./iot-hub-node-node-direct-methods.md\r\n\r\n[lnk-guid]: https://en.wikipedia.org/wiki/Globally_unique_identifier\r\n\r\n[lnk-how-to-configure-createapp]: ./iot-hub-csharp-node-twin-how-to-configure.md#create-the-simulated-device-app\r\n\r\n<!--Update_Description: update wording and code-->"}