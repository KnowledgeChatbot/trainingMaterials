{"Title":"了解 Azure IoT 中心 MQTT 支持","Description":"开发人员指南 - 支持设备使用 MQTT 协议连接到面向设备的 IoT 中心终结点。 介绍了 Azure IoT 设备 SDK 中的内置 MQTT 支持。","Content":"\r\n# <a name=\"communicate-with-your-iot-hub-using-the-mqtt-protocol\"></a>使用 MQTT 协议与 IoT 中心通信\r\nIoT 中心让设备能够在端口 8883 上使用 [MQTT v3.1.1][lnk-mqtt-org] 协议，或在端口 443 上使用基于 WebSocket 的 MQTT v3.1.1 协议来与 IoT 中心设备终结点通信。 IoT 中心要求使用 TLS/SSL 保护所有设备通信（因此，IoT 中心不支持端口 1883 上的非安全连接）。\r\n\r\n## <a name=\"connecting-to-iot-hub\"></a>连接到 IoT 中心\r\n\r\n设备既可以通过 [Azure IoT SDK][lnk-device-sdks] 中的库使用 MQTT 协议连接到 IoT 中心，也可以直接使用 MQTT 协议连接到 IoT 中心。\r\n\r\n## <a name=\"using-the-device-sdks\"></a>使用设备 SDK\r\n支持 MQTT 协议的[设备 SDK][lnk-device-sdks] 可用于 Java、Node.js、C、C# 和 Python。 设备 SDK 使用标准 IoT 中心连接字符串来连接到 IoT 中心。 要使用 MQTT 协议，必须将客户端协议参数设置为 **MQTT**。 默认情况下，设备 SDK 在 **CleanSession** 标志设置为 **0** 的情况下连接到 IoT 中心，并使用 **QoS 1** 来与 IoT 中心交换消息。\r\n\r\n当设备连接到 IoT 中心时，设备 SDK 将提供方法让设备在 IoT 中心发送和接收消息。\r\n\r\n下表包含了每种受支持语言的代码示例链接，并指定了以 MQTT 协议连接到 IoT 中心时要使用的参数。\r\n\r\n| 语言 | 协议参数 |\r\n| --- | --- |\r\n| [Node.js][lnk-sample-node] |azure-iot-device-mqtt |\r\n| [Java][lnk-sample-java] |IotHubClientProtocol.MQTT |\r\n| [C][lnk-sample-c] |MQTT_Protocol |\r\n| [C#][lnk-sample-csharp] |TransportType.Mqtt |\r\n| [Python][lnk-sample-python] |IoTHubTransportProvider.MQTT |\r\n\r\n### <a name=\"migrating-a-device-app-from-amqp-to-mqtt\"></a>将设备应用从 AMQP 迁移到 MQTT\r\n\r\n如果使用[设备 SDK][lnk-device-sdks]，则需要在客户端初始化过程中更改协议参数才可将 AMQP 切换为使用 MQTT，如上所述。\r\n\r\n执行此操作时，请确保检查下列各项：\r\n\r\n* AMQP 针对许多条件返回错误，而 MQTT 会终止连接。 因此异常处理逻辑可能需要进行一些更改。\r\n* MQTT 在接收 *云到设备消息* 时不支持 [拒绝][lnk-messaging]操作。 如果后端应用需要接收来自设备应用的响应，请考虑使用 [直接方法][lnk-methods]。\r\n\r\n## <a name=\"using-the-mqtt-protocol-directly\"></a>直接使用 MQTT 协议\r\n如果设备无法使用设备 SDK，仍可使用端口 8883 上的 MQTT 协议连接到公共设备终结点。 在 **CONNECT** 数据包中，设备应使用以下值：\r\n\r\n- **ClientId** 字段使用 **deviceId**。 \r\n- “**用户名**”字段使用 `{iothubhostname}/{device_id}/api-version=2016-11-14`，其中 {iothubhostname} 是 IoT 中心的完整 CName。\r\n\r\n    例如，如果 IoT 中心的名称为 **contoso.azure-devices.cn**，设备的名称为 **MyDevice01**，则完整“用户名”字段应包含 `contoso.azure-devices.cn/MyDevice01/api-version=2016-11-14`。\r\n    \r\n- “密码”  字段使用 SAS 令牌。 对于 HTTPS 和 AMQP 协议，SAS 令牌的格式是相同的：<br/>`SharedAccessSignature sig={signature-string}&se={expiry}&sr={URL-encoded-resourceURI}`。\r\n\r\n    有关如何生成 SAS 令牌的详细信息，请参阅 [使用 IoT 中心安全令牌][lnk-sas-tokens]的设备部分。\r\n\r\n    测试时也可以使用[设备资源管理器][lnk-device-explorer]工具来快速生成可以复制并粘贴到自己的代码中的 SAS 令牌：\r\n\r\n  1. 转到“设备资源管理器”中的“管理”选项卡。\r\n  2. 单击“**SAS 令牌**”（右上角）。\r\n  3. 在 **SASTokenForm** 上，从 **DeviceID** 下拉列表中选择设备。 设置 **TTL**。\r\n  4. 单击“**生成**”创建令牌。\r\n\r\n     所生成的 SAS 令牌具有以下结构：`HostName={your hub name}.azure-devices.cn;DeviceId=javadevice;SharedAccessSignature=SharedAccessSignature sr={your hub name}.azure-devices.cn%2Fdevices%2FMyDevice01%2Fapi-version%3D2016-11-14&sig=vSgHBMUG.....Ntg%3d&se=1456481802`。\r\n\r\n     此令牌中要用作“**密码**”字段以便使用 MQTT 进行连接的部分是：`SharedAccessSignature sr={your hub name}.azure-devices.cn%2Fdevices%2FMyDevice01%2Fapi-version%3D2016-11-14&sig=vSgHBMUG.....Ntg%3d&se=1456481802`。\r\n\r\n对于 MQTT 连接和断开连接数据包，IoT 中心会在**操作监视**频道发布事件，并提供可帮助对连接问题进行故障排除的其他信息。\r\n\r\n### <a name=\"tlsssl-configuration\"></a>TLS/SSL 配置\r\n\r\n若要直接使用 MQTT 协议，客户端*必须*通过 TLS/SSL 连接。 尝试跳过此配置会失败并显示连接错误。\r\n\r\n若要建立 TLS 连接，可能需要下载并引用 DigiCert Baltimore 根证书。 Azure 使用此证书来保护连接，可以在 [Azure-iot-sdk-c 存储库][lnk-sdk-c-certs]中找到此证书。 可以在 [Digicert 网站][lnk-digicert-root-certs]上找到有关这些证书的详细信息。\r\n\r\n例如，下面说明了如何使用 Eclipse Foundation 提供的 Python 版 [Paho MQTT 库][lnk-paho]实现此功能。\r\n\r\n首先，从命令行环境安装 Paho 库：\r\n\r\n```\r\n>pip install paho-mqtt\r\n```\r\n\r\n然后，在 Python 脚本中实现客户端：\r\n\r\n```\r\nfrom paho.mqtt import client as mqtt\r\nimport ssl\r\n  \r\npath_to_root_cer = \"...local\\\\path\\\\to\\\\digicert.cer\"\r\ndevice_id = \"<device id from device registry>\"\r\nsas_token = \"<generated SAS token>\"\r\nsubdomain = \"<iothub subdomain>\"\r\n\r\nclient = mqtt.Client(client_id=device_id, protocol=mqtt.MQTTv311)\r\n\r\nclient.username_pw_set(username=subdomain+\".azure-devices.cn/\" + device_id, password=sas_token)\r\n\r\nclient.tls_set(ca_certs=path_to_root_cert, certfile=None, keyfile=None, cert_reqs=ssl.CERT_REQUIRED, tls_version=ssl.PROTOCOL_TLSv1, ciphers=None)\r\nclient.tls_insecure_set(False)\r\n\r\nclient.connect(subdomain+\".azure-devices.cn\", port=8883)\r\n```\r\n\r\n\r\n### <a name=\"sending-device-to-cloud-messages\"></a>发送“设备到云”消息\r\n成功建立连接后，设备可以使用 `devices/{device_id}/messages/events/` 或 `devices/{device_id}/messages/events/{property_bag}` 作为**主题名称**将消息发送到 IoT 中心。 `{property_bag}` 元素可让设备使用 URL 编码格式发送包含其他属性的消息。 例如：\r\n\r\n```\r\nRFC 2396-encoded(<PropertyName1>)=RFC 2396-encoded(<PropertyValue1>)&RFC 2396-encoded(<PropertyName2>)=RFC 2396-encoded(<PropertyValue2>)…\r\n```\r\n\r\n> [!NOTE]\r\n> 此 `{property_bag}` 元素使用的编码与 HTTPS 协议中用于查询字符串的编码相同。\r\n>\r\n>\r\n\r\n设备应用还可使用 `devices/{device_id}/messages/events/{property_bag}` 作为 **Will 主题名称**，用于定义要作为遥测消息转发的 Will 消息。\r\n\r\n- IoT 中心不支持 QoS 2 消息。 如果设备应用使用 **QoS 2**发布消息，IoT 中心将断开网络连接。\r\n- IoT 中心不会保存 Retain 消息。 如果设备在 **RETAIN** 标志设置为 1 的情况下发送消息，则 IoT 中心会在消息中添加 **x-opt-retain** 应用程序属性。 在此情况下，IoT 中心不会存储保留消息，而将其传递到后端应用。\r\n- IoT 中心只允许一个设备有一个活动的 MQTT 连接。 代表相同设备 ID 的任何新 MQTT 连接都会导致 IoT 中心删除现有连接。\r\n\r\n有关详细信息，请参阅[消息传送开发人员指南][lnk-messaging]。\r\n\r\n### <a name=\"receiving-cloud-to-device-messages\"></a>接收“云到设备”消息\r\n若要从 IoT 中心接收消息，设备应使用 `devices/{device_id}/messages/devicebound/#` 作为 **主题筛选器**来进行订阅。 主题筛选器中的多级通配符 **#** 仅用于允许设备接收主题名称中的其他属性。 IoT 中心不允许使用 **#** 或 **?** 用于筛选子主题的通配符。 由于 IoT 中心不是一般用途的发布-订阅消息传送中转站，因此它仅支持存档的主题名称和主题筛选器。\r\n\r\n设备成功订阅其 `devices/{device_id}/messages/devicebound/#` 主题筛选器表示的设备特定终结点前，不会从 IoT 中心收到任何消息。 成功建立订阅后，设备仅会开始收到建立订阅后发送给它的“云到设备”消息。 如果设备在“CleanSession”标志设置为“0”的情况下进行连接，订阅在经历不同的会话后将仍然持久存在。 在此情况下，下次使用“CleanSession 0”进行连接时，设备会收到断开连接时发送给它的未处理消息。 但是，如果设备使用设置为“1”的“CleanSession”标志，在订阅其设备终结点前，它不会从 IoT 中心收到任何消息。\r\n\r\n如有任何消息属性，IoT 中心将传送包含**主题名称** `devices/{device_id}/messages/devicebound/` 或 `devices/{device_id}/messages/devicebound/{property_bag}` 的消息。 `{property_bag}` 包含 URL 编码的消息属性键/值对。 属性包中只包含应用程序属性和用户可设置的系统属性（例如 **messageId** 或 **correlationId**）。 系统属性名称具有前缀 **$**，但应用程序属性使用没有前缀的原始属性名称。\r\n\r\n当设备应用使用 **QoS 2** 订阅主题时，IoT 中心会在 **SUBACK** 包中授予最高 QoS 级别 1。 之后，IoT 中心会使用 QoS 1 将消息传送到设备。\r\n\r\n### <a name=\"retrieving-a-device-twins-properties\"></a>检索设备孪生的属性\r\n\r\n首先，设备订阅 `$iothub/twin/res/#`，接收操作的响应。 然后，它向主题 `$iothub/twin/GET/?$rid={request id}` 发送一条空消息，其中包含 **request id** 的填充值。 服务随后会发送一条响应消息，其中包含关于主题 `$iothub/twin/res/{status}/?$rid={request id}` 的设备孪生数据，并且使用与请求相同的“request id”。\r\n\r\nrequest id 可以是消息属性值的任何有效值（如 [IoT 中心消息传送开发人员指南][lnk-messaging]中所述），且需要验证确保状态是整数。\r\n响应正文包含设备孪生的 properties 节：\r\n\r\n标识注册表项的正文限制为“properties”成员，例如：\r\n\r\n        {\r\n            \"properties\": {\r\n                \"desired\": {\r\n                    \"telemetrySendFrequency\": \"5m\",\r\n                    \"$version\": 12\r\n                },\r\n                \"reported\": {\r\n                    \"telemetrySendFrequency\": \"5m\",\r\n                    \"batteryLevel\": 55,\r\n                    \"$version\": 123\r\n                }\r\n            }\r\n        }\r\n\r\n可能的状态代码为：\r\n\r\n|状态 | 说明 |\r\n| ----- | ----------- |\r\n| 200 | 成功 |\r\n| 429 | 请求过多（受限），如 [IoT 中心限制][lnk-quotas]中所述 |\r\n| 5** | 服务器错误 |\r\n\r\n有关详细信息，请参阅[设备孪生开发人员指南][lnk-devguide-twin]。\r\n\r\n### <a name=\"update-device-twins-reported-properties\"></a>更新设备孪生的报告属性\r\n\r\n以下顺序说明了设备如何在 IoT 中心更新设备孪生中报告的属性：\r\n\r\n1. 设备必须先订阅 `$iothub/twin/res/#` 主题，以便接收 IoT 中心的操作响应。\r\n\r\n1. 设备发送一条消息，其中包含 `$iothub/twin/PATCH/properties/reported/?$rid={request id}` 主题的设备孪生更新。 该消息包含 **请求 ID** 值。\r\n\r\n1. 然后，服务发送一条响应消息，其中包含主题 `$iothub/twin/res/{status}/?$rid={request id}` 的已报告属性集合的全新 ETag 值。 此响应消息使用与请求相同的**请求 ID**。\r\n\r\n请求消息正文包含一个 JSON 文档，该文档提供报告属性的新值（不可修改任何其他属性或元数据）。\r\nJSON 文档中的每个成员都会在设备孪生文档中更新或添加相应成员。 设置为 `null`的成员会从包含的对象中删除成员。 例如：\r\n\r\n```\r\n    {\r\n        \"telemetrySendFrequency\": \"35m\",\r\n        \"batteryLevel\": 60\r\n    }\r\n```\r\n\r\n可能的状态代码为：\r\n\r\n|状态 | 说明 |\r\n| ----- | ----------- |\r\n| 200 | 成功 |\r\n| 400 | 错误的请求。 格式不正确的 JSON |\r\n| 429 | 请求过多（受限），如 [IoT 中心限制][lnk-quotas]中所述 |\r\n| 5** | 服务器错误 |\r\n\r\n有关详细信息，请参阅[设备孪生开发人员指南][lnk-devguide-twin]。\r\n\r\n### <a name=\"receiving-desired-properties-update-notifications\"></a>接收所需属性更新通知\r\n\r\n设备连接时，IoT 中心会向主题 `$iothub/twin/PATCH/properties/desired/?$version={new version}`发送通知，内附解决方案后端执行的更新内容。 例如：\r\n\r\n```\r\n    {\r\n        \"telemetrySendFrequency\": \"5m\",\r\n        \"route\": null\r\n    }\r\n```\r\n\r\n对于属性更新， `null` 值表示正在删除 JSON 对象成员。\r\n\r\n\r\n> [!IMPORTANT] \r\n> IoT 中心仅在连接设备时才会生成更改通知。 请确保实现[设备重新连接流][lnk-devguide-twin-reconnection]，让 IoT 中心和设备应用之间的所需属性保持同步。\r\n\r\n有关详细信息，请参阅[设备孪生开发人员指南][lnk-devguide-twin]。\r\n\r\n### <a name=\"respond-to-a-direct-method\"></a>响应直接方法\r\n\r\n首先，设备需要订阅 `$iothub/methods/POST/#`。 IoT 中心向主题 `$iothub/methods/POST/{method name}/?$rid={request id}` 发送方法请求，其中包含有效的 JSON 或空正文。\r\n\r\n设备会向主题 `$iothub/methods/res/{status}/?$rid={request id}` 发送具有有效 JSON 或空正文的消息进行响应，其中“request id”必须与请求消息中的对应项匹配，“status”必须是整数。\r\n\r\n有关详细信息，请参阅[直接方法开发人员指南][lnk-methods]。\r\n\r\n### <a name=\"additional-considerations\"></a>其他注意事项\r\n\r\n最后，如果需要自定义云端的 MQTT 协议行为，则应检查 [Azure IoT 协议网关][lnk-azure-protocol-gateway] ，可以通过它部署直接与 IoT 中心连接的高性能自定义协议网关。 使用 Azure IoT 协议网关可以自定义设备协议，以适应要重建的 MQTT 部署或其他自定义协议。 但是，这种方法要求运行并使用自定义协议网关。\r\n\r\n## <a name=\"next-steps\"></a>后续步骤\r\n\r\n若要了解有关 MQTT 协议的详细信息，请参阅 [MQTT 文档][lnk-mqtt-docs]。\r\n\r\n若要深入了解如何规划 IoT 中心部署，请参阅：\r\n\r\n- [支持其他协议][lnk-protocols]\r\n- [与事件中心比较][lnk-compare]\r\n- [缩放、HA 和 DR][lnk-scaling]\r\n\r\n若要进一步探索 IoT 中心的功能，请参阅：\r\n\r\n* [IoT 中心开发人员指南][lnk-devguide]\r\n* [使用 Azure IoT Edge 模拟设备][lnk-iotedge]\r\n\r\n[lnk-device-sdks]: https://github.com/Azure/azure-iot-sdks\r\n[lnk-mqtt-org]: http://mqtt.org/\r\n[lnk-mqtt-docs]: http://mqtt.org/documentation\r\n[lnk-sample-node]: https://github.com/Azure/azure-iot-sdk-node/blob/master/device/samples/simple_sample_device.js\r\n[lnk-sample-java]: https://github.com/Azure/azure-iot-sdk-java/blob/master/device/iot-device-samples/send-receive-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/SendReceive.java\r\n[lnk-sample-c]: https://github.com/Azure/azure-iot-sdk-c/tree/master/iothub_client/samples/iothub_client_sample_mqtt\r\n[lnk-sample-csharp]: https://github.com/Azure/azure-iot-sdk-csharp/tree/master/device/samples\r\n[lnk-sample-python]: https://github.com/Azure/azure-iot-sdk-python/tree/master/device/samples\r\n[lnk-device-explorer]: https://github.com/Azure/azure-iot-sdk-csharp/blob/master/tools/DeviceExplorer\r\n[lnk-sas-tokens]: ./iot-hub-devguide-security.md#use-sas-tokens-in-a-device-app\r\n[lnk-azure-protocol-gateway]: ./iot-hub-protocol-gateway.md\r\n\r\n[lnk-protocols]: ./iot-hub-protocol-gateway.md\r\n[lnk-compare]: ./iot-hub-compare-event-hubs.md\r\n[lnk-scaling]: ./iot-hub-scaling.md\r\n[lnk-devguide]: ./iot-hub-devguide.md\r\n[lnk-iotedge]: ./iot-hub-linux-iot-edge-simulated-device.md\r\n\r\n[lnk-methods]: ./iot-hub-devguide-direct-methods.md\r\n[lnk-messaging]: ./iot-hub-devguide-messaging.md\r\n[lnk-quotas]: ./iot-hub-devguide-quotas-throttling.md\r\n[lnk-devguide-twin-reconnection]: ./iot-hub-devguide-device-twins.md#device-reconnection-flow\r\n[lnk-devguide-twin]: ./iot-hub-devguide-device-twins.md\r\n\r\n\r\n<!--Update_Description:update meta properties and link references-->\r\n"}