{"Title":"使用 Azure IoT 中心更新设备固件 (.NET/.NET)","Description":"如何使用 Azure IoT 中心上的设备管理进行设备固件更新。 使用适用于 .NET 的 Azure IoT 设备 SDK 实现模拟设备应用，并使用适用于 .NET 的 Azure IoT 服务 SDK 实现可触发固件更新的服务应用。","Content":"# <a name=\"use-device-management-to-initiate-a-device-firmware-update-netnet\"></a>使用设备管理启动设备固件更新 (.NET/.NET)\r\n[!INCLUDE [iot-hub-selector-firmware-update](../../includes/iot-hub-selector-firmware-update.md)]\r\n\r\n## <a name=\"introduction\"></a>介绍\r\n在[设备管理入门][lnk-dm-getstarted]教程中，已了解如何使用[设备孪生][lnk-devtwin]和[直接方法][lnk-c2dmethod]基元来远程重新启动设备。 本教程使用相同的 IoT 中心基元，并演示如何进行端到端模拟固件更新。  此模式在用于 [Raspberry Pi device implementation sample][lnk-rpi-implementation]（Raspberry Pi 设备实现示例）的固件更新实现中使用。\r\n\r\n本教程演示如何：\r\n\r\n* 创建一个 .NET 控制台应用，其通过 IoT 中心在模拟设备应用上调用 **firmwareUpdate** 直接方法。\r\n* 创建模拟设备应用，以便实现 **firmwareUpdate** 直接方法。 该方法会启动等待下载固件映像、下载固件映像以及最后应用固件映像的多阶段过程。 在更新的每个阶段，设备都使用报告的属性来报告进度。\r\n\r\n本教程结束时，用户会有一个 .NET (C#) 控制台设备应用，以及一个 .NET (C#) 控制台后端应用：\r\n\r\n* **SimulatedDeviceFwUpdate**，它使用先前创建的设备标识连接到 IoT 中心，接收 **firmwareUpdate** 直接方法，运行一个多状态过程以模拟固件更新，此过程包括：等待映像下载、下载新映像以及最后应用映像。\r\n\r\n* **TriggerFWUpdate**，它使用服务 SDK 在模拟设备上远程调用 **firmwareUpdate** 直接方法、显示响应并定期（每 500 毫秒）显示更新的报告属性。\r\n\r\n要完成本教程，需要以下各项：\r\n\r\n* Visual Studio 2015 或 Visual Studio 2017。\r\n* 有效的 Azure 帐户。 如果没有帐户，可以创建一个[试用帐户][lnk-free-trial]，只需几分钟即可完成。\r\n\r\n按照[设备管理入门](iot-hub-csharp-csharp-device-management-get-started.md)一文创建 IoT 中心，并获取 IoT 中心连接字符串。\r\n\r\n[!INCLUDE [iot-hub-get-started-create-hub](../../includes/iot-hub-get-started-create-hub.md)]\r\n\r\n[!INCLUDE [iot-hub-get-started-create-device-identity-portal](../../includes/iot-hub-get-started-create-device-identity-portal.md)]\r\n\r\n## <a name=\"trigger-a-remote-firmware-update-on-the-device-using-a-direct-method\"></a>使用直接方法在设备上触发远程固件更新\r\n在本部分中，用户创建一个 .NET 控制台应用（使用 C#），以便在设备上启动远程固件更新。 该应用使用直接方法来启动更新，并使用设备孪生查询定期获取活动固件更新的状态。\r\n\r\n1. 在 Visual Studio 中，使用“**控制台应用程序**”项目模板将 Visual C# Windows 经典桌面项目添加到当前解决方案。 **TriggerFWUpdate**。\r\n\r\n    ![新的 Visual C# Windows 经典桌面项目][img-createserviceapp]\r\n\r\n2. 在“解决方案资源管理器”中，右键单击“TriggerFWUpdate”项目，并单击“管理 NuGet 包”。\r\n3. 在“NuGet 包管理器”窗口中，选择“浏览”，搜索 **microsoft.azure.devices**，选择“安装”以安装 **Microsoft.Azure.Devices** 包，并接受使用条款。 此过程会下载、安装 [Azure IoT 服务 SDK][lnk-nuget-service-sdk] NuGet 包及其依赖项并添加对它的引用。\r\n\r\n    ![“NuGet 包管理器”窗口][img-servicenuget]\r\n4. 在 **Program.cs** 文件顶部添加以下 `using` 语句：\r\n\r\n    ```csharp   \r\n    using Microsoft.Azure.Devices;\r\n    using Microsoft.Azure.Devices.Shared;\r\n    ```\r\n\r\n5. 将以下字段添加到 **Program** 类。 将多个占位符值替换为在上一部分中为中心创建的 IoT 中心连接字符串和设备的 ID。\r\n   \r\n    ```csharp   \r\n    static RegistryManager registryManager;\r\n    static string connString = \"{iot hub connection string}\";\r\n    static ServiceClient client;\r\n    static string targetDevice = \"{deviceIdForTargetDevice}\";\r\n    ```\r\n        \r\n6. 将以下方法添加到 **Program** 类。 此方法每隔 500 毫秒在设备孪生中轮询更新的状态。 仅当状态实际发生更改时，它才向控制器写入数据。 在本示例中，为了防止在订阅中使用额外的 IoT 中心消息，当设备报告 **applyComplete** 状态或错误时，轮询将会停止。  \r\n   \r\n    ```csharp   \r\n    public static async Task QueryTwinFWUpdateReported(DateTime startTime)\r\n    {\r\n        DateTime lastUpdated = startTime;\r\n\r\n        while (true)\r\n        {\r\n            Twin twin = await registryManager.GetTwinAsync(targetDevice);\r\n\r\n            if (twin.Properties.Reported.GetLastUpdated().ToUniversalTime() > lastUpdated.ToUniversalTime())\r\n            {\r\n                lastUpdated = twin.Properties.Reported.GetLastUpdated().ToUniversalTime();\r\n                Console.WriteLine(\"\\n\" + twin.Properties.Reported[\"iothubDM\"].ToJson());\r\n\r\n                var status = twin.Properties.Reported[\"iothubDM\"][\"firmwareUpdate\"][\"status\"].Value;\r\n                if ((status == \"downloadFailed\") || (status == \"applyFailed\") || (status == \"applyComplete\"))\r\n                {\r\n                    Console.WriteLine(\"\\nStop polling.\");\r\n                    return;\r\n                }\r\n            }\r\n            await Task.Delay(500);\r\n        }\r\n    }\r\n    ```\r\n        \r\n7. 将以下方法添加到 **Program** 类：\r\n\r\n    ```csharp   \r\n    public static async Task StartFirmwareUpdate()\r\n    {\r\n        client = ServiceClient.CreateFromConnectionString(connString);\r\n        CloudToDeviceMethod method = new CloudToDeviceMethod(\"firmwareUpdate\");\r\n        method.ResponseTimeout = TimeSpan.FromSeconds(30);\r\n        method.SetPayloadJson(\r\n            @\"{\r\n               fwPackageUri : 'https://someurl'\r\n            }\");\r\n\r\n        CloudToDeviceMethodResult result = await client.InvokeDeviceMethodAsync(targetDevice, method);\r\n\r\n        Console.WriteLine(\"Invoked firmware update on device.\");\r\n    }\r\n    ```\r\n\r\n8. 最后，在 **Main** 方法中添加以下行。 这会创建一个注册表管理器用于读取设备孪生，在工作线程上启动轮询任务，然后触发固件更新。\r\n   \r\n    ```csharp   \r\n    registryManager = RegistryManager.CreateFromConnectionString(connString);\r\n\r\n    Task queryTask = Task.Run(() => (QueryTwinFWUpdateReported(DateTime.Now)));\r\n\r\n    StartFirmwareUpdate().Wait();\r\n    Console.WriteLine(\"Press ENTER to exit.\");\r\n    Console.ReadLine();\r\n    ```\r\n        \r\n9. 生成解决方案。\r\n\r\n## <a name=\"create-a-simulated-device-app\"></a>创建模拟设备应用程序\r\n本部分的操作：\r\n\r\n* 创建一个 .NET 控制台应用，用于响应通过云调用的直接方法\r\n* 模拟后端服务通过直接方法触发的固件更新\r\n* 使用报告属性，允许通过设备孪生查询标识设备及其上次完成固件更新的时间\r\n\r\n1. 在 Visual Studio 中，使用“**控制台应用程序**”项目模板将 Visual C# Windows 经典桌面项目添加到当前解决方案。 将项目命名为 **SimulateDeviceFWUpdate**。\r\n   \r\n    ![新的 Visual C# Windows 经典设备应用][img-createdeviceapp]\r\n    \r\n2. 在“解决方案资源管理器”中，右键单击“SimulateDeviceFWUpdate”项目，并单击“管理 NuGet 包”。\r\n3. 在“NuGet 包管理器”窗口中，选择“浏览”，搜索“microsoft.azure.devices.client”。 选择“安装”，安装“microsoft.azure.devices.client”包，并接受使用条款。 该过程将下载、安装 [Azure IoT 设备 SDK][lnk-nuget-client-sdk] NuGet 包及其依赖项并添加对它的引用。\r\n   \r\n    ![“NuGet 包管理器”窗口客户端应用][img-clientnuget]\r\n4. 在 **Program.cs** 文件顶部添加以下 `using` 语句：\r\n   \r\n    ```csharp   \r\n    using Newtonsoft.Json.Linq;\r\n    using Microsoft.Azure.Devices.Client;\r\n    using Microsoft.Azure.Devices.Shared;\r\n    ```\r\n\r\n5. 将以下字段添加到 **Program** 类。 将占位符值替换为在**创建设备标识**部分中记下的设备连接字符串。\r\n   \r\n    ```csharp   \r\n    static string DeviceConnectionString = \"HostName=<yourIotHubName>.azure-devices.cn;DeviceId=<yourIotDeviceName>;SharedAccessKey=<yourIotDeviceAccessKey>\";\r\n    static DeviceClient Client = null;\r\n    ```\r\n\r\n6. 添加以下方法，以通过设备孪生向云报告状态： \r\n\r\n    ```csharp   \r\n    static async Task reportFwUpdateThroughTwin(Twin twin, TwinCollection fwUpdateValue)\r\n    {\r\n        try\r\n        {\r\n            TwinCollection patch = new TwinCollection();\r\n            TwinCollection iothubDM = new TwinCollection();\r\n\r\n            iothubDM[\"firmwareUpdate\"] = fwUpdateValue;\r\n            patch[\"iothubDM\"] = iothubDM;\r\n\r\n            await Client.UpdateReportedPropertiesAsync(patch);\r\n            Console.WriteLine(\"Twin state reported: {0}\", fwUpdateValue[\"status\"]);\r\n        }\r\n        catch \r\n        {\r\n            Console.WriteLine(\"Error updating device twin\");\r\n            throw;\r\n        }\r\n    }\r\n    ```\r\n\r\n7. 添加以下方法，以模拟固件映像下载：\r\n        \r\n    ```csharp   \r\n    static async Task<byte[]> simulateDownloadImage(string imageUrl)\r\n    {\r\n        var image = \"[fake image data]\";\r\n\r\n        Console.WriteLine(\"Downloading image from \" + imageUrl);\r\n\r\n        await Task.Delay(4000);\r\n\r\n        return Encoding.ASCII.GetBytes(image);\r\n            \r\n    }\r\n    ```\r\n\r\n8. 添加以下方法，以模拟向设备应用固件映像：\r\n        \r\n    ```csharp   \r\n    static async Task simulateApplyImage(byte[] imageData)\r\n    {\r\n        if (imageData == null)\r\n        {\r\n            throw new ArgumentNullException();\r\n        }\r\n\r\n        await Task.Delay(4000);\r\n\r\n    }\r\n    ```\r\n \r\n9.  添加以下方法，以等待下载模拟固件映像。 将状态更新为 **waiting**，并清除孪生上的其他固件更新属性。 清除这些属性会删除先前固件更新中的所有现有值。 之所以需要执行此操作，是因为报告属性是作为 PATCH 操作（增量）而不是 PUT 操作（替换所有先前值的整组属性）发送的。 通常，设备会收到有关可用更新的通知，并且管理员定义的策略会使设备开始下载和应用更新。 此函数是用于启用该策略的逻辑应该运行的位置。 \r\n        \r\n    ```csharp   \r\n    static async Task waitToDownload(Twin twin, string fwUpdateUri)\r\n    {\r\n        var now = DateTime.Now;\r\n        TwinCollection status = new TwinCollection();\r\n        status[\"fwPackageUri\"] = fwUpdateUri;\r\n        status[\"status\"] = \"waiting\";\r\n        status[\"error\"] = null;\r\n        status[\"startedWaitingTime\"] = DateTime.Now;\r\n        status[\"downloadCompleteTime\"] = null;\r\n        status[\"startedApplyingImage\"] = null;\r\n        status[\"lastFirmwareUpdate\"] = null;\r\n\r\n        await reportFwUpdateThroughTwin(twin, status);\r\n\r\n        await Task.Delay(2000);\r\n    }\r\n    ```\r\n\r\n10. 添加以下方法以执行下载。 此方法通过设备孪生将状态更新为 **downloading**，调用 simulate download 方法，并根据 download 操作的结果，通过孪生报告 **downloadComplete** 或 **downloadFailed** 状态。 \r\n        \r\n    ```csharp   \r\n    static async Task<byte[]> downloadImage(Twin twin, string fwUpdateUri)\r\n    {\r\n        try\r\n        {\r\n            TwinCollection statusUpdate = new TwinCollection();\r\n            statusUpdate[\"status\"] = \"downloading\";\r\n            await reportFwUpdateThroughTwin(twin, statusUpdate);\r\n\r\n            byte[] imageData = await simulateDownloadImage(fwUpdateUri);\r\n\r\n            statusUpdate = new TwinCollection();\r\n            statusUpdate[\"status\"] = \"downloadComplete\";\r\n            statusUpdate[\"downloadCompleteTime\"] = DateTime.Now;\r\n            await reportFwUpdateThroughTwin(twin, statusUpdate);\r\n            return imageData;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            TwinCollection statusUpdate = new TwinCollection();\r\n            statusUpdate[\"status\"] = \"downloadFailed\";\r\n            statusUpdate[\"error\"] = new TwinCollection();\r\n            statusUpdate[\"error\"][\"code\"] = ex.GetType().ToString();\r\n            statusUpdate[\"error\"][\"message\"] = ex.Message;\r\n            await reportFwUpdateThroughTwin(twin, statusUpdate);\r\n            throw;\r\n        }\r\n    }\r\n    ```\r\n\r\n11. 添加以下方法以应用映像。 此方法通过设备孪生将状态更新为 **applying**，调用 simulate apply image 方法，并根据 apply 操作的结果，通过孪生更新 **applyComplete** 或 **applyFailed** 状态。 \r\n        \r\n    ```csharp   \r\n    static async Task applyImage(Twin twin, byte[] imageData)\r\n    {\r\n        try\r\n        {\r\n            TwinCollection statusUpdate = new TwinCollection();\r\n            statusUpdate[\"status\"] = \"applying\";\r\n            statusUpdate[\"startedApplyingImage\"] = DateTime.Now;\r\n            await reportFwUpdateThroughTwin(twin, statusUpdate);\r\n\r\n            await simulateApplyImage(imageData);\r\n\r\n            statusUpdate = new TwinCollection();\r\n            statusUpdate[\"status\"] = \"applyComplete\";\r\n            statusUpdate[\"lastFirmwareUpdate\"] = DateTime.Now;\r\n            await reportFwUpdateThroughTwin(twin, statusUpdate);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            TwinCollection statusUpdate = new TwinCollection();\r\n            statusUpdate[\"status\"] = \"applyFailed\";\r\n            statusUpdate[\"error\"] = new TwinCollection();\r\n            statusUpdate[\"error\"][\"code\"] = ex.GetType().ToString();\r\n            statusUpdate[\"error\"][\"message\"] = ex.Message;\r\n            await reportFwUpdateThroughTwin(twin, statusUpdate);\r\n            throw;\r\n        }\r\n    }\r\n    ```\r\n\r\n12. 添加以下方法，将处于“正在等待下载映像”到“正在将映像应用到设备”状态的固件更新操作定序：\r\n        \r\n    ```csharp   \r\n    static async Task doUpdate(string fwUpdateUrl)\r\n    {\r\n        try\r\n        {\r\n            Twin twin = await Client.GetTwinAsync();\r\n            await waitToDownload(twin, fwUpdateUrl);\r\n            byte[] imageData = await downloadImage(twin, fwUpdateUrl);\r\n            await applyImage(twin, imageData);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine();\r\n            Console.WriteLine(\"Error during update: {0}\", ex.Message);\r\n        }\r\n    }\r\n    ```\r\n\r\n13. 添加以下方法，以从云中处理 **updateFirmware** 直接方法。 此方法会将 URL 从消息有效负载提取到固件更新，并将其传递给在另一个 threadpool 线程上启动的 **doUpdate** 任务。 然后，此方法立即向云返回方法响应。\r\n        \r\n    ```csharp   \r\n    static Task<MethodResponse> onFirmwareUpdate(MethodRequest methodRequest, object userContext)\r\n    {\r\n        string fwUpdateUrl = (string)JObject.Parse(methodRequest.DataAsJson)[\"fwPackageUri\"];\r\n        Console.WriteLine(\"\\nMethod: {0} triggered by service, URI is: {1}\", methodRequest.Name, fwUpdateUrl);\r\n\r\n        Task updateTask = Task.Run(() => (doUpdate(fwUpdateUrl)));\r\n\r\n        string result = \"'FirmwareUpdate started.'\";\r\n        return Task.FromResult(new MethodResponse(Encoding.UTF8.GetBytes(result), 200));\r\n    }\r\n    ```\r\n> [!NOTE]\r\n> 此方法触发以**任务**形式运行的模拟更新，然后立即响应方法调用，告知服务已启动固件更新。 更新状态和完成进度将通过设备孪生的报告属性发送到服务。 我们会在启动更新时而不是在完成更新后响应此方法调用，因为：\r\n> * 实际的更新过程所花费的时间很可能比方法调用超时的时间要长。\r\n> * 实际的更新过程很可能要求重新启动，这会重新启动此应用，使 **MetodRequest** 对象不可用。 （但是，即使在重新启动之后，也能更新报告属性。） \r\n\r\n14. 最后，将以下代码添加到 **Main** 方法，打开与 IoT 中心的连接并初始化方法侦听器：\r\n   \r\n    ```csharp   \r\n    try\r\n    {\r\n        Console.WriteLine(\"Connecting to hub\");\r\n        Client = DeviceClient.CreateFromConnectionString(DeviceConnectionString, TransportType.Mqtt);\r\n        \r\n        // setup callback for \"firmware update\" method\r\n        Client.SetMethodHandlerAsync(\"firmwareUpdate\", onFirmwareUpdate, null).Wait();\r\n        Console.WriteLine(\"Waiting for firmware update direct method call\\n Press enter to exit.\");\r\n        Console.ReadLine();\r\n\r\n        Console.WriteLine(\"Exiting...\");\r\n\r\n        // as a good practice, remove the firmware update handler\r\n        Client.SetMethodHandlerAsync(\"firmwareUpdate\", null, null).Wait();\r\n        Client.CloseAsync().Wait();\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        Console.WriteLine();\r\n        Console.WriteLine(\"Error in sample: {0}\", ex.Message);\r\n    }\r\n    ```\r\n        \r\n15. 生成解决方案。       \r\n\r\n> [!NOTE]\r\n> 为简单起见，本教程不实现任何重试策略。 在生产代码中，应该按 MSDN 文章 [Transient Fault Handling][lnk-transient-faults]（暂时性故障处理）中所述实施重试策略（例如指数性的回退）。\r\n\r\n\r\n## <a name=\"run-the-apps\"></a>运行应用\r\n现在，已准备就绪，可以运行应用。\r\n1. 运行 .NET 设备应用 **SimulatedDeviceFWUpdate**。  右键单击“SimulatedDeviceFWUpdate”项目，选择“调试”，并选择“启动新实例”。 它应开始侦听来自 IoT 中心的方法调用： \r\n\r\n2. 连接设备后等待方法调用时，可以运行 .NET **TriggerFWUpdate** 应用来调用模拟设备应用中的固件更新方法。 右键单击“TriggerFWUpdate”项目，选择“调试”，并选择“启动新实例”。 此时，应会看到更新序列已写入 **SimulatedDeviceFWUpdate** 控制台，另外，通过设备报告属性报告的序列已写入 **TriggerFWUpdate** 控制台。 请注意，此过程需要花费几秒钟时间才能完成。 \r\n   \r\n    ![服务和设备应用运行][img-combinedrun]\r\n\r\n\r\n## <a name=\"next-steps\"></a>后续步骤\r\n在本教程中，直接触发了设备的远程固件更新，并使用了报告属性跟踪固件更新的进度。\r\n\r\n若要了解如何扩展 IoT 解决方案并在多个设备上计划方法调用，请参阅 [Schedule and broadcast jobs][lnk-tutorial-jobs] （计划和广播作业）教程。\r\n\r\n<!-- images -->\r\n[img-servicenuget]: media/iot-hub-csharp-csharp-firmware-update/servicesdknuget.png\r\n[img-clientnuget]: media/iot-hub-csharp-csharp-firmware-update/clientsdknuget.png\r\n[img-createserviceapp]: media/iot-hub-csharp-csharp-firmware-update/createserviceapp.png\r\n[img-createdeviceapp]: media/iot-hub-csharp-csharp-firmware-update/createdeviceapp.png\r\n[img-combinedrun]: media/iot-hub-csharp-csharp-firmware-update/combinedrun.png\r\n\r\n[lnk-devtwin]: iot-hub-devguide-device-twins.md\r\n[lnk-c2dmethod]: iot-hub-devguide-direct-methods.md\r\n[lnk-dm-getstarted]: iot-hub-csharp-csharp-device-management-get-started.md\r\n[lnk-tutorial-jobs]: iot-hub-csharp-node-schedule-jobs.md\r\n\r\n[lnk-dev-setup]: https://github.com/Azure/azure-iot-sdk-node/blob/master/doc/node-devbox-setup.md\r\n[lnk-free-trial]: http://www.azure.cn/pricing/1rmb-trial/\r\n[lnk-transient-faults]: https://msdn.microsoft.com/library/hh680901(v=pandp.50).aspx\r\n[lnk-rpi-implementation]: https://github.com/Azure/azure-iot-sdk-c/tree/master/iothub_client/samples/iothub_client_sample_mqtt_dm/pi_device\r\n[lnk-nuget-client-sdk]: https://www.nuget.org/packages/Microsoft.Azure.Devices.Client/\r\n[lnk-nuget-service-sdk]: https://www.nuget.org/packages/Microsoft.Azure.Devices/"}