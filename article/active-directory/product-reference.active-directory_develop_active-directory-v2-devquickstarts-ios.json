{"Title":"Azure AD v2.0 iOS 应用","Description":"如何通过第三方库生成一个使用个人 Microsoft 帐户和工作或学校帐户来登录用户的 iOS 应用。","Content":"\r\n# 使用 v2.0 终结点，通过图形 API 将登录添加到使用第三方库的 iOS 应用\r\nMicrosoft 标识平台使用开放式标准，例如 OAuth2 和 OpenID Connect。开发人员可以使用任何想要的库来与我们的服务集成。为了帮助开发人员将我们的平台与其他库结合使用，我们撰写了数篇演练（例如本演练），演示如何配置第三方库，使其连接到 Microsoft 标识平台。大部分实施 [RFC6749 OAuth2 规范](https://tools.ietf.org/html/rfc6749)的库都能连接到 Microsoft 标识平台。\r\n\r\n借助本演练创建的应用程序，用户可以使用图形 API 登录自己的组织，然后在组织中搜索其他人。\r\n\r\n如果你是 OAuth2 或 OpenID Connect 新手，该示例配置中的大部分内容可能较难理解。建议你阅读 [v2.0 协议 — OAuth 2.0 授权代码流](./active-directory-v2-protocols-oauth-code.md)了解背景信息。\r\n\r\n> [!NOTE]\r\n我们平台中的有些功能（例如条件访问和 Intune 策略管理）采用 OAuth2 或 OpenID Connect 标准中的表达式，所以会要求使用开放源代码 Azure 标识库。\r\n> \r\n> \r\n\r\nv2.0 终结点并不支持所有 Azure Active Directory 方案和功能。\r\n\r\n> [!NOTE]\r\n若要确定是否应使用 v2.0 终结点，请阅读 [v2.0 限制](./active-directory-v2-limitations.md)。\r\n> \r\n> \r\n\r\n## 从 GitHub 下载代码\r\n本教程的代码[在 GitHub 上](https://github.com/Azure-Samples/active-directory-ios-native-nxoauth2-v2)维护。若要遵照该代码，你可以[下载 .zip 格式应用骨架](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-DotNet/archive/skeleton.zip)，或克隆该骨架：\r\n\r\n```\r\ngit clone --branch skeleton git@github.com:Azure-Samples/active-directory-ios-native-nxoauth2-v2.git\r\n```\r\n\r\n你也可以下载以下示例，并立即开始使用：\r\n\r\n```\r\ngit clone git@github.com:Azure-Samples/active-directory-ios-native-nxoauth2-v2.git\r\n```\r\n\r\n## 注册应用程序\r\n在[应用程序注册门户](https://apps.dev.microsoft.com)创建新的应用，或按照[如何使用 v2.0 终结点注册应用](./active-directory-v2-app-registration.md)中的详细步骤操作。请确保：\r\n\r\n- 复制分配给应用的“应用程序 ID”，因为稍后将要用到。\r\n- 为应用添加**移动**平台。\r\n- 从门户复制**重定向 URI**。必须使用默认值 `urn:ietf:wg:oauth:2.0:oob`。\r\n\r\n## 下载 NXOAuth2 第三方库并创建工作区\r\n在本演练中，你将使用 GitHub 提供的 OAuth2Client，这是适用于 Mac OS X 和 iOS 的 OAuth2 库（Cocoa 和 Cocoa Touch）。此库以 OAuth2 规范的第 10 版草稿为基础。它将实现本机应用程序配置文件，并支持用户的授权终结点。用户需要上述各项，才能与 Microsoft 标识平台集成。\r\n\r\n### 使用 CocoaPods 将库添加到项目\r\nCocoaPods 是 Xcode 项目的依赖关系管理器。它会自动管理上述安装步骤。\r\n\r\n```\r\n$ vi Podfile\r\n```\r\n\r\n1. 将以下内容添加到 podfile：\r\n\r\n    ```\r\n    platform :ios, '8.0'\r\n\r\n    target 'QuickStart' do\r\n\r\n    pod 'NXOAuth2Client'\r\n\r\n    end\r\n    ```\r\n\r\n2. 使用 CocoaPods 加载 podfile。这会创建你要加载的新 Xcode 工作区。\r\n\r\n    ```\r\n    $ pod install\r\n    ...\r\n    $ open QuickStart.xcworkspace\r\n    ```\r\n\r\n## 浏览项目结构\r\n在主干中为项目设置以下结构：\r\n\r\n- 具有 UPN 搜索功能的主视图\r\n- 所选用户的相关数据的详细信息视图\r\n- 用户可登录到应用来查询图形的登录视图\r\n\r\n我们将移至主干中的各种文件，以添加身份验证。代码的其他部分（如可视代码）虽然与标识无关，但也会提供给你。\r\n\r\n## 设置库中的 settings.plst 文件\r\n- 在快速入门项目中，打开 `settings.plist` 文件。替换节中的元素值，反映你在 Azure 门户中使用的值。每当使用 Active Directory 身份验证库时，你的代码就会参考这些值。\r\n  - `clientId` 是从门户复制的应用程序的客户端 ID。\r\n  - `redirectUri` 是门户提供的重定向 URL。\r\n\r\n## 在 LoginViewController 中设置 NXOAuth2Client 库\r\nNXOAuth2Client 库要求设置一些值。完成该任务之后，可以使用所获令牌来调用图形 API。因为每当需要进行身份验证时都会调用 `LoginView`，所以合理的做法是将配置值放入该文件中。\r\n\r\n- 让我们在 `LoginViewController.m` 文件中添加一些值，以便针对身份验证和授权来设置上下文。紧跟代码后面的是关于这些值的详细信息。\r\n\r\n    ```objc\r\n    NSString *scopes = @\"openid offline_access User.Read\";\r\n    NSString *authURL = @\"https://login.microsoftonline.com/common/oauth2/v2.0/authorize\";\r\n    NSString *loginURL = @\"https://login.microsoftonline.com/common/login\";\r\n    NSString *bhh = @\"urn:ietf:wg:oauth:2.0:oob?code=\";\r\n    NSString *tokenURL = @\"https://login.microsoftonline.com/common/oauth2/v2.0/token\";\r\n    NSString *keychain = @\"com.microsoft.azureactivedirectory.samples.graph.QuickStart\";\r\n    static NSString * const kIDMOAuth2SuccessPagePrefix = @\"session_state=\";\r\n    NSURL *myRequestedUrl;\r\n    NSURL *myLoadedUrl;\r\n    bool loginFlow = FALSE;\r\n    bool isRequestBusy;\r\n    NSURL *authcode;\r\n    ```\r\n\r\n让我们看看关于代码的详细信息。\r\n\r\n第一个字符串用于 `scopes`。`User.Read` 值允许读取已登录用户的基本配置文件。\r\n\r\n你可以在 [Microsoft Graph 权限范围](https://graph.microsoft.io/docs/authorization/permission_scopes)中了解有关所有可用范围的详细信息。\r\n\r\n对于 `authURL`、`loginURL`、`bhh` 及 `tokenURL`，你应该使用上面提供的值。如果你使用开放源代码 Azure 标识库，我们将使用元数据终结点提取此数据。我们已努力完成为你提取这些值的工作。\r\n\r\n`keychain` 值是一个容器，NXOAuth2Client 库将用来创建密钥链以存储你的令牌。如果想要跨多个应用实现单一登录 (SSO)，可以在每个应用程序中指定相同的密钥链，并请求在 Xcode 权利中使用该密钥链。这会在 Apple 文档中说明。\r\n\r\n我们也需要其余的值，才能使用此库，才能将值应用于上下文。\r\n\r\n### 创建 URL 缓存\r\n在加载视图之后，始终会调用 `(void)viewDidLoad()`，其内部的以下代码会准备好缓存以供我们使用。\r\n\r\n添加以下代码：\r\n\r\n```objc\r\n- (void)viewDidLoad {\r\n    [super viewDidLoad];\r\n    self.loginView.delegate = self;\r\n    [self setupOAuth2AccountStore];\r\n    [self requestOAuth2Access];\r\n    NSURLCache *URLCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024\r\n                                                         diskCapacity:20 * 1024 * 1024\r\n                                                             diskPath:nil];\r\n    [NSURLCache setSharedURLCache:URLCache];\r\n\r\n}\r\n```\r\n\r\n### 创建用于登录的 Web 视图\r\n\r\nWeb 视图可提示用户提供短信等附加因素（如果已配置）或向用户返回错误消息。你将在此处设置 Web 视图，然后编写代码，以从标识服务处理将会在 Web 视图中发生的回叫。\r\n\r\n```objc\r\n-(void)requestOAuth2Access {\r\n    //to sign in to Microsoft APIs using OAuth2, we must show an embedded browser (UIWebView)\r\n    [[NXOAuth2AccountStore sharedStore] requestAccessToAccountWithType:@\"myGraphService\"\r\n                                   withPreparedAuthorizationURLHandler:^(NSURL *preparedURL) {\r\n                                       //navigate to the URL returned by NXOAuth2Client\r\n\r\n                                       NSURLRequest *r = [NSURLRequest requestWithURL:preparedURL];\r\n                                       [self.loginView loadRequest:r];\r\n                                   }];\r\n}\r\n```\r\n\r\n### 重写 Web 视图方法以处理身份验证\r\n\r\n如先前所述，当用户需要登录时，若要告诉 Web 视图发生了什么情况，你可以粘贴以下代码。\r\n\r\n```objc\r\n- (void)resolveUsingUIWebView:(NSURL *)URL {\r\n\r\n    // We get the auth token from a redirect so we need to handle that in the webview.\r\n\r\n    if (![NSThread isMainThread]) {\r\n        [self performSelectorOnMainThread:@selector(resolveUsingUIWebView:) withObject:URL waitUntilDone:YES];\r\n        return;\r\n    }\r\n\r\n    NSURLRequest *hostnameURLRequest = [NSURLRequest requestWithURL:URL cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0f];\r\n    isRequestBusy = YES;\r\n    [self.loginView loadRequest:hostnameURLRequest];\r\n\r\n    NSLog(@\"resolveUsingUIWebView ready (status: UNKNOWN, URL: %@)\", self.loginView.request.URL);\r\n}\r\n\r\n- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {\r\n\r\n    NSLog(@\"webView:shouldStartLoadWithRequest: %@ (%li)\", request.URL, (long)navigationType);\r\n\r\n    // The webview is where all the communication happens. Slightly complicated.\r\n\r\n    myLoadedUrl = [webView.request mainDocumentURL];\r\n    NSLog(@\"***Loaded url: %@\", myLoadedUrl);\r\n\r\n    //if the UIWebView is showing our authorization URL or consent URL, show the UIWebView control\r\n    if ([request.URL.absoluteString rangeOfString:authURL options:NSCaseInsensitiveSearch].location != NSNotFound) {\r\n        self.loginView.hidden = NO;\r\n    } else if ([request.URL.absoluteString rangeOfString:loginURL options:NSCaseInsensitiveSearch].location != NSNotFound) {\r\n        //otherwise hide the UIWebView, we've left the authorization flow\r\n        self.loginView.hidden = NO;\r\n    } else if ([request.URL.absoluteString rangeOfString:bhh options:NSCaseInsensitiveSearch].location != NSNotFound) {\r\n        //otherwise hide the UIWebView, we've left the authorization flow\r\n        self.loginView.hidden = YES;\r\n        [[NXOAuth2AccountStore sharedStore] handleRedirectURL:request.URL];\r\n    }\r\n    else {\r\n        self.loginView.hidden = NO;\r\n        //read the Location from the UIWebView, this is how Microsoft APIs is returning the\r\n        //authentication code and relation information. This is controlled by the redirect URL we chose to use from Microsoft APIs\r\n        //continue the OAuth2 flow\r\n       // [[NXOAuth2AccountStore sharedStore] handleRedirectURL:request.URL];\r\n    }\r\n\r\n    return YES;\r\n\r\n}\r\n```\r\n\r\n### 编写代码以处理 OAuth2 请求的结果\r\n\r\n以下代码会处理从 Web 视图返回的 redirectURL。如果身份验证未成功，此代码将重试一次。同时，库会提供错误，让你可在控制台中查看或以异步方式处理。\r\n\r\n```objc\r\n- (void)handleOAuth2AccessResult:(NSString *)accessResult {\r\n\r\n    AppData* data = [AppData getInstance];\r\n\r\n    //parse the response for success or failure\r\n     if (accessResult)\r\n    //if success, complete the OAuth2 flow by handling the redirect URL and obtaining a token\r\n     {\r\n         [[NXOAuth2AccountStore sharedStore] handleRedirectURL:accessResult];\r\n    } else {\r\n        //start over\r\n        [self requestOAuth2Access];\r\n    }\r\n}\r\n```\r\n\r\n### 设置 OAuth 上下文（称为帐户存储）\r\n\r\n在这里，你可以针对希望应用程序能够访问的每个服务，在共享帐户存储上调用 `-[NXOAuth2AccountStore setClientID:secret:authorizationURL:tokenURL:redirectURL:forAccountType:]`。帐户类型是字符串，可作为特定服务的标识符。由于你正在访问图形 API，因此，代码会将其视为 `\"myGraphService\"`。接着，设置观察器，它会在令牌发生任何更改时通知你。在你获取令牌后，让用户返回到 `masterView`。\r\n\r\n```objc\r\n- (void)setupOAuth2AccountStore {\r\n\r\n        AppData* data = [AppData getInstance];\r\n\r\n    [[NXOAuth2AccountStore sharedStore] setClientID:data.clientId\r\n                                             secret:data.secret\r\n                                              scope:[NSSet setWithObject:scopes]\r\n                                   authorizationURL:[NSURL URLWithString:authURL]\r\n                                           tokenURL:[NSURL URLWithString:tokenURL]\r\n                                        redirectURL:[NSURL URLWithString:data.redirectUriString]\r\n                                      keyChainGroup: keychain\r\n                                     forAccountType:@\"myGraphService\"];\r\n\r\n    [[NSNotificationCenter defaultCenter] addObserverForName:NXOAuth2AccountStoreAccountsDidChangeNotification\r\n                                                      object:[NXOAuth2AccountStore sharedStore]\r\n                                                       queue:nil\r\n                                                  usingBlock:^(NSNotification *aNotification) {\r\n                                                      if (aNotification.userInfo) {\r\n                                                          //account added, we have access\r\n                                                          //we can now request protected data\r\n                                                          NSLog(@\"Success!! We have an access token.\");\r\n                                                          dispatch_async(dispatch_get_main_queue(),^ {\r\n\r\n                                                              MasterViewController* masterViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"masterView\"];\r\n                                                              [self.navigationController pushViewController:masterViewController animated:YES];\r\n                                                          });\r\n                                                      } else {\r\n                                                          //account removed, we lost access\r\n                                                      }\r\n                                                  }];\r\n\r\n    [[NSNotificationCenter defaultCenter] addObserverForName:NXOAuth2AccountStoreDidFailToRequestAccessNotification\r\n                                                      object:[NXOAuth2AccountStore sharedStore]\r\n                                                       queue:nil\r\n                                                  usingBlock:^(NSNotification *aNotification) {\r\n                                                      NSError *error = [aNotification.userInfo objectForKey:NXOAuth2AccountStoreErrorKey];\r\n                                                      NSLog(@\"Error!! %@\", error.localizedDescription);\r\n                                                  }];\r\n}\r\n```\r\n\r\n## 设置主视图以从图形 API 搜索和显示用户\r\n在网格中显示所返回数据的主视图控制器 (MVC) 应用超出了本演练的范围，而且有很多在线教程说明了如何生成该应用。此代码全都在主干文件中。不过，必须在此 MVC 应用程序中处理几件事：\r\n\r\n- 当用户在搜索字段中键入内容时进行拦截\r\n- 将数据的对象提供给主视图，以便在网格中显示结果\r\n\r\n我们会在下面执行这些操作。\r\n\r\n### 添加检查以查看你是否已经登录\r\n如果用户未登录，应用程序就没什么作用，因此，检查缓存中是否已有令牌是明智之举。如果没有，则重定向到登录视图以让用户登录。如果你还记得，在视图加载时执行操作的最佳方式，就是使用 Apple 提供的 `viewDidLoad()` 方法。\r\n\r\n```objc\r\n- (void)viewDidLoad {\r\n    [super viewDidLoad];\r\n\r\n    NXOAuth2AccountStore *store = [NXOAuth2AccountStore sharedStore];\r\n    NSArray *accounts = [store accountsWithAccountType:@\"myGraphService\"];\r\n\r\n        if (accounts.count == 0) {\r\n\r\n        dispatch_async(dispatch_get_main_queue(),^ {\r\n\r\n            LoginViewController* userSelectController = [self.storyboard instantiateViewControllerWithIdentifier:@\"LoginUserView\"];\r\n            [self.navigationController pushViewController:userSelectController animated:YES];\r\n        });\r\n        }\r\n```\r\n\r\n### 在收到数据时更新表视图\r\n\r\n当图形 API 返回数据时，必须显示该数据。为简单起见，下面提供了用于更新表的全部代码。你可以直接在 MVC 样本代码中粘贴正确的值。\r\n\r\n```objc\r\n#pragma mark - Table View\r\n\r\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {\r\n    return 1;\r\n}\r\n\r\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\r\n\r\n        return [upnArray count];\r\n}\r\n\r\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\r\n\r\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"TaskPrototypeCell\" forIndexPath:indexPath];\r\n\r\n    if ( cell == nil ) {\r\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@\"TaskPrototypeCell\"];\r\n    }\r\n\r\n    User *user = nil;\r\n     user = [upnArray objectAtIndex:indexPath.row];\r\n\r\n    // Configure the cell\r\n    cell.textLabel.text = user.name;\r\n    [cell setAccessoryType:UITableViewCellAccessoryDisclosureIndicator];\r\n\r\n    return cell;\r\n}\r\n```\r\n\r\n### 提供用户在搜索字段中键入内容时调用图形 API 的方法\r\n\r\n当用户在框中键入搜索内容时，你需要将该内容塞入图形 API。你将在以下代码中生成的 `GraphAPICaller` 类会将查找功能从演示当中分离出来。现在，让我们编写会将任何搜索字符送入图形 API 的代码。我们的做法是提供称为 `lookupInGraph` 的方法，其采用我们想要搜索的字符串。\r\n\r\n```objc\r\n-(void)lookupInGraph:(NSString *)searchText {\r\nif (searchText.length > 0) {\r\n\r\n    };\r\n\r\n        [GraphAPICaller searchUserList:searchText completionBlock:^(NSMutableArray* returnedUpns, NSError* error) {\r\n            if (returnedUpns) {\r\n\r\n                upnArray = returnedUpns;\r\n\r\n            }\r\n            else\r\n            {\r\n                UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:nil message:[[NSString alloc]initWithFormat:@\"Error : %@\", error.localizedDescription] delegate:nil cancelButtonTitle:@\"Retry\" otherButtonTitles:@\"Cancel\", nil];\r\n\r\n                [alertView setDelegate:self];\r\n\r\n                dispatch_async(dispatch_get_main_queue(),^ {\r\n                    [alertView show];\r\n                });\r\n            }\r\n\r\n        }];\r\n\r\n}\r\n```\r\n\r\n## 编写帮助程序类以访问图形 API\r\n\r\n这是我们应用程序的核心。而其余就是将代码插入 Apple 提供的默认 MVC 模式，你在这里编写的代码会在用户键入内容时查询图形，然后返回该数据。代码如下所示，后面还有其详细说明。\r\n\r\n### 创建新的 Objective C 头文件\r\n\r\n将文件命名为 `GraphAPICaller.h` 并添加以下代码。\r\n\r\n```objc\r\n@interface GraphAPICaller : NSObject<NSURLConnectionDataDelegate>\r\n\r\n+(void) searchUserList:(NSString*)searchString\r\n       completionBlock:(void (^) (NSMutableArray*, NSError* error))completionBlock;\r\n\r\n@end\r\n```\r\n\r\n如你所见，指定的方法会获取字符串并返回 completionBlock。你可能已经猜到了，此 completionBlock 提供的对象会在用户搜索时实时填充数据，以此更新表。\r\n\r\n### 新建 Objective C 文件\r\n将文件命名为 `GraphAPICaller.m` 并添加以下方法。\r\n\r\n```objc\r\n+(void) searchUserList:(NSString*)searchString\r\n       completionBlock:(void (^) (NSMutableArray* Users, NSError* error)) completionBlock\r\n{\r\n    if (!loadedApplicationSettings)\r\n    {\r\n        [self readApplicationSettings];\r\n    }\r\n\r\n    AppData* data = [AppData getInstance];\r\n\r\n    NSString *graphURL = [NSString stringWithFormat:@\"%@%@/users\", data.graphApiUrlString, data.apiversion];\r\n\r\n    NXOAuth2AccountStore *store = [NXOAuth2AccountStore sharedStore];\r\n    NSDictionary* params = [self convertParamsToDictionary:searchString];\r\n\r\n    NSArray *accounts = [store accountsWithAccountType:@\"myGraphService\"];\r\n    [NXOAuth2Request performMethod:@\"GET\"\r\n                        onResource:[NSURL URLWithString:graphURL]\r\n                   usingParameters:params\r\n                       withAccount:accounts[0]\r\n               sendProgressHandler:^(unsigned long long bytesSend, unsigned long long bytesTotal) {\r\n                   // e.g., update a progress indicator\r\n               }\r\n                   responseHandler:^(NSURLResponse *response, NSData *responseData, NSError *error) {\r\n                       // Process the response\r\n                       if (responseData) {\r\n                           NSError *error;\r\n                           NSDictionary *dataReturned = [NSJSONSerialization JSONObjectWithData:responseData options:0 error:nil];\r\n                           NSLog(@\"Graph Response was: %@\", dataReturned);\r\n\r\n                       // We can grab the top most JSON node to get our graph data.\r\n                       NSArray *graphDataArray = [dataReturned objectForKey:@\"value\"];\r\n\r\n                       // Don't be thrown off by the key name being \"value\". It really is the name of the\r\n                       // first node. :-)\r\n\r\n                       //each object is a key value pair\r\n                       NSDictionary *keyValuePairs;\r\n                       NSMutableArray* Users = [[NSMutableArray alloc]init];\r\n\r\n                       for(int i =0; i < graphDataArray.count; i++)\r\n                       {\r\n                           keyValuePairs = [graphDataArray objectAtIndex:i];\r\n\r\n                           User *s = [[User alloc]init];\r\n                           s.upn = [keyValuePairs valueForKey:@\"userPrincipalName\"];\r\n                           s.name =[keyValuePairs valueForKey:@\"displayName\"];\r\n                           s.mail =[keyValuePairs valueForKey:@\"mail\"];\r\n                           s.businessPhones =[keyValuePairs valueForKey:@\"businessPhones\"];\r\n                           s.mobilePhones =[keyValuePairs valueForKey:@\"mobilePhone\"];\r\n\r\n                           [Users addObject:s];\r\n                       }\r\n\r\n                       completionBlock(Users, nil);\r\n                   }\r\n                   else\r\n                   {\r\n                       completionBlock(nil, error);\r\n                   }\r\n\r\n               }];\r\n}\r\n```\r\n\r\n我们会详细解说此方法。\r\n\r\n此代码的核心在于 `NXOAuth2Request`，该方法会采用你已经在 settings.plist 文件中定义的参数。\r\n\r\n第一步是构造正确的图形 API 调用。由于你正在调用 `/users`，因此，你会将它追加到图形 API 资源和版本来进行指定。因为这些都会随着 API 演进而改变，所以合理的做法是将其放在外部设置文件中。\r\n\r\n```objc\r\nNSString *graphURL = [NSString stringWithFormat:@\"%@%@/users\", data.graphApiUrlString, data.apiversion];\r\n```\r\n\r\n接下来，你需要指定也会提供给图形 API 调用的参数。*切记*不要将参数放在资源终结点中，因为系统会在运行时针对所有不符合 URI 的字符擦除该终结点。必须在参数中提供所有查询代码。\r\n\r\n```objc\r\nNSDictionary* params = [self convertParamsToDictionary:searchString];\r\n```\r\n\r\n你可能发现这会调用你尚未编写的 `convertParamsToDictionary` 方法。在文件的最后，让我们立即编写该方法：\r\n\r\n```objc\r\n+(NSDictionary*) convertParamsToDictionary:(NSString*)searchString\r\n{\r\n    NSMutableDictionary* dictionary = [[NSMutableDictionary alloc]init];\r\n\r\n        NSString *query = [NSString stringWithFormat:@\"startswith(givenName, '%@')\", searchString];\r\n\r\n           [dictionary setValue:query forKey:@\"$filter\"];\r\n\r\n    return dictionary;\r\n}\r\n```\r\n\r\n接下来，我们将使用 `NXOAuth2Request` 方法从 API 取回 JSON 格式的数据。\r\n\r\n```objc\r\nNSArray *accounts = [store accountsWithAccountType:@\"myGraphService\"];\r\n    [NXOAuth2Request performMethod:@\"GET\"\r\n                        onResource:[NSURL URLWithString:graphURL]\r\n                   usingParameters:params\r\n                       withAccount:accounts[0]\r\n               sendProgressHandler:^(unsigned long long bytesSend, unsigned long long bytesTotal) {\r\n                   // e.g., update a progress indicator\r\n               }\r\n                   responseHandler:^(NSURLResponse *response, NSData *responseData, NSError *error) {\r\n                       // Process the response\r\n                       if (responseData) {\r\n                           NSError *error;\r\n                           NSDictionary *dataReturned = [NSJSONSerialization JSONObjectWithData:responseData options:0 error:nil];\r\n                           NSLog(@\"Graph Response was: %@\", dataReturned);\r\n\r\n                           // We can grab the top most JSON node to get our graph data.\r\n                           NSArray *graphDataArray = [dataReturned objectForKey:@\"value\"];\r\n```\r\n\r\n最后，来看看你要如何将数据返回到 MasterViewController。数据会以序列化方式返回，而且该数据必须反序列化并加载到 MainViewController 可使用的对象中。出于此目的，主干具有的 `User.m/h` 文件可以创建 User 对象。你会使用图形中的信息填充该 User 对象。\r\n\r\n```objc\r\n// We can grab the top most JSON node to get our graph data.\r\nNSArray *graphDataArray = [dataReturned objectForKey:@\"value\"];\r\n\r\n// Don't be thrown off by the key name being \"value\". It really is the name of the\r\n// first node. :-)\r\n\r\n//each object is a key value pair\r\nNSDictionary *keyValuePairs;\r\nNSMutableArray* Users = [[NSMutableArray alloc]init];\r\n\r\nfor(int i =0; i < graphDataArray.count; i++)\r\n{\r\n    keyValuePairs = [graphDataArray objectAtIndex:i];\r\n\r\n    User *s = [[User alloc]init];\r\n    s.upn = [keyValuePairs valueForKey:@\"userPrincipalName\"];\r\n    s.name =[keyValuePairs valueForKey:@\"displayName\"];\r\n    s.mail =[keyValuePairs valueForKey:@\"mail\"];\r\n    s.businessPhones =[keyValuePairs valueForKey:@\"businessPhones\"];\r\n    s.mobilePhones =[keyValuePairs valueForKey:@\"mobilePhone\"];\r\n\r\n    [Users addObject:s];\r\n```\r\n\r\n## 运行示例\r\n如果你使用主干或遵循本演练，那么，你的应用程序现在应该会运行。启动模拟器，然后单击“登录”以使用应用程序。\r\n\r\n## 获取产品的安全更新\r\n建议访问[安全技术中心](https://technet.microsoft.com/security/dd252948)并订阅安全公告通知，以便在发生安全事件时获取相关通知。\r\n\r\n<!---HONumber=Mooncake_0206_2017-->\r\n<!--Update_Description: wording update-->"}