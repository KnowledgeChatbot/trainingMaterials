{"Title":"Azure Active Directory Node.js 入门","Description":"如何生成一个与 Azure AD 集成、可用于身份验证的 Node.js REST Web API。","Content":"# <a name=\"getting-started-with-web-api-for-node\"></a>节点 WEB API 入门\r\n[!INCLUDE [active-directory-devguide](../../../includes/active-directory-devguide.md)]\r\n\r\n**Passport** 是 Node.js 的身份验证中间件。 Passport 极其灵活并且采用模块化结构，可以在不造成干扰的情况下放入任何基于 Express 的应用程序或 Resitify Web 应用程序。 可以使用一套综合性策略，通过用户名、密码等进行身份验证。 我们针对 Azure Active directory 开发了一个策略。 我们将安装此模块，并添加 Azure Active Directory `passport-azure-ad` 插件。\r\n\r\n为此，需要：\r\n\r\n1. 将应用程序注册到 Azure AD\r\n2. 将应用设置为使用 Passport 的 azure-ad-passport 插件。\r\n3. 配置一个客户端应用程序用于调用待办事项列表 Web API\r\n\r\n本教程的代码 [在 GitHub 上](https://github.com/Azure-Samples/active-directory-node-webapi)维护。\r\n\r\n> [!NOTE]\r\n> 本文未涵盖如何使用 Azure AD B2C 来实施登录、注册和配置文件管理，  而是着重介绍如何在用户通过身份验证后调用 Web API。  如果尚未开始，应该先从[如何与 Azure Active Directory 集成文档](active-directory-how-to-integrate.md)入手，了解 Azure Active Directory 的基础知识。\r\n> \r\n> \r\n\r\n我们已在 GitHub 中的 MIT 许可证下发布了此运行示例的所有源代码，用户可以任意克隆（甚至分发！）这些代码，并提供反馈和拉取请求。\r\n\r\n## <a name=\"about-nodejs-modules\"></a>关于 Node.js 模块\r\n在本演练中，我们使用 Node.js 模块。 模块是可加载的 JavaScript 包，可为应用程序提供特定功能。 通常会使用 Node.js NPM 命令行工具在 NPM 安装目录中安装模块，但一些模块（如 HTTP 模块）是作为核心 Node.js 包的一部分提供的。\r\n安装的模块保存在 Node.js 安装目录的根目录下的 node_modules 目录中。 node_modules 目录中的每个模块都保留自己的 node_modules 目录，其中包含它依赖的所有模块，每个必需的模块都有一个 node_modules 目录。 这种递归的目录结构表示了依赖关系链。\r\n\r\n这种依赖关系链结构会导致应用程序占用空间变大，但保证满足所有依赖项的要求，并且开发中使用的模块版本也会在生产中使用。 这使得生产应用程序的行为更有预测性，并防止出现影响用户的版本控制问题。\r\n\r\n## <a name=\"1-register-a-azure-ad-tenant\"></a>1.注册 Azure AD 租户\r\n若要使用本示例，需要一个 Azure Active Directory 租户。 如果不确定什么是租户或者如何获取租户，请参阅[如何获取 Azure AD 租户](./active-directory-howto-tenant.md)。\r\n\r\n## <a name=\"2-create-an-application\"></a>2.创建应用程序\r\n现在需要在目录中创建应用，以便为 Azure AD 提供一些必要信息，让它与应用安全地通信。  在此案例中，因为客户端应用和 Web API 会组成一个逻辑应用，所以由单一**应用程序 ID** 表示。  若要创建应用，请遵循[这些说明](./active-directory-how-applications-are-added.md)。 如果要生成业务线应用，[这些附加说明可能很有用](../active-directory-applications-guiding-developers-for-lob-applications.md)。\r\n\r\n请务必：\r\n\r\n- 登录到 Azure 管理门户。\r\n- 在左侧的导航栏中单击“Active Directory” 。\r\n- 选择要在其中注册应用程序的租户。\r\n- 单击“应用程序”选项卡，并在底部抽屉中单击“添加”  。\r\n- 根据提示创建一个新的 **Web 应用程序和/或 WebAPI**。\r\n    - 应用程序的**名称**向最终用户描述应用程序\r\n    - “登录 URL”  是应用程序的基本 URL。  示例代码的默认值是 `https://localhost:8080`。\r\n    - “应用程序 ID URI”是应用程序的唯一标识符  。  约定是使用 `https://<tenant-domain>/<app-name>`，例如 `https://contoso.partner.onmschina.cn/my-first-aad-app`\r\n- 完成注册后，AAD 为应用分配唯一的客户端标识符。  在后面的部分中会用到此值，因此，请从“配置”选项卡复制此值。\r\n- 提醒：为应用程序创建一个 **应用程序密码** 并复制下来。  稍后需要它。\r\n- 提醒：复制分配给应用的 **应用程序 ID** 。  稍后也会用到。\r\n\r\n## <a name=\"3-download-nodejs-for-your-platform\"></a>3.下载适用于平台的 node.js\r\n要成功使用本示例，必须正确安装 Node.js。\r\n\r\n请从 [http://nodejs.org](http://nodejs.org)安装 Node.js。\r\n\r\n## <a name=\"4-install-mongodb-on-to-your-platform\"></a>4.在平台上安装 MongoDB\r\n要成功使用本示例，必须正确安装 MongoDB。 我们使用 MongoDB 使 REST API 持久保留在服务器实例之间。\r\n\r\n从 [http://www.mongodb.org](http://www.mongodb.org) 安装 MongoDB。\r\n\r\n> [!NOTE]\r\n> 本演练假定为 MongoDB 使用默认的安装与服务器终结点，在编写本文时，该终结点为：mongodb://localhost\r\n> \r\n> \r\n\r\n## <a name=\"5-install-the-restify-modules-in-to-your-web-api\"></a>5.将 Restify 模块安装到 Web API 中\r\n我们使用 Resitfy 生成 REST API。 Restify 是从 Express 派生的精简灵活 Node.js 应用程序框架，它提供一套可靠的功能用于在 Connect 顶层生成 REST API。\r\n\r\n### <a name=\"install-restify\"></a>安装 Restify\r\n在命令行中，将目录切换到 azuread 目录。 如果 **azuread** 目录不存在，请创建该目录。\r\n\r\n```\r\ncd azuread - or- mkdir azuread; cd azuread \r\n```\r\n\r\n输入以下命令：\r\n\r\n```\r\nnpm install restify \r\n```\r\n\r\n此命令安装 Restify。\r\n\r\n#### <a name=\"did-you-get-an-error\"></a>遇到了错误吗？\r\n在某些操作系统上使用 npm 时，可能会收到错误“错误: EPERM, chmod '/usr/local/bin/..'” 和一个尝试以管理员身份运行帐户的请求。 如果发生这种情况，请使用 sudo 命令以更高的权限级别运行 npm。\r\n\r\n#### <a name=\"did-you-get-an-error-regarding-dtrace\"></a>遇到了有关 DTRACE 的错误吗？\r\n在安装 Restify 时，可能会看到类似于下面的内容：\r\n\r\n```Shell\r\nclang: error: no such file or directory: 'HD/azuread/node_modules/restify/node_modules/dtrace-provider/libusdt'\r\nmake: *** [Release/DTraceProviderBindings.node] Error 1\r\ngyp ERR! build error\r\ngyp ERR! stack Error: `make` failed with exit code: 2\r\ngyp ERR! stack     at ChildProcess.onExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:267:23)\r\ngyp ERR! stack     at ChildProcess.EventEmitter.emit (events.js:98:17)\r\ngyp ERR! stack     at Process.ChildProcess._handle.onexit (child_process.js:789:12)\r\ngyp ERR! System Darwin 13.1.0\r\ngyp ERR! command \"node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"\r\ngyp ERR! cwd /Volumes/Development HD/azuread/node_modules/restify/node_modules/dtrace-provider\r\ngyp ERR! node -v v0.10.11\r\ngyp ERR! node-gyp -v v0.10.0\r\ngyp ERR! not ok\r\nnpm WARN optional dep failed, continuing dtrace-provider@0.2.8\r\n```\r\n\r\nRestify 提供强大的机制来使用 DTrace 跟踪 REST 调用。 但是，许多操作系统不提供 DTrace。 可以安全地忽略这些错误。\r\n\r\n此命令的输出看上去应如下所示：\r\n\r\n```\r\nrestify@2.6.1 node_modules/restify\r\n+-- assert-plus@0.1.4\r\n+-- once@1.3.0\r\n+-- deep-equal@0.0.0\r\n+-- escape-regexp-component@1.0.2\r\n+-- qs@0.6.5\r\n+-- tunnel-agent@0.3.0\r\n+-- keep-alive-agent@0.0.1\r\n+-- lru-cache@2.3.1\r\n+-- node-uuid@1.4.0\r\n+-- negotiator@0.3.0\r\n+-- mime@1.2.11\r\n+-- semver@2.2.1\r\n+-- spdy@1.14.12\r\n+-- backoff@2.3.0\r\n+-- formidable@1.0.14\r\n+-- verror@1.3.6 (extsprintf@1.0.2)\r\n+-- csv@0.3.6\r\n+-- http-signature@0.10.0 (assert-plus@0.1.2, asn1@0.1.11, ctype@0.5.2)\r\n+-- bunyan@0.22.0 (mv@0.0.5)\r\n```\r\n\r\n## <a name=\"6-install-passportjs-in-to-your-web-api\"></a>6.将 Passport.js 安装到 Web API 中\r\n[Passport](http://passportjs.org/) 是 Node.js 的身份验证中间件。 Passport 极其灵活并且采用模块化结构，可以在不造成干扰的情况下放入任何基于 Express 的应用程序或 Resitify Web 应用程序。 一套综合性策略支持使用用户名和密码、Facebook、Twitter 等进行身份验证。 我们针对 Azure Active directory 开发了一个策略。 我们安装此模块，然后添加 Azure Active Directory 策略插件。\r\n\r\n在命令行中，将目录切换到 azuread 目录。\r\n\r\n输入以下命令以安装 passport.js\r\n\r\n```\r\nnpm install passport \r\n```\r\n\r\n该命令的输出应如下所示：\r\n\r\n```\r\npassport@0.1.17 node_modules\\passport\r\n+-- pause@0.0.1\r\n+-- pkginfo@0.2.3\r\n```\r\n\r\n## <a name=\"7-add-passport-azure-ad-to-your-web-api\"></a>7.将 Passport-Azure-AD 添加到 Web API\r\n接下来，我们将使用 passport-azuread 来添加 OAuth 策略，这是一套将 Azure Active Directory 连接到 Passport 的策略。 在此 Rest API 示例中，我们针对持有者令牌使用此策略。\r\n\r\n> [!NOTE]\r\n> 尽管 OAuth2 提供了可以颁发任何已知令牌类型的框架，但只有一部分令牌类型已得到广泛使用。 用于保护终结点的令牌是持有者令牌。 持有者令牌是 OAuth2 中最广泛颁发的令牌，许多实现假定持有者令牌是唯一颁发的令牌类型。\r\n> \r\n> \r\n\r\n在命令行中，将目录切换到 azuread 目录\r\n\r\n键入以下命令以安装 Passport.js passport-azure-ad 模块：\r\n\r\n```\r\nnpm install passport-azure-ad\r\n```\r\n\r\n该命令的输出应如下所示：\r\n\r\n```\r\npassport-azure-ad@1.0.0 node_modules/passport-azure-ad\r\n+-- xtend@4.0.0\r\n+-- xmldom@0.1.19\r\n+-- passport-http-bearer@1.0.1 (passport-strategy@1.0.0)\r\n+-- underscore@1.8.3\r\n+-- async@1.3.0\r\n+-- jsonwebtoken@5.0.2\r\n+-- xml-crypto@0.5.27 (xpath.js@1.0.6)\r\n+-- ursa@0.8.5 (bindings@1.2.1, nan@1.8.4)\r\n+-- jws@3.0.0 (jwa@1.0.1, base64url@1.0.4)\r\n+-- request@2.58.0 (caseless@0.10.0, aws-sign2@0.5.0, forever-agent@0.6.1, stringstream@0.0.4, tunnel-agent@0.4.1, oauth-sign@0.8.0, isstream@0.1.2, extend@2.0.1, json-stringify-safe@5.0.1, node-uuid@1.4.3, qs@3.1.0, combined-stream@1.0.5, mime-types@2.0.14, form-data@1.0.0-rc1, http-signature@0.11.0, bl@0.9.4, tough-cookie@2.0.0, hawk@2.3.1, har-validator@1.8.0)\r\n+-- xml2js@0.4.9 (sax@0.6.1, xmlbuilder@2.6.4)\r\n```\r\n\r\n## <a name=\"8-add-mongodb-modules-to-your-web-api\"></a>8.将 MongoDB 模块添加到 Web API\r\n我们将使用 MongoDB 作为数据存储。为此，我们需要安装这两个广泛使用的插件来管理名为 Mongoose 的模型和架构，以及 MongoDB 的数据库驱动程序（也称为 MongoDB）。\r\n\r\n- `npm install mongoose`\r\n\r\n## <a name=\"9--install-additional-modules\"></a>9.安装其他模块\r\n接下来，我们安装剩余的所需模块。\r\n\r\n在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r\n\r\n```\r\ncd azuread \r\n```\r\n\r\n输入以下命令，在 node_modules 目录中安装以下模块：\r\n\r\n- `npm install assert-plus`\r\n- `npm install bunyan`\r\n- `npm update`\r\n\r\n## <a name=\"10-create-a-serverjs-with-your-dependencies\"></a>10.创建包含依赖项的 server.js\r\nserver.js 文件会提供 Web API 服务器的大多数功能。 我们要将大部分代码添加到此文件。 用于生产目的，需要将功能重构为较小的文件，例如单独的路由和控制器。 在本演示中，我们为此功能使用 server.js。\r\n\r\n在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r\n\r\n```\r\ncd azuread \r\n```\r\n\r\n在偏好的编辑器中创建 `server.js` 文件，并添加以下信息：\r\n\r\n```Javascript\r\n    'use strict';\r\n\r\n    /**\r\n     * Module dependencies.\r\n     */\r\n\r\n    var fs = require('fs');\r\n    var path = require('path');\r\n    var util = require('util');\r\n    var assert = require('assert-plus');\r\n    var bunyan = require('bunyan');\r\n    var getopt = require('posix-getopt');\r\n    var mongoose = require('mongoose/');\r\n    var restify = require('restify');\r\n    var passport = require('passport');\r\n      var BearerStrategy = require('passport-azure-ad').BearerStrategy;\r\n```\r\n\r\n保存文件。 稍后我们会使用该文件。\r\n\r\n## <a name=\"11-create-a-config-file-to-store-your-azure-ad-settings\"></a>11.创建一个配置文件用于存储 Azure AD 设置\r\n\r\n此代码文件会将配置参数从 Azure Active Directory 门户传递到 Passport.js。 在本演练的第一部分中向门户添加 Web API 时，已经创建了这些配置值。 我们会解释在复制代码后，要输入其中的哪些参数值。\r\n\r\n在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r\n\r\n```\r\ncd azuread \r\n```\r\n\r\n在偏好的编辑器中创建 `config.js` 文件，并添加以下信息：\r\n\r\n```Javascript\r\n     exports.creds = {\r\n         mongoose_auth_local: 'mongodb://localhost/tasklist', // Your mongo auth uri goes here\r\n         clientID: 'your client ID',\r\n         audience: 'your application URL',\r\n        // you cannot have users from multiple tenants sign in to your server unless you use the common endpoint\r\n      // example: https://login.microsoftonline.com/common/.well-known/openid-configuration\r\n         identityMetadata: 'https://login.microsoftonline.com/<your tenant id>/.well-known/openid-configuration', \r\n         validateIssuer: true, // if you have validation on, you cannot have users from multiple tenants sign in to your server\r\n         passReqToCallback: false,\r\n         loggingLevel: 'info' // valid are 'info', 'warn', 'error'. Error always goes to stderr in Unix.\r\n\r\n     };\r\n```\r\n\r\n保存文件。 \r\n\r\n## <a name=\"12-add-configuration-to-your-serverjs-file\"></a>12.将配置添加到 server.js 文件\r\n\r\n我们需要在应用程序中，从你刚刚创建的配置文件读取这些值。 为此，我们只需在应用程序中添加 .config 文件作为所需的资源，然后将全局变量设置为 config.js 文档中的值\r\n\r\n在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r\n\r\n```\r\ncd azuread \r\n```\r\n\r\n在偏好的编辑器中打开 `server.js` 文件，并添加以下信息：\r\n\r\n```Javascript\r\nvar config = require('./config');\r\n```\r\n\r\n然后，将包含以下代码的新节添加到 `server.js` 中：\r\n\r\n```Javascript\r\n    var options = {\r\n        // The URL of the metadata document for your app. We will put the keys for token validation from the URL found in the jwks_uri tag of the in the metadata.\r\n        identityMetadata: config.creds.identityMetadata,\r\n        clientID: config.creds.clientID,\r\n        validateIssuer: config.creds.validateIssuer,\r\n        audience: config.creds.audience,\r\n        passReqToCallback: config.creds.passReqToCallback,\r\n        loggingLevel: config.creds.loggingLevel\r\n\r\n    };\r\n\r\n    // array to hold logged in users and the current logged in user (owner)\r\n    var users = [];\r\n    var owner = null;\r\n\r\n    // Our logger\r\n    var log = bunyan.createLogger({\r\n        name: 'Azure Active Directory Bearer Sample',\r\n             streams: [\r\n            {\r\n                stream: process.stderr,\r\n                level: \"error\",\r\n                name: \"error\"\r\n            }, \r\n            {\r\n                stream: process.stdout,\r\n                level: \"warn\",\r\n                name: \"console\"\r\n            }, ]\r\n    });\r\n\r\n      // if logging level specified, switch to it.\r\n      if (config.creds.loggingLevel) { log.levels(\"console\", config.creds.loggingLevel); }\r\n\r\n    // MongoDB setup\r\n    // Setup some configuration\r\n    var serverPort = process.env.PORT || 8080;\r\n    var serverURI = (process.env.PORT) ? config.creds.mongoose_auth_mongohq : config.creds.mongoose_auth_local;\r\n```\r\n\r\n保存文件。 \r\n\r\n## <a name=\"13-add-the-mongodb-model-and-schema-information-using-moongoose\"></a>13.使用 Moongoose 添加 MongoDB 模型和架构信息\r\n\r\n现在，我们已将这三个文件统一放在 REST API 服务中，接下来让我们的准备工作发挥作用。\r\n\r\n对于本演练，我们将使用 MongoDB 来存储***步骤 4*** 中所述的任务。\r\n\r\n回顾我们在***步骤 11*** 中创建的 `config.js` 文件，我们将数据库称为 `tasklist`，因为这是我们在 mogoose_auth_local 连接 URL 的末尾放置的内容。 无需事先在 MongoDB 中创建此数据库，首次运行服务器应用程序时，系统便会创建此数据库（假定它不存在）。\r\n\r\n现在，我们已告诉服务器要使用哪个 MongoDB 数据库，接下来我们需要编写一些附加的代码，以便为服务器任务创建模型和架构。\r\n\r\n#### <a name=\"discussion-of-the-model\"></a>模型介绍\r\n\r\n我们的架构模型非常简单，可以根据需要对其进行扩展。\r\n\r\nNAME - 分配到任务的用户名。 ***字符串***\r\n\r\nTASK - 任务本身。 ***字符串***\r\n\r\nDATE - 任务截止日期。 ***日期时间***\r\n\r\nCOMPLETED - 任务是否已完成。 ***布尔值***\r\n\r\n#### <a name=\"creating-the-schema-in-the-code\"></a>在代码中创建架构\r\n\r\n在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r\n\r\n```\r\ncd azuread \r\n```\r\n\r\n在偏好的编辑器中打开 `server.js` 文件，并在配置条目下面添加以下信息：\r\n\r\n```Javascript\r\n    // Connect to MongoDB\r\n    global.db = mongoose.connect(serverURI);\r\n    var Schema = mongoose.Schema;\r\n    log.info('MongoDB Schema loaded');\r\n\r\n    // Here we create a schema to store our tasks and users. Pretty simple schema for now.\r\n    var TaskSchema = new Schema({\r\n        owner: String,\r\n        task: String,\r\n        completed: Boolean,\r\n        date: Date\r\n    });\r\n\r\n    // Use the schema to register a model\r\n    mongoose.model('Task', TaskSchema);\r\n    var Task = mongoose.model('Task');\r\n```\r\n\r\n从该代码中可以看到，我们会创建架构，然后创建在定义***路由***时，将在整个代码中用于存储数据的模型对象。\r\n\r\n## <a name=\"14-add-our-routes-for-our-task-rest-api-server\"></a>14.为任务 REST API 服务器添加路由\r\n\r\n现在，我们已经创建了一个可用的数据库模型，接下来让我们添加用于 REST API 服务器的路由。\r\n\r\n### <a name=\"about-routes-in-restify\"></a>关于 Restify 中的路由\r\n\r\nRestify 中路由的工作原理，与使用 Express 堆栈时的路由工作原理完全相同。 可以使用客户端应用程序应该调用的 URI 定义路由。 通常，需要在单独的文件中定义路由。 对于本演练，我们会在 server.js 文件中定义路由。 对于生产用途，我们建议在各自的文件中定义路由。\r\n\r\nRestify 路由的典型模式是：\r\n\r\n```Javascript\r\n    function createObject(req, res, next) {\r\n\r\n    // do work on Object\r\n\r\n     _object.name = req.params.object; // passed value is in req.params under object\r\n\r\n     ///...\r\n\r\n    return next(); // keep the server going\r\n    }\r\n\r\n    ....\r\n\r\n    server.post('/service/:add/:object', createObject); // calls createObject on routes that match this.\r\n```\r\n\r\n这是最基本级别的模式。 Resitfy（和 Express）提供更深层的功能，例如，定义应用程序类型，以及跨不同的终结点执行复杂路由。 对于本演练，我们会保持这些路由的简炼性。\r\n\r\n### <a name=\"1-add-default-routes-to-our-server\"></a>1.将默认路由添加到服务器\r\n\r\n现在，我们添加 Create、Retrieve、Update 和 Delete 的基本 CRUD 路由。\r\n\r\n在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r\n\r\n```\r\ncd azuread \r\n```\r\n\r\n在偏好的编辑器中打开 `server.js` 文件，并在前面创建的数据库条目下面添加以下信息：\r\n\r\n```Javascript\r\n    /**\r\n     *\r\n     * APIs for our REST Task server\r\n     */\r\n\r\n    // Create a task\r\n\r\n    function createTask(req, res, next) {\r\n\r\n        // Resitify currently has a bug which doesn't allow you to set default headers\r\n        // This headers comply with CORS and allow us to mongodbServer our response to any origin\r\n\r\n        res.header(\"Access-Control-Allow-Origin\", \"*\");\r\n        res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\r\n\r\n        // Create a new task model, fill it up and save it to Mongodb\r\n        var _task = new Task();\r\n\r\n        if (!req.params.task) {\r\n            req.log.warn('createTodo: missing task');\r\n            next(new MissingTaskError());\r\n            return;\r\n        }\r\n\r\n        _task.owner = owner;\r\n        _task.task = req.params.task;\r\n        _task.date = new Date();\r\n\r\n        _task.save(function(err) {\r\n            if (err) {\r\n                req.log.warn(err, 'createTask: unable to save');\r\n                next(err);\r\n            } else {\r\n                res.send(201, _task);\r\n\r\n            }\r\n        });\r\n\r\n        return next();\r\n\r\n    }\r\n\r\n    // Delete a task by name\r\n\r\n    function removeTask(req, res, next) {\r\n\r\n        Task.remove({\r\n            task: req.params.task,\r\n            owner: owner\r\n        }, function(err) {\r\n            if (err) {\r\n                req.log.warn(err,\r\n                    'removeTask: unable to delete %s',\r\n                    req.params.task);\r\n                next(err);\r\n            } else {\r\n                log.info('Deleted task:', req.params.task);\r\n                res.send(204);\r\n                next();\r\n            }\r\n        });\r\n    }\r\n\r\n    // Delete all tasks\r\n\r\n    function removeAll(req, res, next) {\r\n        Task.remove();\r\n        res.send(204);\r\n        return next();\r\n    }\r\n\r\n    // Get a specific task based on name\r\n\r\n    function getTask(req, res, next) {\r\n\r\n        log.info('getTask was called for: ', owner);\r\n        Task.find({\r\n            owner: owner\r\n        }, function(err, data) {\r\n            if (err) {\r\n                req.log.warn(err, 'get: unable to read %s', owner);\r\n                next(err);\r\n                return;\r\n            }\r\n\r\n            res.json(data);\r\n        });\r\n\r\n        return next();\r\n    }\r\n\r\n    /// Simple returns the list of TODOs that were loaded.\r\n\r\n    function listTasks(req, res, next) {\r\n        // Resitify currently has a bug which doesn't allow you to set default headers\r\n        // This headers comply with CORS and allow us to mongodbServer our response to any origin\r\n\r\n        res.header(\"Access-Control-Allow-Origin\", \"*\");\r\n        res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\r\n\r\n        log.info(\"listTasks was called for: \", owner);\r\n\r\n        Task.find({\r\n            owner: owner\r\n        }).limit(20).sort('date').exec(function(err, data) {\r\n\r\n            if (err) {\r\n                return next(err);\r\n            }\r\n\r\n            if (data.length > 0) {\r\n                log.info(data);\r\n            }\r\n\r\n            if (!data.length) {\r\n                log.warn(err, \"There is no tasks in the database. Did you initalize the database as stated in the README?\");\r\n            }\r\n\r\n            if (!owner) {\r\n                log.warn(err, \"You did not pass an owner when listing tasks.\");\r\n            } else {\r\n\r\n                res.json(data);\r\n\r\n            }\r\n        });\r\n\r\n        return next();\r\n    }\r\n```\r\n\r\n### <a name=\"2-next-lets-add-some-error-handling-in-our-apis\"></a>2.接下来，让我们在 API 中添加一些错误处理方式：\r\n\r\n```\r\n    ///--- Errors for communicating something interesting back to the client\r\n\r\n    function MissingTaskError() {\r\n        restify.RestError.call(this, {\r\n            statusCode: 409,\r\n            restCode: 'MissingTask',\r\n            message: '\"task\" is a required parameter',\r\n            constructorOpt: MissingTaskError\r\n        });\r\n\r\n        this.name = 'MissingTaskError';\r\n    }\r\n    util.inherits(MissingTaskError, restify.RestError);\r\n\r\n    function TaskExistsError(owner) {\r\n        assert.string(owner, 'owner');\r\n\r\n        restify.RestError.call(this, {\r\n            statusCode: 409,\r\n            restCode: 'TaskExists',\r\n            message: owner + ' already exists',\r\n            constructorOpt: TaskExistsError\r\n        });\r\n\r\n        this.name = 'TaskExistsError';\r\n    }\r\n    util.inherits(TaskExistsError, restify.RestError);\r\n\r\n    function TaskNotFoundError(owner) {\r\n        assert.string(owner, 'owner');\r\n\r\n        restify.RestError.call(this, {\r\n            statusCode: 404,\r\n            restCode: 'TaskNotFound',\r\n            message: owner + ' was not found',\r\n            constructorOpt: TaskNotFoundError\r\n        });\r\n\r\n        this.name = 'TaskNotFoundError';\r\n    }\r\n\r\n    util.inherits(TaskNotFoundError, restify.RestError);\r\n```\r\n\r\n## <a name=\"15-create-your-server\"></a>15.创建服务器！\r\n我们已经定义了数据库和路由，最后一件事就是添加用于管理调用的服务器实例。\r\n\r\nRestify（和 Express）允许对 REST API 服务器执行大量的深度自定义，但同样，本演练将使用最基本的设置。\r\n\r\n```Javascript\r\n    /**\r\n     * Our Server\r\n     */\r\n\r\n    var server = restify.createServer({\r\n        name: \"Azure Active Directroy TODO Server\",\r\n        version: \"2.0.1\"\r\n    });\r\n\r\n    // Ensure we don't drop data on uploads\r\n    server.pre(restify.pre.pause());\r\n\r\n    // Clean up sloppy paths like //todo//////1//\r\n    server.pre(restify.pre.sanitizePath());\r\n\r\n    // Handles annoying user agents (curl)\r\n    server.pre(restify.pre.userAgentConnection());\r\n\r\n    // Set a per request bunyan logger (with requestid filled in)\r\n    server.use(restify.requestLogger());\r\n\r\n    // Allow 5 requests/second by IP, and burst to 10\r\n    server.use(restify.throttle({\r\n        burst: 10,\r\n        rate: 5,\r\n        ip: true,\r\n    }));\r\n\r\n    // Use the common stuff you probably want\r\n    server.use(restify.acceptParser(server.acceptable));\r\n    server.use(restify.dateParser());\r\n    server.use(restify.queryParser());\r\n    server.use(restify.gzipResponse());\r\n    server.use(restify.bodyParser({\r\n        mapParams: true\r\n    })); // Allows for JSON mapping to REST\r\n```\r\n\r\n## <a name=\"16-adding-the-routes-to-the-server-without-authentication-for-now\"></a>16.将路由添加到服务器（目前不包括身份验证）\r\n\r\n```Javascript\r\n    /// Now the real handlers. Here we just CRUD\r\n    /**\r\n    /*\r\n    /* Each of these handlers are protected by our OIDCBearerStrategy by invoking 'oidc-bearer'\r\n    /* in the pasport.authenticate() method. We set 'session: false' as REST is stateless and\r\n    /* we don't need to maintain session state. You can experiement removing API protection\r\n    /* by removing the passport.authenticate() method like so:\r\n    /*\r\n    /* server.get('/tasks', listTasks);\r\n    /*\r\n    **/\r\n    server.get('/tasks', listTasks);\r\n    server.get('/tasks', listTasks);\r\n    server.get('/tasks/:owner', getTask);\r\n    server.head('/tasks/:owner', getTask);\r\n    server.post('/tasks/:owner/:task', createTask);\r\n    server.post('/tasks', createTask);\r\n    server.del('/tasks/:owner/:task', removeTask);\r\n    server.del('/tasks/:owner', removeTask);\r\n    server.del('/tasks', removeTask);\r\n    server.del('/tasks', removeAll, function respond(req, res, next) {\r\n    res.send(204);\r\n    next();\r\n    });\r\n    // Register a default '/' handler\r\n    server.get('/', function root(req, res, next) {\r\n    var routes = [\r\n    'GET /',\r\n    'POST /tasks/:owner/:task',\r\n    'POST /tasks (for JSON body)',\r\n    'GET /tasks',\r\n    'PUT /tasks/:owner',\r\n    'GET /tasks/:owner',\r\n    'DELETE /tasks/:owner/:task'\r\n    ];\r\n    res.send(200, routes);\r\n    next();\r\n    });\r\n    server.listen(serverPort, function() {\r\n    var consoleMessage = '\\n Azure Active Directory Tutorial';\r\n    consoleMessage += '\\n +++++++++++++++++++++++++++++++++++++++++++++++++++++';\r\n    consoleMessage += '\\n %s server is listening at %s';\r\n    consoleMessage += '\\n Open your browser to %s/tasks\\n';\r\n    consoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n';\r\n    consoleMessage += '\\n !!! why not try a $curl -isS %s | json to get some ideas? \\n';\r\n    consoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n\\n';\r\n    });\r\n```\r\n\r\n## <a name=\"17-before-we-add-oauth-support-lets-run-the-server\"></a>17.在添加 OAuth 支持之前，让我们先运行服务器。\r\n添加身份验证之前，请先测试服务器\r\n\r\n最简单的检查方法是在命令行中使用 curl。 在这样做之前，我们需要一个用于分析 JSON 输出的简单实用工具。 为此，请安装 json 工具，因为下面的所有示例都要使用该工具。\r\n\r\n```\r\n$npm install -g jsontool \r\n```\r\n\r\n这会全局安装 JSON 工具。 现在，我们已安装了工具，让我们试运行服务器：\r\n\r\n首先，请确保 monogoDB 实例正在运行。\r\n\r\n```\r\n$sudo mongod \r\n```\r\n\r\n然后，切换到目录并开始运行。\r\n\r\n```\r\n$ cd azuread \r\n$ node server.js \r\n\r\n$ curl -isS http://127.0.0.1:8080 | json \r\n```\r\n\r\n```Shell\r\n    HTTP/1.1 200 OK\r\n    Connection: close\r\n    Content-Type: application/json\r\n    Content-Length: 171\r\n    Date: Tue, 14 Jul 2015 05:43:38 GMT\r\n    [\r\n    \"GET /\",\r\n    \"POST /tasks/:owner/:task\",\r\n    \"POST /tasks (for JSON body)\",\r\n    \"GET /tasks\",\r\n    \"PUT /tasks/:owner\",\r\n    \"GET /tasks/:owner\",\r\n    \"DELETE /tasks/:owner/:task\"\r\n    ]\r\n```\r\n\r\n然后，我们按如下所示添加一个任务：\r\n\r\n```\r\n$ curl -isS -X POST http://127.0.0.1:8080/tasks/brandon/Hello \r\n```\r\n\r\n响应应为：\r\n\r\n```Shell\r\n    HTTP/1.1 201 Created\r\n    Connection: close\r\n    Access-Control-Allow-Origin: *\r\n    Access-Control-Allow-Headers: X-Requested-With\r\n    Content-Type: application/x-www-form-urlencoded\r\n    Content-Length: 5\r\n    Date: Tue, 04 Feb 2014 01:02:26 GMT\r\n    Hello\r\n```\r\n\r\n我们可以按如下所示列出 Brandon 的任务：\r\n\r\n```\r\n$ curl -isS http://127.0.0.1:8080/tasks/brandon/ \r\n```\r\n\r\n如果一切正常，我们可以将 OAuth 添加到 REST API 服务器。\r\n\r\n**已有一台装有 MongoDB 的 REST API 服务器！**\r\n\r\n## <a name=\"18-add-authentication-to-our-rest-api-server\"></a>18.将身份验证添加到 REST API 服务器\r\n现在，我们已经运行了 REST API（顺便祝贺你！），接下来，让我们在 Azure AD 中利用它。\r\n\r\n在命令行中，将目录切换到 **azuread** 文件夹（如果尚未进入）：\r\n\r\n```\r\ncd azuread \r\n```\r\n\r\n### <a name=\"1-use-the-oidcbearerstrategy-that-is-included-with-passport-azure-ad\"></a>1：使用 passport-azure-ad 随附的 OIDCBearerStrategy\r\n到目前为止，我们已构建一个典型的 REST TODO 服务器，其中不包含任何授权种类。 这是我们将其结合在一起的起点。\r\n\r\n首先，需指出要使用 Passport。 在其他服务器配置之后紧接着执行此操作：\r\n\r\n```Javascript\r\n    // Let's start using Passport.js\r\n\r\n    server.use(passport.initialize()); // Starts passport\r\n    server.use(passport.session()); // Provides session support\r\n```\r\n\r\n> [!TIP]\r\n> 编写 API 时，应始终将数据链接到令牌中用户无法欺骗的独特内容。 此服务器在存储 TODO 项目时，会根据我们放在“所有者”字段的令牌中的用户对象 ID（通过 token.oid 调用）来存储。 这可确保只有该用户可以访问其 TODO，其他任何人都不可以访问输入的 TODO。 API 中不公开“所有者”信息，因此，外部用户可以请求其他人的 TODO，即使它们已经过身份验证也一样。\r\n> \r\n> \r\n\r\n接下来，我们使用 passport-azure-ad 随附的 Bearer 策略。 先看看下面的代码，稍后我会进行解释。 将此代码放在上面粘贴的内容后面：\r\n\r\n```Javascript\r\n    /**\r\n    /*\r\n    /* Calling the OIDCBearerStrategy and managing users\r\n    /*\r\n    /* Passport pattern provides the need to manage users and info tokens\r\n    /* with a FindorCreate() method that must be provided by the implementor.\r\n    /* Here we just autoregister any user and implement a FindById().\r\n    /* You'll want to do something smarter.\r\n    **/\r\n\r\n    var findById = function(id, fn) {\r\n        for (var i = 0, len = users.length; i < len; i++) {\r\n            var user = users[i];\r\n            if (user.sub === id) {\r\n                log.info('Found user: ', user);\r\n                return fn(null, user);\r\n            }\r\n        }\r\n        return fn(null, null);\r\n    };\r\n\r\n    var bearerStrategy = new BearerStrategy(options,\r\n        function(token, done) {\r\n            log.info('verifying the user');\r\n            log.info(token, 'was the token retreived');\r\n            findById(token.sub, function(err, user) {\r\n                if (err) {\r\n                    return done(err);\r\n                }\r\n                if (!user) {\r\n                    // \"Auto-registration\"\r\n                    log.info('User was added automatically as they were new. Their sub is: ', token.sub);\r\n                    users.push(token);\r\n                    owner = token.sub;\r\n                    return done(null, token);\r\n                }\r\n                owner = token.sub;\r\n                return done(null, user, token);\r\n            });\r\n        }\r\n    );\r\n\r\n    passport.use(bearerStrategy);\r\n```\r\n\r\nPassport 对其所有策略（Twitter、Facebook 等）都使用相似的模式，所有策略写入器都遵循该模式。 查看该策略可以发现，我们已将它作为函数来传递，其中包含一个令牌和一个用作参数的 done。 策略完成所有工作之后，便尽责地返回。 完成后，需要存储用户并储藏令牌，以免再次请求它。\r\n\r\n> [!IMPORTANT]\r\n> 上述代码使用了正好地服务器上进行身份验证的任何用户。 这就是所谓的自动注册。 在生产服务器中，所有人都必须先完成已确定的注册过程。 这通常是在使用者应用中看到的模式，可让向 Facebook 注册，但接着请求填写其他信息。 如果这不是命令行程序，我们本可以从返回的令牌对象中提取电子邮件，然后请求使用者填写其他信息。 由于这是测试服务器，因此，我们直接将它们加入到内存中的数据库。\r\n> \r\n> \r\n\r\n### <a name=\"2-finally-protect-some-endpoints\"></a>2.最后保护一些终结点\r\n\r\n通过结合要使用的协议指定 `passport.authenticate()` 调用来保护终结点。\r\n\r\n让我们在服务器代码中编辑路由，做一些更有趣的事情：\r\n\r\n```Javascript\r\n    server.get('/tasks', passport.authenticate('oauth-bearer', {\r\n    session: false\r\n    }), listTasks);\r\n    server.get('/tasks', passport.authenticate('oauth-bearer', {\r\n    session: false\r\n    }), listTasks);\r\n    server.get('/tasks/:owner', passport.authenticate('oauth-bearer', {\r\n    session: false\r\n    }), getTask);\r\n    server.head('/tasks/:owner', passport.authenticate('oauth-bearer', {\r\n    session: false\r\n    }), getTask);\r\n    server.post('/tasks/:owner/:task', passport.authenticate('oauth-bearer', {\r\n    session: false\r\n    }), createTask);\r\n    server.post('/tasks', passport.authenticate('oauth-bearer', {\r\n    session: false\r\n    }), createTask);\r\n    server.del('/tasks/:owner/:task', passport.authenticate('oauth-bearer', {\r\n    session: false\r\n    }), removeTask);\r\n    server.del('/tasks/:owner', passport.authenticate('oauth-bearer', {\r\n    session: false\r\n    }), removeTask);\r\n    server.del('/tasks', passport.authenticate('oauth-bearer', {\r\n    session: false\r\n    }), removeTask);\r\n    server.del('/tasks', passport.authenticate('oauth-bearer', {\r\n    session: false\r\n    }), removeAll, function respond(req, res, next) {\r\n    res.send(204);\r\n    next();\r\n    });\r\n```\r\n\r\n## <a name=\"19-run-your-server-application-again-and-ensure-it-rejects-you\"></a>19.再次运行服务器应用程序并确保它拒绝你\r\n再次使用 `curl` 来查看是否针对终结点提供了 OAuth2 保护。 应该在针对此终结点运行任何客户端 SDK 之前执行此操作。 返回的标头足以说明一切正常运作。\r\n\r\n首先，请确保 monogoDB 实例正在运行：\r\n\r\n```\r\n$sudo mongod\r\n```\r\n\r\n然后，切换到目录并开始运行。\r\n\r\n```\r\n$ cd azuread\r\n$ node server.js\r\n```\r\n\r\n试用基本 POST：\r\n\r\n```\r\n$ curl -isS -X POST http://127.0.0.1:8080/tasks/brandon/Hello \r\n```\r\n\r\n```Shell\r\n    HTTP/1.1 401 Unauthorized\r\n    Connection: close\r\n    WWW-Authenticate: Bearer realm=\"Users\"\r\n    Date: Tue, 14 Jul 2015 05:45:03 GMT\r\n    Transfer-Encoding: chunked\r\n```\r\n\r\n401 在这里是正常的响应，表明 Passport 层正在尝试重定向到授权终结点，这正是你所希望的。\r\n\r\n## <a name=\"congratulations-you-have-a-rest-api-service-using-oauth2\"></a>祝贺！ 已经创建了一个使用 OAuth2 的 REST API 服务！\r\n\r\n这就是在不使用 OAuth2 兼容客户端的情况下，此服务器能够带来的最大优势。 需要学习其他演练。\r\n\r\n如果只要想要了解如何使用 Restify 和 OAuth2 实现 REST API，此示例中的代码足以帮助你学习开发和生成服务。\r\n\r\n如果对 ADAL 学习历程中的后续步骤感兴趣，我们建议了解下面这些支持的 ADAL 客户端：\r\n\r\n只需将这些代码克隆到开发人员计算机，并根据演练中所述进行配置。\r\n\r\n[ADAL for iOS](https://github.com/MSOpenTech/azure-activedirectory-library-for-ios)\r\n\r\n[ADAL for Android](https://github.com/MSOpenTech/azure-activedirectory-library-for-android)\r\n\r\n[!INCLUDE [active-directory-devquickstarts-additional-resources](../../../includes/active-directory-devquickstarts-additional-resources.md)]\r\n\r\n<!--Update_Description: update meta properties --> \r\n"}