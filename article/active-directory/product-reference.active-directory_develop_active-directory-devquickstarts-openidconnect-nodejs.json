{"Title":"开始使用 node.js 进行 Azure AD 登录和注销","Description":"如何生成一个与 Azure AD 集成以方便登录的 node.js Express MVC Web 应用。","Content":"\r\n# 使用 Azure AD 执行 NodeJS Web 应用登录和注销\r\n我们将在此处使用 Passport 来执行以下操作：\r\n\r\n- 使用 Azure AD 将用户登录到应用。\r\n- 显示有关用户的一些信息。\r\n- 从应用中注销用户。\r\n\r\n**Passport** 是 Node.js 的身份验证中间件。Passport 极其灵活并且采用模块化结构，可以在不造成干扰的情况下放入任何基于 Express 的应用程序或 Resitify Web 应用程序。一套综合性策略支持使用用户名和密码、Facebook、Twitter 等进行身份验证。我们针对 Azure Active directory 开发了一项策略。我们将安装此模块，然后添加 Azure Active Directory `passport-azure-ad` 插件。\r\n\r\n为此，你需要：\r\n\r\n1. 注册应用。\r\n2. 将应用设置为使用 Passport-azure-ad 策略。\r\n3. 使用 Passport 向 Azure AD 发出登录和注销请求。\r\n4. 列显有关用户的数据。\r\n\r\n本教程的代码[在 GitHub 上](https://github.com/AzureADQuickStarts/WebApp-OpenIDConnect-NodeJS)维护。若要遵照该代码，你可以[下载 .zip 格式应用骨架](https://github.com/AzureADQuickStarts/WebApp-OpenIDConnect-NodeJS/archive/skeleton.zip)，或克隆该骨架：\r\n\r\n```\r\ngit clone --branch skeleton https://github.com/AzureADQuickStarts/WebApp-OpenIDConnect-NodeJS.git\r\n```\r\n\r\n本教程末尾也提供完成的应用程序。\r\n\r\n## 1\\.注册应用\r\n- 登录到 Azure 管理门户。\r\n- 在左侧的导航栏中单击“Active Directory”。\r\n- 选择你要在其中注册应用程序的租户。\r\n- 单击“应用程序”选项卡，然后在底部抽屉中单击“添加”。\r\n- 根据提示创建一个新的 **Web 应用程序和/或 WebAPI**。\r\n    - 应用程序的**名称**向最终用户描述你的应用程序\r\n    - “登录 URL”是应用程序的基本 URL。框架的默认值为 http://localhost:3000/auth/openid/return``。\r\n    - “应用程序 ID URI”是应用程序的唯一标识符。约定是使用 `https://<tenant-domain>/<app-name>`，例如 `https://contoso.partner.onmschina.cn/my-first-aad-app`\r\n- 完成注册后，AAD 将为应用分配唯一的客户端标识符。在后面的部分中将会用到此值，因此，请从“配置”选项卡复制此值。\r\n\r\n## 2\\.将先决条件添加到目录\r\n在命令行中，将目录切换到根文件夹（如果尚未这样做），然后运行以下命令：\r\n\r\n- `npm install express`\r\n- `npm install ejs`\r\n- `npm install ejs-locals`\r\n- `npm install restify`\r\n- `npm install mongoose`\r\n- `npm install bunyan`\r\n- `npm install assert-plus`\r\n- `npm install passport`\r\n- 此外，你还需要我们的 `passport-azure-ad`：\r\n- `npm install passport-azure-ad`\r\n\r\n这将会安装 passport-azure-ad 所依赖的库。\r\n\r\n## 3\\.将应用设置为使用 passport-node-js 策略\r\n在这里，我们要将 Express 中间件配置为使用 OpenID Connect 身份验证协议。Passport 将用于发出登录和注销请求、管理用户的会话、获取有关用户的信息，等等。\r\n\r\n- 首先，打开位于项目根目录中的 `config.js` 文件，并在 `exports.creds` 节中输入应用的配置值。\r\n\r\n  - `clientID:` 是在注册门户中为应用分配的**应用程序 ID**。\r\n  - `returnURL` 是在门户中输入的**重定向 URI**。\r\n  - `clientSecret` 是在门户中生成的密码。\r\n- 接下来，打开项目根目录中的 `app.js` 文件，并添加以下调用以调用 `passport-azure-ad` 随附的 `OIDCStrategy` 策略\r\n\r\n    ```JavaScript\r\n    var OIDCStrategy = require('passport-azure-ad').OIDCStrategy;\r\n\r\n    // add a logger\r\n\r\n    var log = bunyan.createLogger({\r\n        name: 'Microsoft OIDC Example Web Application'\r\n    });\r\n    ```\r\n\r\n- 然后，使用我们刚刚提到的策略来处理登录请求\r\n\r\n    ```JavaScript\r\n    // Use the OIDCStrategy within Passport. (Section 2) \r\n    // \r\n    //   Strategies in passport require a `validate` function, which accept\r\n    //   credentials (in this case, an OpenID identifier), and invoke a callback\r\n    //   with a user object.\r\n    passport.use(new OIDCStrategy({\r\n        callbackURL: config.creds.returnURL,\r\n        realm: config.creds.realm,\r\n        clientID: config.creds.clientID,\r\n        clientSecret: config.creds.clientSecret,\r\n        oidcIssuer: config.creds.issuer,\r\n        identityMetadata: config.creds.identityMetadata,\r\n        skipUserProfile: config.creds.skipUserProfile,\r\n        responseType: config.creds.responseType,\r\n        responseMode: config.creds.responseMode\r\n      },\r\n      function(iss, sub, profile, accessToken, refreshToken, done) {\r\n        if (!profile.email) {\r\n          return done(new Error(\"No email found\"), null);\r\n        }\r\n        // asynchronous verification, for effect...\r\n        process.nextTick(function () {\r\n          findByEmail(profile.email, function(err, user) {\r\n            if (err) {\r\n              return done(err);\r\n            }\r\n            if (!user) {\r\n              // \"Auto-registration\"\r\n              users.push(profile);\r\n              return done(null, profile);\r\n            }\r\n            return done(null, user);\r\n          });\r\n        });\r\n      }\r\n    ));\r\n    ```\r\n\r\n    Passport 对其所有策略（Twitter、Facebook 等）都使用所有策略写入器都依循的类似模式。查看该策略，你会发现，我们已将它作为 function() 来传递，其中包含一个令牌和一个用作参数的 done。策略完成所有工作之后，将按计划返回。然后，我们需要存储用户和令牌，因此不需要再次请求。\r\n\r\n    > [!IMPORTANT]\r\n    > 上述代码接受正好向服务器进行身份验证的任何用户。这便是自动注册。在生产服务器中，你希望所有人都必须先经历你确定的注册过程。这通常是在使用者应用中看到的模式，允许注册 Facebook，但接着请求填写其他信息。如果这不是示例应用程序，我们就只能从返回的令牌对象中提取电子邮件，然后请求他们填写其他信息。由于这是测试服务器，我们直接将它们加入到内存中的数据库。\r\n    > \r\n    > \r\n\r\n- 接下来，让我们添加方法，以便根据 Passport 的要求，持续跟踪已登录的用户。这包括将用户信息序列化和反序列化：\r\n\r\n    ```JavaScript\r\n    // Passport session setup. (Section 2)\r\n\r\n    //   To support persistent login sessions, Passport needs to be able to\r\n    //   serialize users into and deserialize users out of the session.  Typically,\r\n    //   this will be as simple as storing the user ID when serializing, and finding\r\n    //   the user by ID when deserializing.\r\n    passport.serializeUser(function(user, done) {\r\n      done(null, user.email);\r\n    });\r\n\r\n    passport.deserializeUser(function(id, done) {\r\n      findByEmail(id, function (err, user) {\r\n        done(err, user);\r\n      });\r\n    });\r\n\r\n    // array to hold logged in users\r\n    var users = [];\r\n\r\n    var findByEmail = function(email, fn) {\r\n      for (var i = 0, len = users.length; i < len; i++) {\r\n        var user = users[i];\r\n       log.info('we are using user: ', user);\r\n        if (user.email === email) {\r\n          return fn(null, user);\r\n        }\r\n      }\r\n      return fn(null, null);\r\n    };\r\n    ```\r\n\r\n- 接下来，让我们添加可加载 Express 引擎的代码。在此处，你将看到我们使用了 Express 提供的默认 /views 和 /routes 模式。\r\n\r\n    ```JavaScript\r\n    // configure Express (Section 2)\r\n\r\n    var app = express();\r\n\r\n    app.configure(function() {\r\n      app.set('views', __dirname + '/views');\r\n      app.set('view engine', 'ejs');\r\n      app.use(express.logger());\r\n      app.use(express.methodOverride());\r\n      app.use(cookieParser());\r\n      app.use(expressSession({ secret: 'keyboard cat', resave: true, saveUninitialized: false }));\r\n      app.use(bodyParser.urlencoded({ extended : true }));\r\n      // Initialize Passport!  Also use passport.session() middleware, to support\r\n      // persistent login sessions (recommended).\r\n      app.use(passport.initialize());\r\n      app.use(passport.session());\r\n      app.use(app.router);\r\n      app.use(express.static(__dirname + '/../../public'));\r\n    });\r\n    ```\r\n\r\n- 最后，让我们添加路由，以便将实际的登录请求递交到 `passport-azure-ad` 引擎：\r\n\r\n    ```JavaScript\r\n    // Our Auth routes (Section 3)\r\n\r\n    // GET /auth/openid\r\n    //   Use passport.authenticate() as route middleware to authenticate the\r\n    //   request.  The first step in OpenID authentication will involve redirecting\r\n    //   the user to their OpenID provider.  After authenticating, the OpenID\r\n    //   provider will redirect the user back to this application at\r\n    //   /auth/openid/return\r\n    app.get('/auth/openid',\r\n      passport.authenticate('azuread-openidconnect', { failureRedirect: '/login' }),\r\n      function(req, res) {\r\n        log.info('Authentication was called in the Sample');\r\n        res.redirect('/');\r\n      });\r\n\r\n    // GET /auth/openid/return\r\n    //   Use passport.authenticate() as route middleware to authenticate the\r\n    //   request.  If authentication fails, the user will be redirected back to the\r\n    //   login page.  Otherwise, the primary route function function will be called,\r\n    //   which, in this example, will redirect the user to the home page.\r\n    app.get('/auth/openid/return',\r\n      passport.authenticate('azuread-openidconnect', { failureRedirect: '/login' }),\r\n      function(req, res) {\r\n        log.info('We received a return from AzureAD.');\r\n        res.redirect('/');\r\n      });\r\n\r\n    // POST /auth/openid/return\r\n    //   Use passport.authenticate() as route middleware to authenticate the\r\n    //   request.  If authentication fails, the user will be redirected back to the\r\n    //   login page.  Otherwise, the primary route function function will be called,\r\n    //   which, in this example, will redirect the user to the home page.\r\n    app.post('/auth/openid/return',\r\n      passport.authenticate('azuread-openidconnect', { failureRedirect: '/login' }),\r\n      function(req, res) {\r\n        log.info('We received a return from AzureAD.');\r\n        res.redirect('/');\r\n      });\r\n    ```\r\n\r\n## 4\\.使用 Passport 向 Azure AD 发出登录和注销请求\r\n\r\n现在，应用已正确配置为使用 OpenID Connect 身份验证协议与 v2.0 终结点通信。`passport-azure-ad` 会代你处理有关创建身份验证消息、验证 Azure AD 提供的令牌以及保留用户会话的繁琐细节。你要做的就是为用户提供登录和注销方式，以及收集有关已登录用户的其他信息。\r\n\r\n- 首先，让我们在 `app.js` 文件中添加 default、login、account 和 logout 方法：\r\n\r\n    ```JavaScript\r\n    //Routes (Section 4)\r\n\r\n    app.get('/', function(req, res){\r\n      res.render('index', { user: req.user });\r\n    });\r\n\r\n    app.get('/account', ensureAuthenticated, function(req, res){\r\n      res.render('account', { user: req.user });\r\n    });\r\n\r\n    app.get('/login',\r\n      passport.authenticate('azuread-openidconnect', { failureRedirect: '/login' }),\r\n      function(req, res) {\r\n        log.info('Login was called in the Sample');\r\n        res.redirect('/');\r\n    });\r\n\r\n    app.get('/logout', function(req, res){\r\n      req.logout();\r\n      res.redirect('/');\r\n    });\r\n    ```\r\n\r\n- 我们详细探讨一下：\r\n\r\n  - `/` 路由将重定向到 index.ejs 视图，并在请求中传递用户（如果存在）\r\n  - `/account` 路由首先***确保我们已经过身份验证***（下面我们将会实现），然后在请求中传递用户，以便我们可以获取有关该用户的其他信息。\r\n  - `/login` 路由将从 `passport-azuread` 调用 azuread-openidconnect 验证器，如果该操作不成功，则将用户重定向回到 /login\r\n  - `/logout` 只是调用 logout.ejs（和路由），以便清除 Cookie 并将用户返回到 index.ejs\r\n- 对于 `app.js` 的最后一个部分，让我们添加上述 `/account` 中使用的 EnsureAuthenticated 方法。\r\n\r\n    ```JavaScript\r\n    // Simple route middleware to ensure user is authenticated. (Section 4)\r\n\r\n    //   Use this route middleware on any resource that needs to be protected.  If\r\n    //   the request is authenticated (typically via a persistent login session),\r\n    //   the request will proceed.  Otherwise, the user will be redirected to the\r\n    //   login page.\r\n    function ensureAuthenticated(req, res, next) {\r\n      if (req.isAuthenticated()) { return next(); }\r\n      res.redirect('/login')\r\n    }\r\n    ```\r\n\r\n- 最后，在 `app.js` 中实际创建服务器本身：\r\n\r\n    ```JavaScript\r\n    app.listen(3000);\r\n    ```\r\n\r\n## 5\\.在 Express 中创建视图与路由，以在网站中显示用户\r\n我们已完成 `app.js`。现在只需添加路由和视图即可，两者将向用户显示我们获取的信息，并处理我们创建的 `/logout` 和 `/login` 路由。\r\n\r\n- 在根目录下创建 `/routes/index.js` 路由。\r\n\r\n    ```JavaScript\r\n    /*\r\n     * GET home page.\r\n     */\r\n\r\n    exports.index = function(req, res){\r\n      res.render('index', { title: 'Express' });\r\n    };\r\n    ```\r\n\r\n- 在根目录下创建 `/routes/user.js` 路由\r\n\r\n    ```JavaScript\r\n    /*\r\n     * GET users listing.\r\n     */\r\n\r\n    exports.list = function(req, res){\r\n      res.send(\"respond with a resource\");\r\n    };\r\n    ```\r\n\r\n    这些简单路由只将请求传递到我们的视图，包括用户（如果存在）。\r\n\r\n- 在根目录下创建 `/views/index.ejs` 视图。这是一个简单的页面，将调用我们的登录和注销方法，并允许我们捕获帐户信息。请注意，如果在请求中传递的用户证明我们拥有已登录的用户，就能使用条件性 `if (!user)`。\r\n\r\n    ```JavaScript\r\n    <% if (!user) { %>\r\n        <h2>Welcome! Please log in.</h2>\r\n        <a href=\"/login\">Log In</a>\r\n    <% } else { %>\r\n        <h2>Hello, <%= user.displayName %>.</h2>\r\n        <a href=\"/account\">Account Info</a></br>\r\n        <a href=\"/logout\">Log Out</a>\r\n    <% } %>\r\n    ```\r\n\r\n- 在根目录下创建 `/views/account.ejs` 视图，以便能够查看 `passport-azuread` 放置在用户请求中的其他信息。\r\n\r\n    ```Javascript\r\n    <% if (!user) { %>\r\n        <h2>Welcome! Please log in.</h2>\r\n        <a href=\"/login\">Log In</a>\r\n    <% } else { %>\r\n    <p>displayName: <%= user.displayName %></p>\r\n    <p>givenName: <%= user.name.givenName %></p>\r\n    <p>familyName: <%= user.name.familyName %></p>\r\n    <p>UPN: <%= user._json.upn %></p>\r\n    <p>Profile ID: <%= user.id %></p>\r\n    <p>Full Claimes</p>\r\n    <%- JSON.stringify(user) %>\r\n    <p></p>\r\n    <a href=\"/logout\">Log Out</a>\r\n    <% } %>\r\n    ```\r\n\r\n- 最后，可以通过添加布局，使视图变得美观。在根目录下创建 '/views/layout.ejs' 视图\r\n\r\n    ```HTML\r\n    <!DOCTYPE html>\r\n    <html>\r\n        <head>\r\n            <title>Passport-OpenID Example</title>\r\n        </head>\r\n        <body>\r\n            <% if (!user) { %>\r\n                <p>\r\n                <a href=\"/\">Home</a> | \r\n                <a href=\"/login\">Log In</a>\r\n                </p>\r\n            <% } else { %>\r\n                <p>\r\n                <a href=\"/\">Home</a> | \r\n                <a href=\"/account\">Account</a> | \r\n                <a href=\"/logout\">Log Out</a>\r\n                </p>\r\n            <% } %>\r\n            <%- body %>\r\n        </body>\r\n    </html>\r\n    ```\r\n\r\n最后，生成并运行应用！\r\n\r\n运行 `node app.js` 并导航到 `http://localhost:3000`\r\n\r\n使用个人 Microsoft 帐户或者工作或学校帐户登录，随后你会看到该用户的标识已出现在 /account 列表中。Web 应用现在使用行业标准协议进行保护，你可以使用个人和工作/学校帐户来验证用户。\r\n\r\n[此处以 .zip 格式提供了](https://github.com/AzureADQuickStarts/WebApp-OpenIDConnect-NodeJS/archive/complete.zip)完整示例（不包括配置值），你也可以从 GitHub 克隆该示例：\r\n\r\n```\r\ngit clone --branch complete https://github.com/AzureADQuickStarts/WebApp-OpenIDConnect-NodeJS.git\r\n```\r\n\r\n现在，可以转到更高级的主题。你可能想要尝试：\r\n\r\n[使用 Azure AD 保护 Web API >>](./active-directory-devquickstarts-webapi-nodejs.md)\r\n\r\n[!INCLUDE [active-directory-devquickstarts-additional-resources](../../../includes/active-directory-devquickstarts-additional-resources.md)]\r\n\r\n<!---HONumber=Mooncake_0120_2017-->\r\n<!---Update_Description: wording update -->"}