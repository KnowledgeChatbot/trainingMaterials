{"Title":"使用 Node.js 保护 Azure Active Directory v2.0 Web API","Description":"了解如何构建一个可从个人 Microsoft 帐户及公司或学校帐户接受令牌的 Node.js Web API。","Content":"# <a name=\"secure-a-web-api-by-using-nodejs\"></a>使用 Node.js 保护 Web API\r\n> [!NOTE]\r\n> 并非所有 Azure Active Directory 方案和功能都可与 v2.0 终结点配合使用。 若要确定是应该使用 v2.0 终结点还是应该使用 v1.0 终结点，请阅读 [v2.0 限制](active-directory-v2-limitations.md)。\r\n> \r\n> \r\n\r\n使用 Azure Active Directory (Azure AD) v2.0 终结点时，可以使用 [OAuth 2.0](active-directory-v2-protocols.md) 访问令牌来保护 Web API。 同时拥有个人 Microsoft 帐户以及工作或学校帐户的用户可以使用 OAuth 2.0 访问令牌安全访问你的 Web API。\r\n\r\n*Passport* 是 Node.js 的身份验证中间件。 Passport 很灵活并且采用模块化结构，可以在不造成干扰的情况下放入任何基于 Express 的应用程序或 Resitify Web 应用程序。 在 Passport 中，有一套综合性策略支持使用用户名和密码、Facebook、Twitter 或其他选项进行身份验证。 我们针对 Azure AD 开发了一项策略。 本文介绍了如何安装该模块及添加 Azure AD `passport-azure-ad` 插件。\r\n\r\n## <a name=\"download\"></a>下载\r\n本教程的代码 [在 GitHub 上](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs)维护。 若要按照本教程操作，可以[下载 .zip 文件格式的应用框架](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs/archive/skeleton.zip)，或克隆该框架：\r\n\r\n```git clone --branch skeleton https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs.git```\r\n\r\n还可以在本教程结束时获得完整的应用程序。\r\n\r\n## <a name=\"1-register-an-app\"></a>1：注册应用\r\n在 [apps.dev.microsoft.com](https://apps.dev.microsoft.com/?deeplink=/appList) 上创建新应用，或按照[以下详细步骤](active-directory-v2-app-registration.md)注册应用。 确保：\r\n\r\n- 复制分配给应用的**应用程序 ID**。 在本教程中需要用到它。\r\n- 为应用添加 **移动** 平台。\r\n- 从门户复制 **重定向 URI** 。 必须使用默认的 URI 值 `urn:ietf:wg:oauth:2.0:oob`。\r\n\r\n## <a name=\"2-install-nodejs\"></a>2：安装 Node.js\r\n若要使用本教程中的示例，必须[安装 Node.js](http://nodejs.org)。\r\n\r\n## <a name=\"3-install-mongodb\"></a>3：安装 MongoDB\r\n若要成功使用本示例，必须[安装 MongoDB](http://www.mongodb.org)。 本示例使用 MongoDB 来使 REST API 持久保留在服务器实例之间。\r\n\r\n> [!NOTE]\r\n> 本文假设对 MongoDB 使用默认的安装与服务器终结点：mongodb://localhost。\r\n> \r\n> \r\n\r\n## <a name=\"4-install-the-restify-modules-in-your-web-api\"></a>4：在 Web API 中安装 Restify 模块\r\n我们使用 Resitfy 来构建 REST API。 Restify 是派生自 Express 的精简弹性 Node.js 应用程序框架。 Restify 提供了一套稳健功能用于在 Connect 的顶层构建 REST API。\r\n\r\n### <a name=\"install-restify\"></a>安装 Restify\r\n1.  在命令行中，将目录切换到 **azuread**：\r\n\r\n    `cd azuread`\r\n\r\n    如果 **azuread** 目录不存在，请创建该目录。\r\n\r\n    `mkdir azuread`\r\n\r\n2.  安装 Restify：\r\n\r\n    `npm install restify`\r\n\r\n    此命令的输出应如下所示：\r\n\r\n    ```\r\n    restify@2.6.1 node_modules/restify\r\n    ├── assert-plus@0.1.4\r\n    ├── once@1.3.0\r\n    ├── deep-equal@0.0.0\r\n    ├── escape-regexp-component@1.0.2\r\n    ├── qs@0.6.5\r\n    ├── tunnel-agent@0.3.0\r\n    ├── keep-alive-agent@0.0.1\r\n    ├── lru-cache@2.3.1\r\n    ├── node-uuid@1.4.0\r\n    ├── negotiator@0.3.0\r\n    ├── mime@1.2.11\r\n    ├── semver@2.2.1\r\n    ├── spdy@1.14.12\r\n    ├── backoff@2.3.0\r\n    ├── formidable@1.0.14\r\n    ├── verror@1.3.6 (extsprintf@1.0.2)\r\n    ├── csv@0.3.6\r\n    ├── http-signature@0.10.0 (assert-plus@0.1.2, asn1@0.1.11, ctype@0.5.2)\r\n    └── bunyan@0.22.0(mv@0.0.5)\r\n    ```\r\n\r\n#### <a name=\"did-you-get-an-error\"></a>遇到了错误吗？\r\n在某些操作系统上使用 `npm` 命令时，可能会看到此消息：`Error: EPERM, chmod '/usr/local/bin/..'`。 发生此错误后，接着会要求以管理员身份尝试运行帐户。 如果发生此问题，请使用 `sudo` 命令，以更高特权级别运行 `npm`。\r\n\r\n#### <a name=\"did-you-get-an-error-related-to-dtrace\"></a>遇到了 DTrace 相关的错误吗？\r\n安装 Restify 时，可能会看到以下消息：\r\n\r\n```Shell\r\nclang: error: no such file or directory: 'HD/azuread/node_modules/restify/node_modules/dtrace-provider/libusdt'\r\nmake: *** [Release/DTraceProviderBindings.node] Error 1\r\ngyp ERR! build error\r\ngyp ERR! stack Error: `make` failed with exit code: two\r\ngyp ERR! stack     at ChildProcess.onExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:267:23)\r\ngyp ERR! stack     at ChildProcess.EventEmitter.emit (events.js:98:17)\r\ngyp ERR! stack     at Process.ChildProcess._handle.onexit (child_process.js:789:12)\r\ngyp ERR! System Darwin 13.1.0\r\ngyp ERR! command \"node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"\r\ngyp ERR! cwd /Volumes/Development HD/azuread/node_modules/restify/node_modules/dtrace-provider\r\ngyp ERR! node -v v0.10.11\r\ngyp ERR! node-gyp -v v0.10.0\r\ngyp ERR! not ok\r\nnpm WARN optional dep failed, continuing dtrace-provider@0.2.8\r\n```\r\n\r\nRestify 提供强大的机制来使用 DTrace 跟踪 REST 调用。 但是，许多操作系统不提供 DTrace。 可以放心地忽略此错误消息。\r\n\r\n\r\n## <a name=\"5-install-passportjs-in-your-web-api\"></a>5：将 Passport.js 安装到 Web API 中\r\n1.  在命令行提示符下，将目录切换到 **azuread**。\r\n\r\n2.  安装 Passport.js：\r\n\r\n    `npm install passport`\r\n\r\n    此命令的输出应如下所示：\r\n\r\n    ```\r\n     passport@0.1.17 node_modules\\passport\r\n    ├── pause@0.0.1\r\n    └── pkginfo@0.2.3\r\n    ```\r\n\r\n## <a name=\"6-add-passport-azure-ad-to-your-web-api\"></a>6：将 passport-azure-ad 添加到 Web API\r\n接下来，使用 passport-azuread 添加 OAuth 策略。 `passport-azuread` 是一套将 Azure AD 连接到 Passport 的策略。 在此 REST API 示例中，我们将针对持有者令牌使用此策略。\r\n\r\n> [!NOTE]\r\n> 尽管 OAuth 2.0 提供了可以颁发任何已知令牌类型的框架，但我们通常使用其中的某些令牌类型。 我们往往使用持有者令牌保护终结点。 持有者令牌是 OAuth 2.0 中最广泛颁发的令牌类型。 许多 OAuth 2.0 实现假设持有者令牌是唯一颁发的令牌类型。\r\n> \r\n> \r\n\r\n1.  在命令行中，将目录切换到 **azuread**。\r\n\r\n    `cd azuread`\r\n\r\n2.  安装 Passport.js `passport-azure-ad` 模块：\r\n\r\n    `npm install passport-azure-ad`\r\n\r\n    此命令的输出应如下所示：\r\n\r\n    ```\r\n    passport-azure-ad@1.0.0 node_modules/passport-azure-ad\r\n    ├── xtend@4.0.0\r\n    ├── xmldom@0.1.19\r\n    ├── passport-http-bearer@1.0.1 (passport-strategy@1.0.0)\r\n    ├── underscore@1.8.3\r\n    ├── async@1.3.0\r\n    ├── jsonwebtoken@5.0.2\r\n    ├── xml-crypto@0.5.27 (xpath.js@1.0.6)\r\n    ├── ursa@0.8.5 (bindings@1.2.1, nan@1.8.4)\r\n    ├── jws@3.0.0 (jwa@1.0.1, base64url@1.0.4)\r\n    ├── request@2.58.0 (caseless@0.10.0, aws-sign2@0.5.0, forever-agent@0.6.1, stringstream@0.0.4, tunnel-agent@0.4.1, oauth-sign@0.8.0, isstream@0.1.2, extend@2.0.1, json-stringify-safe@5.0.1, node-uuid@1.4.3, qs@3.1.0, combined-stream@1.0.5, mime-types@2.0.14, form-data@1.0.0-rc1, http-signature@0.11.0, bl@0.9.4, tough-cookie@2.0.0, hawk@2.3.1, har-validator@1.8.0)\r\n    └── xml2js@0.4.9 (sax@0.6.1, xmlbuilder@2.6.4)\r\n    ```\r\n\r\n## <a name=\"7-add-mongodb-modules-to-your-web-api\"></a>7：将 MongoDB 模块添加到 Web API\r\n本示例使用 MongoDB 作为数据存储。 \r\n\r\n1.  安装 Mongoose，这是广泛用于管理模型和架构的插件： \r\n\r\n    `npm install mongoose`\r\n\r\n2.  安装 MongoDB 的数据库驱动程序（也称为 MongoDB）：\r\n\r\n    `npm install mongodb`\r\n\r\n## <a name=\"8-install-additional-modules\"></a>8：安装其他模块\r\n安装剩余的所需模块。\r\n\r\n1.  在命令行中，将目录切换到 **azuread**：\r\n\r\n    `cd azuread`\r\n\r\n2.  输入以下命令。 这些命令在 node_modules 目录中安装以下模块：\r\n\r\n    *   `npm install crypto`\r\n    *   `npm install assert-plus`\r\n    *   `npm install posix-getopt`\r\n    *   `npm install util`\r\n    *   `npm install path`\r\n    *   `npm install connect`\r\n    *   `npm install xml-crypto`\r\n    *   `npm install xml2js`\r\n    *   `npm install xmldom`\r\n    *   `npm install async`\r\n    *   `npm install request`\r\n    *   `npm install underscore`\r\n    *   `npm install grunt-contrib-jshint@0.1.1`\r\n    *   `npm install grunt-contrib-nodeunit@0.1.2`\r\n    *   `npm install grunt-contrib-watch@0.2.0`\r\n    *   `npm install grunt@0.4.1`\r\n    *   `npm install xtend@2.0.3`\r\n    *   `npm install bunyan`\r\n    *   `npm update`\r\n\r\n## <a name=\"9-create-a-serverjs-file-for-your-dependencies\"></a>9：创建依赖项的 Server.js 文件\r\nServer.js 文件保存 Web API 服务器的大多数功能。 大部分代码将添加到此文件中。 用于生产目的，可以将功能重构为较小的文件，例如单独的路由和控制器。 本文为此目的使用 Server.js。\r\n\r\n1.  在命令行中，将目录切换到 **azuread**：\r\n\r\n    `cd azuread`\r\n\r\n2.  使用所选的编辑器创建 Server.js 文件。 在文件中添加以下信息：\r\n\r\n    ```Javascript\r\n    'use strict';\r\n    /**\r\n    * Module dependencies.\r\n    */\r\n    var util = require('util');\r\n    var assert = require('assert-plus');\r\n    var mongoose = require('mongoose/');\r\n    var bunyan = require('bunyan');\r\n    var restify = require('restify');\r\n    var config = require('./config');\r\n    var passport = require('passport');\r\n    var OIDCBearerStrategy = require('passport-azure-ad').OIDCStrategy;\r\n    ```\r\n\r\n3.  保存文件。 稍后将要使用此文件。\r\n\r\n## <a name=\"10-create-a-config-file-to-store-your-azure-ad-settings\"></a>10：创建一个配置文件用于存储 Azure AD 设置\r\n此代码文件将配置参数从 Azure AD 门户传递到 Passport.js。 在本文开头部分向门户添加 Web API 时，你创建了这些配置值。 在你复制代码后，我们将解释要输入其中的哪些参数值。\r\n\r\n1.  在命令行中，将目录切换到 **azuread**：\r\n\r\n    `cd azuread`\r\n\r\n2.  在编辑器中创建 Config.js 文件。 添加以下信息：\r\n\r\n    ```Javascript\r\n    // Don't commit this file to your public repos. This config is for first-run.\r\n    exports.creds = {\r\n    mongoose_auth_local: 'mongodb://localhost/tasklist', // Your Mongo auth URI goes here.\r\n    issuer: 'https://sts.chinacloudapi.cn/**<your application id>**/',\r\n    audience: '<your redirect URI>',\r\n    identityMetadata: 'https://login.partner.microsoftonline.cn/common/.well-known/openid-configuration' // For Microsoft, you should never need to change this.\r\n    };\r\n\r\n    ```\r\n\r\n\r\n\r\n### <a name=\"required-values\"></a>必需的值\r\n\r\n-   **IdentityMetadata**：`passport-azure-ad` 将在此处查找适用于标识提供者 (IDP) 的配置数据，以及用于验证 JSON Web 令牌 (JWT) 的密钥。 如果使用 Azure AD，可能不需要更改此值。\r\n\r\n-   audience：来自门户的重定向 URI。\r\n\r\n> [!NOTE]\r\n> 频繁滚动更新密钥。 请确保始终从“openid_keys”URL 提取密钥，并且应用程序能够访问 Internet。\r\n> \r\n> \r\n\r\n## <a name=\"11-add-the-configuration-to-your-serverjs-file\"></a>11：将配置添加到 Server.js 文件\r\n应用程序需要从刚刚创建的配置文件读取值。 在应用程序中添加 .config 文件作为所需的资源。 将全局变量设置为 Config.js 中的值。\r\n\r\n1.  在命令行提示符下，将目录切换到 **azuread**：\r\n\r\n    `cd azuread`\r\n\r\n2.  在编辑器中打开 Server.js。 添加以下信息：\r\n\r\n    ```Javascript\r\n    var config = require('./config');\r\n    ```\r\n\r\n3.  将一个新节添加到 Server.js：\r\n\r\n    ```Javascript\r\n    // Pass these options in to the ODICBearerStrategy.\r\n    var options = {\r\n    // The URL of the metadata document for your app. Put the keys for token validation from the URL found in the jwks_uri tag in the metadata.\r\n    identityMetadata: config.creds.identityMetadata,\r\n    issuer: config.creds.issuer,\r\n    audience: config.creds.audience\r\n    };\r\n    // Array to hold signed-in users and the current signed-in user (owner).\r\n    var users = [];\r\n    var owner = null;\r\n    // Your logger\r\n    var log = bunyan.createLogger({\r\n    name: 'Azure Active Directory Sample'\r\n    });\r\n    ```\r\n\r\n## <a name=\"12-add-the-mongodb-model-and-schema-information-by-using-mongoose\"></a>12：使用 Mongoose 添加 MongoDB 模型和架构信息\r\n接下来，在 REST API 服务中连接这三个文件。\r\n\r\n本文使用 MongoDB 来存储任务。 *步骤 4* 将介绍此操作。\r\n\r\n在步骤 11 创建的 Config.js 文件中，数据库名为 *tasklist*。 该名称也是在 mongoose_auth_local 连接 URL 末尾处输入的内容。 不需要在 MongoDB 中事先创建此数据库。 首次运行服务器应用程序时，将会创建该数据库（假设该数据库尚不存在）。\r\n\r\n你已告知服务器要使用哪个 MongoDB 数据库。 接下来，需要编写一些额外的代码，为服务器的任务创建模型和架构。\r\n\r\n### <a name=\"the-model\"></a>模型\r\n架构模型非常简单。 可以根据需要扩展它。 \r\n\r\n架构模型具有以下值：\r\n\r\n-   **NAME**。 分配给任务的人员。 这是一个**字符串**值。\r\n-   **TASK**。 任务的名称。 这是一个**字符串**值。\r\n-   **DATE**。 任务截止日期。 这是一个**日期时间**值。\r\n-   **COMPLETED**。 任务是否已完成。 这是一个**布尔**值。\r\n\r\n### <a name=\"create-the-schema-in-the-code\"></a>在代码中创建架构\r\n1.  在命令行中，将目录切换到 **azuread**：\r\n\r\n    `cd azuread`\r\n\r\n2.  在编辑器中打开 Server.js。 在配置项下面添加以下信息：\r\n\r\n    ```Javascript\r\n    // MongoDB setup.\r\n    // Set up some configuration.\r\n    var serverPort = process.env.PORT || 8080;\r\n    var serverURI = (process.env.PORT) ? config.creds.mongoose_auth_mongohq : config.creds.mongoose_auth_local;\r\n    // Connect to MongoDB.\r\n    global.db = mongoose.connect(serverURI);\r\n    var Schema = mongoose.Schema;\r\n    log.info('MongoDB Schema loaded');\r\n    ```\r\n\r\n此代码连接到 MongoDB 服务器。 它还返回架构对象。\r\n\r\n#### <a name=\"using-the-schema-create-your-model-in-the-code\"></a>使用该架构在代码中创建模型\r\n在上述代码的下面添加以下代码：\r\n\r\n```Javascript\r\n// Create a basic schema to store your tasks and users.\r\nvar TaskSchema = new Schema({\r\nowner: String,\r\ntask: String,\r\ncompleted: Boolean,\r\ndate: Date\r\n});\r\n// Use the schema to register a model.\r\nmongoose.model('Task', TaskSchema);\r\nvar Task = mongoose.model('Task');\r\n```\r\n\r\n从该代码中可以看到，首先会创建架构。 接下来，创建模型对象。 定义**路由**时，将使用模型对象存储整个代码中的数据。\r\n\r\n## <a name=\"13-add-your-routes-for-your-task-rest-api-server\"></a>13：为任务 REST API 服务器添加路由\r\n现在，你已创建了可以使用的数据库模型，接下来请添加用于 REST API 服务器的路由。\r\n\r\n### <a name=\"about-routes-in-restify\"></a>关于 Restify 中的路由\r\nRestify 中路由的工作原理与使用 Express 堆栈时的工作原理完全相同。 可以使用客户端应用程序应该调用的 URI 定义路由。 通常，需要在单独的文件中定义路由。 本教程将在 Server.js 中放置路由。 对于生产用途，我们建议在各自的文件中构建路由。\r\n\r\nRestify 路由的典型模式是：\r\n\r\n```Javascript\r\nfunction createObject(req, res, next) {\r\n// Do work on object.\r\n_object.name = req.params.object; // Passed value is in req.params under object.\r\n///...\r\nreturn next(); // Keep the server going.\r\n}\r\n....\r\nserver.post('/service/:add/:object', createObject); // calls createObject on routes that match this.\r\n```\r\n\r\n\r\n这是最基本级别的模式。 Resitfy（以及 Express）提供更深层的功能，例如，定义应用程序类型，以及跨不同的终结点提供复杂路由。\r\n\r\n#### <a name=\"add-default-routes-to-your-server\"></a>将默认路由添加到服务器\r\n添加基本 CRUD 路由：**create**、**retrieve**、**update** 和 **delete**。\r\n\r\n1.  在命令行中，将目录切换到 **azuread**：\r\n\r\n    `cd azuread`\r\n\r\n2.  在编辑器中打开 Server.js。 在前面输入的数据库项下面添加以下信息：\r\n\r\n    ```Javascript\r\n    /**\r\n    *\r\n    * APIs for your REST task server\r\n    */\r\n    // Create a task.\r\n    function createTask(req, res, next) {\r\n    // Resitify currently has a bug that doesn't allow you to set default headers.\r\n    // These headers comply with CORS, and allow you to use MongoDB Server as your response to any origin.\r\n    res.header(\"Access-Control-Allow-Origin\", \"*\");\r\n    res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\r\n    // Create a new task model, fill it, and save it to MongoDB.\r\n    var _task = new Task();\r\n    if (!req.params.task) {\r\n    req.log.warn({\r\n    params: p\r\n    }, 'createTodo: missing task');\r\n    next(new MissingTaskError());\r\n    return;\r\n    }\r\n    _task.owner = owner;\r\n    _task.task = req.params.task;\r\n    _task.date = new Date();\r\n    _task.save(function(err) {\r\n    if (err) {\r\n    req.log.warn(err, 'createTask: unable to save');\r\n    next(err);\r\n    } else {\r\n    res.send(201, _task);\r\n    }\r\n    });\r\n    return next();\r\n    }\r\n    // Delete a task by name.\r\n    function removeTask(req, res, next) {\r\n    Task.remove({\r\n    task: req.params.task,\r\n    owner: owner\r\n    }, function(err) {\r\n    if (err) {\r\n    req.log.warn(err,\r\n    'removeTask: unable to delete %s',\r\n    req.params.task);\r\n    next(err);\r\n    } else {\r\n    log.info('Deleted task:', req.params.task);\r\n    res.send(204);\r\n    next();\r\n    }\r\n    });\r\n    }\r\n    // Delete all tasks.\r\n    function removeAll(req, res, next) {\r\n    Task.remove();\r\n    res.send(204);\r\n    return next();\r\n    }\r\n    // Get a specific task based on name.\r\n    function getTask(req, res, next) {\r\n    log.info('getTask was called for: ', owner);\r\n    Task.find({\r\n    owner: owner\r\n    }, function(err, data) {\r\n    if (err) {\r\n    req.log.warn(err, 'get: unable to read %s', owner);\r\n    next(err);\r\n    return;\r\n    }\r\n    res.json(data);\r\n    });\r\n    return next();\r\n    }\r\n    /// Returns the list of TODOs that were loaded.\r\n    function listTasks(req, res, next) {\r\n    // Resitify currently has a bug that doesn't allow you to set default headers.\r\n    // These headers comply with CORS, and allow us to use MongoDB Server as our response to any origin.\r\n    res.header(\"Access-Control-Allow-Origin\", \"*\");\r\n    res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\r\n    log.info(\"listTasks was called for: \", owner);\r\n    Task.find({\r\n    owner: owner\r\n    }).limit(20).sort('date').exec(function(err, data) {\r\n    if (err)\r\n    return next(err);\r\n    if (data.length > 0) {\r\n    log.info(data);\r\n    }\r\n    if (!data.length) {\r\n    log.warn(err, \"There are no tasks in the database. Add one!\");\r\n    }\r\n    if (!owner) {\r\n    log.warn(err, \"You did not pass an owner when listing tasks.\");\r\n    } else {\r\n    res.json(data);\r\n    }\r\n    });\r\n    return next();\r\n    }\r\n    ```\r\n\r\n### <a name=\"add-error-handling-for-the-routes\"></a>为路由添加错误处理\r\n添加一些错误处理，以便将遇到的问题传达给客户端。\r\n\r\n添加以下代码（前面已编写这些代码）：\r\n\r\n```Javascript\r\n///--- Errors for communicating something more information back to the client.\r\nfunction MissingTaskError() {\r\nrestify.RestError.call(this, {\r\nstatusCode: 409,\r\nrestCode: 'MissingTask',\r\nmessage: '\"task\" is a required parameter',\r\nconstructorOpt: MissingTaskError\r\n});\r\nthis.name = 'MissingTaskError';\r\n}\r\nutil.inherits(MissingTaskError, restify.RestError);\r\nfunction TaskExistsError(owner) {\r\nassert.string(owner, 'owner');\r\nrestify.RestError.call(this, {\r\nstatusCode: 409,\r\nrestCode: 'TaskExists',\r\nmessage: owner + ' already exists',\r\nconstructorOpt: TaskExistsError\r\n});\r\nthis.name = 'TaskExistsError';\r\n}\r\nutil.inherits(TaskExistsError, restify.RestError);\r\nfunction TaskNotFoundError(owner) {\r\nassert.string(owner, 'owner');\r\nrestify.RestError.call(this, {\r\nstatusCode: 404,\r\nrestCode: 'TaskNotFound',\r\nmessage: owner + ' was not found',\r\nconstructorOpt: TaskNotFoundError\r\n});\r\nthis.name = 'TaskNotFoundError';\r\n}\r\nutil.inherits(TaskNotFoundError, restify.RestError);\r\n```\r\n\r\n\r\n## <a name=\"14-create-your-server\"></a>14：创建服务器\r\n最后一个步骤是添加服务器实例。 服务器实例用于管理调用。\r\n\r\nRestify（和 Express）提供可对 REST API 服务器使用的深度自定义功能。 本教程使用最基本的设置。\r\n\r\n```Javascript\r\n/**\r\n* Your server\r\n*/\r\nvar server = restify.createServer({\r\nname: \"Azure Active Directory TODO Server\",\r\nversion: \"2.0.1\"\r\n});\r\n// Ensure that you don't drop data on uploads.\r\nserver.pre(restify.pre.pause());\r\n// Clean up imprecise paths like //todo//////1//.\r\nserver.pre(restify.pre.sanitizePath());\r\n// Handle annoying user agents (curl).\r\nserver.pre(restify.pre.userAgentConnection());\r\n// Set a per-request Bunyan logger (with requestid filled in).\r\nserver.use(restify.requestLogger());\r\n// Allow 5 requests/second by IP address, and burst to 10.\r\nserver.use(restify.throttle({\r\nburst: 10,\r\nrate: 5,\r\nip: true,\r\n}));\r\n// Use common commands, such as:\r\nserver.use(restify.acceptParser(server.acceptable));\r\nserver.use(restify.dateParser());\r\nserver.use(restify.queryParser());\r\nserver.use(restify.gzipResponse());\r\nserver.use(restify.bodyParser({\r\nmapParams: true\r\n}));\r\n```\r\n## <a name=\"15-add-the-routes-without-authentication-for-now\"></a>15：添加路由（目前不包括身份验证）\r\n```Javascript\r\n/// Use CRUD to add the real handlers.\r\n/**\r\n/*\r\n/* Each of these handlers is protected by your Open ID Connect Bearer strategy. Invoke 'oidc-bearer'\r\n/* in the pasport.authenticate() method. Because REST is stateless, set 'session: false'. You \r\n/* don't need to maintain session state. You can experiment with removing API protection.\r\n/* To do this, remove the passport.authenticate() method:\r\n/*\r\n/* server.get('/tasks', listTasks);\r\n/*\r\n**/\r\nserver.get('/tasks', listTasks);\r\nserver.get('/tasks', listTasks);\r\nserver.get('/tasks/:owner', getTask);\r\nserver.head('/tasks/:owner', getTask);\r\nserver.post('/tasks/:owner/:task', createTask);\r\nserver.post('/tasks', createTask);\r\nserver.del('/tasks/:owner/:task', removeTask);\r\nserver.del('/tasks/:owner', removeTask);\r\nserver.del('/tasks', removeTask);\r\nserver.del('/tasks', removeAll, function respond(req, res, next) {\r\nres.send(204);\r\nnext();\r\n});\r\n// Register a default '/' handler\r\nserver.get('/', function root(req, res, next) {\r\nvar routes = [\r\n'GET /',\r\n'POST /tasks/:owner/:task',\r\n'POST /tasks (for JSON body)',\r\n'GET /tasks',\r\n'PUT /tasks/:owner',\r\n'GET /tasks/:owner',\r\n'DELETE /tasks/:owner/:task'\r\n];\r\nres.send(200, routes);\r\nnext();\r\n});\r\nserver.listen(serverPort, function() {\r\nvar consoleMessage = '\\n Azure Active Directory Tutorial';\r\nconsoleMessage += '\\n +++++++++++++++++++++++++++++++++++++++++++++++++++++';\r\nconsoleMessage += '\\n %s server is listening at %s';\r\nconsoleMessage += '\\n Open your browser to %s/tasks\\n';\r\nconsoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n';\r\nconsoleMessage += '\\n !!! why not try a $curl -isS %s | json to get some ideas? \\n';\r\nconsoleMessage += '+++++++++++++++++++++++++++++++++++++++++++++++++++++ \\n\\n';\r\n});\r\n```\r\n## <a name=\"16-run-the-server\"></a>16：运行服务器\r\n添加身份验证之前最好是先测试服务器。\r\n\r\n测试服务器的最简单方法是在命令提示符下使用 curl。 为此，需要使用一个用于分析 JSON 输出的简单实用工具。 \r\n\r\n1.  安装要在以下示例中使用的 JSON 工具：\r\n\r\n    `$npm install -g jsontool`\r\n\r\n    这将全局安装 JSON 工具。\r\n\r\n2.  确保 MongoDB 实例正在运行：\r\n\r\n    `$sudo mongod`\r\n\r\n3.  将目录切换到 **azuread**，然后运行 curl：\r\n\r\n    `$ cd azuread`\r\n    `$ node server.js`\r\n\r\n    `$ curl -isS http://127.0.0.1:8080 | json`\r\n\r\n    ```Shell\r\n    HTTP/1.1 2.0OK\r\n    Connection: close\r\n    Content-Type: application/json\r\n    Content-Length: 171\r\n    Date: Tue, 14 Jul 2015 05:43:38 GMT\r\n    [\r\n    \"GET /\",\r\n    \"POST /tasks/:owner/:task\",\r\n    \"POST /tasks (for JSON body)\",\r\n    \"GET /tasks\",\r\n    \"PUT /tasks/:owner\",\r\n    \"GET /tasks/:owner\",\r\n    \"DELETE /tasks/:owner/:task\"\r\n    ]\r\n    ```\r\n\r\n4.  添加任务：\r\n\r\n    `$ curl -isS -X POST http://127.0.0.1:8888/tasks/brandon/Hello`\r\n\r\n    响应应为：\r\n\r\n    ```Shell\r\n    HTTP/1.1 201 Created\r\n    Connection: close\r\n    Access-Control-Allow-Origin: *\r\n    Access-Control-Allow-Headers: X-Requested-With\r\n    Content-Type: application/x-www-form-urlencoded\r\n    Content-Length: 5\r\n    Date: Tue, 04 Feb 2014 01:02:26 GMT\r\n    Hello\r\n    ```\r\n\r\n5.  列出 Brandon 的任务：\r\n\r\n    `$ curl -isS http://127.0.0.1:8080/tasks/brandon/`\r\n\r\n如果运行了所有这些命令且未出错，则可以将 OAuth 添加到 REST API 服务器。\r\n\r\n*现在，已有一台装有 MongoDB 的 REST API 服务器！*\r\n\r\n## <a name=\"17-add-authentication-to-your-rest-api-server\"></a>17：将身份验证添加到 REST API 服务器\r\n运行 REST API 后，请将它设置为与 Azure AD 配合使用。\r\n\r\n在命令行中，将目录切换到 **azuread**：\r\n\r\n`cd azuread`\r\n\r\n### <a name=\"use-the-oidcbearerstrategy-thats-included-with-passport-azure-ad\"></a>使用 passport-azure-ad 包含的 oidcbearerstrategy\r\n到目前为止，我们已构建了一个典型的 REST TODO 服务器，其中不包含任何授权种类。 现在，请添加身份验证。\r\n\r\n首先，指出你要使用 Passport。 在前面的服务器配置后面紧接着插入以下代码：\r\n\r\n```Javascript\r\n// Start using Passport.js.\r\n\r\nserver.use(passport.initialize()); // Starts passport\r\nserver.use(passport.session()); // Provides session support\r\n```\r\n\r\n> [!TIP]\r\n> 编写 API 时，最好是始终将数据链接到用户无法证明其在令牌中是唯一的项目。 此服务器存储 TODO 项目时，会根据令牌（通过 token.sub 调用）中的用户订阅 ID 来存储它们。 token.sub 放在“owner”字段中。 这可以确保只有该用户能够访问其自己的 TODO（待办事项）。 任何人都无法访问输入的 TODO。 “owner”的 API 中不公开任何信息。 外部用户可以请求其他用户的 TODO，即使他们已经过身份验证。\r\n> \r\n> \r\n\r\n接下来，使用 `passport-azure-ad` 中随附的 Open ID Connect Bearer 策略。 将此代码放在上面粘贴的内容后面：\r\n\r\n```Javascript\r\n/**\r\n/*\r\n/* Calling the OIDCBearerStrategy and managing users.\r\n/*\r\n/* Because of the Passport pattern, you need to manage users and info tokens\r\n/* with a FindorCreate() method. The method must be provided by the implementor.\r\n/* In the following code, you autoregister any user and implement a FindById().\r\n/* It's a good idea to do something more advanced.\r\n**/\r\nvar findById = function(id, fn) {\r\nfor (var i = 0, len = users.length; i < len; i++) {\r\nvar user = users[i];\r\nif (user.sub === id) {\r\nlog.info('Found user: ', user);\r\nreturn fn(null, user);\r\n}\r\n}\r\nreturn fn(null, null);\r\n};\r\nvar oidcStrategy = new OIDCBearerStrategy(options,\r\nfunction(token, done) {\r\nlog.info('verifying the user');\r\nlog.info(token, 'was the token retrieved');\r\nfindById(token.sub, function(err, user) {\r\nif (err) {\r\nreturn done(err);\r\n}\r\nif (!user) {\r\n// \"Auto-registration\"\r\nlog.info('User was added automatically, because they were new. Their sub is: ', token.sub);\r\nusers.push(token);\r\nowner = token.sub;\r\nreturn done(null, token);\r\n}\r\nowner = token.sub;\r\nreturn done(null, user, token);\r\n});\r\n}\r\n);\r\npassport.use(oidcStrategy);\r\n```\r\n\r\nPassport 对其所有策略（Twitter、Facebook 等）都使用类似的模式。 所有策略编写器都遵循该模式。 向策略传递使用令牌和 `done` 作为参数的 `function()`。 策略会在完成所有任务后返回。 存储用户和令牌，这样一来，就不需要再次请求。\r\n\r\n> [!IMPORTANT]\r\n> 前面的代码会将所有可以进行身份验证的用户转到服务器。 这就是所谓的自动注册。 在生产服务器上，你会希望所有人都先经历你选择的注册过程，然后才能进入服务器。 通常会在消费类应用中看到这种模式。 应用可能会允许使用 Facebook 注册，但随后会要求输入其他信息。 如果在本教程中没有使用命令行程序，可从返回的令牌对象中提取电子邮件。 然后，可以要求用户输入其他信息。 由于这是测试服务器，可以直接将用户添加到内存中数据库。\r\n> \r\n> \r\n\r\n### <a name=\"protect-endpoints\"></a>保护终结点\r\n通过结合想要使用的协议指定 **passport.authenticate()** 调用来保护终结点。\r\n\r\n可以在服务器代码中针对更高级的选项编辑路由：\r\n\r\n```Javascript\r\nserver.get('/tasks', passport.authenticate('oidc-bearer', {\r\nsession: false\r\n}), listTasks);\r\nserver.get('/tasks', passport.authenticate('oidc-bearer', {\r\nsession: false\r\n}), listTasks);\r\nserver.get('/tasks/:owner', passport.authenticate('oidc-bearer', {\r\nsession: false\r\n}), getTask);\r\nserver.head('/tasks/:owner', passport.authenticate('oidc-bearer', {\r\nsession: false\r\n}), getTask);\r\nserver.post('/tasks/:owner/:task', passport.authenticate('oidc-bearer', {\r\nsession: false\r\n}), createTask);\r\nserver.post('/tasks', passport.authenticate('oidc-bearer', {\r\nsession: false\r\n}), createTask);\r\nserver.del('/tasks/:owner/:task', passport.authenticate('oidc-bearer', {\r\nsession: false\r\n}), removeTask);\r\nserver.del('/tasks/:owner', passport.authenticate('oidc-bearer', {\r\nsession: false\r\n}), removeTask);\r\nserver.del('/tasks', passport.authenticate('oidc-bearer', {\r\nsession: false\r\n}), removeTask);\r\nserver.del('/tasks', passport.authenticate('oidc-bearer', {\r\nsession: false\r\n}), removeAll, function respond(req, res, next) {\r\nres.send(204);\r\nnext();\r\n});\r\n```\r\n\r\n## <a name=\"18-run-your-server-application-again\"></a>18：再次运行服务器应用程序\r\n再次使用 curl 来检查是否针对终结点提供 OAuth 2.0 保护。 请在针对此终结点运行任何客户端 SDK 之前执行此操作。 返回的标头应告知身份验证是否正常工作。\r\n\r\n1.  确保 MongoDB 实例正在运行：\r\n\r\n    `$sudo mongod`\r\n\r\n2.  切换到 **azuread** 目录，然后使用 curl：\r\n\r\n    `$ cd azuread`\r\n\r\n    `$ node server.js`\r\n\r\n3.  试用基本 POST：\r\n\r\n    `$ curl -isS -X POST http://127.0.0.1:8080/tasks/brandon/Hello`\r\n\r\n    ```Shell\r\n    HTTP/1.1 401 Unauthorized\r\n    Connection: close\r\n    WWW-Authenticate: Bearer realm=\"Users\"\r\n    Date: Tue, 14 Jul 2015 05:45:03 GMT\r\n    Transfer-Encoding: chunked\r\n    ```\r\n\r\n401 响应表明 Passport 层正在尝试重定向到授权终结点，这正是我们所希望的。\r\n\r\n*你现在已创建了一个使用 OAuth 2.0 的 REST API 服务！*\r\n\r\n这就是在不使用 OAuth 2.0 兼容客户端的情况下，此服务器能够带来的最大优势。 相关信息，请参阅其他教程。\r\n\r\n## <a name=\"next-steps\"></a>后续步骤\r\n某个 [.zip 文件](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs/archive/complete.zip)提供了完整的示例（不包括配置值）供参考。 还可以从 GitHub 中进行克隆：\r\n\r\n```git clone --branch complete https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs.git```\r\n\r\n现在，可以继续学习更高级的主题。 请尝试学习[使用 v2.0 终结点保护 Node.js Web 应用](active-directory-v2-devquickstarts-node-web.md)。\r\n\r\n下面是一些其他资源：\r\n\r\n- [Azure AD v2.0 开发人员指南](active-directory-appmodel-v2-overview.md)\r\n- [堆栈溢出“azure-active-directory”标记](http://stackoverflow.com/questions/tagged/azure-active-directory)\r\n\r\n### <a name=\"get-security-updates-for-our-products\"></a>获取关于我们产品的安全更新\r\n我们建议注册，以便在发生安全事件时获得通知。 在 [Microsoft 技术安全通知](https://technet.microsoft.com/security/dd252948)页上订阅安全顾问警报。\r\n\r\n\r\n"}