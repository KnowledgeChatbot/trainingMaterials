{"Title":"Azure AD Connect 同步：操作任务和注意事项","Description":"本主题介绍 Azure AD Connect 同步的操作任务，以及如何准备运行此组件。","Content":"# <a name=\"azure-ad-connect-sync-operational-tasks-and-consideration\"></a>Azure AD Connect 同步：操作任务和注意事项\r\n本主题旨在介绍 Azure AD Connect 同步的操作任务。\r\n\r\n## <a name=\"staging-mode\"></a>暂存模式\r\n暂存模式可以用于许多方案，包括：\r\n\r\n- 高可用性。\r\n- 测试和部署新的配置更改。\r\n- 引入新的服务器并解除旧服务器。\r\n\r\n当服务器处于暂存模式时，可以在激活服务器之前更改配置并预览更改。 它还允许运行完全导入和完全同步，以便在生产环境中应用所有更改之前验证这些更改是否符合预期。\r\n\r\n可以在安装过程中选择将服务器置于**暂存模式**。 此操作可以激活服务器进行导入和同步，但不会运行任何导出。 处于暂存模式的服务器不会运行密码同步或密码写回，即使在安装期间选择了这些功能。 如果禁用暂存模式，服务器将开始导出，启用密码同步，并启用密码写回。\r\n\r\n仍然可以使用 Synchronization Service Manager 强制导出。\r\n\r\n处于暂存模式的服务器会继续接收来自 Active Directory 和 Azure AD 的更改。 它始终都有最新更改的副本，并且可以非常快速地接管另一服务器的责任。 如果对主要服务器进行配置更改，则需要负责对处于暂存模式的服务器进行相同的更改。\r\n\r\n对于熟悉旧式同步技术的人员而言，暂存模式是不同的，因为服务器有自身的 SQL 数据库。 此体系结构允许将暂存模式服务器放置在不同的数据中心。\r\n\r\n### <a name=\"verify-the-configuration-of-a-server\"></a>验证服务器的配置\r\n若要应用此方法，请遵循以下步骤：\r\n\r\n1. [准备](#prepare)\r\n2. [配置](#configuration)\r\n3. [导入和同步](#import-and-synchronize)\r\n4. [验证](#verify)\r\n5. [切换活动服务器](#switch-active-server)\r\n\r\n#### <a name=\"prepare\"></a>准备\r\n1. 安装 Azure AD Connect，选择“暂存模式”，然后取消选择安装向导中最后一页上的“启动同步”。 此模式允许手动运行同步引擎。\r\n   ![ReadyToConfigure](./media/active-directory-aadconnectsync-operations/readytoconfigure.png)\r\n2. 注销/登录并从“开始”菜单选择“同步服务”。\r\n\r\n#### 配置 <a name=\"configuration\"></a>\r\n如果对主服务器进行了自定义更改并希望比较配置和临时服务器，则使用 [Azure AD Connect 配置文档管理器](https://github.com/Microsoft/AADConnectConfigDocumenter)。\r\n\r\n#### <a name=\"import-and-synchronize\"></a>导入和同步\r\n1. 选择“连接器”，并选择第一个 Active Directory 域服务类型的连接器。 单击“运行”，然后依次选择“完全导入”和“确定”。 针对此类型的所有连接器执行这些步骤。\r\n2. 选择 Azure Active Directory (Microsoft) 类型的连接器。 单击“运行”，然后依次选择“完全导入”和“确定”。\r\n3. 确保“连接器”选项卡仍处于选中状态。 针对每个 Active Directory 域服务类型的连接器，单击“运行”，然后依次选择“增量同步”和“确定”。\r\n4. 选择 Azure Active Directory (Microsoft) 类型的连接器。 单击“运行”，然后依次选择“增量同步”和“确定”。\r\n\r\n现在，已将导出更改暂存到 Azure AD 和本地 AD（如果你正在使用 Exchange 混合部署）。 后续步骤可让你在实际开始导出到目录之前，检查将要更改的内容。\r\n\r\n#### 验证 <a name=\"verify\"></a>\r\n1. 启动 cmd 提示符并转到 `%ProgramFiles%\\Azure AD Sync\\bin`\r\n2. 运行：`csexport \"Name of Connector\" %temp%\\export.xml /f:x` 连接器名称可以在同步服务中找到。 它的名称类似于“contoso.com - AAD”（表示 Azure AD）。\r\n3. 运行：`CSExportAnalyzer %temp%\\export.xml > %temp%\\export.csv` 现在，%temp% 中已有名为 export.csv 的文件，可在 Microsoft Excel 中检查。 此文件包含要导出的所有更改。\r\n4. 对数据或配置进行必要的更改并再次执行这些步骤（导入、同步和身份验证），直到要导出的更改都按预期进行。\r\n\r\n了解 export.csv 文件。大部分的文件都简单易懂。 请理解内容中的的一些缩写：\r\n- OMODT — 对象修改类型。 指示对象级别的操作是添加、更新还是删除。\r\n- AMODT — 属性修改类型。 指示属性级别的操作是添加、更新还是删除。\r\n\r\n检索通用标识符。export.csv 文件包含要导出的所有更改。 每行都对应于连接器空间中某个对象的更改，该对象由 DN 属性标识。 DN 属性是分配给连接器空间中对象的唯一标识符。 当 export.csv 中存在较多待分析的行/更改时，仅凭 DN 属性可能难以判断哪些对象发生了更改。 要简化分析更改的进程，请使用 csanalyzer.ps1 PowerShell 脚本。 该脚本可检索对象的通用标识符（如 displayName 和 userPrincipalName 等）。 使用脚本：\r\n1. 将 PowerShell 脚本从 [CSAnalyzer](#appendix-csanalyzer) 部分复制到名为 `csanalyzer.ps1` 的文件。\r\n2. 打开 PowerShell 窗口并浏览到已在其中创建 PowerShell 脚本的文件夹。\r\n3. 运行：`.\\csanalyzer.ps1 -xmltoimport %temp%\\export.xml`。\r\n4. 现在已有名为 **processedusers1.csv** 的文件，可在 Microsoft Excel 中检查。 请注意，该文件提供从 DN 属性到通用标识符（如 displayName 和 userPrincipalName 等）的映射。 当前尚不包括要导出的实际属性更改。\r\n\r\n#### 切换活动服务器 <a name=\"switch-active-server\"></a>\r\n1. 在当前处于活动状态的服务器上，关闭服务器 (DirSync/FIM/Azure AD Sync)，使它不会导出到 Azure AD，或将它设为暂存模式 (Azure AD Connect)。\r\n2. 在处于“暂存模式”的服务器上运行安装向导，然后禁用“暂存模式”。\r\n   ![ReadyToConfigure](./media/active-directory-aadconnectsync-operations/additionaltasks.png)\r\n\r\n## <a name=\"disaster-recovery\"></a>灾难恢复\r\n实现设计的一部分是规划在灾难中失去同步服务器时如何应对。 有不同的模型可用，要使用哪一种模型取决于许多因素，包括：\r\n\r\n- 停机期间无法对 Azure AD 中的对象进行更改的容限度如何？\r\n- 如果使用密码同步，用户是否接受他们在本地更改时必须在 Azure AD 中使用旧密码？\r\n- 是否对实时操作具有依赖性，例如密码写回？\r\n\r\n根据这些问题的回答和组织的策略，实施下列其中一个策略：\r\n\r\n- 根据需要重建。\r\n- 具有备用的待机服务器（称为 **暂存模式**）。\r\n- 使用虚拟机。\r\n\r\n如果不使用内置的 SQL Express 数据库，则还应查看 [SQL 高可用性](#sql-high-availability) 部分。\r\n\r\n### <a name=\"rebuild-when-needed\"></a>根据需要重建\r\n必要时规划服务器重建为可行的策略。 通常，在几个小时内即可完成安装同步引擎以及执行初始导入和同步。 如果没有可用的备用服务器，则可以暂时使用域控制器托管同步引擎。\r\n\r\n同步引擎服务器不会存储有关对象的任何状态，因此可以通过 Active Directory 与 Azure AD 中的数据重建数据库。 **sourceAnchor** 属性可用于联接来自本地和云的对象。 如果重新生成包含本地与云中现有对象的服务器，同步引擎会在重新安装时再次同时匹配这些对象。 需要记录和保存的内容是对服务器进行的配置更改，例如筛选和同步规则。 在开始同步之前，必须重新应用这些自定义配置。\r\n\r\n### <a name=\"have-a-spare-standby-server---staging-mode\"></a>具有备用的待机服务器 - 暂存模式\r\n如果环境更复杂，我们建议使用一个或多个待机服务器。 可以在安装过程中启用服务器的 **暂存模式**。\r\n\r\n\r\n### <a name=\"use-virtual-machines\"></a>使用虚拟机\r\n常用的受支持方法是在虚拟机中运行同步引擎。 如果主机有问题，可将包含同步引擎服务器的映像迁移到另一个服务器。\r\n\r\n### <a name=\"sql-high-availability\"></a>SQL 高可用性\r\n如果未使用 Azure AD Connect 随附的 SQL Server Express，还应考虑 SQL Server 的高可用性。 支持的高可用性解决方案包括 SQL 群集和 AOA（Always On 可用性组）。 不支持的解决方案包括镜像。\r\n\r\nAzure AD Connect 版本 1.1.524.0 中添加了对 SQL AOA 的支持。 安装 Azure AD Connect 之前，必须启用 SQL AOA。 在安装期间，Azure AD Connect 会检测是否已为提供的 SQL 实例启用 SQL AOA。 如果启用了 SQL AOA，Azure AD Connect 进一步指出如果 SQL AOA 配置为使用同步复制或异步复制。 设置可用性组侦听器时，我们建议将 RegisterAllProvidersIP 属性设置为 0。 这是因为，Azure AD Connect 目前使用 SQL Native Client 连接到 SQL，而 SQL Native Client 不支持使用 MultiSubNetFailover 属性。\r\n\r\n## 附录 CSAnalyzer <a name=\"appendix-csanalyzer\"></a>\r\n有关如何使用此脚本的信息，请参阅[验证](#verify)部分。\r\n\r\n```\r\nParam(\r\n    [Parameter(Mandatory=$true, HelpMessage=\"Must be a file generated using csexport 'Name of Connector' export.xml /f:x)\")]\r\n    [string]$xmltoimport=\"%temp%\\exportedStage1a.xml\",\r\n    [Parameter(Mandatory=$false, HelpMessage=\"Maximum number of users per output file\")][int]$batchsize=1000,\r\n    [Parameter(Mandatory=$false, HelpMessage=\"Show console output\")][bool]$showOutput=$false\r\n)\r\n\r\n#LINQ isn't loaded automatically, so force it\r\n[Reflection.Assembly]::Load(\"System.Xml.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\") | Out-Null\r\n\r\n[int]$count=1\r\n[int]$outputfilecount=1\r\n[array]$objOutputUsers=@()\r\n\r\n#XML must be generated using \"csexport \"Name of Connector\" export.xml /f:x\"\r\nwrite-host \"Importing XML\" -ForegroundColor Yellow\r\n\r\n#XmlReader.Create won't properly resolve the file location,\r\n#so expand and then resolve it\r\n$resolvedXMLtoimport=Resolve-Path -Path ([Environment]::ExpandEnvironmentVariables($xmltoimport))\r\n\r\n#use an XmlReader to deal with even large files\r\n$result=$reader = [System.Xml.XmlReader]::Create($resolvedXMLtoimport) \r\n$result=$reader.ReadToDescendant('cs-object')\r\ndo \r\n{\r\n    #create the object placeholder\r\n    #adding them up here means we can enforce consistency\r\n    $objOutputUser=New-Object psobject\r\n    Add-Member -InputObject $objOutputUser -MemberType NoteProperty -Name ID -Value \"\"\r\n    Add-Member -InputObject $objOutputUser -MemberType NoteProperty -Name Type -Value \"\"\r\n    Add-Member -inputobject $objOutputUser -MemberType NoteProperty -Name DN -Value \"\"\r\n    Add-Member -inputobject $objOutputUser -MemberType NoteProperty -Name operation -Value \"\"\r\n    Add-Member -inputobject $objOutputUser -MemberType NoteProperty -Name UPN -Value \"\"\r\n    Add-Member -inputobject $objOutputUser -MemberType NoteProperty -Name displayName -Value \"\"\r\n    Add-Member -inputobject $objOutputUser -MemberType NoteProperty -Name sourceAnchor -Value \"\"\r\n    Add-Member -inputobject $objOutputUser -MemberType NoteProperty -Name alias -Value \"\"\r\n    Add-Member -inputobject $objOutputUser -MemberType NoteProperty -Name primarySMTP -Value \"\"\r\n    Add-Member -inputobject $objOutputUser -MemberType NoteProperty -Name onPremisesSamAccountName -Value \"\"\r\n    Add-Member -inputobject $objOutputUser -MemberType NoteProperty -Name mail -Value \"\"\r\n\r\n    $user = [System.Xml.Linq.XElement]::ReadFrom($reader)\r\n    if ($showOutput) {Write-Host Found an exported object... -ForegroundColor Green}\r\n\r\n    #object id\r\n    $outID=$user.Attribute('id').Value\r\n    if ($showOutput) {Write-Host ID: $outID}\r\n    $objOutputUser.ID=$outID\r\n\r\n    #object type\r\n    $outType=$user.Attribute('object-type').Value\r\n    if ($showOutput) {Write-Host Type: $outType}\r\n    $objOutputUser.Type=$outType\r\n\r\n    #dn\r\n    $outDN= $user.Element('unapplied-export').Element('delta').Attribute('dn').Value\r\n    if ($showOutput) {Write-Host DN: $outDN}\r\n    $objOutputUser.DN=$outDN\r\n\r\n    #operation\r\n    $outOperation= $user.Element('unapplied-export').Element('delta').Attribute('operation').Value\r\n    if ($showOutput) {Write-Host Operation: $outOperation}\r\n    $objOutputUser.operation=$outOperation\r\n\r\n    #now that we have the basics, go get the details\r\n\r\n    foreach ($attr in $user.Element('unapplied-export-hologram').Element('entry').Elements(\"attr\"))\r\n    {\r\n        $attrvalue=$attr.Attribute('name').Value\r\n        $internalvalue= $attr.Element('value').Value\r\n\r\n        switch ($attrvalue)\r\n        {\r\n            \"userPrincipalName\"\r\n            {\r\n                if ($showOutput) {Write-Host UPN: $internalvalue}\r\n                $objOutputUser.UPN=$internalvalue\r\n            }\r\n            \"displayName\"\r\n            {\r\n                if ($showOutput) {Write-Host displayName: $internalvalue}\r\n                $objOutputUser.displayName=$internalvalue\r\n            }\r\n            \"sourceAnchor\"\r\n            {\r\n                if ($showOutput) {Write-Host sourceAnchor: $internalvalue}\r\n                $objOutputUser.sourceAnchor=$internalvalue\r\n            }\r\n            \"alias\"\r\n            {\r\n                if ($showOutput) {Write-Host alias: $internalvalue}\r\n                $objOutputUser.alias=$internalvalue\r\n            }\r\n            \"proxyAddresses\"\r\n            {\r\n                if ($showOutput) {Write-Host primarySMTP: ($internalvalue -replace \"SMTP:\",\"\")}\r\n                $objOutputUser.primarySMTP=$internalvalue -replace \"SMTP:\",\"\"\r\n            }\r\n        }\r\n    }\r\n\r\n    $objOutputUsers += $objOutputUser\r\n\r\n    Write-Progress -activity \"Processing ${xmltoimport} in batches of ${batchsize}\" -status \"Batch ${outputfilecount}: \" -percentComplete (($objOutputUsers.Count / $batchsize) * 100)\r\n\r\n    #every so often, dump the processed users in case we blow up somewhere\r\n    if ($count % $batchsize -eq 0)\r\n    {\r\n        Write-Host Hit the maximum users processed without completion... -ForegroundColor Yellow\r\n\r\n        #export the collection of users as as CSV\r\n        Write-Host Writing processedusers${outputfilecount}.csv -ForegroundColor Yellow\r\n        $objOutputUsers | Export-Csv -path processedusers${outputfilecount}.csv -NoTypeInformation\r\n\r\n        #increment the output file counter\r\n        $outputfilecount+=1\r\n\r\n        #reset the collection and the user counter\r\n        $objOutputUsers = $null\r\n        $count=0\r\n    }\r\n\r\n    $count+=1\r\n\r\n    #need to bail out of the loop if no more users to process\r\n    if ($reader.NodeType -eq [System.Xml.XmlNodeType]::EndElement)\r\n    {\r\n        break\r\n    }\r\n\r\n} while ($reader.Read)\r\n\r\n#need to write out any users that didn't get picked up in a batch of 1000\r\n#export the collection of users as as CSV\r\nWrite-Host Writing processedusers${outputfilecount}.csv -ForegroundColor Yellow\r\n$objOutputUsers | Export-Csv -path processedusers${outputfilecount}.csv -NoTypeInformation\r\n```\r\n\r\n## <a name=\"next-steps\"></a>后续步骤\r\n**概述主题**  \r\n\r\n- [Azure AD Connect 同步：理解和自定义同步](active-directory-aadconnectsync-whatis.md)  \r\n- [将本地标识与 Azure Active Directory 集成](active-directory-aadconnect.md)  \r\n\r\n<!-- Update_Description: wording update -->\r\n"}