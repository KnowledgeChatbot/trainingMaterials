{"Title":"使用 Microsoft PlayReady 或 Apple FairPlay 保护 HLS 内容 - Azure","Description":"本主题概括介绍并演示了如何使用 Azure 媒体服务通过 Apple FairPlay 动态加密 HTTP Live Streaming (HLS) 内容。 它还演示了如何使用媒体服务许可证传送服务将 FairPlay 许可证传送到客户端。","Content":"# <a name=\"protect-your-hls-content-with-apple-fairplay-or-microsoft-playready\"></a>使用 Apple FairPlay 或 Microsoft PlayReady 保护 HLS 内容\r\n使用 Azure 媒体服务，可使用以下格式动态加密 HTTP Live Streaming (HLS) 内容：  \r\n\r\n* **AES-128 信封明文密钥**\r\n\r\n    整个区块使用 AES-128 CBC 模式进行加密。 iOS 和 OS X 播放器本身支持解密流。 有关详细信息，请参阅[使用 AES-128 动态加密和密钥传递服务](media-services-protect-with-aes128.md)。\r\n* **Apple FairPlay**\r\n\r\n    各视频和音频示例都使用 AES-128 CBC 模式进行加密。 FairPlay 流式处理 (FPS) 集成到设备操作系统，iOS 和 Apple TV 本身支持这项功能。 OS X 上的 Safari 通过加密媒体扩展 (EME) 接口支持来启用 FPS。\r\n* **Microsoft PlayReady**\r\n\r\n下图显示了 HLS + FairPlay 或 PlayReady 动态加密工作流。\r\n\r\n![动态加密工作流的图示](./media/media-services-content-protection-overview/media-services-content-protection-with-fairplay.png)\r\n\r\n本主题演示如何使用媒体服务通过 Apple FairPlay 动态加密 HLS 内容。 它还演示了如何使用媒体服务许可证传送服务将 FairPlay 许可证传送到客户端。\r\n\r\n> [!NOTE]\r\n> 如果还想要使用 PlayReady 加密 HLS 内容，则需要创建一个通用的内容密钥并将其与资产相关联。 还需要配置内容密钥的授权策略，如[使用 PlayReady 动态通用加密](media-services-protect-with-drm.md)中所述。\r\n>\r\n>\r\n\r\n## <a name=\"requirements-and-considerations\"></a>要求和注意事项\r\n\r\n在使用媒体服务传送通过 FairPlay 加密的 HLS 和传送 FairPlay 许可证时，需要以下各项：\r\n\r\n    - 一个 Azure 帐户。 有关详细信息，请参阅 [Azure 试用](https://www.azure.cn/pricing/1rmb-trial/?WT.mc_id=A261C142F)。\r\n    - 一个媒体服务帐户。若要创建媒体服务帐户，请参阅[使用 Azure 门户创建 Azure 媒体服务帐户](media-services-portal-create-account.md)。\r\n    - 注册 [Apple 开发计划](https://developer.apple.com/)。\r\n    - Apple 要求内容所有者获取 [部署包](https://developer.apple.com/contact/fps/)。 说明已使用媒体服务实现密钥安全模块 (KSM)，以及正在请求最终 FPS 包。 最终 FPS 包中有如何生成证书和获取应用程序密钥 (ASK) 的说明。 可使用 ASK 配置 FairPlay。 \r\n    - Azure 媒体服务 .NET SDK **3.6.0** 版本或更高版本。\r\n\r\n必须在媒体服务密钥传送端上设置以下各项：\r\n\r\n  * 应用证书 (AC)：这是一个包含私钥的 .pfx 文件。 创建此文件，并使用密码对其进行加密。\r\n\r\n       配置密钥传送策略时，必须提供该密码和 Base64 格式的 .pfx 文件。\r\n\r\n      以下步骤介绍如何为 FairPlay 生成 .pfx 证书文件：\r\n\r\n    1. 从 https://slproweb.com/products/Win32OpenSSL.html 安装 OpenSSL。\r\n\r\n        转到 Apple 提供的 FairPlay 证书和其他文件所在的文件夹。\r\n    2. 从命令行运行以下命令。 这会将 .cer 文件转换为 .pem 文件。\r\n\r\n        \"C:\\OpenSSL-Win32\\bin\\openssl.exe\" x509 -inform der -in fairplay.cer -out fairplay-out.pem\r\n    3. 从命令行运行以下命令。 这会将 .pem 文件转换为包含私钥的 .pfx 文件。 然后， OpenSSL 会要求提供 .pfx 文件的密码。\r\n\r\n        \"C:\\OpenSSL-Win32\\bin\\openssl.exe\" pkcs12 -export -out fairplay-out.pfx -inkey privatekey.pem -in fairplay-out.pem -passin file:privatekey-pem-pass.txt\r\n  * 应用证书密码：用于创建 .pfx 文件的密码。\r\n  * 应用证书密码 ID：必须上传密码，其方式与上传其他媒体服务密钥类似。 使用 ContentKeyType.FairPlayPfxPassword 枚举值获取媒体服务 ID。 需要在密钥传送策略选项中使用此 ID。\r\n  * iv：这是 16 字节的随机值。 该值必须与资产传送策略中的 iv 相匹配。 生成 iv 并将其放入以下两个位置：资产传送策略和密钥传送策略选项。\r\n  * ASK：使用 Apple 开发人员门户生成证书时会收到此密钥。 每个开发团队会收到唯一的 ASK。 请保存一份 ASK 副本，并将其存储在安全位置。 稍后需要将 ASK 作为 FairPlayAsk 配置到媒体服务。\r\n  * ASK ID：将 ASK 上传到媒体服务中时，将获取此 ID。 必须使用 ContentKeyType.FairPlayAsk 枚举值上传 ASK。 因此，将返回媒体服务 ID，在设置密钥传送策略选项时应使用此 ID。\r\n\r\n以下事项必须通过 FPS 客户端来设置：\r\n\r\n  * 应用证书 (AC)：这是一个包含公钥的 .cer/.der 文件，操作系统使用它来加密某些负载。 媒体服务需要了解它，因为播放器需要它。 密钥传送服务使用相应的私钥对其进行解密。\r\n\r\n若要播放 FairPlay 加密的流，需要先获取实际 ASK，然后生成实际证书。 该过程将创建所有三个部分：\r\n\r\n  * .der 文件\r\n  * .pfx 文件\r\n  * .pfx 的密码\r\n\r\n以下客户端支持使用 AES-128 CBC 加密的 HLS：OS X 上的 Safari、Apple TV、iOS。\r\n\r\n## <a name=\"configure-fairplay-dynamic-encryption-and-license-delivery-services\"></a>配置 FairPlay 动态加密和许可证传送服务\r\n下面是使用 FairPlay 保护资产的常规步骤，这些步骤使用媒体服务许可证传送服务，也使用动态加密。\r\n\r\n1. 创建资产并将文件上传到资产。\r\n2. 将包含文件的资产编码为自适应比特率 MP4 集。\r\n3. 创建内容密钥并将其与编码资产相关联。  \r\n4. 配置内容密钥授权策略。 指定以下项：\r\n\r\n   * 传送方法（在本例中为 FairPlay）。\r\n   * FairPlay 策略选项配置。 有关如何配置 FairPlay 的详细信息，请参阅以下示例中的 ConfigureFairPlayPolicyOptions() 方法。\r\n\r\n     > [!NOTE]\r\n     > 通常，可能只需配置一次 FairPlay 策略选项，因为仅有一套证书和 ASK。\r\n     >\r\n     >\r\n   * 限制（开放或令牌）。\r\n   * 特定于密钥传送类型的信息，用于定义将密钥传送到客户端的方式。\r\n5. 配置资产传送策略。 传送策略配置包括：\r\n\r\n   * 传送协议 (HLS)。\r\n   * 动态加密类型（常用的 CBC 加密）。\r\n   * 许可证获取 URL。\r\n\r\n     > [!NOTE]\r\n     > 如果要传送使用 FairPlay 和其他数字版权管理 (DRM) 系统加密的流，则必须配置单独的传送策略：\r\n     >\r\n     > * 一个 IAssetDeliveryPolicy，用于使用通用加密 (CENC) (PlayReady + Widevine) 和 Smooth with PlayReady 配置 HTTP 上的动态自适应流式处理 (DASH)\r\n     > * 另一个 IAssetDeliveryPolicy 用来配置 HLS 的 FairPlay\r\n     >\r\n     >\r\n6. 创建 OnDemand 定位符以获取流式处理 URL。\r\n\r\n## <a name=\"use-fairplay-key-delivery-by-player-apps\"></a>使用播放器应用执行的 FairPlay 密钥传送\r\n可以通过使用 iOS SDK 开发播放器应用。 若要能够播放 FairPlay 内容，必须实现许可证交换协议。 此协议不由 Apple 指定。 而是取决于每个应用发送密钥传送请求的方式。 媒体服务 FairPlay 密钥传送服务需要 SPC 为采用以下形式的 www-form-url 编码后消息：\r\n\r\n    spc=<Base64 encoded SPC>\r\n\r\n> [!NOTE]\r\n> Azure Media Player 不支持现成的 FairPlay 播放。 若要获得 MAC OS X 上的 FairPlay 播放，需要通过 Apple 开发人员帐户获得示例播放器。\r\n>\r\n>\r\n\r\n## <a name=\"streaming-urls\"></a>流 URL\r\n如果使用了多个 DRM 加密资产，则应在流式处理 URL 中使用加密标记：（format='m3u8-aapl'， encryption='xxx'）。\r\n\r\n请注意以下事项：\r\n\r\n* 仅可指定零个或一个加密类型。\r\n* 如果资产仅应用了一种加密，则无需在 URL 中指定加密类型。\r\n* 加密类型不区分大小写。\r\n* 可以指定以下加密类型：  \r\n  * cenc：通用加密 (PlayReady)\r\n  * cbcs-aapl：Fairplay\r\n  * cbc：AES 信封加密\r\n\r\n## <a name=\"create-and-configure-a-visual-studio-project\"></a>创建和配置 Visual Studio 项目\r\n\r\n1. 设置开发环境，并在 app.config 文件中填充连接信息，如[使用 .NET 进行媒体服务开发](media-services-dotnet-how-to-use.md)中所述。 \r\n2. 将以下元素添加到 app.config 文件中定义的 appSettings：\r\n\r\n        <add key=\"Issuer\" value=\"http://testacs.com\"/>\r\n        <add key=\"Audience\" value=\"urn:test\"/>\r\n\r\n## <a name=\"example\"></a>示例\r\n\r\n以下示例演示使用媒体服务传送使用 FairPlay 加密的内容的能力。 适用于 .NET 的 Azure 媒体服务 SDK 版本 3.6.0 中引入了此功能。 \r\n\r\n使用本部分中所示的代码覆盖 Program.cs 文件中的代码。\r\n\r\n>[!NOTE]\r\n>不同 AMS 策略的策略限制为 1,000,000 个（例如，对于定位器策略或 ContentKeyAuthorizationPolicy）。 如果始终使用相同的日期/访问权限，则应使用相同的策略 ID，例如，用于要长期就地保留的定位符的策略（非上传策略）。 有关详细信息，请参阅[此](media-services-dotnet-manage-entities.md#limit-access-policies)主题。\r\n\r\n请务必将变量更新为指向输入文件所在的文件夹。\r\n\r\n    using System;\r\n    using System.Collections.Generic;\r\n    using System.Configuration;\r\n    using System.IO;\r\n    using System.Linq;\r\n    using System.Threading;\r\n    using Microsoft.WindowsAzure.MediaServices.Client;\r\n    using Microsoft.WindowsAzure.MediaServices.Client.ContentKeyAuthorization;\r\n    using Microsoft.WindowsAzure.MediaServices.Client.DynamicEncryption;\r\n    using Microsoft.WindowsAzure.MediaServices.Client.FairPlay;\r\n    using Newtonsoft.Json;\r\n    using System.Security.Cryptography.X509Certificates;\r\n\r\n    namespace DynamicEncryptionWithFairPlay\r\n    {\r\n        class Program\r\n        {\r\n        // Read values from the App.config file.\r\n        private static readonly string _AADTenantDomain =\r\n        ConfigurationManager.AppSettings[\"AADTenantDomain\"];\r\n        private static readonly string _RESTAPIEndpoint =\r\n        ConfigurationManager.AppSettings[\"MediaServiceRESTAPIEndpoint\"];\r\n\r\n        private static readonly Uri _sampleIssuer =\r\n            new Uri(ConfigurationManager.AppSettings[\"Issuer\"]);\r\n        private static readonly Uri _sampleAudience =\r\n            new Uri(ConfigurationManager.AppSettings[\"Audience\"]);\r\n\r\n        // Field for service context.\r\n        private static CloudMediaContext _context = null;\r\n\r\n        private static readonly string _mediaFiles =\r\n            Path.GetFullPath(@\"../..\\Media\");\r\n\r\n        private static readonly string _singleMP4File =\r\n            Path.Combine(_mediaFiles, @\"BigBuckBunny.mp4\");\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            var tokenCredentials = new AzureAdTokenCredentials(_AADTenantDomain, AzureEnvironments.AzureChinaCloudEnvironment);\r\n            var tokenProvider = new AzureAdTokenProvider(tokenCredentials);\r\n\r\n            _context = new CloudMediaContext(new Uri(_RESTAPIEndpoint), tokenProvider);\r\n\r\n            bool tokenRestriction = false;\r\n            string tokenTemplateString = null;\r\n\r\n            IAsset asset = UploadFileAndCreateAsset(_singleMP4File);\r\n            Console.WriteLine(\"Uploaded asset: {0}\", asset.Id);\r\n\r\n            IAsset encodedAsset = EncodeToAdaptiveBitrateMP4Set(asset);\r\n            Console.WriteLine(\"Encoded asset: {0}\", encodedAsset.Id);\r\n\r\n            IContentKey key = CreateCommonCBCTypeContentKey(encodedAsset);\r\n            Console.WriteLine(\"Created key {0} for the asset {1} \", key.Id, encodedAsset.Id);\r\n            Console.WriteLine(\"FairPlay License Key delivery URL: {0}\", key.GetKeyDeliveryUrl(ContentKeyDeliveryType.FairPlay));\r\n            Console.WriteLine();\r\n\r\n            if (tokenRestriction)\r\n            tokenTemplateString = AddTokenRestrictedAuthorizationPolicy(key);\r\n            else\r\n            AddOpenAuthorizationPolicy(key);\r\n\r\n            Console.WriteLine(\"Added authorization policy: {0}\", key.AuthorizationPolicyId);\r\n            Console.WriteLine();\r\n\r\n            CreateAssetDeliveryPolicy(encodedAsset, key);\r\n            Console.WriteLine(\"Created asset delivery policy. \\n\");\r\n            Console.WriteLine();\r\n\r\n            if (tokenRestriction && !String.IsNullOrEmpty(tokenTemplateString))\r\n            {\r\n            // Deserializes a string containing an Xml representation of a TokenRestrictionTemplate\r\n            // back into a TokenRestrictionTemplate class instance.\r\n            TokenRestrictionTemplate tokenTemplate =\r\n                TokenRestrictionTemplateSerializer.Deserialize(tokenTemplateString);\r\n\r\n            // Generate a test token based on the the data in the given TokenRestrictionTemplate.\r\n            // Note, you need to pass the key id Guid because we specified\r\n            // TokenClaim.ContentKeyIdentifierClaim in during the creation of TokenRestrictionTemplate.\r\n            Guid rawkey = EncryptionUtils.GetKeyIdAsGuid(key.Id);\r\n            string testToken = TokenRestrictionTemplateSerializer.GenerateTestToken(tokenTemplate, null, rawkey,\r\n                                        DateTime.UtcNow.AddDays(365));\r\n            Console.WriteLine(\"The authorization token is:\\nBearer {0}\", testToken);\r\n            Console.WriteLine();\r\n            }\r\n\r\n            string url = GetStreamingOriginLocator(encodedAsset);\r\n            Console.WriteLine(\"Encrypted HLS URL: {0}/manifest(format=m3u8-aapl)\", url);\r\n\r\n            Console.ReadLine();\r\n        }\r\n\r\n        static public IAsset UploadFileAndCreateAsset(string singleFilePath)\r\n        {\r\n            if (!File.Exists(singleFilePath))\r\n            {\r\n            Console.WriteLine(\"File does not exist.\");\r\n            return null;\r\n            }\r\n\r\n            var assetName = Path.GetFileNameWithoutExtension(singleFilePath);\r\n            IAsset inputAsset = _context.Assets.Create(assetName, AssetCreationOptions.None);\r\n\r\n            var assetFile = inputAsset.AssetFiles.Create(Path.GetFileName(singleFilePath));\r\n\r\n            Console.WriteLine(\"Created assetFile {0}\", assetFile.Name);\r\n\r\n            Console.WriteLine(\"Upload {0}\", assetFile.Name);\r\n\r\n            assetFile.Upload(singleFilePath);\r\n            Console.WriteLine(\"Done uploading {0}\", assetFile.Name);\r\n\r\n            return inputAsset;\r\n        }\r\n\r\n        static public IAsset EncodeToAdaptiveBitrateMP4Set(IAsset inputAsset)\r\n        {\r\n            var encodingPreset = \"Adaptive Streaming\";\r\n\r\n            IJob job = _context.Jobs.Create(String.Format(\"Encoding {0}\", inputAsset.Name));\r\n\r\n            var mediaProcessors =\r\n            _context.MediaProcessors.Where(p => p.Name.Contains(\"Media Encoder Standard\")).ToList();\r\n\r\n            var latestMediaProcessor =\r\n            mediaProcessors.OrderBy(mp => new Version(mp.Version)).LastOrDefault();\r\n\r\n            ITask encodeTask = job.Tasks.AddNew(\"Encoding\", latestMediaProcessor, encodingPreset, TaskOptions.None);\r\n            encodeTask.InputAssets.Add(inputAsset);\r\n            encodeTask.OutputAssets.AddNew(String.Format(\"{0} as {1}\", inputAsset.Name, encodingPreset), AssetCreationOptions.StorageEncrypted);\r\n\r\n            job.StateChanged += new EventHandler<JobStateChangedEventArgs>(JobStateChanged);\r\n            job.Submit();\r\n            job.GetExecutionProgressTask(CancellationToken.None).Wait();\r\n\r\n            return job.OutputMediaAssets[0];\r\n        }\r\n\r\n        static public IContentKey CreateCommonCBCTypeContentKey(IAsset asset)\r\n        {\r\n            // Create HLS SAMPLE AES encryption content key\r\n            Guid keyId = Guid.NewGuid();\r\n            byte[] contentKey = GetRandomBuffer(16);\r\n\r\n            IContentKey key = _context.ContentKeys.Create(\r\n                        keyId,\r\n                        contentKey,\r\n                        \"ContentKey\",\r\n                        ContentKeyType.CommonEncryptionCbcs);\r\n\r\n            // Associate the key with the asset.\r\n            asset.ContentKeys.Add(key);\r\n\r\n            return key;\r\n        }\r\n\r\n\r\n        static public void AddOpenAuthorizationPolicy(IContentKey contentKey)\r\n        {\r\n            // Create ContentKeyAuthorizationPolicy with Open restrictions\r\n            // and create authorization policy          \r\n\r\n            List<ContentKeyAuthorizationPolicyRestriction> restrictions = new List<ContentKeyAuthorizationPolicyRestriction>\r\n                    {\r\n                    new ContentKeyAuthorizationPolicyRestriction\r\n                    {\r\n                        Name = \"Open\",\r\n                        KeyRestrictionType = (int)ContentKeyRestrictionType.Open,\r\n                        Requirements = null\r\n                    }\r\n                    };\r\n\r\n\r\n            // Configure FairPlay policy option.\r\n            string FairPlayConfiguration = ConfigureFairPlayPolicyOptions();\r\n\r\n            IContentKeyAuthorizationPolicyOption FairPlayPolicy =\r\n            _context.ContentKeyAuthorizationPolicyOptions.Create(\"\",\r\n            ContentKeyDeliveryType.FairPlay,\r\n            restrictions,\r\n            FairPlayConfiguration);\r\n\r\n\r\n            IContentKeyAuthorizationPolicy contentKeyAuthorizationPolicy = _context.\r\n                ContentKeyAuthorizationPolicies.\r\n                CreateAsync(\"Deliver Common CBC Content Key with no restrictions\").\r\n                Result;\r\n\r\n            contentKeyAuthorizationPolicy.Options.Add(FairPlayPolicy);\r\n\r\n            // Associate the content key authorization policy with the content key.\r\n            contentKey.AuthorizationPolicyId = contentKeyAuthorizationPolicy.Id;\r\n            contentKey = contentKey.UpdateAsync().Result;\r\n        }\r\n\r\n        public static string AddTokenRestrictedAuthorizationPolicy(IContentKey contentKey)\r\n        {\r\n            string tokenTemplateString = GenerateTokenRequirements();\r\n\r\n            List<ContentKeyAuthorizationPolicyRestriction> restrictions = new List<ContentKeyAuthorizationPolicyRestriction>\r\n                    {\r\n                    new ContentKeyAuthorizationPolicyRestriction\r\n                    {\r\n                        Name = \"Token Authorization Policy\",\r\n                        KeyRestrictionType = (int)ContentKeyRestrictionType.TokenRestricted,\r\n                        Requirements = tokenTemplateString,\r\n                    }\r\n                    };\r\n\r\n            // Configure FairPlay policy option.\r\n            string FairPlayConfiguration = ConfigureFairPlayPolicyOptions();\r\n\r\n\r\n            IContentKeyAuthorizationPolicyOption FairPlayPolicy =\r\n            _context.ContentKeyAuthorizationPolicyOptions.Create(\"Token option\",\r\n                   ContentKeyDeliveryType.FairPlay,\r\n                   restrictions,\r\n                   FairPlayConfiguration);\r\n\r\n            IContentKeyAuthorizationPolicy contentKeyAuthorizationPolicy = _context.\r\n                ContentKeyAuthorizationPolicies.\r\n                CreateAsync(\"Deliver Common CBC Content Key with token restrictions\").\r\n                Result;\r\n\r\n            contentKeyAuthorizationPolicy.Options.Add(FairPlayPolicy);\r\n\r\n            // Associate the content key authorization policy with the content key\r\n            contentKey.AuthorizationPolicyId = contentKeyAuthorizationPolicy.Id;\r\n            contentKey = contentKey.UpdateAsync().Result;\r\n\r\n            return tokenTemplateString;\r\n        }\r\n\r\n        private static string ConfigureFairPlayPolicyOptions()\r\n        {\r\n            // For testing you can provide all zeroes for ASK bytes together with the cert from Apple FPS SDK.\r\n            // However, for production you must use a real ASK from Apple bound to a real prod certificate.\r\n            byte[] askBytes = Guid.NewGuid().ToByteArray();\r\n            var askId = Guid.NewGuid();\r\n            // Key delivery retrieves askKey by askId and uses this key to generate the response.\r\n            IContentKey askKey = _context.ContentKeys.Create(\r\n                        askId,\r\n                        askBytes,\r\n                        \"askKey\",\r\n                        ContentKeyType.FairPlayASk);\r\n\r\n            //Customer password for creating the .pfx file.\r\n            string pfxPassword = \"<customer password for creating the .pfx file>\";\r\n            // Key delivery retrieves pfxPasswordKey by pfxPasswordId and uses this key to generate the response.\r\n            var pfxPasswordId = Guid.NewGuid();\r\n            byte[] pfxPasswordBytes = System.Text.Encoding.UTF8.GetBytes(pfxPassword);\r\n            IContentKey pfxPasswordKey = _context.ContentKeys.Create(\r\n                        pfxPasswordId,\r\n                        pfxPasswordBytes,\r\n                        \"pfxPasswordKey\",\r\n                        ContentKeyType.FairPlayPfxPassword);\r\n\r\n            // iv - 16 bytes random value, must match the iv in the asset delivery policy.\r\n            byte[] iv = Guid.NewGuid().ToByteArray();\r\n\r\n            //Specify the .pfx file created by the customer.\r\n            var appCert = new X509Certificate2(\"path to the .pfx file created by the customer\", pfxPassword, X509KeyStorageFlags.Exportable);\r\n\r\n            string FairPlayConfiguration =\r\n            Microsoft.WindowsAzure.MediaServices.Client.FairPlay.FairPlayConfiguration.CreateSerializedFairPlayOptionConfiguration(\r\n                appCert,\r\n                pfxPassword,\r\n                pfxPasswordId,\r\n                askId,\r\n                iv);\r\n\r\n            return FairPlayConfiguration;\r\n        }\r\n\r\n        static private string GenerateTokenRequirements()\r\n        {\r\n            TokenRestrictionTemplate template = new TokenRestrictionTemplate(TokenType.SWT);\r\n\r\n            template.PrimaryVerificationKey = new SymmetricVerificationKey();\r\n            template.AlternateVerificationKeys.Add(new SymmetricVerificationKey());\r\n            template.Audience = _sampleAudience.ToString();\r\n            template.Issuer = _sampleIssuer.ToString();\r\n            template.RequiredClaims.Add(TokenClaim.ContentKeyIdentifierClaim);\r\n\r\n            return TokenRestrictionTemplateSerializer.Serialize(template);\r\n        }\r\n\r\n        static public void CreateAssetDeliveryPolicy(IAsset asset, IContentKey key)\r\n        {\r\n            var kdPolicy = _context.ContentKeyAuthorizationPolicies.Where(p => p.Id == key.AuthorizationPolicyId).Single();\r\n\r\n            var kdOption = kdPolicy.Options.Single(o => o.KeyDeliveryType == ContentKeyDeliveryType.FairPlay);\r\n\r\n            FairPlayConfiguration configFP = JsonConvert.DeserializeObject<FairPlayConfiguration>(kdOption.KeyDeliveryConfiguration);\r\n\r\n            // Get the FairPlay license service URL.\r\n            Uri acquisitionUrl = key.GetKeyDeliveryUrl(ContentKeyDeliveryType.FairPlay);\r\n\r\n            // The reason the below code replaces \"https://\" with \"skd://\" is because\r\n            // in the IOS player sample code which you obtained in Apple developer account,\r\n            // the player only recognizes a Key URL that starts with skd://.\r\n            // However, if you are using a customized player,\r\n            // you can choose whatever protocol you want.\r\n            // For example, \"https\".\r\n\r\n            Dictionary<AssetDeliveryPolicyConfigurationKey, string> assetDeliveryPolicyConfiguration =\r\n            new Dictionary<AssetDeliveryPolicyConfigurationKey, string>\r\n            {\r\n                    {AssetDeliveryPolicyConfigurationKey.FairPlayLicenseAcquisitionUrl, acquisitionUrl.ToString().Replace(\"https://\", \"skd://\")},\r\n                    {AssetDeliveryPolicyConfigurationKey.CommonEncryptionIVForCbcs, configFP.ContentEncryptionIV}\r\n            };\r\n\r\n            var assetDeliveryPolicy = _context.AssetDeliveryPolicies.Create(\r\n                \"AssetDeliveryPolicy\",\r\n            AssetDeliveryPolicyType.DynamicCommonEncryptionCbcs,\r\n            AssetDeliveryProtocol.HLS,\r\n            assetDeliveryPolicyConfiguration);\r\n\r\n            // Add AssetDelivery Policy to the asset\r\n            asset.DeliveryPolicies.Add(assetDeliveryPolicy);\r\n\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets the streaming origin locator.\r\n        /// </summary>\r\n        /// <param name=\"assets\"></param>\r\n        /// <returns></returns>\r\n        static public string GetStreamingOriginLocator(IAsset asset)\r\n        {\r\n\r\n            // Get a reference to the streaming manifest file from the  \r\n            // collection of files in the asset.\r\n\r\n            var assetFile = asset.AssetFiles.Where(f => f.Name.ToLower().\r\n                         EndsWith(\".ism\")).\r\n                         FirstOrDefault();\r\n\r\n            // Create a 30-day readonly access policy.\r\n            IAccessPolicy policy = _context.AccessPolicies.Create(\"Streaming policy\",\r\n            TimeSpan.FromDays(30),\r\n            AccessPermissions.Read);\r\n\r\n            // Create a locator to the streaming content on an origin.\r\n            ILocator originLocator = _context.Locators.CreateLocator(LocatorType.OnDemandOrigin, asset,\r\n            policy,\r\n            DateTime.UtcNow.AddMinutes(-5));\r\n\r\n            // Create a URL to the manifest file.\r\n            return originLocator.Path + assetFile.Name;\r\n        }\r\n\r\n        static private void JobStateChanged(object sender, JobStateChangedEventArgs e)\r\n        {\r\n            Console.WriteLine(string.Format(\"{0}\\n  State: {1}\\n  Time: {2}\\n\\n\",\r\n            ((IJob)sender).Name,\r\n            e.CurrentState,\r\n            DateTime.UtcNow.ToString(@\"yyyy_M_d__hh_mm_ss\")));\r\n        }\r\n\r\n        static private byte[] GetRandomBuffer(int length)\r\n        {\r\n            var returnValue = new byte[length];\r\n\r\n            using (var rng =\r\n            new System.Security.Cryptography.RNGCryptoServiceProvider())\r\n            {\r\n            rng.GetBytes(returnValue);\r\n            }\r\n\r\n            return returnValue;\r\n        }\r\n        }\r\n    }\r\n\r\n\r\n<!--Update_Description: update code to use AAD token instead of ACS-->"}