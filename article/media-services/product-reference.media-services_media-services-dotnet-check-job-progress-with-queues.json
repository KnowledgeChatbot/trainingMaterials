{"Title":"使用 Azure 队列存储通过 .NET 监视媒体服务作业通知","Description":"了解如何使用 Azure 队列存储监视媒体服务作业通知。 代码示例用 C# 编写，并使用用于 .NET 的媒体服务 SDK。","Content":"# <a name=\"use-azure-queue-storage-to-monitor-media-services-job-notifications-with-net\"></a>使用 Azure 队列存储通过 .NET 监视媒体服务作业通知\r\n运行编码作业时，通常需要采用某种方式来跟踪作业进度。 可以配置媒体服务将通知传送到 [Azure 队列存储](../storage/storage-dotnet-how-to-use-queues.md)。 然后可以通过从队列存储获取通知来监视作业进度。 \r\n\r\n用户可以从任何位置访问已传给到队列存储中的消息。 队列存储消息体系结构十分可靠，且伸缩性极高。 建议使用其他方法轮询消息的队列存储。\r\n\r\n一种常见的媒体服务通知侦听方案是：正在开发一个内容管理系统，完成编码作业后，该系统需要执行一些其他任务（例如触发工作流的下一步骤或者发布内容）。\r\n\r\n本主题说明如何从队列存储获取通知消息。  \r\n\r\n## <a name=\"considerations\"></a>注意事项\r\n开发使用队列存储的媒体服务应用程序时，请注意以下几点：\r\n\r\n* 队列存储不保证按照先进先出 (FIFO) 的顺序传递消息。 有关详细信息，请参阅 [Azure 队列和 Azure 服务总线队列比较与对照](https://msdn.microsoft.com/library/azure/hh767287.aspx)。\r\n* 队列存储不是推送服务。 必须轮询队列。\r\n* 可以有任意数目的队列。 有关详细信息，请参阅 [队列服务 REST API](https://docs.microsoft.com/rest/api/storageservices/Queue-Service-REST-API)。\r\n* 队列存储存在一些需注意的限制和细节问题。 相关说明请参阅 [Azure 队列和 Azure 服务总线队列比较与对照](/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted)。\r\n\r\n## <a name=\"net-code-example\"></a>.NET 代码示例\r\n\r\n本部分中的代码示例执行以下操作：\r\n\r\n1. 定义一个映射为通知消息格式的 **EncodingJobMessage** 类。 代码将从队列接收到的消息反序列化为 **EncodingJobMessage** 类型的对象。\r\n2. 从 app.config 文件中加载媒体服务和存储帐户信息。 本代码示例使用此信息创建 **CloudMediaContext** 和 **CloudQueue** 对象。\r\n3. 创建接收编码作业相关通知消息的队列。\r\n4. 创建一个映射到队列的通知终结点。\r\n5. 将通知终结点附加到作业，并提交编码作业。 可以将多个通知终结点附加到一个作业。\r\n6. 将 **NotificationJobState.FinalStatesOnly** 传递到 **AddNew** 方法。 （本例中，只想了解作业处理的最终状态。）\r\n\r\n    ```\r\n    job.JobNotificationSubscriptions.AddNew(NotificationJobState.FinalStatesOnly, _notificationEndPoint);\r\n    ```\r\n7. 如果传递 **NotificationJobState.All**，则会收到以下所有状态更改通知：已排队、已计划、处理中和已完成。 但如前所述，队列存储不保证按顺序传递。 若要对消息排序，请使用 **Timestamp** 属性（在以下示例的 **EncodingJobMessage** 类型中定义）。 可能出现重复消息。 若要检查重复项，请使用 **ETag 属性**（在 **EncodingJobMessage** 类型中定义）。 此外，可能会跳过某些状态更改通知。\r\n8. 每 10 秒检查一次队列，等待作业进入已完成状态。 处理消息后删除消息。\r\n9. 删除队列和通知终结点。\r\n\r\n> [!NOTE]\r\n> 监视作业状态的建议方法是侦听通知消息，如以下示例所示。\r\n>\r\n> 或者，可以使用 IJob.State 属性检查作业状态。  在 **IJob** 的状态设置为“已完成”之前，可能会先收到一条指示作业已完成的通知消息。 IJob.State 属性在延迟片刻之后反映正确的状态。\r\n>\r\n>\r\n\r\n### <a name=\"create-and-configure-a-visual-studio-project\"></a>创建和配置 Visual Studio 项目\r\n\r\n1. 设置开发环境，并在 app.config 文件中填充连接信息，如[使用 .NET 进行媒体服务开发](media-services-dotnet-how-to-use.md)中所述。 \r\n2. 创建新的文件夹（文件夹可以位于本地驱动器上的任何位置），然后复制需要编码和流式处理或渐进式下载的 .mp4 文件。 在此示例中，我们使用了“C:\\Media”路径。\r\n\r\n### <a name=\"code\"></a>代码\r\n\r\n```\r\nusing System;\r\nusing System.Linq;\r\nusing System.Configuration;\r\nusing System.IO;\r\nusing System.Threading;\r\nusing System.Collections.Generic;\r\nusing Microsoft.WindowsAzure.MediaServices.Client;\r\nusing Microsoft.WindowsAzure.Storage;\r\nusing Microsoft.WindowsAzure.Storage.Queue;\r\nusing System.Runtime.Serialization.Json;\r\n\r\nnamespace JobNotification\r\n{\r\n    public class EncodingJobMessage\r\n    {\r\n        // MessageVersion is used for version control.\r\n        public String MessageVersion { get; set; }\r\n\r\n        // Type of the event. Valid values are\r\n        // JobStateChange and NotificationEndpointRegistration.\r\n        public String EventType { get; set; }\r\n\r\n        // ETag is used to help the customer detect if\r\n        // the message is a duplicate of another message previously sent.\r\n        public String ETag { get; set; }\r\n\r\n        // Time of occurrence of the event.\r\n        public String TimeStamp { get; set; }\r\n\r\n        // Collection of values specific to the event.\r\n\r\n        // For the JobStateChange event the values are:\r\n        //     JobId - Id of the Job that triggered the notification.\r\n        //     NewState- The new state of the Job. Valid values are:\r\n        //          Scheduled, Processing, Canceling, Cancelled, Error, Finished\r\n        //     OldState- The old state of the Job. Valid values are:\r\n        //          Scheduled, Processing, Canceling, Cancelled, Error, Finished\r\n\r\n        // For the NotificationEndpointRegistration event the values are:\r\n        //     NotificationEndpointId- Id of the NotificationEndpoint\r\n        //          that triggered the notification.\r\n        //     State- The state of the Endpoint.\r\n        //          Valid values are: Registered and Unregistered.\r\n\r\n        public IDictionary<string, object> Properties { get; set; }\r\n    }\r\n\r\n    class Program\r\n    {\r\n\r\n        // Read values from the App.config file.\r\n        private static readonly string _AADTenantDomain =\r\n            ConfigurationManager.AppSettings[\"AADTenantDomain\"];\r\n        private static readonly string _RESTAPIEndpoint =\r\n            ConfigurationManager.AppSettings[\"MediaServiceRESTAPIEndpoint\"];\r\n        private static readonly string _StorageConnectionString = \r\n            ConfigurationManager.AppSettings[\"StorageConnectionString\"];\r\n\r\n        private static CloudMediaContext _context = null;\r\n        private static CloudQueue _queue = null;\r\n        private static INotificationEndPoint _notificationEndPoint = null;\r\n\r\n        private static readonly string _singleInputMp4Path =\r\n            Path.GetFullPath(@\"C:\\Media\\BigBuckBunny.mp4\");\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            string endPointAddress = Guid.NewGuid().ToString();\r\n\r\n            // Create the context.\r\n            var tokenCredentials = new AzureAdTokenCredentials(_AADTenantDomain, AzureEnvironments.AzureChinaCloudEnvironment);\r\n            var tokenProvider = new AzureAdTokenProvider(tokenCredentials);\r\n\r\n            _context = new CloudMediaContext(new Uri(_RESTAPIEndpoint), tokenProvider);\r\n\r\n            // Create the queue that will be receiving the notification messages.\r\n            _queue = CreateQueue(_StorageConnectionString, endPointAddress);\r\n\r\n            // Create the notification point that is mapped to the queue.\r\n            _notificationEndPoint =\r\n                    _context.NotificationEndPoints.Create(\r\n                    Guid.NewGuid().ToString(), NotificationEndPointType.AzureQueue, endPointAddress);\r\n\r\n\r\n            if (_notificationEndPoint != null)\r\n            {\r\n                IJob job = SubmitEncodingJobWithNotificationEndPoint(_singleInputMp4Path);\r\n                WaitForJobToReachedFinishedState(job.Id);\r\n            }\r\n\r\n            // Clean up.\r\n            _queue.Delete();\r\n            _notificationEndPoint.Delete();\r\n        }\r\n\r\n\r\n        static public CloudQueue CreateQueue(string storageAccountConnectionString, string endPointAddress)\r\n        {\r\n            CloudStorageAccount storageAccount = CloudStorageAccount.Parse(storageAccountConnectionString);\r\n\r\n            // Create the queue client\r\n            CloudQueueClient queueClient = storageAccount.CreateCloudQueueClient();\r\n\r\n            // Retrieve a reference to a queue\r\n            CloudQueue queue = queueClient.GetQueueReference(endPointAddress);\r\n\r\n            // Create the queue if it doesn't already exist\r\n            queue.CreateIfNotExists();\r\n\r\n            return queue;\r\n        }\r\n\r\n\r\n        public static IJob SubmitEncodingJobWithNotificationEndPoint(string inputMediaFilePath)\r\n        {\r\n            // Declare a new job.\r\n            IJob job = _context.Jobs.Create(\"My MP4 to Smooth Streaming encoding job\");\r\n\r\n            //Create an encrypted asset and upload the mp4.\r\n            IAsset asset = CreateAssetAndUploadSingleFile(AssetCreationOptions.StorageEncrypted,\r\n                inputMediaFilePath);\r\n\r\n            // Get a media processor reference, and pass to it the name of the\r\n            // processor to use for the specific task.\r\n            IMediaProcessor processor = GetLatestMediaProcessorByName(\"Media Encoder Standard\");\r\n\r\n            // Create a task with the conversion details, using a configuration file.\r\n            ITask task = job.Tasks.AddNew(\"My encoding Task\",\r\n                processor,\r\n                \"Adaptive Streaming\",\r\n                Microsoft.WindowsAzure.MediaServices.Client.TaskOptions.None);\r\n\r\n            // Specify the input asset to be encoded.\r\n            task.InputAssets.Add(asset);\r\n\r\n            // Add an output asset to contain the results of the job.\r\n            task.OutputAssets.AddNew(\"Output asset\",\r\n                AssetCreationOptions.None);\r\n\r\n            // Add a notification point to the job. You can add multiple notification points.  \r\n            job.JobNotificationSubscriptions.AddNew(NotificationJobState.FinalStatesOnly,\r\n                _notificationEndPoint);\r\n\r\n            job.Submit();\r\n\r\n            return job;\r\n        }\r\n\r\n        public static void WaitForJobToReachedFinishedState(string jobId)\r\n        {\r\n            int expectedState = (int)JobState.Finished;\r\n            int timeOutInSeconds = 600;\r\n\r\n            bool jobReachedExpectedState = false;\r\n            DateTime startTime = DateTime.Now;\r\n            int jobState = -1;\r\n\r\n            while (!jobReachedExpectedState)\r\n            {\r\n                // Specify how often you want to get messages from the queue.\r\n                Thread.Sleep(TimeSpan.FromSeconds(10));\r\n\r\n                foreach (var message in _queue.GetMessages(10))\r\n                {\r\n                    using (Stream stream = new MemoryStream(message.AsBytes))\r\n                    {\r\n                        DataContractJsonSerializerSettings settings = new DataContractJsonSerializerSettings();\r\n                        settings.UseSimpleDictionaryFormat = true;\r\n                        DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(EncodingJobMessage), settings);\r\n                        EncodingJobMessage encodingJobMsg = (EncodingJobMessage)ser.ReadObject(stream);\r\n\r\n                        Console.WriteLine();\r\n\r\n                        // Display the message information.\r\n                        Console.WriteLine(\"EventType: {0}\", encodingJobMsg.EventType);\r\n                        Console.WriteLine(\"MessageVersion: {0}\", encodingJobMsg.MessageVersion);\r\n                        Console.WriteLine(\"ETag: {0}\", encodingJobMsg.ETag);\r\n                        Console.WriteLine(\"TimeStamp: {0}\", encodingJobMsg.TimeStamp);\r\n                        foreach (var property in encodingJobMsg.Properties)\r\n                        {\r\n                            Console.WriteLine(\"    {0}: {1}\", property.Key, property.Value);\r\n                        }\r\n\r\n                        // We are only interested in messages\r\n                        // where EventType is \"JobStateChange\".\r\n                        if (encodingJobMsg.EventType == \"JobStateChange\")\r\n                        {\r\n                            string JobId = (String)encodingJobMsg.Properties.Where(j => j.Key == \"JobId\").FirstOrDefault().Value;\r\n                            if (JobId == jobId)\r\n                            {\r\n                                string oldJobStateStr = (String)encodingJobMsg.Properties.\r\n                                                            Where(j => j.Key == \"OldState\").FirstOrDefault().Value;\r\n                                string newJobStateStr = (String)encodingJobMsg.Properties.\r\n                                                            Where(j => j.Key == \"NewState\").FirstOrDefault().Value;\r\n\r\n                                JobState oldJobState = (JobState)Enum.Parse(typeof(JobState), oldJobStateStr);\r\n                                JobState newJobState = (JobState)Enum.Parse(typeof(JobState), newJobStateStr);\r\n\r\n                                if (newJobState == (JobState)expectedState)\r\n                                {\r\n                                    Console.WriteLine(\"job with Id: {0} reached expected state: {1}\",\r\n                                        jobId, newJobState);\r\n                                    jobReachedExpectedState = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    // Delete the message after we've read it.\r\n                    _queue.DeleteMessage(message);\r\n                }\r\n\r\n                // Wait until timeout\r\n                TimeSpan timeDiff = DateTime.Now - startTime;\r\n                bool timedOut = (timeDiff.TotalSeconds > timeOutInSeconds);\r\n                if (timedOut)\r\n                {\r\n                    Console.WriteLine(@\"Timeout for checking job notification messages,\r\n                                        latest found state ='{0}', wait time = {1} secs\",\r\n                        jobState,\r\n                        timeDiff.TotalSeconds);\r\n\r\n                    throw new TimeoutException();\r\n                }\r\n            }\r\n        }\r\n\r\n        static private IAsset CreateAssetAndUploadSingleFile(AssetCreationOptions assetCreationOptions, string singleFilePath)\r\n        {\r\n            var asset = _context.Assets.Create(\"UploadSingleFile_\" + DateTime.UtcNow.ToString(),\r\n                assetCreationOptions);\r\n\r\n            var fileName = Path.GetFileName(singleFilePath);\r\n\r\n            var assetFile = asset.AssetFiles.Create(fileName);\r\n\r\n            Console.WriteLine(\"Created assetFile {0}\", assetFile.Name);\r\n            Console.WriteLine(\"Upload {0}\", assetFile.Name);\r\n\r\n            assetFile.Upload(singleFilePath);\r\n            Console.WriteLine(\"Done uploading of {0}\", assetFile.Name);\r\n\r\n            return asset;\r\n        }\r\n\r\n        static private IMediaProcessor GetLatestMediaProcessorByName(string mediaProcessorName)\r\n        {\r\n            var processor = _context.MediaProcessors.Where(p => p.Name == mediaProcessorName).\r\n                ToList().OrderBy(p => new Version(p.Version)).LastOrDefault();\r\n\r\n            if (processor == null)\r\n                throw new ArgumentException(string.Format(\"Unknown media processor\", mediaProcessorName));\r\n\r\n            return processor;\r\n        }\r\n    }\r\n}\r\n```\r\n以上示例生成了以下输出。 值会有所变化。\r\n\r\n    Created assetFile BigBuckBunny.mp4\r\n    Upload BigBuckBunny.mp4\r\n    Done uploading of BigBuckBunny.mp4\r\n\r\n    EventType: NotificationEndPointRegistration\r\n    MessageVersion: 1.0\r\n    ETag: e0238957a9b25bdf3351a88e57978d6a81a84527fad03bc23861dbe28ab293f6\r\n    TimeStamp: 2013-05-14T20:22:37\r\n        NotificationEndPointId: nb:nepid:UUID:d6af9412-2488-45b2-ba1f-6e0ade6dbc27\r\n        State: Registered\r\n        Name: dde957b2-006e-41f2-9869-a978870ac620\r\n        Created: 2013-05-14T20:22:35\r\n\r\n    EventType: JobStateChange\r\n    MessageVersion: 1.0\r\n    ETag: 4e381f37c2d844bde06ace650310284d6928b1e50101d82d1b56220cfcb6076c\r\n    TimeStamp: 2013-05-14T20:24:40\r\n        JobId: nb:jid:UUID:526291de-f166-be47-b62a-11ffe6d4be54\r\n        JobName: My MP4 to Smooth Streaming encoding job\r\n        NewState: Finished\r\n        OldState: Processing\r\n        AccountName: westeuropewamsaccount\r\n    job with Id: nb:jid:UUID:526291de-f166-be47-b62a-11ffe6d4be54 reached expected\r\n    State: Finished\r\n\r\n<!--Update_Description: update code to use AAD token instead of ACS-->"}