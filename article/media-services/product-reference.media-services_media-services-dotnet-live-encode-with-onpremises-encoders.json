{"Title":"如何使用 .NET 通过本地编码器执行实时传送视频流","Description":"本主题演示如何使用 .NET 通过本地编码器执行实时编码。","Content":"# <a name=\"how-to-perform-live-streaming-with-on-premises-encoders-using-net\"></a>如何使用 .NET 通过本地编码器执行实时传送视频流\r\n> [!div class=\"op_single_selector\"]\r\n> * [门户](media-services-portal-live-passthrough-get-started.md)\r\n> * [.NET](media-services-dotnet-live-encode-with-onpremises-encoders.md)\r\n> * [REST](https://docs.microsoft.com/rest/api/media/operations/channel)\r\n> \r\n> \r\n\r\n本教程逐步演示如何使用 Azure 媒体服务 .NET SDK 创建为实现直通传送而配置的 **频道** 。 \r\n\r\n## <a name=\"prerequisites\"></a>先决条件\r\n以下是完成本教程所需具备的条件：\r\n\r\n* 一个 Azure 帐户。\r\n* 一个媒体服务帐户。 若要创建媒体服务帐户，请参阅 [如何创建媒体服务帐户](media-services-portal-create-account.md)。\r\n* 设置开发环境。 有关详细信息，请参阅[设置环境](media-services-set-up-computer.md)。\r\n* 网络摄像机。 例如， [Telestream Wirecast 编码器](http://www.telestream.net/wirecast/overview.htm)。\r\n\r\n建议阅读以下文章：\r\n\r\n* [Azure 媒体服务 RTMP 支持和实时编码器](https://azure.microsoft.com/blog/2014/09/18/azure-media-services-rtmp-support-and-live-encoders/)\r\n* [使用可创建多比特率流的本地编码器实时传送视频流](media-services-live-streaming-with-onprem-encoders.md)\r\n\r\n## <a name=\"create-and-configure-a-visual-studio-project\"></a>创建和配置 Visual Studio 项目\r\n\r\n设置开发环境，并在 app.config 文件中填充连接信息，如[使用 .NET 进行媒体服务开发](media-services-dotnet-how-to-use.md)中所述。 \r\n\r\n## <a name=\"example\"></a>示例\r\n下面的代码示例演示如何完成以下任务：\r\n\r\n* 连接到媒体服务\r\n* 创建频道\r\n* 更新频道\r\n* 检索频道的输入终结点。 应向本地实时编码器提供输入终结点。 实时编码器将相机的信号转换为流，以便发送到通道的输入（插入）终结点。\r\n* 检索频道的预览终结点\r\n* 创建并启动节目\r\n* 创建访问该节目所需的定位符\r\n* 创建并启动 StreamingEndpoint\r\n* 更新流式处理终结点\r\n* 关闭资源\r\n\r\n>[!IMPORTANT]\r\n>确保要从中流式传输内容的流式处理终结点处于“正在运行”状态。 \r\n    \r\n>[!NOTE]\r\n>不同 AMS 策略的策略限制为 1,000,000 个（例如，对于定位器策略或 ContentKeyAuthorizationPolicy）。 如果始终使用相同的日期/访问权限，则应使用相同的策略 ID，例如，用于要长期就地保留的定位符的策略（非上传策略）。 有关详细信息，请参阅[此](media-services-dotnet-manage-entities.md#limit-access-policies)主题。\r\n\r\n有关如何配置实时编码器的信息，请参阅 [Azure 媒体服务 RTMP 支持和实时编码器](https://azure.microsoft.com/blog/2014/09/18/azure-media-services-rtmp-support-and-live-encoders/)。\r\n\r\n    using System;\r\n    using System.Collections.Generic;\r\n    using System.Configuration;\r\n    using System.Linq;\r\n    using System.Net;\r\n    using System.Security.Cryptography;\r\n    using Microsoft.WindowsAzure.MediaServices.Client;\r\n\r\n    namespace AMSLiveTest\r\n    {\r\n        class Program\r\n        {\r\n        private const string StreamingEndpointName = \"streamingendpoint001\";\r\n        private const string ChannelName = \"channel001\";\r\n        private const string AssetlName = \"asset001\";\r\n        private const string ProgramlName = \"program001\";\r\n\r\n        // Read values from the App.config file.\r\n        private static readonly string _AADTenantDomain =\r\n        ConfigurationManager.AppSettings[\"AADTenantDomain\"];\r\n        private static readonly string _RESTAPIEndpoint =\r\n        ConfigurationManager.AppSettings[\"MediaServiceRESTAPIEndpoint\"];\r\n\r\n        private static CloudMediaContext _context = null;\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            var tokenCredentials = new AzureAdTokenCredentials(_AADTenantDomain, AzureEnvironments.AzureChinaCloudEnvironment);\r\n            var tokenProvider = new AzureAdTokenProvider(tokenCredentials);\r\n\r\n            _context = new CloudMediaContext(new Uri(_RESTAPIEndpoint), tokenProvider);\r\n\r\n            IChannel channel = CreateAndStartChannel();\r\n\r\n            // Set the Live Encoder to point to the channel's input endpoint:\r\n            string ingestUrl = channel.Input.Endpoints.FirstOrDefault().Url.ToString();\r\n\r\n            // Use the previewEndpoint to preview and verify\r\n            // that the input from the encoder is actually reaching the Channel.\r\n            string previewEndpoint = channel.Preview.Endpoints.FirstOrDefault().Url.ToString();\r\n\r\n            IProgram program = CreateAndStartProgram(channel);\r\n            ILocator locator = CreateLocatorForAsset(program.Asset, program.ArchiveWindowLength);\r\n            IStreamingEndpoint streamingEndpoint = CreateAndStartStreamingEndpoint(false);\r\n\r\n            // Once you are done streaming, clean up your resources.\r\n            Cleanup(streamingEndpoint, channel);\r\n        }\r\n\r\n        public static IChannel CreateAndStartChannel()\r\n        {\r\n            //If you want to change the Smooth fragments to HLS segment ratio, you would set the ChannelCreationOptions’s Output property.\r\n\r\n            IChannel channel = _context.Channels.Create(\r\n            new ChannelCreationOptions\r\n            {\r\n            Name = ChannelName,\r\n            Input = CreateChannelInput(),\r\n            Preview = CreateChannelPreview()\r\n            });\r\n\r\n            //Starting and stopping Channels can take some time to execute. To determine the state of operations after calling Start or Stop, query the IChannel.State .\r\n\r\n            channel.Start();\r\n\r\n            return channel;\r\n        }\r\n\r\n        private static ChannelInput CreateChannelInput()\r\n        {\r\n            return new ChannelInput\r\n            {\r\n            StreamingProtocol = StreamingProtocol.RTMP,\r\n            AccessControl = new ChannelAccessControl\r\n            {\r\n                IPAllowList = new List<IPRange>\r\n                    {\r\n                    new IPRange\r\n                    {\r\n                    Name = \"TestChannelInput001\",\r\n                    // Setting 0.0.0.0 for Address and 0 for SubnetPrefixLength\r\n                    // will allow access to IP addresses.\r\n                    Address = IPAddress.Parse(\"0.0.0.0\"),\r\n                    SubnetPrefixLength = 0\r\n                    }\r\n                }\r\n            }\r\n            };\r\n        }\r\n\r\n        private static ChannelPreview CreateChannelPreview()\r\n        {\r\n            return new ChannelPreview\r\n            {\r\n            AccessControl = new ChannelAccessControl\r\n            {\r\n                IPAllowList = new List<IPRange>\r\n                {\r\n                    new IPRange\r\n                    {\r\n                    Name = \"TestChannelPreview001\",\r\n                    // Setting 0.0.0.0 for Address and 0 for SubnetPrefixLength\r\n                    // will allow access to IP addresses.\r\n                    Address = IPAddress.Parse(\"0.0.0.0\"),\r\n                    SubnetPrefixLength = 0\r\n                    }\r\n                }\r\n            }\r\n            };\r\n        }\r\n\r\n        public static void UpdateCrossSiteAccessPoliciesForChannel(IChannel channel)\r\n        {\r\n            var clientPolicy =\r\n            @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\r\n            <access-policy>\r\n                <cross-domain-access>\r\n                <policy>\r\n                    <allow-from http-request-headers=\"\"*\"\" http-methods=\"\"*\"\">\r\n                    <domain uri=\"\"*\"\"/>\r\n                    </allow-from>\r\n                    <grant-to>\r\n                       <resource path=\"\"/\"\" include-subpaths=\"\"true\"\"/>\r\n                    </grant-to>\r\n                </policy>\r\n                </cross-domain-access>\r\n            </access-policy>\";\r\n\r\n            var xdomainPolicy =\r\n            @\"<?xml version=\"\"1.0\"\" ?>\r\n            <cross-domain-policy>\r\n                <allow-access-from domain=\"\"*\"\" />\r\n            </cross-domain-policy>\";\r\n\r\n            channel.CrossSiteAccessPolicies.ClientAccessPolicy = clientPolicy;\r\n            channel.CrossSiteAccessPolicies.CrossDomainPolicy = xdomainPolicy;\r\n\r\n            channel.Update();\r\n        }\r\n\r\n        public static IProgram CreateAndStartProgram(IChannel channel)\r\n        {\r\n            IAsset asset = _context.Assets.Create(AssetlName, AssetCreationOptions.None);\r\n\r\n            // Create a Program on the Channel. You can have multiple Programs that overlap or are sequential;\r\n            // however each Program must have a unique name within your Media Services account.\r\n            IProgram program = channel.Programs.Create(ProgramlName, TimeSpan.FromHours(3), asset.Id);\r\n            program.Start();\r\n\r\n            return program;\r\n        }\r\n\r\n        public static ILocator CreateLocatorForAsset(IAsset asset, TimeSpan ArchiveWindowLength)\r\n        {\r\n            // You cannot create a streaming locator using an AccessPolicy that includes write or delete permissions.            \r\n\r\n            var locator = _context.Locators.CreateLocator\r\n            (\r\n                LocatorType.OnDemandOrigin,\r\n                asset,\r\n                _context.AccessPolicies.Create\r\n                (\r\n                \"Live Stream Policy\",\r\n                ArchiveWindowLength,\r\n                AccessPermissions.Read\r\n                )\r\n            );\r\n\r\n            return locator;\r\n        }\r\n\r\n        public static IStreamingEndpoint CreateAndStartStreamingEndpoint(bool createNew)\r\n        {\r\n            IStreamingEndpoint streamingEndpoint = null;\r\n            if (createNew)\r\n            {\r\n            var options = new StreamingEndpointCreationOptions\r\n            {\r\n                Name = StreamingEndpointName,\r\n                ScaleUnits = 1,\r\n                AccessControl = GetAccessControl(),\r\n                CacheControl = GetCacheControl()\r\n            };\r\n\r\n            streamingEndpoint = _context.StreamingEndpoints.Create(options);\r\n            }\r\n            else\r\n            {\r\n            streamingEndpoint = _context.StreamingEndpoints.FirstOrDefault();\r\n            }\r\n\r\n\r\n            if (streamingEndpoint.State == StreamingEndpointState.Stopped)\r\n            streamingEndpoint.Start();\r\n\r\n            return streamingEndpoint;\r\n        }\r\n\r\n        private static StreamingEndpointAccessControl GetAccessControl()\r\n        {\r\n            return new StreamingEndpointAccessControl\r\n            {\r\n            IPAllowList = new List<IPRange>\r\n                {\r\n                new IPRange\r\n                {\r\n                    Name = \"Allow all\",\r\n                    Address = IPAddress.Parse(\"0.0.0.0\"),\r\n                    SubnetPrefixLength = 0\r\n                }\r\n                },\r\n\r\n            AkamaiSignatureHeaderAuthenticationKeyList = new List<AkamaiSignatureHeaderAuthenticationKey>\r\n                {\r\n                new AkamaiSignatureHeaderAuthenticationKey\r\n                {\r\n                    Identifier = \"My key\",\r\n                    Expiration = DateTime.UtcNow + TimeSpan.FromDays(365),\r\n                    Base64Key = Convert.ToBase64String(GenerateRandomBytes(16))\r\n                }\r\n                }\r\n            };\r\n        }\r\n\r\n        private static byte[] GenerateRandomBytes(int length)\r\n        {\r\n            var bytes = new byte[length];\r\n            using (var rng = new RNGCryptoServiceProvider())\r\n            {\r\n            rng.GetBytes(bytes);\r\n            }\r\n\r\n            return bytes;\r\n        }\r\n\r\n        private static StreamingEndpointCacheControl GetCacheControl()\r\n        {\r\n            return new StreamingEndpointCacheControl\r\n            {\r\n            MaxAge = TimeSpan.FromSeconds(1000)\r\n            };\r\n        }\r\n\r\n        public static void UpdateCrossSiteAccessPoliciesForStreamingEndpoint(IStreamingEndpoint streamingEndpoint)\r\n        {\r\n            var clientPolicy =\r\n            @\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\r\n            <access-policy>\r\n                <cross-domain-access>\r\n                <policy>\r\n                    <allow-from http-request-headers=\"\"*\"\" http-methods=\"\"*\"\">\r\n                    <domain uri=\"\"*\"\"/>\r\n                    </allow-from>\r\n                    <grant-to>\r\n                       <resource path=\"\"/\"\" include-subpaths=\"\"true\"\"/>\r\n                    </grant-to>\r\n                </policy>\r\n                </cross-domain-access>\r\n            </access-policy>\";\r\n\r\n            var xdomainPolicy =\r\n            @\"<?xml version=\"\"1.0\"\" ?>\r\n            <cross-domain-policy>\r\n                <allow-access-from domain=\"\"*\"\" />\r\n            </cross-domain-policy>\";\r\n\r\n            streamingEndpoint.CrossSiteAccessPolicies.ClientAccessPolicy = clientPolicy;\r\n            streamingEndpoint.CrossSiteAccessPolicies.CrossDomainPolicy = xdomainPolicy;\r\n\r\n            streamingEndpoint.Update();\r\n        }\r\n\r\n        public static void Cleanup(IStreamingEndpoint streamingEndpoint,\r\n                        IChannel channel)\r\n        {\r\n            if (streamingEndpoint != null)\r\n            {\r\n            streamingEndpoint.Stop();\r\n            if(streamingEndpoint.Name != \"default\")\r\n                streamingEndpoint.Delete();\r\n            }\r\n\r\n            IAsset asset;\r\n            if (channel != null)\r\n            {\r\n\r\n            foreach (var program in channel.Programs)\r\n            {\r\n                asset = _context.Assets.Where(se => se.Id == program.AssetId)\r\n                            .FirstOrDefault();\r\n\r\n                program.Stop();\r\n                program.Delete();\r\n\r\n                if (asset != null)\r\n                {\r\n                foreach (var l in asset.Locators)\r\n                    l.Delete();\r\n\r\n                asset.Delete();\r\n                }\r\n            }\r\n\r\n            channel.Stop();\r\n            channel.Delete();\r\n            }\r\n        }\r\n        }\r\n    }\r\n\r\n\r\n<!--Update_Description: update code to use AAD token instead of ACS-->"}