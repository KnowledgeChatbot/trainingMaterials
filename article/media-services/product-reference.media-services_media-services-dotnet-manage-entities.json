{"Title":"使用媒体服务 .NET SDK 管理资产和相关的实体","Description":"了解如何使用适用于 .NET 的媒体服务 SDK 管理资产和相关的实体。","Content":"# <a name=\"managing-assets-and-related-entities-with-media-services-net-sdk\"></a>使用媒体服务 .NET SDK 管理资产和相关的实体\r\n> [!div class=\"op_single_selector\"]\r\n> * [.NET](media-services-dotnet-manage-entities.md)\r\n> * [REST](media-services-rest-manage-entities.md)\r\n> \r\n> \r\n\r\n本主题介绍如何使用 .NET 管理 Azure 媒体服务实体。 \r\n\r\n>[!NOTE]\r\n> 从 2017 年 4 月 1 日开始，用户帐户中任何超过 90 天的作业记录及其关联的任务记录都会被系统自动删除，即使记录总数低于最大配额。 例如，在 2017 年 4 月 1 日，用户帐户中 2016 年 12 月 31 日以前的任何作业记录都会被系统自动删除。 若需存档作业/任务信息，可使用本主题所述代码。\r\n\r\n## <a name=\"prerequisites\"></a>先决条件\r\n\r\n设置开发环境，并在 app.config 文件中填充连接信息，如[使用 .NET 进行媒体服务开发](media-services-dotnet-how-to-use.md)中所述。 \r\n\r\n## <a name=\"get-an-asset-reference\"></a>获取资产引用\r\n一个常见的任务是获取对媒体服务中某个现有资产的引用。 以下代码示例演示了如何根据资产 ID，从服务器上下文对象上的资产集合中获取资产引用。以下代码示例使用 Linq 查询来获取对现有 IAsset 对象的引用。\r\n\r\n    static IAsset GetAsset(string assetId)\r\n    {\r\n        // Use a LINQ Select query to get an asset.\r\n        var assetInstance =\r\n            from a in _context.Assets\r\n            where a.Id == assetId\r\n            select a;\r\n        // Reference the asset as an IAsset.\r\n        IAsset asset = assetInstance.FirstOrDefault();\r\n\r\n        return asset;\r\n    }\r\n\r\n## <a name=\"list-all-assets\"></a>列出所有资产\r\n随着存储空间中的资产数量的增长，这对列出资产很有用。 以下代码示例演示了如何循环访问服务器上下文对象上的资产集合。 对于每个资产，该代码示例还会将其一些属性值写入控制台。 例如，每个资产可以包含多个媒体文件。 代码示例会写出与每个资产关联的所有文件。\r\n\r\n    static void ListAssets()\r\n    {\r\n        string waitMessage = \"Building the list. This may take a few \"\r\n            + \"seconds to a few minutes depending on how many assets \"\r\n            + \"you have.\"\r\n            + Environment.NewLine + Environment.NewLine\r\n            + \"Please wait...\"\r\n            + Environment.NewLine;\r\n        Console.Write(waitMessage);\r\n\r\n        // Create a Stringbuilder to store the list that we build. \r\n        StringBuilder builder = new StringBuilder();\r\n\r\n        foreach (IAsset asset in _context.Assets)\r\n        {\r\n            // Display the collection of assets.\r\n            builder.AppendLine(\"\");\r\n            builder.AppendLine(\"******ASSET******\");\r\n            builder.AppendLine(\"Asset ID: \" + asset.Id);\r\n            builder.AppendLine(\"Name: \" + asset.Name);\r\n            builder.AppendLine(\"==============\");\r\n            builder.AppendLine(\"******ASSET FILES******\");\r\n\r\n            // Display the files associated with each asset. \r\n            foreach (IAssetFile fileItem in asset.AssetFiles)\r\n            {\r\n                builder.AppendLine(\"Name: \" + fileItem.Name);\r\n                builder.AppendLine(\"Size: \" + fileItem.ContentFileSize);\r\n                builder.AppendLine(\"==============\");\r\n            }\r\n        }\r\n\r\n        // Display output in console.\r\n        Console.Write(builder.ToString());\r\n    }\r\n\r\n## <a name=\"get-a-job-reference\"></a>获取作业引用\r\n\r\n处理媒体服务代码中的任务时，通常需要根据 ID 获取对现有作业的引用。以下代码示例演示了如何获取对作业集合中某个 IJob 对象的引用。\r\n\r\n开始长时运行的编码作业时，可能需要获取作业引用，并且需要检查线程上的作业状态。 在这种情况下，当方法从某个线程返回时，需要检索对作业的刷新引用。\r\n\r\n    static IJob GetJob(string jobId)\r\n    {\r\n        // Use a Linq select query to get an updated \r\n        // reference by Id. \r\n        var jobInstance =\r\n            from j in _context.Jobs\r\n            where j.Id == jobId\r\n            select j;\r\n        // Return the job reference as an Ijob. \r\n        IJob job = jobInstance.FirstOrDefault();\r\n\r\n        return job;\r\n    }\r\n\r\n## <a name=\"list-jobs-and-assets\"></a>列出作业和资产\r\n在媒体服务中列出资产及其关联作业是一项重要的相关任务。 以下代码示例演示了如何列出每个 IJob 对象，它会针对每个作业显示作业的相关属性、所有相关的任务、所有输入资产和所有输出资产。 本示例中的代码对各种其他任务也有所帮助。 例如，如果想要列出你先前运行的一个或多个编码作业的输出资产，本代码演示如何访问输出资产。 如果拥有对某个输出资产的引用，可以通过下载或提供 URL 的方式，将内容传递给其他用户或应用程序。 \r\n\r\n有关传递资产选项的详细信息，请参阅[使用适用于 .NET 的媒体服务 SDK 传递资产](media-services-deliver-streaming-content.md)。\r\n\r\n    // List all jobs on the server, and for each job, also list \r\n    // all tasks, all input assets, all output assets.\r\n\r\n    static void ListJobsAndAssets()\r\n    {\r\n        string waitMessage = \"Building the list. This may take a few \"\r\n            + \"seconds to a few minutes depending on how many assets \"\r\n            + \"you have.\"\r\n            + Environment.NewLine + Environment.NewLine\r\n            + \"Please wait...\"\r\n            + Environment.NewLine;\r\n        Console.Write(waitMessage);\r\n\r\n        // Create a Stringbuilder to store the list that we build. \r\n        StringBuilder builder = new StringBuilder();\r\n\r\n        foreach (IJob job in _context.Jobs)\r\n        {\r\n            // Display the collection of jobs on the server.\r\n            builder.AppendLine(\"\");\r\n            builder.AppendLine(\"******JOB*******\");\r\n            builder.AppendLine(\"Job ID: \" + job.Id);\r\n            builder.AppendLine(\"Name: \" + job.Name);\r\n            builder.AppendLine(\"State: \" + job.State);\r\n            builder.AppendLine(\"Order: \" + job.Priority);\r\n            builder.AppendLine(\"==============\");\r\n\r\n            // For each job, display the associated tasks (a job  \r\n            // has one or more tasks). \r\n            builder.AppendLine(\"******TASKS*******\");\r\n            foreach (ITask task in job.Tasks)\r\n            {\r\n                builder.AppendLine(\"Task Id: \" + task.Id);\r\n                builder.AppendLine(\"Name: \" + task.Name);\r\n                builder.AppendLine(\"Progress: \" + task.Progress);\r\n                builder.AppendLine(\"Configuration: \" + task.Configuration);\r\n                if (task.ErrorDetails != null)\r\n                {\r\n                    builder.AppendLine(\"Error: \" + task.ErrorDetails);\r\n                }\r\n                builder.AppendLine(\"==============\");\r\n            }\r\n\r\n            // For each job, display the list of input media assets.\r\n            builder.AppendLine(\"******JOB INPUT MEDIA ASSETS*******\");\r\n            foreach (IAsset inputAsset in job.InputMediaAssets)\r\n            {\r\n\r\n                if (inputAsset != null)\r\n                {\r\n                    builder.AppendLine(\"Input Asset Id: \" + inputAsset.Id);\r\n                    builder.AppendLine(\"Name: \" + inputAsset.Name);\r\n                    builder.AppendLine(\"==============\");\r\n                }\r\n            }\r\n\r\n            // For each job, display the list of output media assets.\r\n            builder.AppendLine(\"******JOB OUTPUT MEDIA ASSETS*******\");\r\n            foreach (IAsset theAsset in job.OutputMediaAssets)\r\n            {\r\n                if (theAsset != null)\r\n                {\r\n                    builder.AppendLine(\"Output Asset Id: \" + theAsset.Id);\r\n                    builder.AppendLine(\"Name: \" + theAsset.Name);\r\n                    builder.AppendLine(\"==============\");\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // Display output in console.\r\n        Console.Write(builder.ToString());\r\n    }\r\n\r\n## <a name=\"list-all-access-policies\"></a>列出所有访问策略\r\n在媒体服务中，可以对资产或其文件定义访问策略。 访问策略定义文件或资产的权限（访问类型以及持续时间）。 在媒体服务代码中，通常通过创建 IAccessPolicy 对象来定义访问策略对象，并将其与现有资产相关联。 然后创建一个 ILocator 对象，它允许用户提供对媒体服务中的资产的直接访问。 本文档系列随附的 Visual Studio 项目包含几个代码示例，这些代码示例演示如何创建和分配访问策略和定位符到资产。\r\n\r\n以下代码示例演示如何列出服务器上所有的访问策略，并显示与每个策略关联的权限类型。 查看访问策略的另一个有用方法是列出服务器上的所有 ILocator 对象，并针对每个定位符，可以使用其 AccessPolicy 属性列出其关联的访问策略。\r\n\r\n    static void ListAllPolicies()\r\n    {\r\n        foreach (IAccessPolicy policy in _context.AccessPolicies)\r\n        {\r\n            Console.WriteLine(\"\");\r\n            Console.WriteLine(\"Name:  \" + policy.Name);\r\n            Console.WriteLine(\"ID:  \" + policy.Id);\r\n            Console.WriteLine(\"Permissions: \" + policy.Permissions);\r\n            Console.WriteLine(\"==============\");\r\n\r\n        }\r\n    }\r\n    \r\n## <a name=\"limit-access-policies\"></a>限制访问策略数 \r\n\r\n>[!NOTE]\r\n> 不同 AMS 策略的策略限制为 1,000,000 个（例如，对于定位器策略或 ContentKeyAuthorizationPolicy）。 如果始终使用相同的日期/访问权限，则应使用相同的策略 ID，例如，用于要长期就地保留的定位符的策略（非上传策略）。 \r\n\r\n例如，可以使用以下代码创建通用的策略组，该代码在应用程序中只运行一次。 可以将 ID 记录到日志文件中供以后使用：\r\n\r\n    double year = 365.25;\r\n    double week = 7;\r\n    IAccessPolicy policyYear = _context.AccessPolicies.Create(\"One Year\", TimeSpan.FromDays(year), AccessPermissions.Read);\r\n    IAccessPolicy policy100Year = _context.AccessPolicies.Create(\"Hundred Years\", TimeSpan.FromDays(year * 100), AccessPermissions.Read);\r\n    IAccessPolicy policyWeek = _context.AccessPolicies.Create(\"One Week\", TimeSpan.FromDays(week), AccessPermissions.Read);\r\n\r\n    Console.WriteLine(\"One year policy ID is: \" + policyYear.Id);\r\n    Console.WriteLine(\"100 year policy ID is: \" + policy100Year.Id);\r\n    Console.WriteLine(\"One week policy ID is: \" + policyWeek.Id);\r\n\r\n然后即可在代码中使用现有的 ID，如下所示：\r\n\r\n    const string policy1YearId = \"nb:pid:UUID:2a4f0104-51a9-4078-ae26-c730f88d35cf\";\r\n\r\n    // Get the standard policy for 1 year read only\r\n    var tempPolicyId = from b in _context.AccessPolicies\r\n                       where b.Id == policy1YearId\r\n                       select b;\r\n    IAccessPolicy policy1Year = tempPolicyId.FirstOrDefault();\r\n\r\n    // Get the existing asset\r\n    var tempAsset = from a in _context.Assets\r\n                where a.Id == assetID\r\n                select a;\r\n    IAsset asset = tempAsset.SingleOrDefault();\r\n\r\n    ILocator originLocator = _context.Locators.CreateLocator(LocatorType.OnDemandOrigin, asset,\r\n        policy1Year,\r\n        DateTime.UtcNow.AddMinutes(-5));\r\n    Console.WriteLine(\"The locator base path is \" + originLocator.BaseUri.ToString());\r\n\r\n## <a name=\"list-all-locators\"></a>列出所有定位符\r\n定位符是一个 URL，提供访问资产的直接路径，以及定位符的关联访问策略所定义的对该资产的权限。 每个资产都有一个在其定位符属性上与其关联的 ILocator 对象集合。 服务器上下文还具有一个包含所有定位符的定位符集合。\r\n\r\n以下代码示例列出了服务器上的所有定位符。 对于每个定位符，它会显示相关资产和访问策略的 ID。 它也显示权限的类型、到期日期和访问资产的完整路径。\r\n\r\n请注意，访问资产的定位符路径仅仅是访问资产的基本 URL。 要创建用户或应用程序可以浏览到的单个文件的直接路径，你的代码必须将特定文件路径添加到定位符路径。 有关如何进行操作的详细信息，请参阅主题[使用适用于 .NET 的媒体服务 SDK 传递资产](media-services-deliver-streaming-content.md)。\r\n\r\n    static void ListAllLocators()\r\n    {\r\n        foreach (ILocator locator in _context.Locators)\r\n        {\r\n            Console.WriteLine(\"***********\");\r\n            Console.WriteLine(\"Locator Id: \" + locator.Id);\r\n            Console.WriteLine(\"Locator asset Id: \" + locator.AssetId);\r\n            Console.WriteLine(\"Locator access policy Id: \" + locator.AccessPolicyId);\r\n            Console.WriteLine(\"Access policy permissions: \" + locator.AccessPolicy.Permissions);\r\n            Console.WriteLine(\"Locator expiration: \" + locator.ExpirationDateTime);\r\n            // The locator path is the base or parent path (with included permissions) to access  \r\n            // the media content of an asset. To create a full URL to a specific media file, take \r\n            // the locator path and then append a file name and info as needed.  \r\n            Console.WriteLine(\"Locator base path: \" + locator.Path);\r\n            Console.WriteLine(\"\");\r\n        }\r\n    }\r\n\r\n## <a name=\"enumerating-through-large-collections-of-entities\"></a>枚举大型实体集合\r\n查询实体时，一次返回的实体数限制为 1000 个，因为公共 REST v2 将查询结果数限制为 1000 个。 枚举大型实体集合时，需要使用 Skip 和 Take。 \r\n\r\n以下函数将循环访问所提供的媒体服务帐户中的所有作业。 媒体服务在作业集合中返回 1000 个作业。 该函数使用 Skip 和 Take 来确保枚举所有作业（如果你帐户中的作业超过 1000 个）。\r\n\r\n    static void ProcessJobs()\r\n    {\r\n        try\r\n        {\r\n\r\n            int skipSize = 0;\r\n            int batchSize = 1000;\r\n            int currentBatch = 0;\r\n\r\n            while (true)\r\n            {\r\n                // Loop through all Jobs (1000 at a time) in the Media Services account\r\n                IQueryable _jobsCollectionQuery = _context.Jobs.Skip(skipSize).Take(batchSize);\r\n                foreach (IJob job in _jobsCollectionQuery)\r\n                {\r\n                    currentBatch++;\r\n                    Console.WriteLine(\"Processing Job Id:\" + job.Id);\r\n                }\r\n\r\n                if (currentBatch == batchSize)\r\n                {\r\n                    skipSize += batchSize;\r\n                    currentBatch = 0;\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex.Message);\r\n        }\r\n    }\r\n\r\n## <a name=\"delete-an-asset\"></a>删除资产\r\n以下示例删除了一个资产。\r\n\r\n    static void DeleteAsset( IAsset asset)\r\n    {\r\n        // delete the asset\r\n        asset.Delete();\r\n\r\n        // Verify asset deletion\r\n        if (GetAsset(asset.Id) == null)\r\n            Console.WriteLine(\"Deleted the Asset\");\r\n\r\n    }\r\n\r\n## <a name=\"delete-a-job\"></a>删除作业\r\n若要删除某一作业，必须检查该作业的状态是否如“状态”属性中所示。 可以删除已完成或已取消的作业，但是必须先取消处于其他状态（如已排队、已计划、或处理中）的作业，才可以删除这些作业。\r\n\r\n以下代码示例演示了一种删除作业的方法，通过检查作业状态，当作业状态为已完成或取消时，删除作业。 此代码取决于本主题的上一节，用于获取对作业的引用：获取作业引用。\r\n\r\n    static void DeleteJob(string jobId)\r\n    {\r\n        bool jobDeleted = false;\r\n\r\n        while (!jobDeleted)\r\n        {\r\n            // Get an updated job reference.  \r\n            IJob job = GetJob(jobId);\r\n\r\n            // Check and handle various possible job states. You can \r\n            // only delete a job whose state is Finished, Error, or Canceled.   \r\n            // You can cancel jobs that are Queued, Scheduled, or Processing,  \r\n            // and then delete after they are canceled.\r\n            switch (job.State)\r\n            {\r\n                case JobState.Finished:\r\n                case JobState.Canceled:\r\n                case JobState.Error:\r\n                    // Job errors should already be logged by polling or event \r\n                    // handling methods such as CheckJobProgress or StateChanged.\r\n                    // You can also call job.DeleteAsync to do async deletes.\r\n                    job.Delete();\r\n                    Console.WriteLine(\"Job has been deleted.\");\r\n                    jobDeleted = true;\r\n                    break;\r\n                case JobState.Canceling:\r\n                    Console.WriteLine(\"Job is cancelling and will be deleted \"\r\n                        + \"when finished.\");\r\n                    Console.WriteLine(\"Wait while job finishes canceling...\");\r\n                    Thread.Sleep(5000);\r\n                    break;\r\n                case JobState.Queued:\r\n                case JobState.Scheduled:\r\n                case JobState.Processing:\r\n                    job.Cancel();\r\n                    Console.WriteLine(\"Job is scheduled or processing and will \"\r\n                        + \"be deleted.\");\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n\r\n## <a name=\"delete-an-access-policy\"></a>删除访问策略\r\n以下代码示例演示如何基于策略 ID，获取对访问策略的引用，并删除该策略。\r\n\r\n    static void DeleteAccessPolicy(string existingPolicyId)\r\n    {\r\n        // To delete a specific access policy, get a reference to the policy.  \r\n        // based on the policy Id passed to the method.\r\n        var policyInstance =\r\n                from p in _context.AccessPolicies\r\n                where p.Id == existingPolicyId\r\n                select p;\r\n        IAccessPolicy policy = policyInstance.FirstOrDefault();\r\n\r\n        policy.Delete();\r\n\r\n    }\r\n\r\n\r\n\r\n"}