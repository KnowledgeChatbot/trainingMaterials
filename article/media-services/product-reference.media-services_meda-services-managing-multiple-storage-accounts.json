{"Title":"跨多个存储帐户管理媒体服务资产","Description":"本文提供如何跨多个存储帐户管理媒体服务资产的指导。","Content":"# <a name=\"managing-media-services-assets-across-multiple-storage-accounts\"></a>跨多个存储帐户管理媒体服务资产\r\n从 Microsoft Azure 媒体服务 2.2 开始，可以将多个存储帐户附加到一个媒体服务帐户。 将多个存储帐户附加到一个媒体服务帐户这一功能具有以下优势：\r\n\r\n* 使多个存储帐户之间的资产实现负载均衡。\r\n* 缩放媒体服务以处理大量内容（目前，单个存储帐户的上限为 500 TB）。 \r\n\r\n本主题演示如何使用 [Azure Resource Manager API](https://docs.microsoft.com/rest/api/media/mediaservice) 和 [Powershell](https://docs.microsoft.com/powershell/powershell/module/azurerm.media) 将多个存储帐户附加到媒体服务帐户。 此外还说明如何在使用媒体服务 SDK 创建资产时指定不同的存储帐户。 \r\n\r\n## <a name=\"considerations\"></a>注意事项\r\n将多个存储帐户附加到媒体服务帐户时，请注意以下事项：\r\n\r\n* 附加到媒体服务帐户的所有存储帐户必须与媒体服务帐户位于同一数据中心。\r\n* 目前，存储帐户一旦附加到指定的媒体服务帐户便无法断开。\r\n* 主存储帐户是在创建媒体服务帐户创建时指定的帐户。 目前无法更改默认存储帐户。 \r\n* 目前，如果需要将冷存储帐户添加到 AMS 帐户，该存储帐户必须为 Blob 类型且设置为“非主”。\r\n\r\n其他注意事项：\r\n\r\n构建数据流内容的 URL 时，媒体服务会使用 IAssetFile.Name 属性的值（如 http://{WAMSAccount}.origin.mediaservices.chinacloudapi.cn/{GUID}/{IAssetFile.Name}/streamingParameters。）出于这个原因，不允许使用百分号编码。 Name 属性的值不能含有任何以下[百分号编码保留字符](http://zh.wikipedia.org/wiki/百分号编码#.E4.BF.9D.E7.95.99.E5.AD.97.E7.AC.A6.E7.9A.84.E7.99.BE.E5.88.86.E5.8F.B7.E7.BC.96.E7.A0.81)：!*'();:@&=+$,/?%#[]\"。 此外，文件扩展名中只能含有一个“.”。\r\n\r\n## <a name=\"to-attach-storage-accounts\"></a>附加存储帐户  \r\n\r\n若要将存储帐户附加到 AMS 帐户，请使用 [Azure Resource Manager API](https://docs.microsoft.com/rest/api/media/mediaservice) 和 [Powershell](https://docs.microsoft.com/powershell/module/azurerm.media)，如以下示例所示。\r\n```\r\n$regionName = \"China East\"\r\n$subscriptionId = \" xxxxxxxx-xxxx-xxxx-xxxx- xxxxxxxxxxxx \"\r\n$resourceGroupName = \"SkyMedia-ChinaEast-App\"\r\n$mediaAccountName = \"sky\"\r\n$storageAccount1Name = \"skystorage1\"\r\n$storageAccount2Name = \"skystorage2\"\r\n$storageAccount1Id = \"/subscriptions/$subscriptionId/resourceGroups/$resourceGroupName/providers/Microsoft.Storage/storageAccounts/$storageAccount1Name\"\r\n$storageAccount2Id = \"/subscriptions/$subscriptionId/resourceGroups/$resourceGroupName/providers/Microsoft.Storage/storageAccounts/$storageAccount2Name\"\r\n$storageAccount1 = New-AzureRmMediaServiceStorageConfig -StorageAccountId $storageAccount1Id -IsPrimary\r\n$storageAccount2 = New-AzureRmMediaServiceStorageConfig -StorageAccountId $storageAccount2Id\r\n$storageAccounts = @($storageAccount1, $storageAccount2)\r\n\r\nSet-AzureRmMediaService -ResourceGroupName $resourceGroupName -AccountName $mediaAccountName -StorageAccounts $storageAccounts\r\n```\r\n\r\n### <a name=\"support-for-cool-storage\"></a>支持冷存储\r\n\r\n目前，如果需要将冷存储帐户添加到 AMS 帐户，该存储帐户必须为 Blob 类型且设置为“非主”。\r\n\r\n## <a name=\"to-manage-media-services-assets-across-multiple-storage-accounts\"></a>跨多个存储帐户管理媒体服务资产\r\n以下代码使用最新的媒体服务 SDK 执行下列任务：\r\n\r\n1. 显示与指定媒体服务帐户关联的所有存储帐户。\r\n2. 检索默认存储帐户的名称。\r\n3. 在默认存储帐户中创建一个新资产。\r\n4. 在指定存储帐户中创建编码作业的输出资产。\r\n   \r\n```\r\nusing Microsoft.WindowsAzure.MediaServices.Client;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Configuration;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace MultipleStorageAccounts\r\n{\r\n    class Program\r\n    {\r\n        // Location of the media file that you want to encode. \r\n        private static readonly string _singleInputFilePath =\r\n            Path.GetFullPath(@\"../..\\supportFiles\\multifile\\interview2.wmv\");\r\n\r\n        // Read values from the App.config file.\r\n        private static readonly string _AADTenantDomain =\r\n        ConfigurationManager.AppSettings[\"AADTenantDomain\"];\r\n        private static readonly string _RESTAPIEndpoint =\r\n        ConfigurationManager.AppSettings[\"MediaServiceRESTAPIEndpoint\"];\r\n\r\n        private static CloudMediaContext _context;\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            var tokenCredentials = new AzureAdTokenCredentials(_AADTenantDomain, AzureEnvironments.AzureChinaCloudEnvironment);\r\n            var tokenProvider = new AzureAdTokenProvider(tokenCredentials);\r\n\r\n            _context = new CloudMediaContext(new Uri(_RESTAPIEndpoint), tokenProvider);\r\n\r\n            // Display the storage accounts associated with \r\n            // the specified Media Services account:\r\n            foreach (var sa in _context.StorageAccounts)\r\n                Console.WriteLine(sa.Name);\r\n\r\n            // Retrieve the name of the default storage account.\r\n            var defaultStorageName = _context.StorageAccounts.Where(s => s.IsDefault == true).FirstOrDefault();\r\n            Console.WriteLine(\"Name: {0}\", defaultStorageName.Name);\r\n            Console.WriteLine(\"IsDefault: {0}\", defaultStorageName.IsDefault);\r\n\r\n            // Retrieve the name of a storage account that is not the default one.\r\n            var notDefaultStroageName = _context.StorageAccounts.Where(s => s.IsDefault == false).FirstOrDefault();\r\n            Console.WriteLine(\"Name: {0}\", notDefaultStroageName.Name);\r\n            Console.WriteLine(\"IsDefault: {0}\", notDefaultStroageName.IsDefault);\r\n\r\n            // Create the original asset in the default storage account.\r\n            IAsset asset = CreateAssetAndUploadSingleFile(AssetCreationOptions.None,\r\n                defaultStorageName.Name, _singleInputFilePath);\r\n            Console.WriteLine(\"Created the asset in the {0} storage account\", asset.StorageAccountName);\r\n\r\n            // Create an output asset of the encoding job in the other storage account.\r\n            IAsset outputAsset = CreateEncodingJob(asset, notDefaultStroageName.Name, _singleInputFilePath);\r\n            if (outputAsset != null)\r\n                Console.WriteLine(\"Created the output asset in the {0} storage account\", outputAsset.StorageAccountName);\r\n\r\n        }\r\n\r\n        static public IAsset CreateAssetAndUploadSingleFile(AssetCreationOptions assetCreationOptions, string storageName, string singleFilePath)\r\n        {\r\n            var assetName = \"UploadSingleFile_\" + DateTime.UtcNow.ToString();\r\n\r\n            // If you are creating an asset in the default storage account, you can omit the StorageName parameter.\r\n            var asset = _context.Assets.Create(assetName, storageName, assetCreationOptions);\r\n\r\n            var fileName = Path.GetFileName(singleFilePath);\r\n\r\n            var assetFile = asset.AssetFiles.Create(fileName);\r\n\r\n            Console.WriteLine(\"Created assetFile {0}\", assetFile.Name);\r\n\r\n            assetFile.Upload(singleFilePath);\r\n\r\n            Console.WriteLine(\"Done uploading {0}\", assetFile.Name);\r\n\r\n            return asset;\r\n        }\r\n\r\n        static IAsset CreateEncodingJob(IAsset asset, string storageName, string inputMediaFilePath)\r\n        {\r\n            // Declare a new job.\r\n            IJob job = _context.Jobs.Create(\"My encoding job\");\r\n            // Get a media processor reference, and pass to it the name of the \r\n            // processor to use for the specific task.\r\n            IMediaProcessor processor = GetLatestMediaProcessorByName(\"Media Encoder Standard\");\r\n\r\n            // Create a task with the encoding details, using a string preset.\r\n            ITask task = job.Tasks.AddNew(\"My encoding task\",\r\n                processor,\r\n                \"Adaptive Streaming\",\r\n                Microsoft.WindowsAzure.MediaServices.Client.TaskOptions.ProtectedConfiguration);\r\n\r\n            // Specify the input asset to be encoded.\r\n            task.InputAssets.Add(asset);\r\n            // Add an output asset to contain the results of the job. \r\n            // This output is specified as AssetCreationOptions.None, which \r\n            // means the output asset is not encrypted. \r\n            task.OutputAssets.AddNew(\"Output asset\", storageName,\r\n                AssetCreationOptions.None);\r\n\r\n            // Use the following event handler to check job progress.  \r\n            job.StateChanged += new\r\n                    EventHandler<JobStateChangedEventArgs>(StateChanged);\r\n\r\n            // Launch the job.\r\n            job.Submit();\r\n\r\n            // Check job execution and wait for job to finish. \r\n            Task progressJobTask = job.GetExecutionProgressTask(CancellationToken.None);\r\n            progressJobTask.Wait();\r\n\r\n            // Get an updated job reference.\r\n            job = GetJob(job.Id);\r\n\r\n            // If job state is Error the event handling \r\n            // method for job progress should log errors.  Here we check \r\n            // for error state and exit if needed.\r\n            if (job.State == JobState.Error)\r\n            {\r\n                Console.WriteLine(\"\\nExiting method due to job error.\");\r\n                return null;\r\n            }\r\n\r\n            // Get a reference to the output asset from the job.\r\n            IAsset outputAsset = job.OutputMediaAssets[0];\r\n\r\n            return outputAsset;\r\n        }\r\n\r\n        private static IMediaProcessor GetLatestMediaProcessorByName(string mediaProcessorName)\r\n        {\r\n            var processor = _context.MediaProcessors.Where(p => p.Name == mediaProcessorName).\r\n                ToList().OrderBy(p => new Version(p.Version)).LastOrDefault();\r\n\r\n            if (processor == null)\r\n                throw new ArgumentException(string.Format(\"Unknown media processor\", mediaProcessorName));\r\n\r\n            return processor;\r\n        }\r\n\r\n        private static void StateChanged(object sender, JobStateChangedEventArgs e)\r\n        {\r\n            Console.WriteLine(\"Job state changed event:\");\r\n            Console.WriteLine(\"  Previous state: \" + e.PreviousState);\r\n            Console.WriteLine(\"  Current state: \" + e.CurrentState);\r\n\r\n            switch (e.CurrentState)\r\n            {\r\n                case JobState.Finished:\r\n                    Console.WriteLine();\r\n                    Console.WriteLine(\"********************\");\r\n                    Console.WriteLine(\"Job is finished.\");\r\n                    Console.WriteLine(\"Please wait while local tasks or downloads complete...\");\r\n                    Console.WriteLine(\"********************\");\r\n                    Console.WriteLine();\r\n                    Console.WriteLine();\r\n                    break;\r\n                case JobState.Canceling:\r\n                case JobState.Queued:\r\n                case JobState.Scheduled:\r\n                case JobState.Processing:\r\n                    Console.WriteLine(\"Please wait...\\n\");\r\n                    break;\r\n                case JobState.Canceled:\r\n                case JobState.Error:\r\n                    // Cast sender as a job.\r\n                    IJob job = (IJob)sender;\r\n                    // Display or log error details as needed.\r\n                    Console.WriteLine(\"An error occurred in {0}\", job.Id);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        static IJob GetJob(string jobId)\r\n        {\r\n            // Use a Linq select query to get an updated \r\n            // reference by Id. \r\n            var jobInstance =\r\n                from j in _context.Jobs\r\n                where j.Id == jobId\r\n                select j;\r\n            // Return the job reference as an Ijob. \r\n            IJob job = jobInstance.FirstOrDefault();\r\n\r\n            return job;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n<!--Update_Description: update code to use AAD token instead of ACS-->\r\n"}