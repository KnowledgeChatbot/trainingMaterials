{"Title":"使用 Azure 媒体服务实现故障转移流式处理","Description":"本主题说明如何实现故障转移流式处理方案。","Content":"# <a name=\"implement-failover-streaming-with-azure-media-services\"></a>使用 Azure 媒体服务实现故障转移流式处理\r\n\r\n本演练演示如何将内容 (blob) 从一个资产复制到另一个资产，以便处理按需流式处理的冗余。 如果想要将 Azure 内容交付网络设置为当某个数据中心发生中断时在两个数据中心之间故障转移，则很适合采用此方案。 本演练使用 Azure 媒体服务 SDK、Azure 媒体服务 REST API 和 Azure 存储 SDK 来演示以下任务：\r\n\r\n1. 在“数据中心 A”中设置一个媒体服务帐户。\r\n2. 将一个夹层文件上传到源资产中。\r\n3. 将该资产编码成多比特率 MP4 文件。 \r\n4. 创建一个只读的共享访问签名定位符。 源资产可以使用此定位符获取对关联到源资产的存储帐户中的容器的读取访问权限。\r\n5. 从上一步骤中创建的只读共享访问签名定位符获取源资产的容器名称。 在存储帐户之间复制 Blob 时必须使用此名称（本主题稍后会介绍。）\r\n6. 为通过编码任务创建的资产创建源定位器。 \r\n\r\n然后，如果要处理故障转移，请执行以下操作：\r\n\r\n1. 在“数据中心 B”中设置一个媒体服务帐户。\r\n2. 在目标媒体服务帐户中创建一个目标空资产。\r\n3. 创建一个写入共享访问签名定位符。 目标空资产将使用此定位符获取对关联到目标资产的目标存储帐户中的容器的写入访问权限。\r\n4. 使用 Azure 存储 SDK 在“数据中心 A”中的源存储帐户与“数据中心 B”中的目标存储帐户之间复制 Blob（资产文件）。 这些存储帐户与所需的资产关联。\r\n5. 将复制到目标 blob 容器的 blob（资产文件）与目标资产关联。 \r\n6. 在“数据中心 B”中为资产创建来源定位符，并指定针对“数据中心 A”中的资产生成的定位符 ID。\r\n\r\n这样，便会提供 URL 的相对路径相同（只有基本 URL 不同）的流式处理 URL。 \r\n\r\n然后，若要处理任何中断情况，可在这些源定位符的顶层创建内容交付网络。 \r\n\r\n请注意以下事项：\r\n\r\n* 当前版本的媒体服务 SDK 不支持以编程方式生成会将资产与资产文件关联的 IAssetFile 信息。 应该使用 CreateFileInfos 媒体服务 REST API 来实现此目的。 \r\n* 不支持使用存储加密资产 (AssetCreationOptions.StorageEncrypted) 进行复制（因为两个媒体服务帐户中的加密密钥不同）。 \r\n* 若要使用动态打包，请确保要从中流式传输内容的流式处理终结点处于“正在运行”状态。\r\n\r\n> [!NOTE]\r\n> 请考虑将媒体服务[复制器工具](http://replicator.codeplex.com/)用作备用选项，以手动实现故障转移流式处理方案。 此工具可用于在两个媒体服务帐户之间复制资产。\r\n> \r\n> \r\n\r\n## <a name=\"prerequisites\"></a>先决条件\r\n* 在新的或现有的 Azure 订阅中拥有两个媒体服务帐户。 请参阅[如何创建媒体服务帐户](media-services-portal-create-account.md)。\r\n* 操作系统：Windows 7、Windows 2008 R2 或 Windows 8。\r\n* .NET Framework 4.5 或 .NET Framework 4。\r\n* Visual Studio 2010 SP1 或更高版本（专业版、高级专业版、旗舰版或学习版）。\r\n\r\n## <a name=\"set-up-your-project\"></a>设置项目\r\n在本部分，将要创建并设置一个 C# 控制台应用程序项目。\r\n\r\n1. 使用 Visual Studio 创建包含 C# 控制台应用程序项目的新解决方案。 输入 HandleRedundancyForOnDemandStreaming 作为名称，然后单击“确定”。\r\n2. 在与 HandleRedundancyForOnDemandStreaming.csproj 项目文件相同的级别创建 SupportFiles 文件夹。 在 SupportFiles 文件夹下创建 OutputFiles 和 MP4Files 文件夹。 将一个 .mp4 文件复制到 MP4Files 文件夹。 （本示例使用 BigBuckBunny.mp4 文件。） \r\n3. 使用 Nuget 添加对媒体服务相关 DLL 的引用。 在 Visual Studio 主菜单中，选择“工具” > “库包管理器” > “包管理器控制台”。 在控制台窗口中键入 Install-Package windowsazure.mediaservices，并按 Enter。\r\n4. 添加此项目所需的其他引用：System.Configuration、System.Runtime.Serialization 和 System.Web。\r\n5. 将默认添加到 Programs.cs 文件中的 using 语句替换为以下语句：\r\n   \r\n        using System;\r\n        using System.Configuration;\r\n        using System.Globalization;\r\n        using System.IO;\r\n        using System.Net;\r\n        using System.Runtime.Serialization.Json;\r\n        using System.Text;\r\n        using System.Threading;\r\n        using System.Threading.Tasks;\r\n        using System.Web;\r\n        using System.Xml;\r\n        using System.Linq;\r\n        using Microsoft.WindowsAzure;\r\n        using Microsoft.WindowsAzure.MediaServices.Client;\r\n        using Microsoft.WindowsAzure.Storage;\r\n        using Microsoft.WindowsAzure.Storage.Blob;\r\n        using Microsoft.WindowsAzure.Storage.Auth;\r\n6. 将 appSettings 节添加到 .config 文件，并根据媒体服务和存储密钥与名称值更新值。 \r\n   \r\n        <appSettings>\r\n          <add key=\"MediaServicesAccountNameSource\" value=\"Media-Services-Account-Name-Source\"/>\r\n          <add key=\"MediaServicesAccountKeySource\" value=\"Media-Services-Account-Key-Source\"/>\r\n          <add key=\"MediaServicesStorageAccountNameSource\" value=\"Media-Services-Storage-Account-Name-Source\"/>\r\n          <add key=\"MediaServicesStorageAccountKeySource\" value=\"Media-Services-Storage-Account-Key-Source\"/>\r\n          <add key=\"MediaServicesAccountNameTarget\" value=\"Media-Services-Account-Name-Target\" />\r\n          <add key=\"MediaServicesAccountKeyTarget\" value=\" Media-Services-Account-Key-Target\" />\r\n          <add key=\"MediaServicesStorageAccountNameTarget\" value=\" Media-Services-Storage-Account-Name-Target\" />\r\n          <add key=\"MediaServicesStorageAccountKeyTarget\" value=\" Media-Services-Storage-Account-Key-Target\" />\r\n        </appSettings>\r\n\r\n## <a name=\"add-code-that-handles-redundancy-for-on-demand-streaming\"></a>添加用于处理按需流式处理冗余的代码\r\n在本部分，将创建用于处理冗余的功能。\r\n\r\n1. 将以下类级字段添加到 Program 类。\r\n       \r\n        // Read values from the App.config file.\r\n        private static readonly string MediaServicesAccountNameSource = ConfigurationManager.AppSettings[\"MediaServicesAccountNameSource\"];\r\n        private static readonly string MediaServicesAccountKeySource = ConfigurationManager.AppSettings[\"MediaServicesAccountKeySource\"];\r\n        private static readonly string StorageNameSource = ConfigurationManager.AppSettings[\"MediaServicesStorageAccountNameSource\"];\r\n        private static readonly string StorageKeySource = ConfigurationManager.AppSettings[\"MediaServicesStorageAccountKeySource\"];\r\n        \r\n        private static readonly string MediaServicesAccountNameTarget = ConfigurationManager.AppSettings[\"MediaServicesAccountNameTarget\"];\r\n        private static readonly string MediaServicesAccountKeyTarget = ConfigurationManager.AppSettings[\"MediaServicesAccountKeyTarget\"];\r\n        private static readonly string StorageNameTarget = ConfigurationManager.AppSettings[\"MediaServicesStorageAccountNameTarget\"];\r\n        private static readonly string StorageKeyTarget = ConfigurationManager.AppSettings[\"MediaServicesStorageAccountKeyTarget\"];\r\n        \r\n        // Base support files path.  Update this field to point to the base path  \r\n        // for the local support files folder that you create. \r\n        private static readonly string SupportFiles = Path.GetFullPath(@\"../..\\SupportFiles\");\r\n        \r\n        // Paths to support files (within the above base path). \r\n        private static readonly string SingleInputMp4Path = Path.GetFullPath(SupportFiles + @\"\\MP4Files\\BigBuckBunny.mp4\");\r\n        private static readonly string OutputFilesFolder = Path.GetFullPath(SupportFiles + @\"\\OutputFiles\");\r\n        \r\n        // Class-level field used to keep a reference to the service context.\r\n        static private CloudMediaContext _contextSource = null;\r\n        static private CloudMediaContext _contextTarget = null;\r\n        static private MediaServicesCredentials _cachedCredentialsSource = null;\r\n        static private MediaServicesCredentials _cachedCredentialsTarget = null;\r\n\r\n2. 请使用以下定义替换默认的 Main 方法定义。 下面定义了从 Main 调用的方法定义。\r\n        \r\n        static void Main(string[] args)\r\n        {\r\n            _cachedCredentialsSource = new MediaServicesCredentials(\r\n                            MediaServicesAccountNameSource,\r\n                            MediaServicesAccountKeySource);\r\n        \r\n            _cachedCredentialsTarget = new MediaServicesCredentials(\r\n                            MediaServicesAccountNameTarget,\r\n                            MediaServicesAccountKeyTarget);\r\n        \r\n            // Get server context.    \r\n            _contextSource = new CloudMediaContext(_cachedCredentialsSource);\r\n            _contextTarget = new CloudMediaContext(_cachedCredentialsTarget);\r\n        \r\n            IAsset assetSingleFile = CreateAssetAndUploadSingleFile(_contextSource,\r\n                                        AssetCreationOptions.None,\r\n                                        SingleInputMp4Path);\r\n        \r\n            IJob job = CreateEncodingJob(_contextSource, assetSingleFile);\r\n        \r\n            if (job.State != JobState.Error)\r\n            {\r\n                IAsset sourceOutputAsset = job.OutputMediaAssets[0];\r\n                // Get the locator for Smooth Streaming\r\n                var sourceOriginLocator = GetStreamingOriginLocator(_contextSource, sourceOutputAsset);\r\n        \r\n                Console.WriteLine(\"Locator Id: {0}\", sourceOriginLocator.Id);\r\n                \r\n                // 1.Create a read-only SAS locator for the source asset to have read access to the container in the source Storage account (associated with the source Media Services account)\r\n                var readSasLocator = GetSasReadLocator(_contextSource, sourceOutputAsset);\r\n        \r\n                // 2.Get the container name of the source asset from the read-only SAS locator created in the previous step\r\n                string containerName = (new Uri(readSasLocator.Path)).Segments[1];\r\n        \r\n                // 3.Create a target empty asset in the target Media Services account\r\n                var targetAsset = CreateTargetEmptyAsset(_contextTarget, containerName);\r\n        \r\n                // 4.Create a write SAS locator for the target empty asset to have write access to the container in the target Storage account (associated with the target Media Services account)\r\n                ILocator writeSasLocator = CreateSasWriteLocator(_contextTarget, targetAsset);\r\n        \r\n                // Get asset container name.\r\n                string targetContainerName = (new Uri(writeSasLocator.Path)).Segments[1];\r\n        \r\n                // 5.Copy the blobs in the source container (source asset) to the target container (target empty asset)\r\n                CopyBlobsFromDifferentStorage(containerName, targetContainerName, StorageNameSource, StorageKeySource, StorageNameTarget, StorageKeyTarget);\r\n        \r\n                // 6.Use the CreateFileInfos Media Services REST API to automatically generate all the IAssetFile’s for the target asset. \r\n                //      This API call is not supported in the current Media Services SDK for .NET. \r\n                CreateFileInfosForAssetWithRest(_contextTarget, targetAsset, MediaServicesAccountNameTarget, MediaServicesAccountKeyTarget);\r\n        \r\n                // Check if the AssetFiles are now  associated with the asset.\r\n                Console.WriteLine(\"Asset files assocated with the {0} asset:\", targetAsset.Name);\r\n                foreach (var af in targetAsset.AssetFiles)\r\n                {\r\n                    Console.WriteLine(af.Name);\r\n                }\r\n        \r\n                // 7.Copy the Origin locator of the source asset to the target asset by using the same Id\r\n                var replicatedLocatorPath = CreateOriginLocatorWithRest(_contextTarget,\r\n                            MediaServicesAccountNameTarget, MediaServicesAccountKeyTarget,\r\n                            sourceOriginLocator.Id, targetAsset.Id);\r\n        \r\n                // Create a full URL to the manifest file. Use this for playback\r\n                // in streaming media clients. \r\n                string originalUrlForClientStreaming = sourceOriginLocator.Path + GetPrimaryFile(sourceOutputAsset).Name + \"/manifest\";\r\n        \r\n                Console.WriteLine(\"Original Locator Path: {0}\\n\", originalUrlForClientStreaming);\r\n        \r\n                string replicatedUrlForClientStreaming = replicatedLocatorPath + GetPrimaryFile(sourceOutputAsset).Name + \"/manifest\";\r\n        \r\n                Console.WriteLine(\"Replicated Locator Path: {0}\", replicatedUrlForClientStreaming);\r\n        \r\n                readSasLocator.Delete();\r\n                writeSasLocator.Delete();\r\n        }\r\n\r\n3. 以下方法定义是从 Main 调用的。\r\n\r\n    >[!NOTE]\r\n    >不同媒体服务策略的策略数限制为 1,000,000 个（例如，Locator 策略或 ContentKeyAuthorizationPolicy 就是如此）。 如果始终使用相同的天数和访问权限，应使用相同的策略 ID。 例如，对于需要长期保留使用的定位符，请使用相同的策略 ID（非上传策略）。 有关详细信息，请参阅[此主题](media-services-dotnet-manage-entities.md#limit-access-policies)。\r\n\r\n        public static IAsset CreateAssetAndUploadSingleFile(CloudMediaContext context,\r\n                                                        AssetCreationOptions assetCreationOptions,\r\n                                                        string singleFilePath)\r\n        {\r\n            var assetName = \"UploadSingleFile_\" + DateTime.UtcNow.ToString();\r\n   \r\n            var asset = context.Assets.Create(assetName, assetCreationOptions);\r\n   \r\n            Console.WriteLine(\"Asset name: \" + asset.Name);\r\n   \r\n            var fileName = Path.GetFileName(singleFilePath);\r\n   \r\n            var assetFile = asset.AssetFiles.Create(fileName);\r\n   \r\n            Console.WriteLine(\"Created assetFile {0}\", assetFile.Name);\r\n   \r\n            Console.WriteLine(\"Upload {0}\", assetFile.Name);\r\n   \r\n            assetFile.Upload(singleFilePath);\r\n            Console.WriteLine(\"Done uploading of {0}\", assetFile.Name);\r\n   \r\n            return asset;\r\n        }\r\n   \r\n        public static IJob CreateEncodingJob(CloudMediaContext context, IAsset asset)\r\n        {\r\n            // Declare a new job.\r\n            IJob job = context.Jobs.Create(\"My encoding job\");\r\n   \r\n            // Get a media processor reference, and pass to it the name of the \r\n            // processor to use for the specific task.\r\n            IMediaProcessor processor = GetLatestMediaProcessorByName(context,\r\n                                                    \"Media Encoder Standard\");\r\n   \r\n            // Create a task with the encoding details, using a string preset.\r\n            // In this case \"Adaptive Streaming\" preset is used.\r\n            ITask task = job.Tasks.AddNew(\"My encoding task\",\r\n                processor,\r\n                \"Adaptive Streaming\",\r\n                TaskOptions.ProtectedConfiguration);\r\n   \r\n            // Specify the input asset to be encoded.\r\n            task.InputAssets.Add(asset);\r\n   \r\n            // Add an output asset to contain the results of the job. \r\n            // This output is specified as AssetCreationOptions.None, which \r\n            // means the output asset is in the clear (unencrypted). \r\n            var outputAssetName = \"OutputAsset_\" + Guid.NewGuid();\r\n            task.OutputAssets.AddNew(outputAssetName,\r\n                AssetCreationOptions.None);\r\n   \r\n            // Use the following event handler to check job progress.  \r\n            job.StateChanged += new\r\n                    EventHandler<JobStateChangedEventArgs>(StateChanged);\r\n   \r\n            // Launch the job.\r\n            job.Submit();\r\n   \r\n            // Optionally log job details. This displays basic job details\r\n            // to the console and saves them to a JobDetails-{JobId}.txt file \r\n            // in your output folder.\r\n            LogJobDetails(context, job.Id);\r\n   \r\n            // Check job execution and wait for job to finish. \r\n            Task progressJobTask = job.GetExecutionProgressTask(CancellationToken.None);\r\n            progressJobTask.Wait();\r\n   \r\n            // Get an updated job reference.\r\n            job = GetJob(context, job.Id);\r\n   \r\n            // Since we the output asset contains a set of Smooth Streaming files,\r\n            // set the .ism file to be the primary file\r\n            if (job.State != JobState.Error)\r\n                SetPrimaryFile(job.OutputMediaAssets[0]);\r\n   \r\n            return job;\r\n        }\r\n   \r\n        public static ILocator GetStreamingOriginLocator(CloudMediaContext context, IAsset assetToStream)\r\n        {\r\n            // Get a reference to the streaming manifest file from the  \r\n            // collection of files in the asset. \r\n            IAssetFile manifestFile = GetPrimaryFile(assetToStream);\r\n   \r\n            // Create a 30-day readonly access policy. \r\n            // You cannot create a streaming locator using an AccessPolicy that includes write or delete permissions.            \r\n   \r\n            IAccessPolicy policy = context.AccessPolicies.Create(\"Streaming policy\",\r\n                TimeSpan.FromDays(30),\r\n                AccessPermissions.Read);\r\n   \r\n            // Create a locator to the streaming content on an origin. \r\n            ILocator originLocator = context.Locators.CreateLocator(LocatorType.OnDemandOrigin,\r\n                assetToStream,\r\n                policy,\r\n                DateTime.UtcNow.AddMinutes(-5));\r\n   \r\n            // Return the locator. \r\n            return originLocator;\r\n        }\r\n   \r\n        public static ILocator GetSasReadLocator(CloudMediaContext context, IAsset asset)\r\n        {\r\n            IAccessPolicy accessPolicy = context.AccessPolicies.Create(\"File Download Policy\",\r\n                TimeSpan.FromDays(30), AccessPermissions.Read);\r\n   \r\n            ILocator sasLocator = context.Locators.CreateLocator(LocatorType.Sas,\r\n                asset, accessPolicy);\r\n   \r\n            return sasLocator;\r\n        }\r\n   \r\n        public static ILocator CreateSasWriteLocator(CloudMediaContext context, IAsset asset)\r\n        {\r\n   \r\n            IAccessPolicy writePolicy = context.AccessPolicies.Create(\"Write Policy\",\r\n                TimeSpan.FromDays(30), AccessPermissions.Write);\r\n   \r\n            ILocator sasLocator = context.Locators.CreateLocator(LocatorType.Sas,\r\n                asset, writePolicy);\r\n   \r\n            return sasLocator;\r\n        }\r\n   \r\n        public static IAsset CreateTargetEmptyAsset(CloudMediaContext context, string containerName)\r\n        {\r\n            // Create a new asset.\r\n            IAsset assetToBeProcessed = context.Assets.Create(containerName,\r\n                AssetCreationOptions.None);\r\n   \r\n            return assetToBeProcessed;\r\n        }\r\n   \r\n        public static void CreateFileInfosForAssetWithRest(CloudMediaContext context, IAsset asset, string mediaServicesAccountNameTarget,\r\n            string mediaServicesAccountKeyTarget)\r\n        {\r\n            string apiServer = \"\";\r\n            string scope = \"\";\r\n            string acsBaseAddress = \"\";\r\n   \r\n            string acsToken = GetAcsBearerToken(mediaServicesAccountNameTarget,\r\n                                    mediaServicesAccountKeyTarget, scope, acsBaseAddress);\r\n   \r\n            if (!string.IsNullOrEmpty(acsToken))\r\n            {\r\n                CreateFileInfos(apiServer, acsToken, asset.Id);\r\n            }\r\n        }\r\n   \r\n        public static string CreateOriginLocatorWithRest(CloudMediaContext context, string mediaServicesAccountNameTarget,\r\n            string mediaServicesAccountKeyTarget, string locatorIdToReplicate, string targetAssetId)\r\n        {\r\n            //Make sure we are not asking for a duplicate:\r\n            var locator = context.Locators.Where(l => l.Id == locatorIdToReplicate).FirstOrDefault();\r\n            if (locator != null)\r\n                return \"\";\r\n   \r\n            string locatorNewPath = \"\";\r\n            string apiServer = \"\";\r\n            string scope = \"\";\r\n            string acsBaseAddress = \"\";\r\n   \r\n            string acsToken = GetAcsBearerToken(mediaServicesAccountNameTarget,\r\n                                    mediaServicesAccountKeyTarget, scope, acsBaseAddress);\r\n   \r\n            if (!string.IsNullOrEmpty(acsToken))\r\n            {\r\n                var asset = context.Assets.Where(a => a.Id == targetAssetId).FirstOrDefault();\r\n   \r\n                // You cannot create a streaming locator using an AccessPolicy that includes write or delete permissions.            \r\n                var accessPolicy = context.AccessPolicies.Create(\"RestTest\", TimeSpan.FromDays(100),\r\n                                                                    AccessPermissions.Read);\r\n                if (asset != null)\r\n                {\r\n                    string redirectedServiceUri = null;\r\n   \r\n                    var xmlResponse = CreateLocator(apiServer, out redirectedServiceUri, acsToken,\r\n                                                                asset.Id, accessPolicy.Id,\r\n                                                                (int)LocatorType.OnDemandOrigin,\r\n                                                                DateTime.UtcNow.AddMinutes(-10), locatorIdToReplicate);\r\n   \r\n                    Console.WriteLine(\"Redirected to: \" + redirectedServiceUri);\r\n                    if (xmlResponse != null)\r\n                    {\r\n                        Console.WriteLine(String.Format(\"Locator Id: {0}\",\r\n                                                        xmlResponse.GetElementsByTagName(\"Id\")[0].InnerText));\r\n                        Console.WriteLine(String.Format(\"Locator Path: {0}\",\r\n                                xmlResponse.GetElementsByTagName(\"Path\")[0].InnerText));\r\n\r\n                        locatorNewPath = xmlResponse.GetElementsByTagName(\"Path\")[0].InnerText;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return locatorNewPath;\r\n        }\r\n\r\n        public static void SetPrimaryFile(IAsset asset)\r\n        {\r\n\r\n            var ismAssetFiles = asset.AssetFiles.ToList().\r\n                        Where(f => f.Name.EndsWith(\".ism\", StringComparison.OrdinalIgnoreCase))\r\n                        .ToArray();\r\n\r\n            if (ismAssetFiles.Count() != 1)\r\n                throw new ArgumentException(\"The asset should have only one, .ism file\");\r\n\r\n            ismAssetFiles.First().IsPrimary = true;\r\n            ismAssetFiles.First().Update();\r\n        }\r\n\r\n        public static IAssetFile GetPrimaryFile(IAsset asset)\r\n        {\r\n            var theManifest =\r\n                    from f in asset.AssetFiles\r\n                    where f.Name.EndsWith(\".ism\")\r\n                    select f;\r\n\r\n            // Cast the reference to a true IAssetFile type. \r\n            IAssetFile manifestFile = theManifest.First();\r\n\r\n            return manifestFile;\r\n        }\r\n\r\n        public static IAsset RefreshAsset(CloudMediaContext context, IAsset asset)\r\n        {\r\n            asset = context.Assets.Where(a => a.Id == asset.Id).FirstOrDefault();\r\n            return asset;\r\n        }\r\n\r\n        public static void CopyBlobsFromDifferentStorage(string sourceContainerName, string targetContainerName,\r\n                                            string srcAccountName, string srcAccountKey,\r\n                                            string destAccountName, string destAccountKey)\r\n        {\r\n            var srcAccount = new CloudStorageAccount(new StorageCredentials(srcAccountName, srcAccountKey), true);\r\n            var destAccount = new CloudStorageAccount(new StorageCredentials(destAccountName, destAccountKey), true);\r\n\r\n            var cloudBlobClient = srcAccount.CreateCloudBlobClient();\r\n            var targetBlobClient = destAccount.CreateCloudBlobClient();\r\n\r\n            var sourceContainer = cloudBlobClient.GetContainerReference(sourceContainerName);\r\n            var targetContainer = targetBlobClient.GetContainerReference(targetContainerName);\r\n            targetContainer.CreateIfNotExists();\r\n\r\n            string blobToken = sourceContainer.GetSharedAccessSignature(new SharedAccessBlobPolicy()\r\n            {\r\n                // Specify the expiration time for the signature.\r\n                SharedAccessExpiryTime = DateTime.Now.AddDays(1),\r\n                // Specify the permissions granted by the signature.\r\n                Permissions = SharedAccessBlobPermissions.Write | SharedAccessBlobPermissions.Read\r\n            });\r\n\r\n            foreach (var sourceBlob in sourceContainer.ListBlobs())\r\n            {\r\n                string fileName = (sourceBlob as ICloudBlob).Name;\r\n                var sourceCloudBlob = sourceContainer.GetBlockBlobReference(fileName);\r\n                sourceCloudBlob.FetchAttributes();\r\n\r\n                if (sourceCloudBlob.Properties.Length > 0)\r\n                {\r\n                    // In Azure Media Services, the files are stored as block blobs. \r\n                    // Page blobs are not supported by Azure Media Services.  \r\n                    var destinationBlob = targetContainer.GetBlockBlobReference(fileName);\r\n                    destinationBlob.StartCopyFromBlob(new Uri(sourceBlob.Uri.AbsoluteUri + blobToken));\r\n\r\n                    while (true)\r\n                    {\r\n                        // The StartCopyFromBlob is an async operation, \r\n                        // so we want to check if the copy operation is completed before proceeding. \r\n                        // To do that, we call FetchAttributes on the blob and check the CopyStatus. \r\n                        destinationBlob.FetchAttributes();\r\n                        if (destinationBlob.CopyState.Status != CopyStatus.Pending)\r\n                        {\r\n                            break;\r\n                        }\r\n                        //It's still not completed. So wait for some time.\r\n                        System.Threading.Thread.Sleep(1000);\r\n                    }\r\n                }\r\n\r\n                Console.WriteLine(fileName);\r\n            }\r\n\r\n            Console.WriteLine(\"Done copying.\");\r\n        }\r\n\r\n        private static IMediaProcessor GetLatestMediaProcessorByName(CloudMediaContext context, string mediaProcessorName)\r\n        {\r\n\r\n            var processor = context.MediaProcessors.Where(p => p.Name == mediaProcessorName).\r\n                ToList().OrderBy(p => new Version(p.Version)).LastOrDefault();\r\n\r\n            if (processor == null)\r\n                throw new ArgumentException(string.Format(\"Unknown media processor\", mediaProcessorName));\r\n\r\n            return processor;\r\n        }\r\n\r\n        // This method is a handler for events that track job progress.   \r\n        private static void StateChanged(object sender, JobStateChangedEventArgs e)\r\n        {\r\n            Console.WriteLine(\"Job state changed event:\");\r\n            Console.WriteLine(\"  Previous state: \" + e.PreviousState);\r\n            Console.WriteLine(\"  Current state: \" + e.CurrentState);\r\n\r\n            switch (e.CurrentState)\r\n            {\r\n                case JobState.Finished:\r\n                    Console.WriteLine();\r\n                    Console.WriteLine(\"********************\");\r\n                    Console.WriteLine(\"Job is finished.\");\r\n                    Console.WriteLine(\"Please wait while local tasks or downloads complete...\");\r\n                    Console.WriteLine(\"********************\");\r\n                    Console.WriteLine();\r\n                    Console.WriteLine();\r\n                    break;\r\n                case JobState.Canceling:\r\n                case JobState.Queued:\r\n                case JobState.Scheduled:\r\n                case JobState.Processing:\r\n                    Console.WriteLine(\"Please wait...\\n\");\r\n                    break;\r\n                case JobState.Canceled:\r\n                case JobState.Error:\r\n                    // Cast sender as a job.\r\n                    IJob job = (IJob)sender;\r\n                    // Display or log error details as needed.\r\n                    LogJobStop(null, job.Id);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        private static void LogJobStop(CloudMediaContext context, string jobId)\r\n        {\r\n            StringBuilder builder = new StringBuilder();\r\n            IJob job = GetJob(context, jobId);\r\n\r\n            builder.AppendLine(\"\\nThe job stopped due to cancellation or an error.\");\r\n            builder.AppendLine(\"***************************\");\r\n            builder.AppendLine(\"Job ID: \" + job.Id);\r\n            builder.AppendLine(\"Job Name: \" + job.Name);\r\n            builder.AppendLine(\"Job State: \" + job.State.ToString());\r\n            builder.AppendLine(\"Job started (server UTC time): \" + job.StartTime.ToString());\r\n            // Log job errors if they exist.  \r\n            if (job.State == JobState.Error)\r\n            {\r\n                builder.Append(\"Error Details: \\n\");\r\n                foreach (ITask task in job.Tasks)\r\n                {\r\n                    foreach (ErrorDetail detail in task.ErrorDetails)\r\n                    {\r\n                        builder.AppendLine(\"  Task Id: \" + task.Id);\r\n                        builder.AppendLine(\"    Error Code: \" + detail.Code);\r\n                        builder.AppendLine(\"    Error Message: \" + detail.Message + \"\\n\");\r\n                    }\r\n                }\r\n            }\r\n            builder.AppendLine(\"***************************\\n\");\r\n            // Write the output to a local file and to the console. The template \r\n            // for an error output file is:  JobStop-{JobId}.txt\r\n            string outputFile = OutputFilesFolder + @\"\\JobStop-\" + JobIdAsFileName(job.Id) + \".txt\";\r\n            WriteToFile(outputFile, builder.ToString());\r\n            Console.Write(builder.ToString());\r\n        }\r\n\r\n        private static void LogJobDetails(CloudMediaContext context, string jobId)\r\n        {\r\n            StringBuilder builder = new StringBuilder();\r\n            IJob job = GetJob(context, jobId);\r\n\r\n            builder.AppendLine(\"\\nJob ID: \" + job.Id);\r\n            builder.AppendLine(\"Job Name: \" + job.Name);\r\n            builder.AppendLine(\"Job submitted (client UTC time): \" + DateTime.UtcNow.ToString());\r\n\r\n            // Write the output to a local file and to the console. The template \r\n            // for an error output file is:  JobDetails-{JobId}.txt\r\n            string outputFile = OutputFilesFolder + @\"\\JobDetails-\" + JobIdAsFileName(job.Id) + \".txt\";\r\n            WriteToFile(outputFile, builder.ToString());\r\n            Console.Write(builder.ToString());\r\n        }\r\n\r\n        // Replace \":\" with \"_\" in Job id values so they can \r\n        // be used as log file names.  \r\n        private static string JobIdAsFileName(string jobID)\r\n        {\r\n            return jobID.Replace(\":\", \"_\");\r\n        }\r\n\r\n        // Write method output to the output files folder.\r\n        private static void WriteToFile(string outFilePath, string fileContent)\r\n        {\r\n            StreamWriter sr = File.CreateText(outFilePath);\r\n            sr.WriteLine(fileContent);\r\n            sr.Close();\r\n        }\r\n\r\n        private static IJob GetJob(CloudMediaContext context, string jobId)\r\n        {\r\n            // Use a Linq select query to get an updated \r\n            // reference by Id. \r\n            var jobInstance =\r\n                from j in context.Jobs\r\n                where j.Id == jobId\r\n                select j;\r\n\r\n            // Return the job reference as an Ijob. \r\n            IJob job = jobInstance.FirstOrDefault();\r\n\r\n            return job;\r\n        }\r\n\r\n        private static IAsset GetAsset(CloudMediaContext context, string assetId)\r\n        {\r\n            // Use a LINQ Select query to get an asset.\r\n            var assetInstance =\r\n                from a in context.Assets\r\n                where a.Id == assetId\r\n                select a;\r\n\r\n            // Reference the asset as an IAsset.\r\n            IAsset asset = assetInstance.FirstOrDefault();\r\n\r\n            return asset;\r\n        }\r\n\r\n        public static void DeleteAllAssets(CloudMediaContext context)\r\n        {\r\n            // Loop through and delete all assets.\r\n            foreach (IAsset asset in context.Assets)\r\n            {\r\n                DeleteLocatorsForAsset(context, asset);\r\n\r\n                asset.Delete();\r\n            }\r\n        }\r\n\r\n        public static void DeleteLocatorsForAsset(CloudMediaContext context, IAsset asset)\r\n        {\r\n            string assetId = asset.Id;\r\n            var locators = from a in context.Locators\r\n                            where a.AssetId == assetId\r\n                            select a;\r\n            foreach (var locator in locators)\r\n            {\r\n                Console.WriteLine(\"Deleting locator {0} for asset {1}\", locator.Path, assetId);\r\n\r\n                locator.Delete();\r\n            }\r\n        }\r\n\r\n        public static void DeleteAccessPolicy(CloudMediaContext context, string existingPolicyId)\r\n        {\r\n            // To delete a specific access policy, get a reference to the policy.  \r\n            // based on the policy Id passed to the method.\r\n            var policyInstance =\r\n                    from p in context.AccessPolicies\r\n                    where p.Id == existingPolicyId\r\n                    select p;\r\n\r\n            IAccessPolicy policy = policyInstance.FirstOrDefault();\r\n\r\n            policy.Delete();\r\n\r\n        }\r\n\r\n        //////////////////////////////////////////////////////\r\n        /// The following methods use REST calls.\r\n        //////////////////////////////////////////////////////\r\n\r\n        public static string GetAcsBearerToken(string clientId, string clientSecret, string scope, string accessControlServiceUri)\r\n        {\r\n            if (string.IsNullOrEmpty(clientId))\r\n                throw new ArgumentNullException(\"clientId\");\r\n\r\n            if (string.IsNullOrEmpty(clientSecret))\r\n                throw new ArgumentNullException(\"clientSecret\");\r\n\r\n            if (string.IsNullOrEmpty(scope))\r\n            {\r\n                scope = \"urn:WindowsAzureMediaServices\";\r\n            }\r\n            else if (!scope.ToLower().StartsWith(\"urn:\"))\r\n            {\r\n                scope = \"urn:\" + scope;\r\n            }\r\n\r\n            if (string.IsNullOrEmpty(accessControlServiceUri))\r\n            {\r\n                accessControlServiceUri = \"https://wamsprodglobal001acs.accesscontrol.chinacloudapi.cn/v2/OAuth2-13\";\r\n            }\r\n            else if (!accessControlServiceUri.ToLower().EndsWith(\"/v2/oauth2-13\"))\r\n            {\r\n                accessControlServiceUri = accessControlServiceUri.TrimEnd('/') + \"/v2/OAuth2-13\";\r\n            }\r\n\r\n            HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(accessControlServiceUri);\r\n            request.Method = \"POST\";\r\n            request.ContentType = \"application/x-www-form-urlencoded\";\r\n            request.KeepAlive = true;\r\n            string acsBearerToken = null;\r\n\r\n            var requestBytes = Encoding.ASCII.GetBytes(\"grant_type=client_credentials&client_id=\" +\r\n                clientId + \"&client_secret=\" + HttpUtility.UrlEncode(clientSecret) +\r\n                \"&scope=\" + HttpUtility.UrlEncode(scope));\r\n            request.ContentLength = requestBytes.Length;\r\n\r\n            var requestStream = request.GetRequestStream();\r\n            requestStream.Write(requestBytes, 0, requestBytes.Length);\r\n            requestStream.Close();\r\n\r\n            var response = (HttpWebResponse)request.GetResponse();\r\n\r\n            if (response.StatusCode == HttpStatusCode.OK)\r\n            {\r\n                using (Stream responseStream = response.GetResponseStream())\r\n                {\r\n                    using (StreamReader stream = new StreamReader(responseStream))\r\n                    {\r\n                        string responseString = stream.ReadToEnd();\r\n                        var reader = JsonReaderWriterFactory.CreateJsonReader(Encoding.UTF8.GetBytes(responseString),\r\n                            new XmlDictionaryReaderQuotas());\r\n\r\n                        while (reader.Read())\r\n                        {\r\n                            if ((reader.Name == \"access_token\") && (reader.NodeType == XmlNodeType.Element))\r\n                            {\r\n                                if (reader.Read())\r\n                                {\r\n                                    acsBearerToken = reader.Value;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return acsBearerToken;\r\n        }\r\n\r\n        public static XmlDocument CreateLocator(string mediaServicesApiServerUri,\r\n                                                out string redirectedMediaServicesApiServerUri,\r\n                                                string acsBearerToken, string assetId,\r\n                                                string accessPolicyId, int locatorType,\r\n                                                DateTime startTime, string locatorIdToReplicate = null,\r\n                                                bool autoRedirect = true)\r\n        {\r\n            if (string.IsNullOrEmpty(mediaServicesApiServerUri))\r\n            {\r\n                mediaServicesApiServerUri = \"https://wamsshaclus001rest-hs.chinacloudapp.cn/api/\";\r\n            }\r\n            if (!mediaServicesApiServerUri.EndsWith(\"/\"))\r\n                mediaServicesApiServerUri = mediaServicesApiServerUri + \"/\";\r\n\r\n            if (string.IsNullOrEmpty(acsBearerToken)) throw new ArgumentNullException(\"acsBearerToken\");\r\n            if (string.IsNullOrEmpty(assetId)) throw new ArgumentNullException(\"assetId\");\r\n            if (string.IsNullOrEmpty(accessPolicyId)) throw new ArgumentNullException(\"accessPolicyId\");\r\n\r\n            redirectedMediaServicesApiServerUri = null;\r\n            XmlDocument xmlResponse = null;\r\n\r\n            StringBuilder sb = new StringBuilder();\r\n            sb.Append(\"{ \\\"AssetId\\\" : \\\"\" + assetId + \"\\\"\");\r\n            sb.Append(\", \\\"AccessPolicyId\\\" : \\\"\" + accessPolicyId + \"\\\"\");\r\n            sb.Append(\", \\\"Type\\\" : \\\"\" + locatorType + \"\\\"\");\r\n            if (startTime != DateTime.MinValue)\r\n                sb.Append(\", \\\"StartTime\\\" : \\\"\" + startTime.ToString(\"G\", CultureInfo.CreateSpecificCulture(\"en-us\")) + \"\\\"\");\r\n            if (!string.IsNullOrEmpty(locatorIdToReplicate))\r\n                sb.Append(\", \\\"Id\\\" : \\\"\" + locatorIdToReplicate + \"\\\"\");\r\n            sb.Append(\"}\");\r\n\r\n            string requestbody = sb.ToString();\r\n\r\n            try\r\n            {\r\n                var request = GenerateRequest(\"POST\", mediaServicesApiServerUri, \"Locators\",\r\n                    null, acsBearerToken, requestbody);\r\n                var response = (HttpWebResponse)request.GetResponse();\r\n\r\n                switch (response.StatusCode)\r\n                {\r\n                    case HttpStatusCode.MovedPermanently:\r\n                        //Recurse once with the mediaServicesApiServerUri redirect Location:\r\n                        if (autoRedirect)\r\n                        {\r\n                            redirectedMediaServicesApiServerUri = response.Headers[\"Location\"];\r\n                            string secondRedirection = null;\r\n                            xmlResponse = CreateLocator(redirectedMediaServicesApiServerUri,\r\n                                                        out secondRedirection, acsBearerToken,\r\n                                                        assetId, accessPolicyId, locatorType,\r\n                                                        startTime, locatorIdToReplicate, false);\r\n                        }\r\n                        else\r\n                        {\r\n                            Console.WriteLine(\"Redirection to {0} failed.\",\r\n                                mediaServicesApiServerUri);\r\n                            return null;\r\n                        }\r\n                        break;\r\n                    case HttpStatusCode.Created:\r\n                        using (Stream responseStream = response.GetResponseStream())\r\n                        {\r\n                            using (StreamReader stream = new StreamReader(responseStream))\r\n                            {\r\n                                string responseString = stream.ReadToEnd();\r\n                                var reader = JsonReaderWriterFactory.\r\n                                    CreateJsonReader(Encoding.UTF8.GetBytes(responseString),\r\n                                        new XmlDictionaryReaderQuotas());\r\n\r\n                                xmlResponse = new XmlDocument();\r\n                                reader.Read();\r\n                                xmlResponse.LoadXml(reader.ReadInnerXml());\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        Console.WriteLine(response.StatusDescription);\r\n                        break;\r\n                }\r\n            }\r\n            catch (WebException ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n\r\n            return xmlResponse;\r\n        }\r\n\r\n        public static void CreateFileInfos(string mediaServicesApiServerUri,\r\n                                    string acsBearerToken,\r\n                                    string assetId\r\n                                    )\r\n        {\r\n            if (String.IsNullOrEmpty(mediaServicesApiServerUri))\r\n            {\r\n                mediaServicesApiServerUri = \"https://wamsshaclus001rest-hs.chinacloudapp.cn/api/\";\r\n            }\r\n            if (!mediaServicesApiServerUri.EndsWith(\"/\"))\r\n                mediaServicesApiServerUri = mediaServicesApiServerUri + \"/\";\r\n\r\n            if (String.IsNullOrEmpty(acsBearerToken)) throw new ArgumentNullException(\"acsBearerToken\");\r\n            if (String.IsNullOrEmpty(assetId)) throw new ArgumentNullException(\"assetId\");\r\n\r\n            string id = assetId.Replace(\":\", \"%\");\r\n\r\n            UriBuilder builder = new UriBuilder(mediaServicesApiServerUri);\r\n            builder.Path = Path.Combine(builder.Path, \"CreateFileInfos\");\r\n            builder.Query = String.Format(CultureInfo.InvariantCulture, \"assetid='{0}'\", assetId);\r\n\r\n            try\r\n            {\r\n                var request = GenerateRequest(\"GET\", mediaServicesApiServerUri, \"CreateFileInfos\",\r\n                    String.Format(CultureInfo.InvariantCulture, \"assetid='{0}'\", assetId), acsBearerToken, null);\r\n\r\n                using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())\r\n                {\r\n                    if (response.StatusCode == HttpStatusCode.MovedPermanently)\r\n                    {\r\n                        string redirectedMediaServicesApiUrl = response.Headers[\"Location\"];\r\n\r\n                        CreateFileInfos(redirectedMediaServicesApiUrl, acsBearerToken, assetId);\r\n                    }\r\n                    else if ((response.StatusCode != HttpStatusCode.OK) &&\r\n                        (response.StatusCode != HttpStatusCode.Accepted) &&\r\n                        (response.StatusCode != HttpStatusCode.Created) &&\r\n                        (response.StatusCode != HttpStatusCode.NoContent))\r\n                    {\r\n                        // TODO: Throw a more specific exception.\r\n                        throw new Exception(\"Invalid response received \");\r\n                    }\r\n                }\r\n            }\r\n            catch (WebException ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n        }\r\n\r\n        private static HttpWebRequest GenerateRequest(string verb,\r\n                                                        string mediaServicesApiServerUri,\r\n                                                        string resourcePath, string query,\r\n                                                        string acsBearerToken, string requestbody)\r\n        {\r\n            var uriBuilder = new UriBuilder(mediaServicesApiServerUri);\r\n            uriBuilder.Path += resourcePath;\r\n            if (query != null)\r\n            {\r\n                uriBuilder.Query = query;\r\n            }\r\n            HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(uriBuilder.Uri);\r\n            request.AllowAutoRedirect = false; //We manage our own redirects.\r\n            request.Method = verb;\r\n\r\n            if (resourcePath == \"$metadata\")\r\n                request.MediaType = \"application/xml\";\r\n            else\r\n            {\r\n                request.ContentType = \"application/json;odata=verbose\";\r\n                request.Accept = \"application/json;odata=verbose\";\r\n            }\r\n\r\n            request.Headers.Add(\"DataServiceVersion\", \"3.0\");\r\n            request.Headers.Add(\"MaxDataServiceVersion\", \"3.0\");\r\n            request.Headers.Add(\"x-ms-version\", \"2.1\");\r\n            request.Headers.Add(HttpRequestHeader.Authorization, \"Bearer \" + acsBearerToken);\r\n\r\n            if (requestbody != null)\r\n            {\r\n                var requestBytes = Encoding.ASCII.GetBytes(requestbody);\r\n                request.ContentLength = requestBytes.Length;\r\n\r\n                var requestStream = request.GetRequestStream();\r\n                requestStream.Write(requestBytes, 0, requestBytes.Length);\r\n                requestStream.Close();\r\n            }\r\n            else\r\n            {\r\n                request.ContentLength = 0;\r\n            }\r\n            return request;\r\n        }\r\n\r\n## <a name=\"next-steps\"></a>后续步骤\r\n现在，可以使用流量管理器在两个数据中心之间路由请求，因此可在发生任何中断时故障转移。\r\n<!--Update_Description: update code-->"}