{"Title":"使用 Azure 媒体包装器完成静态打包任务","Description":"本主题说明了通过 Azure 媒体包装器完成的各种任务。","Content":"# <a name=\"using-azure-media-packager-to-accomplish-static-packaging-tasks\"></a>使用 Azure 媒体包装器完成静态打包任务\r\n\r\n>[!NOTE]\r\n>Microsoft Azure 媒体包装器和 Microsoft Azure 媒体加密器的使用期限已延长到 2017 年 3 月 1 日。 在此日期之前，这些处理器的功能将添加到 Media Encoder Standard (MES) 中。 客户将收到有关如何迁移工作流以将作业发送到 MES 的指示。 格式转换和加密功能也可通过动态打包和动态加密提供。\r\n\r\n## <a name=\"overview\"></a>概述\r\n\r\n要通过 Internet 传送数字视频，必须对媒体进行压缩。 数字视频文件相当大，可能因过大而无法通过 Internet 传送或者无法在客户的设备上正常显示。 编码是压缩视频和音频以便客户能够查看媒体的过程。 视频经过编码后即可放入不同的文件容器中。 将编码后的媒体放入容器这一过程称为打包。 以 MP4 文件为例，可以使用 Azure 媒体包装器将其转换为平滑流式处理或 HLS 内容。 \r\n\r\n媒体服务支持动态和静态打包。 使用静态打包时，需要以客户要求的各种格式创建内容副本。 使用动态打包，只需要创建一个包含一组自适应比特率 MP4 或平滑流文件的资产。 然后，按需流式处理服务器会确保用户的用户以选定的协议按清单或分段请求中的指定格式接收流。 因此，用户只需以单一存储格式存储文件并为其付费，媒体服务服务就会基于客户端的请求构建并提供相应响应。\r\n\r\n> [!NOTE]\r\n> 建议使用[动态打包](media-services-dynamic-packaging-overview.md)。\r\n> \r\n> \r\n\r\n但是，有的方案需要静态打包： \r\n\r\n* 验证使用外部编码器编码的自适应比特率 MP4（例如，使用第三方编码器）。\r\n\r\n还可以使用静态打包执行下列任务。 但是，仍建议使用动态加密。\r\n\r\n* 通过静态加密使用 PlayReady 来保护平滑流和 MPEG DASH\r\n* 通过静态加密使用 AES-128 来保护 HLSv3\r\n* 通过静态加密使用 PlayReady 来保护 HLSv3\r\n\r\n## <a name=\"validating-adaptive-bitrate-mp4s-encoded-with-external-encoders\"></a>验证使用外部编码器编码的自适应比特率 MP4\r\n若要使用一组未使用媒体服务的编码器编码的自适应比特率（多比特率）MP4 文件，则应在进一步处理前验证这些文件。 媒体服务包装程序可以验证包含一组 MP4 文件的资产，并可检查该资产是否可以打包成平滑流或 HLS。 如果验证任务失败，则处理该任务的作业完成并显示错误。 用于定义验证任务的预设的 XML 可以在 [Azure 媒体包装器的任务预设](http://msdn.microsoft.com/library/azure/hh973635.aspx) 主题中找到。\r\n\r\n> [!NOTE]\r\n> 请使用 Media Encoder Standard 来生成内容，或使用媒体服务包装程序来验证内容，以避免运行时问题。 如果按需流式处理服务器在运行时无法解析源文件，则你会收到 HTTP 1.1 错误“415 不支持的媒体类型”。 服务器多次未能解析源文件会影响按需流式处理服务器的性能，并且可能会减少服务于其他请求的可用带宽。 Azure 媒体服务在其按需流式处理服务上提供一个服务级别协议 (SLA)；但是，如果以上述方式滥用服务器，则无法遵循此 SLA。\r\n> \r\n> \r\n\r\n本部分演示如何处理验证任务。 本部分还演示如何查看完成时出现 JobStatus.Error 的作业的状态和错误消息。\r\n\r\n若要使用媒体服务包装程序验证 MP4 文件，必须创建自己的清单 (.ism) 文件，并将其与源文件一起上传到媒体服务帐户。 下面是 Media Encoder Standard 生成的 .ism 文件的一个示例。 文件名区分大小写。 另请确保 .ism 文件中的文本采用 UTF-8 编码。\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\r\n<smil xmlns=\"http://www.w3.org/2001/SMIL20/Language\">\r\n  <head>\r\n<!-- Tells the server that these input files are MP4s – specific to Dynamic Packaging -->\r\n    <meta name=\"formats\" content=\"mp4\" /> \r\n  </head>\r\n  <body>\r\n    <switch>\r\n      <video src=\"BigBuckBunny_1000.mp4\" />\r\n      <video src=\"BigBuckBunny_1500.mp4\" />\r\n      <video src=\"BigBuckBunny_2250.mp4\" />\r\n      <video src=\"BigBuckBunny_3400.mp4\" />\r\n      <video src=\"BigBuckBunny_400.mp4\" />\r\n      <video src=\"BigBuckBunny_650.mp4\" />\r\n      <audio src=\"BigBuckBunny_400.mp4\" />\r\n    </switch>\r\n  </body>\r\n</smil>\r\n```\r\n\r\n创建自适应比特率 MP4 集后，便可以利用动态打包功能。 动态打包允许通过指定的协议传送流，而不需要进一步地打包。 有关详细信息，请参阅[动态打包](media-services-dynamic-packaging-overview.md)。\r\n\r\n以下代码示例使用 Azure 媒体服务 .NET SDK 扩展。  请确保更新代码，以指向输入 MP4 文件和 .ism 文件所在的文件夹。 并指向 MediaPackager_ValidateTask.xml 文件所在的位置。 此 XML 文件在 [Azure 媒体包装器的任务预设](http://msdn.microsoft.com/library/azure/hh973635.aspx) 主题中定义。\r\n\r\n```\r\nusing Microsoft.WindowsAzure.MediaServices.Client;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Configuration;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing System.Xml.Linq;\r\n\r\nnamespace MediaServicesStaticPackaging\r\n{\r\n    class Program\r\n    {\r\n        private static readonly string _mediaFiles =\r\n            Path.GetFullPath(@\"../..\\Media\");\r\n\r\n        // The MultibitrateMP4Files folder should also\r\n        // contain the .ism manifest file.\r\n        private static readonly string _multibitrateMP4s =\r\n            Path.Combine(_mediaFiles, @\"MultibitrateMP4Files\");\r\n\r\n        // XML Configruation files path.\r\n        private static readonly string _configurationXMLFiles = @\"../..\\Configurations\";\r\n\r\n        private static MediaServicesCredentials _cachedCredentials = null;\r\n        private static CloudMediaContext _context = null;\r\n\r\n        // Media Services account information.\r\n        private static readonly string _mediaServicesAccountName =\r\n            ConfigurationManager.AppSettings[\"MediaServicesAccountName\"];\r\n        private static readonly string _mediaServicesAccountKey =\r\n            ConfigurationManager.AppSettings[\"MediaServicesAccountKey\"];\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            // Create and cache the Media Services credentials in a static class variable.\r\n            _cachedCredentials = new MediaServicesCredentials(\r\n                            _mediaServicesAccountName,\r\n                            _mediaServicesAccountKey);\r\n            // Use the cached credentials to create CloudMediaContext.\r\n            _context = new CloudMediaContext(_cachedCredentials);\r\n\r\n            // Ingest a set of multibitrate MP4s.\r\n            //\r\n            // Use the SDK extension method to create a new asset by \r\n            // uploading files from a local directory.\r\n            IAsset multibitrateMP4sAsset = _context.Assets.CreateFromFolder(\r\n                _multibitrateMP4s,\r\n                AssetCreationOptions.None,\r\n                (af, p) =>\r\n                {\r\n                    Console.WriteLine(\"Uploading '{0}' - Progress: {1:0.##}%\", af.Name, p.Progress);\r\n                });\r\n\r\n            // Use Azure Media Packager to validate the files.\r\n            IAsset validatedMP4s =\r\n                ValidateMultibitrateMP4s(multibitrateMP4sAsset);\r\n\r\n            // Publish the asset.\r\n            _context.Locators.Create(\r\n                LocatorType.OnDemandOrigin,\r\n                validatedMP4s,\r\n                AccessPermissions.Read,\r\n                TimeSpan.FromDays(30));\r\n\r\n                                 // Get the streaming URLs.\r\n            Console.WriteLine(\"Smooth Streaming URL:\");\r\n            Console.WriteLine(validatedMP4s.GetSmoothStreamingUri().ToString());\r\n            Console.WriteLine(\"MPEG DASH URL:\");\r\n            Console.WriteLine(validatedMP4s.GetMpegDashUri().ToString());\r\n            Console.WriteLine(\"HLS URL:\");\r\n            Console.WriteLine(validatedMP4s.GetHlsUri().ToString());\r\n        }\r\n\r\n        public static IAsset ValidateMultibitrateMP4s(IAsset multibitrateMP4sAsset)\r\n        {\r\n            // Set .ism as a primary file \r\n            // in a multibitrate MP4 set.\r\n            SetISMFileAsPrimary(multibitrateMP4sAsset);\r\n\r\n            // Create a new job.\r\n            IJob job = _context.Jobs.Create(\"MP4 validation and converstion to Smooth Stream job.\");\r\n\r\n            // Read the task configuration data into a string. \r\n            string configMp4Validation = File.ReadAllText(Path.Combine(\r\n                    _configurationXMLFiles,\r\n                    \"MediaPackager_ValidateTask.xml\"));\r\n\r\n            // Get the SDK extension method to  get a reference to the Azure Media Packager.\r\n            IMediaProcessor processor = _context.MediaProcessors.GetLatestMediaProcessorByName(\r\n                MediaProcessorNames.WindowsAzureMediaPackager);\r\n\r\n            // Create a task with the conversion details, using the configuration data. \r\n            ITask task = job.Tasks.AddNew(\"Mp4 Validation Task\",\r\n                processor,\r\n                configMp4Validation,\r\n                TaskOptions.None);\r\n\r\n            // Specify the input asset to be validated.\r\n            task.InputAssets.Add(multibitrateMP4sAsset);\r\n\r\n            // Add an output asset to contain the results of the job. \r\n            // This output is specified as AssetCreationOptions.None, which \r\n            // means the output asset is in the clear (unencrypted). \r\n            task.OutputAssets.AddNew(\"Validated output asset\",\r\n                    AssetCreationOptions.None);\r\n\r\n            // Submit the job and wait until it is completed.\r\n            job.Submit();\r\n            job = job.StartExecutionProgressTask(\r\n                j =>\r\n                {\r\n                    Console.WriteLine(\"Job state: {0}\", j.State);\r\n                    Console.WriteLine(\"Job progress: {0:0.##}%\", j.GetOverallProgress());\r\n                },\r\n                CancellationToken.None).Result;\r\n\r\n            // If the validation task fails and job completes with JobState.Error,\r\n            // display the error message and throw an exception.\r\n            if (job.State == JobState.Error)\r\n            {\r\n                Console.WriteLine(\"  Job ID: \" + job.Id);\r\n                Console.WriteLine(\"  Name: \" + job.Name);\r\n                Console.WriteLine(\"  State: \" + job.State);\r\n\r\n                foreach (var jobTask in job.Tasks)\r\n                {\r\n                    Console.WriteLine(\"  Task Id: \" + jobTask.Id);\r\n                    Console.WriteLine(\"  Name: \" + jobTask.Name);\r\n                    Console.WriteLine(\"  Progress: \" + jobTask.Progress);\r\n                    Console.WriteLine(\"  Configuration: \" + jobTask.Configuration);\r\n                    Console.WriteLine(\"  Running time: \" + jobTask.RunningDuration);\r\n                    if (jobTask.ErrorDetails != null)\r\n                    {\r\n                        foreach (var errordetail in jobTask.ErrorDetails)\r\n                        {\r\n\r\n                            Console.WriteLine(\"  Error Message:\" + errordetail.Message);\r\n                            Console.WriteLine(\"  Error Code:\" + errordetail.Code);\r\n                        }\r\n                    }\r\n                }\r\n                throw new Exception(\"The specified multi-bitrate MP4 set is not valid.\");\r\n            }\r\n\r\n            return job.OutputMediaAssets[0];\r\n        }\r\n\r\n        static void SetISMFileAsPrimary(IAsset asset)\r\n        {\r\n            var ismAssetFiles = asset.AssetFiles.ToList().\r\n                Where(f => f.Name.EndsWith(\".ism\", StringComparison.OrdinalIgnoreCase)).ToArray();\r\n\r\n            // The following code assigns the first .ism file as the primary file in the asset.\r\n            // An asset should have one .ism file.  \r\n            ismAssetFiles.First().IsPrimary = true;\r\n            ismAssetFiles.First().Update();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## <a name=\"using-static-encryption-to-protect-your-smooth-and-mpeg-dash-with-playready\"></a>通过静态加密使用 PlayReady 来保护平滑流和 MPEG DASH\r\n若想要通过 PlayReady 来保护内容，则可选择使用[动态加密](media-services-protect-with-drm.md)（推荐选项）或静态加密（如本部分所述）。\r\n\r\n本部分的示例将夹层文件（在本例中为 MP4）编码为自适应比特率 MP4 文件。 然后，它将 MP4 打包为平滑流，并使用 PlayReady 对平滑流进行加密。 因此，能对平滑流或 MPEG DASH 进行流式处理。\r\n\r\n媒体服务现在提供有用于传送 Microsoft PlayReady 许可证的服务。 本文中的示例显示如何配置媒体服务 PlayReady 许可证传送服务（请参阅以下代码中定义的 ConfigureLicenseDeliveryService 方法）。 有关媒体服务 PlayReady 许可证传送服务的详细信息，请参阅[使用 PlayReady 动态加密和许可证传送服务](media-services-protect-with-drm.md)。\r\n\r\n> [!NOTE]\r\n> 若要传送使用 PlayReady 加密的 MPEG DASH，请确保通过将 useSencBox 和 adjustSubSamples 属性（在 [Azure 媒体加密器的任务预设](http://msdn.microsoft.com/library/azure/hh973610.aspx)主题中说明）设为 true 来使用 CENC 选项。  \r\n> \r\n> \r\n\r\n确保更新以下代码，以便指向输入 MP4 文件所在的文件夹，\r\n\r\n并指向 MediaPackager_MP4ToSmooth.xml 和 MediaEncryptor_PlayReadyProtection.xml 文件所在的位置。 MediaPackager_MP4ToSmooth.xml 在 [Azure 媒体包装器的任务预设](http://msdn.microsoft.com/library/azure/hh973635.aspx)中定义，MediaEncryptor_PlayReadyProtection.xml 在 [Azure 媒体加密器的任务预设](http://msdn.microsoft.com/library/azure/hh973610.aspx)主题中定义。 \r\n\r\n该示例定义的 UpdatePlayReadyConfigurationXMLFile 方法可用于动态更新 MediaEncryptor_PlayReadyProtection.xml 文件。 如果有可用的密钥种子，则可以使用 CommonEncryption.GeneratePlayReadyContentKey 方法基于 keySeedValue 和 keyId 值生成内容密钥。\r\n\r\n```\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Configuration;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing Microsoft.WindowsAzure.MediaServices.Client;\r\nusing System.Xml.Linq;\r\nusing Microsoft.WindowsAzure.MediaServices.Client.ContentKeyAuthorization;\r\nusing Microsoft.WindowsAzure.MediaServices.Client.DynamicEncryption;\r\n\r\nnamespace PlayReadyStaticEncryptAndKeyDeliverySvc\r\n{\r\n    class Program\r\n    {\r\n\r\n        private static readonly string _mediaFiles =\r\n            Path.GetFullPath(@\"../..\\Media\");\r\n\r\n        private static readonly string _singleMP4File =\r\n            Path.Combine(_mediaFiles, @\"BigBuckBunny.mp4\");\r\n\r\n        // XML Configruation files path.\r\n        private static readonly string _configurationXMLFiles = @\"../..\\Configurations\\\";\r\n\r\n        private static MediaServicesCredentials _cachedCredentials = null;\r\n        private static CloudMediaContext _context = null;\r\n\r\n        // Media Services account information.\r\n        private static readonly string _mediaServicesAccountName =\r\n            ConfigurationManager.AppSettings[\"MediaServiceAccountName\"];\r\n        private static readonly string _mediaServicesAccountKey =\r\n            ConfigurationManager.AppSettings[\"MediaServiceAccountKey\"];\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            // Create and cache the Media Services credentials in a static class variable.\r\n            _cachedCredentials = new MediaServicesCredentials(\r\n                            _mediaServicesAccountName,\r\n                            _mediaServicesAccountKey);\r\n            // Use the cached credentials to create CloudMediaContext.\r\n            _context = new CloudMediaContext(_cachedCredentials);\r\n\r\n            // Encoding and encrypting assets //////////////////////\r\n            // Load a single MP4 file.\r\n            IAsset asset = IngestSingleMP4File(_singleMP4File, AssetCreationOptions.None);\r\n\r\n            // Encode an MP4 file to a set of multibitrate MP4s.\r\n            // Then, package a set of MP4s to clear Smooth Streaming.\r\n            IAsset clearSmoothStreamAsset =\r\n                ConvertMP4ToMultibitrateMP4sToSmoothStreaming(asset);\r\n\r\n            // Create a common encryption content key that is used \r\n            // a) to set the key values in the MediaEncryptor_PlayReadyProtection.xml file\r\n            //    that is used for encryption.\r\n            // b) to configure the license delivery service and \r\n            //\r\n            Guid keyId;\r\n            byte[] contentKey;\r\n\r\n            IContentKey key = CreateCommonEncryptionKey(out keyId, out contentKey);\r\n\r\n            // The content key authorization policy must be configured by you \r\n            // and met by the client in order for the PlayReady license\r\n            // to be delivered to the client. \r\n            // In this example the Media Services PlayReady license delivery service is used.\r\n            ConfigureLicenseDeliveryService(key);\r\n\r\n            // Get the Media Services PlayReady license delivery URL.\r\n            // This URL will be assigned to the licenseAcquisitionUrl property \r\n            // of the MediaEncryptor_PlayReadyProtection.xml file.\r\n            Uri acquisitionUrl = key.GetKeyDeliveryUrl(ContentKeyDeliveryType.PlayReadyLicense);\r\n\r\n            // Update the MediaEncryptor_PlayReadyProtection.xml file with the key and URL info.\r\n            UpdatePlayReadyConfigurationXMLFile(keyId, contentKey, acquisitionUrl);\r\n\r\n            // Encrypt your clear Smooth Streaming to Smooth Streaming with PlayReady.\r\n            IAsset outputAsset = CreateSmoothStreamEncryptedWithPlayReady(clearSmoothStreamAsset);\r\n\r\n            // You can use the http://smf.cloudapp.net/healthmonitor player \r\n            // to test the smoothStreamURL URL.\r\n            string smoothStreamURL = outputAsset.GetSmoothStreamingUri().ToString();\r\n            Console.WriteLine(\"Smooth Streaming URL:\");\r\n            Console.WriteLine(smoothStreamURL);\r\n\r\n            // You can use the http://dashif.org/reference/players/javascript/ player \r\n            // to test the dashURL URL.\r\n            string dashURL = outputAsset.GetMpegDashUri().ToString();\r\n            Console.WriteLine(\"MPEG DASH URL:\");\r\n            Console.WriteLine(dashURL);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Creates a job with 2 tasks: \r\n        /// 1 task - encodes a single MP4 to multibitrate MP4s,\r\n        /// 2 task - packages MP4s to Smooth Streaming.\r\n        /// </summary>\r\n        /// <returns>The output asset.</returns>\r\n        public static IAsset ConvertMP4ToMultibitrateMP4sToSmoothStreaming(IAsset asset)\r\n        {\r\n            // Create a new job.\r\n            IJob job = _context.Jobs.Create(\"Convert MP4 to Smooth Streaming.\");\r\n\r\n            // Add task 1 - Encode single MP4 into multibitrate MP4s.\r\n            IAsset MP4sAsset = EncodeMP4IntoMultibitrateMP4sTask(job, asset);\r\n            // Add task 2 - Package a multibitrate MP4 set to Clear Smooth Stream.\r\n            IAsset packagedAsset = PackageMP4ToSmoothStreamingTask(job, MP4sAsset);\r\n\r\n            // Submit the job and wait until it is completed.\r\n            job.Submit();\r\n            job = job.StartExecutionProgressTask(\r\n                j =>\r\n                {\r\n                    Console.WriteLine(\"Job state: {0}\", j.State);\r\n                    Console.WriteLine(\"Job progress: {0:0.##}%\", j.GetOverallProgress());\r\n                },\r\n                CancellationToken.None).Result;\r\n\r\n            // Get the output asset that contains the Smooth Streaming asset.\r\n            return job.OutputMediaAssets[1];\r\n        }\r\n\r\n        /// <summary>\r\n        /// Encrypts Smooth Stream with PlayReady.\r\n        /// Then creates a Smooth Streaming Url.\r\n        /// </summary>\r\n        /// <param name=\"clearSmoothAsset\">Asset that contains clear Smooth Streaming.</param>\r\n        /// <returns>The output asset.</returns>\r\n        public static IAsset CreateSmoothStreamEncryptedWithPlayReady(IAsset clearSmoothStreamAsset)\r\n        {\r\n            // Create a job.\r\n            IJob job = _context.Jobs.Create(\"Encrypt to PlayReady Smooth Streaming.\");\r\n\r\n            // Add task 1 - Encrypt Smooth Streaming with PlayReady \r\n            IAsset encryptedSmoothAsset =\r\n                EncryptSmoothStreamWithPlayReadyTask(job, clearSmoothStreamAsset);\r\n\r\n            // Submit the job and wait until it is completed.\r\n            job.Submit();\r\n            job = job.StartExecutionProgressTask(\r\n                j =>\r\n                {\r\n                    Console.WriteLine(\"Job state: {0}\", j.State);\r\n                    Console.WriteLine(\"Job progress: {0:0.##}%\", j.GetOverallProgress());\r\n                },\r\n                CancellationToken.None).Result;\r\n\r\n            // The OutputMediaAssets[0] contains the desired asset.\r\n            _context.Locators.Create(\r\n                LocatorType.OnDemandOrigin,\r\n                job.OutputMediaAssets[0],\r\n                AccessPermissions.Read,\r\n                TimeSpan.FromDays(30));\r\n\r\n            return job.OutputMediaAssets[0];\r\n        }\r\n\r\n        /// <summary>\r\n        /// Create a common encryption content key that is used \r\n        /// to set the key values in the MediaEncryptor_PlayReadyProtection.xml file\r\n        /// that is used for encryption.\r\n        /// </summary>\r\n        /// <param name=\"keyId\"></param>\r\n        /// <param name=\"contentKey\"></param>\r\n        /// <returns></returns>\r\n        public static IContentKey CreateCommonEncryptionKey(out Guid keyId, out byte[] contentKey)\r\n        {\r\n            keyId = Guid.NewGuid();\r\n            contentKey = GetRandomBuffer(16);\r\n\r\n            IContentKey key = _context.ContentKeys.Create(\r\n                                    keyId,\r\n                                    contentKey,\r\n                                    \"ContentKey\",\r\n                                    ContentKeyType.CommonEncryption);\r\n\r\n            return key;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Update your configuration .xml file dynamically.\r\n        /// </summary>\r\n        public static void UpdatePlayReadyConfigurationXMLFile(Guid keyId, byte[] keyValue, Uri licenseAcquisitionUrl)\r\n        {\r\n            string xmlFileName = Path.Combine(_configurationXMLFiles,\r\n                                        @\"MediaEncryptor_PlayReadyProtection.xml\");\r\n\r\n            XNamespace xmlns = \"http://schemas.microsoft.com/iis/media/v4/TM/TaskDefinition#\";\r\n\r\n            // Prepare the encryption task template\r\n            XDocument doc = XDocument.Load(xmlFileName);\r\n\r\n            var licenseAcquisitionUrlEl = doc\r\n                    .Descendants(xmlns + \"property\")\r\n                    .Where(p => p.Attribute(\"name\").Value == \"licenseAcquisitionUrl\")\r\n                    .FirstOrDefault();\r\n            var contentKeyEl = doc\r\n                    .Descendants(xmlns + \"property\")\r\n                    .Where(p => p.Attribute(\"name\").Value == \"contentKey\")\r\n                    .FirstOrDefault();\r\n            var keyIdEl = doc\r\n                    .Descendants(xmlns + \"property\")\r\n                    .Where(p => p.Attribute(\"name\").Value == \"keyId\")\r\n                    .FirstOrDefault();\r\n\r\n            // Update the \"value\" property.\r\n            if (licenseAcquisitionUrlEl != null)\r\n                licenseAcquisitionUrlEl.Attribute(\"value\").SetValue(licenseAcquisitionUrl.ToString());\r\n\r\n            if (contentKeyEl != null)\r\n                contentKeyEl.Attribute(\"value\").SetValue(Convert.ToBase64String(keyValue));\r\n\r\n            if (keyIdEl != null)\r\n                keyIdEl.Attribute(\"value\").SetValue(keyId);\r\n\r\n            doc.Save(xmlFileName);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Uploads a single file.\r\n        /// </summary>\r\n        /// <param name=\"fileDir\">The location of the files.</param>\r\n        /// <param name=\"assetCreationOptions\">\r\n        ///  You can specify the following encryption options for the AssetCreationOptions.\r\n        ///      None:  no encryption.  \r\n        ///      StorageEncrypted: storage encryption. Encrypts a clear input file \r\n        ///        before it is uploaded to Azure storage. \r\n        ///      CommonEncryptionProtected: for Common Encryption Protected (CENC) files. \r\n        ///        For example, a set of files that are already PlayReady encrypted. \r\n        ///      EnvelopeEncryptionProtected: for HLS with AES encryption files.\r\n        ///        NOTE: The files must have been encoded and encrypted by Transform Manager. \r\n        ///     </param>\r\n        /// <returns>Returns an asset that contains a single file.</returns>\r\n        /// </summary>\r\n        /// <returns></returns>\r\n        private static IAsset IngestSingleMP4File(string fileDir, AssetCreationOptions assetCreationOptions)\r\n        {\r\n            // Use the SDK extension method to create a new asset by \r\n            // uploading a mezzanine file from a local path.\r\n            IAsset asset = _context.Assets.CreateFromFile(\r\n                fileDir,\r\n                assetCreationOptions,\r\n                (af, p) =>\r\n                {\r\n                    Console.WriteLine(\"Uploading '{0}' - Progress: {1:0.##}%\", af.Name, p.Progress);\r\n                });\r\n\r\n            return asset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Creates a task to encode to Adaptive Bitrate. \r\n        /// Adds the new task to a job.\r\n        /// </summary>\r\n        /// <param name=\"job\">The job to which to add the new task.</param>\r\n        /// <param name=\"asset\">The input asset.</param>\r\n        /// <returns>The output asset.</returns>\r\n        private static IAsset EncodeMP4IntoMultibitrateMP4sTask(IJob job, IAsset asset)\r\n        {\r\n            // Get the SDK extension method to  get a reference to the Media Encoder Standard.\r\n            IMediaProcessor encoder = _context.MediaProcessors.GetLatestMediaProcessorByName(\r\n                MediaProcessorNames.MediaEncoderStandard);\r\n\r\n            ITask adpativeBitrateTask = job.Tasks.AddNew(\"MP4 to Adaptive Bitrate Task\",\r\n               encoder,\r\n               \"H264 Multiple Bitrate 720p\",\r\n               TaskOptions.None);\r\n\r\n            // Specify the input Asset\r\n            adpativeBitrateTask.InputAssets.Add(asset);\r\n\r\n            // Add an output asset to contain the results of the job. \r\n            // This output is specified as AssetCreationOptions.None, which \r\n            // means the output asset is in the clear (unencrypted).\r\n            IAsset abrAsset = adpativeBitrateTask.OutputAssets.AddNew(\"Multibitrate MP4s\",\r\n                                    AssetCreationOptions.None);\r\n\r\n            return abrAsset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Creates a task to convert the MP4 file(s) to a Smooth Streaming asset.\r\n        /// Adds the new task to a job.\r\n        /// </summary>\r\n        /// <param name=\"job\">The job to which to add the new task.</param>\r\n        /// <param name=\"asset\">The input asset.</param>\r\n        /// <returns>The output asset.</returns>\r\n        private static IAsset PackageMP4ToSmoothStreamingTask(IJob job, IAsset asset)\r\n        {\r\n            // Get the SDK extension method to  get a reference to the Azure Media Packager.\r\n            IMediaProcessor packager = _context.MediaProcessors.GetLatestMediaProcessorByName(\r\n                MediaProcessorNames.WindowsAzureMediaPackager);\r\n\r\n            // Azure Media Packager does not accept string presets, so load xml configuration\r\n            string smoothConfig = File.ReadAllText(Path.Combine(\r\n                        _configurationXMLFiles,\r\n                        \"MediaPackager_MP4toSmooth.xml\"));\r\n\r\n            // Create a new Task to convert adaptive bitrate to Smooth Streaming.\r\n            ITask smoothStreamingTask = job.Tasks.AddNew(\"MP4 to Smooth Task\",\r\n               packager,\r\n               smoothConfig,\r\n               TaskOptions.None);\r\n\r\n            // Specify the input Asset, which is the output Asset from the first task\r\n            smoothStreamingTask.InputAssets.Add(asset);\r\n\r\n            // Add an output asset to contain the results of the job. \r\n            // This output is specified as AssetCreationOptions.None, which \r\n            // means the output asset is in the clear (unencrypted).\r\n            IAsset smoothOutputAsset =\r\n                smoothStreamingTask.OutputAssets.AddNew(\"Clear Smooth Stream\",\r\n                    AssetCreationOptions.None);\r\n\r\n            return smoothOutputAsset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Creates a task to encrypt Smooth Streaming with PlayReady.\r\n        /// Note: To deliver DASH, make sure to set the useSencBox and adjustSubSamples \r\n        /// configuration properties to true. \r\n        /// In this example, MediaEncryptor_PlayReadyProtection.xml contains configuration.\r\n        /// </summary>\r\n        /// <param name=\"job\">The job to which to add the new task.</param>\r\n        /// <param name=\"asset\">The input asset.</param>\r\n        /// <returns>The output asset.</returns>\r\n        private static IAsset EncryptSmoothStreamWithPlayReadyTask(IJob job, IAsset asset)\r\n        {\r\n            // Get the SDK extension method to  get a reference to the Azure Media Encryptor.\r\n            IMediaProcessor playreadyProcessor = _context.MediaProcessors.GetLatestMediaProcessorByName(\r\n                MediaProcessorNames.WindowsAzureMediaEncryptor);\r\n\r\n            // Read the configuration XML.\r\n            //\r\n            // Note that the configuration defined in MediaEncryptor_PlayReadyProtection.xml\r\n            // is using keySeedValue. It is recommended that you do this only for testing \r\n            // and not in production. For more information, see \r\n            // https://www.azure.cn/documentation/articles/media-services-static-packaging/.\r\n            //\r\n            string configPlayReady = File.ReadAllText(Path.Combine(_configurationXMLFiles,\r\n                                        @\"MediaEncryptor_PlayReadyProtection.xml\"));\r\n\r\n            ITask playreadyTask = job.Tasks.AddNew(\"My PlayReady Task\",\r\n               playreadyProcessor,\r\n               configPlayReady,\r\n               TaskOptions.ProtectedConfiguration);\r\n\r\n            playreadyTask.InputAssets.Add(asset);\r\n\r\n            // Add an output asset to contain the results of the job. \r\n            // This output is specified as AssetCreationOptions.CommonEncryptionProtected.\r\n            IAsset playreadyAsset = playreadyTask.OutputAssets.AddNew(\r\n                                            \"PlayReady Smooth Streaming\",\r\n                                            AssetCreationOptions.CommonEncryptionProtected);\r\n\r\n            return playreadyAsset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Configures authorization policy for the content key. \r\n        /// </summary>\r\n        /// <param name=\"contentKey\">The content key.</param>\r\n        static public void ConfigureLicenseDeliveryService(IContentKey contentKey)\r\n        {\r\n            // Create ContentKeyAuthorizationPolicy with Open restrictions \r\n            // and create authorization policy          \r\n\r\n            List<ContentKeyAuthorizationPolicyRestriction> restrictions = new List<ContentKeyAuthorizationPolicyRestriction>\r\n            {\r\n                new ContentKeyAuthorizationPolicyRestriction \r\n                { \r\n                    Name = \"Open\", \r\n                    KeyRestrictionType = (int)ContentKeyRestrictionType.Open, \r\n                    Requirements = null\r\n                }\r\n            };\r\n\r\n            // Configure PlayReady license template.\r\n            string newLicenseTemplate = ConfigurePlayReadyLicenseTemplate();\r\n\r\n            IContentKeyAuthorizationPolicyOption policyOption =\r\n                _context.ContentKeyAuthorizationPolicyOptions.Create(\"\",\r\n                    ContentKeyDeliveryType.PlayReadyLicense,\r\n                        restrictions, newLicenseTemplate);\r\n\r\n            IContentKeyAuthorizationPolicy contentKeyAuthorizationPolicy = _context.\r\n                        ContentKeyAuthorizationPolicies.\r\n                        CreateAsync(\"Deliver Common Content Key with no restrictions\").\r\n                        Result;\r\n\r\n            contentKeyAuthorizationPolicy.Options.Add(policyOption);\r\n\r\n            // Associate the content key authorization policy with the content key.\r\n            contentKey.AuthorizationPolicyId = contentKeyAuthorizationPolicy.Id;\r\n            contentKey = contentKey.UpdateAsync().Result;\r\n        }\r\n\r\n        static private string ConfigurePlayReadyLicenseTemplate()\r\n        {\r\n            // The following code configures PlayReady License Template using .NET classes\r\n            // and returns the XML string.\r\n\r\n            PlayReadyLicenseResponseTemplate responseTemplate = new PlayReadyLicenseResponseTemplate();\r\n            PlayReadyLicenseTemplate licenseTemplate = new PlayReadyLicenseTemplate();\r\n\r\n            responseTemplate.LicenseTemplates.Add(licenseTemplate);\r\n\r\n            return MediaServicesLicenseTemplateSerializer.Serialize(responseTemplate);\r\n        }\r\n\r\n        static private byte[] GetRandomBuffer(int length)\r\n        {\r\n            var returnValue = new byte[length];\r\n\r\n            using (var rng =\r\n                new System.Security.Cryptography.RNGCryptoServiceProvider())\r\n            {\r\n                rng.GetBytes(returnValue);\r\n            }\r\n\r\n            return returnValue;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## <a name=\"using-static-encryption-to-protect-hlsv3-with-aes-128\"></a>通过静态加密使用 AES-128 来保护 HLSv3\r\n如果你要使用 AES-128 加密 HLS，可以选择使用动态加密（推荐选项）或静态加密（如本部分所述）。 如果决定使用动态加密，请参阅[使用 AES-128 动态加密和密钥传送服务](media-services-protect-with-aes128.md)。\r\n\r\n> [!NOTE]\r\n> 要将内容转换为 HLS，必须先将内容转换/编码为平滑流。\r\n> 此外，对于使用 AES 加密的 HLS，请确保在 MediaPackager_SmoothToHLS.xml 文件中设置以下属性：将加密属性设置为 true，将密钥值和 keyuri 值设置为指向身份验证\\授权服务器。\r\n> 媒体服务将创建密钥文件，并将其放置在资产容器中。 应该将 /asset-containerguid/*.key 文件复制到服务器（或创建自己的密钥文件），然后从资产容器中删除 *.key 文件。\r\n> \r\n> \r\n\r\n本部分的示例将夹层文件（在本例中为 MP4）编码为多比特率 MP4 文件，然后将 MP4 打包为平滑流式处理。 然后，它将平滑流式处理打包成使用高级加密标准 (AES) 128 位流加密法加密的 HTTP Live Streamin (HLS)。 确保更新以下代码，以便指向输入 MP4 文件所在的文件夹， 并指向 MediaPackager_MP4ToSmooth.xml 和 MediaPackager_SmoothToHLS.xml 配置文件所在的位置。 可以在 [Azure 媒体包装器的任务预设](http://msdn.microsoft.com/library/azure/hh973635.aspx) 主题中找到这些文件的定义。\r\n\r\n```\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Configuration;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing Microsoft.WindowsAzure.MediaServices.Client;\r\nusing System.Xml.Linq;\r\n\r\nnamespace MediaServicesContentProtection\r\n{\r\n    class Program\r\n    {\r\n        // Paths to support files (within the above base path). You can use \r\n        // the provided sample media files from the \"SupportFiles\" folder, or \r\n        // provide paths to your own media files below to run these samples.\r\n\r\n        private static readonly string _mediaFiles =\r\n            Path.GetFullPath(@\"../..\\Media\");\r\n\r\n        private static readonly string _singleMP4File =\r\n            Path.Combine(_mediaFiles, @\"SingleMP4\\BigBuckBunny.mp4\");\r\n\r\n        // XML Configruation files path.\r\n        private static readonly string _configurationXMLFiles = @\"../..\\Configurations\\\";\r\n\r\n        private static MediaServicesCredentials _cachedCredentials = null;\r\n        private static CloudMediaContext _context = null;\r\n\r\n        // Media Services account information.\r\n        private static readonly string _mediaServicesAccountName = \r\n            ConfigurationManager.AppSettings[\"MediaServiceAccountName\"];\r\n        private static readonly string _mediaServicesAccountKey = \r\n            ConfigurationManager.AppSettings[\"MediaServiceAccountKey\"];\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            // Create and cache the Media Services credentials in a static class variable.\r\n            _cachedCredentials = new MediaServicesCredentials(\r\n                            _mediaServicesAccountName, \r\n                            _mediaServicesAccountKey);\r\n            // Use the cached credentials to create CloudMediaContext.\r\n            _context = new CloudMediaContext(_cachedCredentials);\r\n\r\n            // Encoding and encrypting assets //////////////////////\r\n\r\n            // Load an MP4 file.\r\n            IAsset asset = IngestSingleMP4File(_singleMP4File, AssetCreationOptions.None);\r\n\r\n            // Encode an MP4 file to a set of multibitrate MP4s.\r\n            // Then, package a set of MP4s to clear Smooth Streaming.\r\n            IAsset clearSmoothStreamAsset = ConvertMP4ToMultibitrateMP4sToSmoothStreaming(asset);\r\n\r\n            // Create HLS encrypted with AES.\r\n            IAsset HLSEncryptedWithAESAsset = CreateHLSEncryptedWithAES(clearSmoothStreamAsset);\r\n\r\n            // You can use the following player to test the HLS with AES stream.\r\n            // http://apps.microsoft.com/windows/app/3ivx-hls-player/f79ce7d0-2993-4658-bc4e-83dc182a0614 \r\n            string hlsWithAESURL = HLSEncryptedWithAESAsset.GetHlsUri().ToString();\r\n            Console.WriteLine(\"HLS with AES URL:\");\r\n            Console.WriteLine(hlsWithAESURL);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Creates a job with 2 tasks: \r\n        /// 1 task - encodes a single MP4 to multibitrate MP4s,\r\n        /// 2 task - packages MP4s to Smooth Streaming.\r\n        /// </summary>\r\n        /// <returns>The output asset.</returns>\r\n        public static IAsset ConvertMP4ToMultibitrateMP4sToSmoothStreaming(IAsset asset)\r\n        {\r\n            // Create a new job.\r\n            IJob job = _context.Jobs.Create(\"Convert MP4 to Smooth Streaming.\");\r\n\r\n            // Add task 1 - Encode single MP4 into multibitrate MP4s.\r\n            IAsset MP4sAsset = EncodeSingleMP4IntoMultibitrateMP4sTask(job, asset);\r\n            // Add task 2 - Package a multibitrate MP4 set to Clear Smooth Streaming.\r\n            IAsset packagedAsset = PackageMP4ToSmoothStreamingTask(job, MP4sAsset);\r\n\r\n            // Submit the job and wait until it is completed.\r\n            job.Submit();\r\n            job = job.StartExecutionProgressTask(\r\n                j =>\r\n                {\r\n                    Console.WriteLine(\"Job state: {0}\", j.State);\r\n                    Console.WriteLine(\"Job progress: {0:0.##}%\", j.GetOverallProgress());\r\n                },\r\n                CancellationToken.None).Result;\r\n\r\n            // Get the output asset that contains Smooth Streaming.\r\n            return job.OutputMediaAssets[1];\r\n        }\r\n\r\n        /// <summary>\r\n        /// Encrypts an HLS with AES-128.\r\n        /// </summary>\r\n        /// <param name=\"clearSmoothAsset\">Asset that contains clear Smooth Streaming.</param>\r\n        /// <returns>The output asset.</returns>\r\n        public static IAsset CreateHLSEncryptedWithAES(IAsset clearSmoothStreamAsset)\r\n        {\r\n            IJob job = _context.Jobs.Create(\"Encrypt to HLS with AES.\");\r\n\r\n            // Add task 1 - Package clear Smooth Streaming to HLS with AES.\r\n            PackageSmoothStreamToHLS(job, clearSmoothStreamAsset);\r\n\r\n            // Submit the job and wait until it is completed.\r\n            job.Submit();\r\n            job = job.StartExecutionProgressTask(\r\n                j =>\r\n                {\r\n                    Console.WriteLine(\"Job state: {0}\", j.State);\r\n                    Console.WriteLine(\"Job progress: {0:0.##}%\", j.GetOverallProgress());\r\n                },\r\n                CancellationToken.None).Result;\r\n\r\n            // The OutputMediaAssets[0] contains the desired asset.\r\n            _context.Locators.Create(\r\n                LocatorType.OnDemandOrigin,\r\n                job.OutputMediaAssets[0],\r\n                AccessPermissions.Read,\r\n                TimeSpan.FromDays(30));\r\n\r\n            return job.OutputMediaAssets[0];\r\n        }\r\n\r\n        /// <summary>\r\n        /// Uploads a single file.\r\n        /// </summary>\r\n        /// <param name=\"fileDir\">The location of the files.</param>\r\n        /// <param name=\"assetCreationOptions\">\r\n        ///  You can specify the following encryption options for the AssetCreationOptions.\r\n        ///      None:  no encryption.  \r\n        ///      StorageEncrypted: storage encryption. Encrypts a clear input file \r\n        ///        before it is uploaded to Azure storage. \r\n        ///      CommonEncryptionProtected: for Common Encryption Protected (CENC) files. \r\n        ///        For example, a set of files that are already PlayReady encrypted. \r\n        ///      EnvelopeEncryptionProtected: for HLS with AES encryption files.\r\n        ///        NOTE: The files must have been encoded and encrypted by Transform Manager. \r\n        ///     </param>\r\n        /// <returns>Returns an asset that contains a single file.</returns>\r\n        /// </summary>\r\n        /// <returns></returns>\r\n        private static IAsset IngestSingleMP4File(string fileDir, AssetCreationOptions assetCreationOptions)\r\n        {\r\n            // Use the SDK extension method to create a new asset by \r\n            // uploading a mezzanine file from a local path.\r\n            IAsset asset = _context.Assets.CreateFromFile(\r\n                fileDir,\r\n                assetCreationOptions,\r\n                (af, p) =>\r\n                {\r\n                    Console.WriteLine(\"Uploading '{0}' - Progress: {1:0.##}%\", af.Name, p.Progress);\r\n                });\r\n\r\n            return asset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Creates a task to encode to Adaptive Bitrate. \r\n        /// Adds the new task to a job.\r\n        /// </summary>\r\n        /// <param name=\"job\">The job to which to add the new task.</param>\r\n        /// <param name=\"asset\">The input asset.</param>\r\n        /// <returns>The output asset.</returns>\r\n        private static IAsset EncodeSingleMP4IntoMultibitrateMP4sTask(IJob job, IAsset asset)\r\n        {\r\n            // Get the SDK extension method to  get a reference to the Media Encoder Standard.\r\n            IMediaProcessor encoder = _context.MediaProcessors.GetLatestMediaProcessorByName(\r\n                MediaProcessorNames.MediaEncoderStandard);\r\n\r\n            ITask adpativeBitrateTask = job.Tasks.AddNew(\"MP4 to Adaptive Bitrate Task\",\r\n               encoder,\r\n               \"H264 Multiple Bitrate 720p\",\r\n               TaskOptions.None);\r\n\r\n            // Specify the input Asset\r\n            adpativeBitrateTask.InputAssets.Add(asset);\r\n\r\n            // Add an output asset to contain the results of the job. \r\n            // This output is specified as AssetCreationOptions.None, which \r\n            // means the output asset is in the clear (unencrypted).\r\n            IAsset abrAsset = adpativeBitrateTask.OutputAssets.AddNew(\"Multibitrate MP4s\", \r\n                                    AssetCreationOptions.None);\r\n\r\n            return abrAsset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Creates a task to convert the MP4 file(s) to a Smooth Streaming asset.\r\n        /// Adds the new task to a job.\r\n        /// </summary>\r\n        /// <param name=\"job\">The job to which to add the new task.</param>\r\n        /// <param name=\"asset\">The input asset.</param>\r\n        /// <returns>The output asset.</returns>\r\n        private static IAsset PackageMP4ToSmoothStreamingTask(IJob job, IAsset asset)\r\n        {\r\n            // Get the SDK extension method to  get a reference to the Azure Media Packager.\r\n            IMediaProcessor packager = _context.MediaProcessors.GetLatestMediaProcessorByName(\r\n                MediaProcessorNames.WindowsAzureMediaPackager);\r\n\r\n            // Azure Media Packager does not accept string presets, so load xml configuration\r\n            string smoothConfig = File.ReadAllText(Path.Combine(\r\n                        _configurationXMLFiles, \r\n                        \"MediaPackager_MP4toSmooth.xml\"));\r\n\r\n            // Create a new Task to convert adaptive bitrate to Smooth Streaming.\r\n            ITask smoothStreamingTask = job.Tasks.AddNew(\"MP4 to Smooth Task\",\r\n               packager,\r\n               smoothConfig,\r\n               TaskOptions.None);\r\n\r\n            // Specify the input Asset, which is the output Asset from the first task\r\n            smoothStreamingTask.InputAssets.Add(asset);\r\n\r\n            // Add an output asset to contain the results of the job. \r\n            // This output is specified as AssetCreationOptions.None, which \r\n            // means the output asset is in the clear (unencrypted).\r\n            IAsset smoothOutputAsset = \r\n                smoothStreamingTask.OutputAssets.AddNew(\"Clear Smooth Streaming\", \r\n                    AssetCreationOptions.None);\r\n\r\n            return smoothOutputAsset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Converts Smooth Streaming to HLS.\r\n        /// </summary>\r\n        /// <param name=\"job\">The job to which to add the new task.</param>\r\n        /// <param name=\"asset\">The Smooth Streaming asset.</param>\r\n        /// <returns>The asset that was packaged to HLS.</returns>\r\n        private static IAsset PackageSmoothStreamToHLS(IJob job, IAsset smoothStreamAsset)\r\n        {\r\n            // Get the SDK extension method to  get a reference to the Azure Media Packager.\r\n            IMediaProcessor processor = _context.MediaProcessors.GetLatestMediaProcessorByName(\r\n                MediaProcessorNames.WindowsAzureMediaPackager);\r\n\r\n            // Read the configuration data into a string. \r\n            // For the HLS to get encrypted with AES make sure to set the\r\n            // encrypt configuration property to true.\r\n            //\r\n            // In production, it is recommended to do the following:\r\n            //    Set a Key url for your authn/authz server.\r\n            //    Copy the /asset-containerguid/*.key file to your server (or craft a key file for yourself).\r\n            //    Delete *.key from the asset container.\r\n            //\r\n            string configuration = File.ReadAllText(Path.Combine(_configurationXMLFiles, @\"MediaPackager_SmoothToHLS.xml\"));\r\n\r\n            // Create a task with the encoding details, using a configuration file.\r\n            ITask task = job.Tasks.AddNew(\"My Smooth Streaming to HLS Task\",\r\n               processor,\r\n               configuration,\r\n               TaskOptions.ProtectedConfiguration);\r\n\r\n            // Specify the input asset to be encoded.\r\n            task.InputAssets.Add(smoothStreamAsset);\r\n\r\n            // Add an output asset to contain the results of the job. \r\n            IAsset outputAsset = \r\n                task.OutputAssets.AddNew(\"HLS asset\", AssetCreationOptions.None);\r\n\r\n            return outputAsset;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## <a name=\"using-static-encryption-to-protect-hlsv3-with-playready\"></a>通过静态加密使用 PlayReady 来保护 HLSv3\r\n若想要通过 PlayReady 来保护内容，则可选择使用[动态加密](media-services-protect-with-drm.md)（推荐选项）或静态加密（如本部分所述）。\r\n\r\n>[!NOTE]\r\n> 要使用 PlayReady 保护你的内容，必须先将内容转换/编码为平滑流格式。\r\n\r\n本部分的示例将夹层文件（在本例中为 MP4）编码为多比特率 MP4 文件。 然后，它将 MP4 打包为平滑流，并使用 PlayReady 对平滑流进行加密。 若要生成使用 PlayReady 加密的 HTTP Live Streaming (HLS)，需要将 PlayReady 平滑流式处理资产打包成 HLS。 本主题演示如何执行所有这些步骤。\r\n\r\n媒体服务现在提供有用于传送 Microsoft PlayReady 许可证的服务。 本文中的示例显示如何配置媒体服务 PlayReady 许可证传送服务（请参阅以下代码中定义的 **ConfigureLicenseDeliveryService** 方法）。 \r\n\r\n确保更新以下代码，以便指向输入 MP4 文件所在的文件夹， 并指向 MediaPackager_MP4ToSmooth.xml、MediaPackager_SmoothToHLS.xml 和 MediaEncryptor_PlayReadyProtection.xml 文件所在的位置。 MediaPackager_MP4ToSmooth.xml 和 MediaPackager_SmoothToHLS.xml 在 [Azure 媒体包装器的任务预设](http://msdn.microsoft.com/library/azure/hh973635.aspx)中定义，MediaEncryptor_PlayReadyProtection.xml 在 [Azure 媒体加密器的任务预设](http://msdn.microsoft.com/library/azure/hh973610.aspx)主题中定义。\r\n\r\n```\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Configuration;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing Microsoft.WindowsAzure.MediaServices.Client;\r\nusing System.Xml.Linq;\r\nusing Microsoft.WindowsAzure.MediaServices.Client.ContentKeyAuthorization;\r\nusing Microsoft.WindowsAzure.MediaServices.Client.DynamicEncryption;\r\n\r\nnamespace MediaServicesContentProtection\r\n{\r\n    class Program\r\n    {\r\n        // Paths to support files (within the above base path). You can use \r\n        // the provided sample media files from the \"SupportFiles\" folder, or \r\n        // provide paths to your own media files below to run these samples.\r\n\r\n        private static readonly string _mediaFiles =\r\n            Path.GetFullPath(@\"../..\\Media\");\r\n\r\n        private static readonly string _singleMP4File =\r\n            Path.Combine(_mediaFiles, @\"SingleMP4\\BigBuckBunny.mp4\");\r\n\r\n        // XML Configruation files path.\r\n        private static readonly string _configurationXMLFiles = @\"../..\\Configurations\\\";\r\n\r\n        private static MediaServicesCredentials _cachedCredentials = null;\r\n        private static CloudMediaContext _context = null;\r\n\r\n        // Media Services account information.\r\n        private static readonly string _mediaServicesAccountName =\r\n            ConfigurationManager.AppSettings[\"MediaServiceAccountName\"];\r\n        private static readonly string _mediaServicesAccountKey =\r\n            ConfigurationManager.AppSettings[\"MediaServiceAccountKey\"];\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            // Create and cache the Media Services credentials in a static class variable.\r\n            _cachedCredentials = new MediaServicesCredentials(\r\n                            _mediaServicesAccountName,\r\n                            _mediaServicesAccountKey);\r\n            // Used the chached credentials to create CloudMediaContext.\r\n            _context = new CloudMediaContext(_cachedCredentials);\r\n\r\n            // Load an MP4 file.\r\n            IAsset asset = IngestSingleMP4File(_singleMP4File, AssetCreationOptions.None);\r\n\r\n            // Encode an MP4 file to a set of multibitrate MP4s.\r\n            // Then, package a set of MP4s to clear Smooth Streaming.\r\n            IAsset clearSmoothStreamAsset = ConvertMP4ToMultibitrateMP4sToSmoothStreaming(asset);\r\n\r\n            // Create a common encryption content key that is used \r\n            // a) to set the key values in the MediaEncryptor_PlayReadyProtection.xml file\r\n            //    that is used for encryption.\r\n            // b) to configure the license delivery service and \r\n            //\r\n            Guid keyId;\r\n            byte[] contentKey;\r\n\r\n            IContentKey key = CreateCommonEncryptionKey(out keyId, out contentKey);\r\n\r\n            // The content key authorization policy must be configured by you \r\n            // and met by the client in order for the PlayReady license\r\n            // to be delivered to the client. \r\n            // In this example the Media Services PlayReady license delivery service is used.\r\n            ConfigureLicenseDeliveryService(key);\r\n\r\n            // Get the Media Services PlayReady license delivery URL.\r\n            // This URL will be assigned to the licenseAcquisitionUrl property \r\n            // of the MediaEncryptor_PlayReadyProtection.xml file.\r\n            Uri acquisitionUrl = key.GetKeyDeliveryUrl(ContentKeyDeliveryType.PlayReadyLicense);\r\n\r\n            // Update the MediaEncryptor_PlayReadyProtection.xml file with the key and URL info.\r\n            UpdatePlayReadyConfigurationXMLFile(keyId, contentKey, acquisitionUrl);\r\n\r\n            // Create HLS encrypted with PlayReady.\r\n            IAsset playReadyHLSAsset = CreateHLSEncryptedWithPlayReady(clearSmoothStreamAsset);\r\n            //\r\n            string hlsWithPlayReadyURL = playReadyHLSAsset.GetHlsUri().ToString();\r\n            Console.WriteLine(\"HLS with PlayReady URL:\");\r\n            Console.WriteLine(hlsWithPlayReadyURL);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Creates a job with 2 tasks: \r\n        /// 1 task - encodes a single MP4 to multibitrate MP4s,\r\n        /// 2 task - packages MP4s to Smooth Streaming.\r\n        /// </summary>\r\n        /// <returns>The output asset.</returns>\r\n        public static IAsset ConvertMP4ToMultibitrateMP4sToSmoothStreaming(IAsset asset)\r\n        {\r\n            // Create a new job.\r\n            IJob job = _context.Jobs.Create(\"Convert MP4 to Smooth Streaming.\");\r\n\r\n            // Add task 1 - Encode single MP4 into multibitrate MP4s.\r\n            IAsset MP4sAsset = EncodeSingleMP4IntoMultibitrateMP4sTask(job, asset);\r\n            // Add task 2 - Package a multibitrate MP4 set to Clear Smooth Streaming.\r\n            IAsset packagedAsset = PackageMP4ToSmoothStreamingTask(job, MP4sAsset);\r\n\r\n            // Submit the job and wait until it is completed.\r\n            job.Submit();\r\n            job = job.StartExecutionProgressTask(\r\n                j =>\r\n                {\r\n                    Console.WriteLine(\"Job state: {0}\", j.State);\r\n                    Console.WriteLine(\"Job progress: {0:0.##}%\", j.GetOverallProgress());\r\n                },\r\n                CancellationToken.None).Result;\r\n\r\n            // Get the output asset that contains Smooth Streaming.\r\n            return job.OutputMediaAssets[1];\r\n        }\r\n\r\n        /// <summary>\r\n        /// Create a common encryption content key that is used \r\n        /// to set the key values in the MediaEncryptor_PlayReadyProtection.xml file\r\n        /// that is used for encryption.\r\n        /// </summary>\r\n        /// <param name=\"keyId\"></param>\r\n        /// <param name=\"contentKey\"></param>\r\n        /// <returns></returns>\r\n        public static IContentKey CreateCommonEncryptionKey(out Guid keyId, out byte[] contentKey)\r\n        {\r\n            keyId = Guid.NewGuid();\r\n            contentKey = GetRandomBuffer(16);\r\n\r\n            IContentKey key = _context.ContentKeys.Create(\r\n                                    keyId,\r\n                                    contentKey,\r\n                                    \"ContentKey\",\r\n                                    ContentKeyType.CommonEncryption);\r\n\r\n            return key;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Update your configuration .xml file dynamically.\r\n        /// </summary>\r\n        public static void UpdatePlayReadyConfigurationXMLFile(Guid keyId, byte[] keyValue, Uri licenseAcquisitionUrl)\r\n        {\r\n            string xmlFileName = Path.Combine(_configurationXMLFiles,\r\n                                        @\"MediaEncryptor_PlayReadyProtection.xml\");\r\n\r\n            XNamespace xmlns = \"http://schemas.microsoft.com/iis/media/v4/TM/TaskDefinition#\";\r\n\r\n            // Prepare the encryption task template\r\n            XDocument doc = XDocument.Load(xmlFileName);\r\n\r\n            var licenseAcquisitionUrlEl = doc\r\n                    .Descendants(xmlns + \"property\")\r\n                    .Where(p => p.Attribute(\"name\").Value == \"licenseAcquisitionUrl\")\r\n                    .FirstOrDefault();\r\n            var contentKeyEl = doc\r\n                    .Descendants(xmlns + \"property\")\r\n                    .Where(p => p.Attribute(\"name\").Value == \"contentKey\")\r\n                    .FirstOrDefault();\r\n            var keyIdEl = doc\r\n                    .Descendants(xmlns + \"property\")\r\n                    .Where(p => p.Attribute(\"name\").Value == \"keyId\")\r\n                    .FirstOrDefault();\r\n\r\n            // Update the \"value\" property.\r\n            if (licenseAcquisitionUrlEl != null)\r\n                licenseAcquisitionUrlEl.Attribute(\"value\").SetValue(licenseAcquisitionUrl.ToString());\r\n\r\n            if (contentKeyEl != null)\r\n                contentKeyEl.Attribute(\"value\").SetValue(Convert.ToBase64String(keyValue));\r\n\r\n            if (keyIdEl != null)\r\n                keyIdEl.Attribute(\"value\").SetValue(keyId);\r\n\r\n            doc.Save(xmlFileName);\r\n        }\r\n\r\n        /// <summary>\r\n        // Encrypts clear Smooth Streaming to Smooth Streaming with PlayReady.\r\n        // Then, packages the PlayReady Smooth Streaming to HLS with PlayReady.\r\n        /// </summary>\r\n        /// <param name=\"clearSmoothAsset\">Asset that contains clear Smooth Streaming.</param>\r\n        /// <returns>The output asset.</returns>\r\n        public static IAsset CreateHLSEncryptedWithPlayReady(IAsset clearSmoothStreamAsset)\r\n        {\r\n            IJob job = _context.Jobs.Create(\"Encrypt to HLS with PlayReady.\");\r\n\r\n            // Add task 1 - Encrypt Smooth Streaming with PlayReady \r\n            IAsset encryptedSmoothAsset =\r\n                EncryptSmoothStreamWithPlayReadyTask(job, clearSmoothStreamAsset);\r\n\r\n            // Add task 2 - Package to HLS with PlayReady.\r\n            PackageSmoothStreamToHLS(job, encryptedSmoothAsset);\r\n\r\n            // Submit the job and wait until it is completed.\r\n            job.Submit();\r\n            job = job.StartExecutionProgressTask(\r\n                j =>\r\n                {\r\n                    Console.WriteLine(\"Job state: {0}\", j.State);\r\n                    Console.WriteLine(\"Job progress: {0:0.##}%\", j.GetOverallProgress());\r\n                },\r\n                CancellationToken.None).Result;\r\n\r\n            // Since we had two tasks, the OutputMediaAssets[1]\r\n            // contains the desired asset.\r\n            _context.Locators.Create(\r\n                LocatorType.OnDemandOrigin,\r\n                job.OutputMediaAssets[1],\r\n                AccessPermissions.Read,\r\n                TimeSpan.FromDays(30));\r\n\r\n            return job.OutputMediaAssets[1];\r\n        }\r\n\r\n        /// <summary>\r\n        /// Uploads a single file.\r\n        /// </summary>\r\n        /// <param name=\"fileDir\">The location of the files.</param>\r\n        /// <param name=\"assetCreationOptions\">\r\n        ///  You can specify the following encryption options for the AssetCreationOptions.\r\n        ///      None:  no encryption.  \r\n        ///      StorageEncrypted: storage encryption. Encrypts a clear input file \r\n        ///        before it is uploaded to Azure storage. \r\n        ///      CommonEncryptionProtected: for Common Encryption Protected (CENC) files. \r\n        ///        For example, a set of files that are already PlayReady encrypted. \r\n        ///      EnvelopeEncryptionProtected: for HLS with AES encryption files.\r\n        ///        NOTE: The files must have been encoded and encrypted by Transform Manager. \r\n        ///     </param>\r\n        /// <returns>Returns an asset that contains a single file.</returns>\r\n        /// </summary>\r\n        /// <returns></returns>\r\n        private static IAsset IngestSingleMP4File(string fileDir, AssetCreationOptions assetCreationOptions)\r\n        {\r\n            // Use the SDK extension method to create a new asset by \r\n            // uploading a mezzanine file from a local path.\r\n            IAsset asset = _context.Assets.CreateFromFile(\r\n                fileDir,\r\n                assetCreationOptions,\r\n                (af, p) =>\r\n                {\r\n                    Console.WriteLine(\"Uploading '{0}' - Progress: {1:0.##}%\", af.Name, p.Progress);\r\n                });\r\n\r\n            return asset;\r\n\r\n        }\r\n        /// <summary>\r\n        /// Creates a task to encode to Adaptive Bitrate. \r\n        /// Adds the new task to a job.\r\n        /// </summary>\r\n        /// <param name=\"job\">The job to which to add the new task.</param>\r\n        /// <param name=\"asset\">The input asset.</param>\r\n        /// <returns>The output asset.</returns>\r\n        private static IAsset EncodeSingleMP4IntoMultibitrateMP4sTask(IJob job, IAsset asset)\r\n        {\r\n            // Get the SDK extension method to  get a reference to the Media Encoder Standard.\r\n            IMediaProcessor encoder = _context.MediaProcessors.GetLatestMediaProcessorByName(\r\n                MediaProcessorNames.MediaEncoderStandard);\r\n\r\n            ITask adpativeBitrateTask = job.Tasks.AddNew(\"MP4 to Adaptive Bitrate Task\",\r\n               encoder,\r\n               \"H264 Multiple Bitrate 720p\",\r\n               TaskOptions.None);\r\n\r\n            // Specify the input Asset\r\n            adpativeBitrateTask.InputAssets.Add(asset);\r\n\r\n            // Add an output asset to contain the results of the job. \r\n            // This output is specified as AssetCreationOptions.None, which \r\n            // means the output asset is in the clear (unencrypted).\r\n            IAsset abrAsset = adpativeBitrateTask.OutputAssets.AddNew(\"Multibitrate MP4s\",\r\n                                    AssetCreationOptions.None);\r\n\r\n            return abrAsset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Creates a task to convert the MP4 file(s) to a Smooth Streaming asset.\r\n        /// Adds the new task to a job.\r\n        /// </summary>\r\n        /// <param name=\"job\">The job to which to add the new task.</param>\r\n        /// <param name=\"asset\">The input asset.</param>\r\n        /// <returns>The output asset.</returns>\r\n        private static IAsset PackageMP4ToSmoothStreamingTask(IJob job, IAsset asset)\r\n        {\r\n            // Get the SDK extension method to  get a reference to the Azure Media Packager.\r\n            IMediaProcessor packager = _context.MediaProcessors.GetLatestMediaProcessorByName(\r\n                MediaProcessorNames.WindowsAzureMediaPackager);\r\n\r\n            // Azure Media Packager does not accept string presets, so load xml configuration\r\n            string smoothConfig = File.ReadAllText(Path.Combine(\r\n                        _configurationXMLFiles,\r\n                        \"MediaPackager_MP4toSmooth.xml\"));\r\n\r\n            // Create a new Task to convert adaptive bitrate to Smooth Streaming.\r\n            ITask smoothStreamingTask = job.Tasks.AddNew(\"MP4 to Smooth Task\",\r\n               packager,\r\n               smoothConfig,\r\n               TaskOptions.None);\r\n\r\n            // Specify the input Asset, which is the output Asset from the first task\r\n            smoothStreamingTask.InputAssets.Add(asset);\r\n\r\n            // Add an output asset to contain the results of the job. \r\n            // This output is specified as AssetCreationOptions.None, which \r\n            // means the output asset is in the clear (unencrypted).\r\n            IAsset smoothOutputAsset =\r\n                smoothStreamingTask.OutputAssets.AddNew(\"Clear Smooth Streaming\",\r\n                    AssetCreationOptions.None);\r\n\r\n            return smoothOutputAsset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Converts Smooth Stream to HLS.\r\n        /// </summary>\r\n        /// <param name=\"job\">The job to which to add the new task.</param>\r\n        /// <param name=\"asset\">The Smooth Stream asset.</param>\r\n        /// <returns>The asset that was packaged to HLS.</returns>\r\n        private static IAsset PackageSmoothStreamToHLS(IJob job, IAsset smoothStreamAsset)\r\n        {\r\n            // Get the SDK extension method to  get a reference to the Azure Media Packager.\r\n            IMediaProcessor processor = _context.MediaProcessors.GetLatestMediaProcessorByName(\r\n                MediaProcessorNames.WindowsAzureMediaPackager);\r\n\r\n            // Read the configuration data into a string. \r\n            //\r\n            string configuration = File.ReadAllText(\r\n                        Path.Combine(_configurationXMLFiles,\r\n                                    @\"MediaPackager_SmoothToHLS.xml\"));\r\n\r\n            // Create a task with the encoding details, using a configuration file.\r\n            ITask task = job.Tasks.AddNew(\"My Smooth to HLS Task\",\r\n               processor,\r\n               configuration,\r\n               TaskOptions.ProtectedConfiguration);\r\n\r\n            // Specify the input asset to be encoded.\r\n            task.InputAssets.Add(smoothStreamAsset);\r\n\r\n            // Add an output asset to contain the results of the job. \r\n            IAsset outputAsset =\r\n                task.OutputAssets.AddNew(\"HLS asset\", AssetCreationOptions.None);\r\n\r\n            return outputAsset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Creates a task to encrypt Smooth Streaming with PlayReady.\r\n        /// Note: Do deliver DASH, make sure to set the useSencBox and adjustSubSamples \r\n        /// configuration properties to true.\r\n        /// </summary>\r\n        /// <param name=\"job\">The job to which to add the new task.</param>\r\n        /// <param name=\"asset\">The input asset.</param>\r\n        /// <returns>The output asset.</returns>\r\n        private static IAsset EncryptSmoothStreamWithPlayReadyTask(IJob job, IAsset asset)\r\n        {\r\n            // Get the SDK extension method to  get a reference to the Azure Media Encryptor.\r\n            IMediaProcessor playreadyProcessor = _context.MediaProcessors.GetLatestMediaProcessorByName(\r\n                MediaProcessorNames.WindowsAzureMediaEncryptor);\r\n\r\n            // Read the configuration XML.\r\n            //\r\n            // Note that the configuration defined in MediaEncryptor_PlayReadyProtection.xml\r\n            // is using keySeedValue. It is recommended that you do this only for testing \r\n            // and not in production. For more information, see \r\n            // https://www.sazure.cn/documentation/articles/media-services-static-packaging.\r\n            //\r\n            string configPlayReady = File.ReadAllText(Path.Combine(_configurationXMLFiles,\r\n                                        @\"MediaEncryptor_PlayReadyProtection.xml\"));\r\n\r\n            ITask playreadyTask = job.Tasks.AddNew(\"My PlayReady Task\",\r\n               playreadyProcessor,\r\n               configPlayReady,\r\n               TaskOptions.ProtectedConfiguration);\r\n\r\n            playreadyTask.InputAssets.Add(asset);\r\n\r\n            // Add an output asset to contain the results of the job. \r\n            // This output is specified as AssetCreationOptions.CommonEncryptionProtected.\r\n            IAsset playreadyAsset = playreadyTask.OutputAssets.AddNew(\r\n                                            \"PlayReady Smooth Streaming\",\r\n                                            AssetCreationOptions.CommonEncryptionProtected);\r\n\r\n            return playreadyAsset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Configures authorization policy for the content key. \r\n        /// </summary>\r\n        /// <param name=\"contentKey\">The content key.</param>\r\n        static public void ConfigureLicenseDeliveryService(IContentKey contentKey)\r\n        {\r\n            // Create ContentKeyAuthorizationPolicy with Open restrictions \r\n            // and create authorization policy          \r\n\r\n            List<ContentKeyAuthorizationPolicyRestriction> restrictions = new List<ContentKeyAuthorizationPolicyRestriction>\r\n            {\r\n                new ContentKeyAuthorizationPolicyRestriction \r\n                { \r\n                    Name = \"Open\", \r\n                    KeyRestrictionType = (int)ContentKeyRestrictionType.Open, \r\n                    Requirements = null\r\n                }\r\n            };\r\n\r\n            // Configure PlayReady license template.\r\n            string newLicenseTemplate = ConfigurePlayReadyLicenseTemplate();\r\n\r\n            IContentKeyAuthorizationPolicyOption policyOption =\r\n                _context.ContentKeyAuthorizationPolicyOptions.Create(\"\",\r\n                    ContentKeyDeliveryType.PlayReadyLicense,\r\n                        restrictions, newLicenseTemplate);\r\n\r\n            IContentKeyAuthorizationPolicy contentKeyAuthorizationPolicy = _context.\r\n                        ContentKeyAuthorizationPolicies.\r\n                        CreateAsync(\"Deliver Common Content Key with no restrictions\").\r\n                        Result;\r\n\r\n            contentKeyAuthorizationPolicy.Options.Add(policyOption);\r\n\r\n            // Associate the content key authorization policy with the content key.\r\n            contentKey.AuthorizationPolicyId = contentKeyAuthorizationPolicy.Id;\r\n            contentKey = contentKey.UpdateAsync().Result;\r\n        }\r\n\r\n        static private string ConfigurePlayReadyLicenseTemplate()\r\n        {\r\n            // The following code configures PlayReady License Template using .NET classes\r\n            // and returns the XML string.\r\n\r\n            PlayReadyLicenseResponseTemplate responseTemplate = new PlayReadyLicenseResponseTemplate();\r\n            PlayReadyLicenseTemplate licenseTemplate = new PlayReadyLicenseTemplate();\r\n\r\n            responseTemplate.LicenseTemplates.Add(licenseTemplate);\r\n\r\n            return MediaServicesLicenseTemplateSerializer.Serialize(responseTemplate);\r\n        }\r\n        static private byte[] GetRandomBuffer(int length)\r\n        {\r\n            var returnValue = new byte[length];\r\n\r\n            using (var rng =\r\n                new System.Security.Cryptography.RNGCryptoServiceProvider())\r\n            {\r\n                rng.GetBytes(returnValue);\r\n            }\r\n\r\n            return returnValue;\r\n        }\r\n\r\n    }\r\n}\r\n```"}