{"Title":"如何使用 Azure 媒体服务实时传送视频流以通过 .NET 创建多比特率流","Description":"本教程指导使用 .NET SDK 完成创建通道的步骤，该通道接收单比特率实时流，并将其编码为多比特率流。","Content":"# <a name=\"how-to-perform-live-streaming-using-azure-media-services-to-create-multi-bitrate-streams-with-net\"></a>如何使用 Azure 媒体服务执行实时流式处理以通过 .NET 创建多比特率流\r\n> [!div class=\"op_single_selector\"]\r\n> * [门户](media-services-portal-creating-live-encoder-enabled-channel.md)\r\n> * [.NET](media-services-dotnet-creating-live-encoder-enabled-channel.md)\r\n> * [REST API](https://docs.microsoft.com/rest/api/media/operations/channel)\r\n>[!NOTE]\r\n> 要完成本教程，需要一个 Azure 帐户。 有关详细信息，请参阅 [Azure 试用版](https://www.azure.cn/pricing/1rmb-trial/?WT.mc_id=A261C142F)。 \r\n\r\n## <a name=\"overview\"></a>概述\r\n本教程介绍了创建**通道**的步骤，该通道接收单比特率实时流，并将其编码为多比特率流。\r\n\r\n有关为实时编码启用的通道的更多相关概念信息，请参阅[使用 Azure 媒体服务实时传送视频流以创建多比特率流](media-services-manage-live-encoder-enabled-channels.md)。\r\n\r\n## <a name=\"common-live-streaming-scenario\"></a>常见的实时流方案\r\n以下步骤介绍创建常见的实时流式处理应用程序时涉及的任务。\r\n\r\n>[!NOTE]\r\n> 目前，实时事件的最大建议持续时间为 8 小时。 如果需要运行一个需要更长时间的通道，请通过 Azure.cn 联系 amslived。\r\n\r\n1. 将视频摄像机连接到计算机。 启动并配置可以通过以下协议之一输出单比特率流的本地实时编码器：RTMP、平滑流式处理或 RTP (MPEG-TS)。 有关详细信息，请参阅 [Azure 媒体服务 RTMP 支持和实时编码器](http://go.microsoft.com/fwlink/?LinkId=532824)。\r\n\r\n    此步骤也可以在创建通道后执行。\r\n\r\n2. 创建并启动通道。\r\n3. 检索通道引入 URL。\r\n\r\n    实时编码器使用引入 URL 将流发送到频道。\r\n\r\n4. 检索频道预览 URL。\r\n\r\n    使用此 URL 来验证通道是否正常接收实时流。\r\n\r\n5. 创建资源。\r\n6. 如果想让资源在播放期间进行动态加密，请执行以下操作：\r\n7. 创建内容密钥。\r\n8. 配置内容密钥授权策略。\r\n9. 配置资产传送策略（由动态打包和动态加密使用）。\r\n10. 创建节目并指定使用创建的资产。\r\n11. 通过创建按需定位器发布与节目关联的资产。\r\n\r\n    >[!NOTE]\r\n    >创建 AMS 帐户后，会将一个处于“已停止”状态的**默认**流式处理终结点添加到帐户。 要从中流式传输内容的流式处理终结点必须处于“正在运行”状态。 \r\n\r\n12. 准备好开始流式传输和存档后，启动节目。\r\n13. （可选）可以向实时编码器发信号，以启动广告。 将广告插入到输出流中。\r\n14. 在要停止对事件进行流式传输和存档时，停止节目。\r\n15. 删除节目（并选择性地删除资产）。\r\n\r\n## <a name=\"what-youll-learn\"></a>学习内容\r\n本主题演示如何使用适用于 .NET 的媒体服务 SDK 对通道和节目执行不同操作。 由于许多操作都长时间运行，因此使用管理长时间运行的操作的 .NET API。\r\n\r\n本主题显示如何执行以下任务：\r\n\r\n1. 创建并启动通道。 会使用长时间运行的 API。\r\n2. 获取频道引入（输入）终结点。 应将此终结点提供给可以发送单比特率实时流的编码器。\r\n3. 获取预览终结点。 此终结点用于预览流。\r\n4. 创建用于存储你的内容的资源。 还应配置资源传送策略，如此示例中所示。\r\n5. 创建节目并指定使用先前创建的资源。 启动该节目。 会使用长时间运行的 API。\r\n6. 为资源创建定位器，以便发布内容，并可以将内容流式传输到客户端。\r\n7. 显示和隐藏清单。 启动和停止广告。 会使用长时间运行的 API。\r\n8. 清理通道及所有关联的资源。\r\n\r\n## <a name=\"prerequisites\"></a>先决条件\r\n以下是完成本教程所需具备的条件。\r\n\r\n* 一个 Azure 帐户。 如果没有帐户，可以创建一个试用帐户，只需几分钟即可完成。 有关详细信息，请参阅 [Azure 试用版](https://www.azure.cn/pricing/1rmb-trial/?WT.mc_id=A261C142F)。 获取可用来尝试付费版 Azure 服务的信用额度。 即使在信用额度用完后，也可保留帐户并使用免费的 Azure 服务和功能，例如 Azure 应用服务中的 Web 应用功能。\r\n* 一个媒体服务帐户。 若要创建媒体服务帐户，请参阅[创建帐户](media-services-portal-create-account.md)。\r\n* Visual Studio 2010 SP1（Professional、Premium、Ultimate 或 Express）或更高版本。\r\n* 必须使用适用于 .NET 的媒体服务 SDK 版本 3.2.0.0 或更高版本。\r\n* 可以发送单比特率实时流的摄像头和编码器。\r\n\r\n## <a name=\"considerations\"></a>注意事项\r\n* 目前，实时事件的最大建议持续时间为 8 小时。 如果需要运行一个需要更长时间的通道，请通过 Azure.cn 联系 amslived。\r\n* 不同 AMS 策略的策略限制为 1,000,000 个（例如，对于定位器策略或 ContentKeyAuthorizationPolicy）。 如果始终使用相同的日期/访问权限，则应使用相同的策略 ID，例如，用于要长期就地保留的定位符的策略（非上传策略）。 有关详细信息，请参阅[此](media-services-dotnet-manage-entities.md#limit-access-policies)主题。\r\n\r\n## <a name=\"download-sample\"></a>下载示例\r\n\r\n可以从[此处](https://azure.microsoft.com/documentation/samples/media-services-dotnet-encode-live-stream-with-ams-clear/)下载本主题所述的示例。\r\n\r\n## <a name=\"set-up-for-development-with-media-services-sdk-for-net\"></a>使用用于 .NET 的媒体服务 SDK 进行开发设置\r\n\r\n设置开发环境，并在 app.config 文件中填充连接信息，如[使用 .NET 进行媒体服务开发](media-services-dotnet-how-to-use.md)中所述。 \r\n\r\n## <a name=\"code-example\"></a>代码示例\r\n\r\n    using System;\r\n    using System.Collections.Generic;\r\n    using System.Configuration;\r\n    using System.IO;\r\n    using System.Linq;\r\n    using System.Net;\r\n    using Microsoft.WindowsAzure.MediaServices.Client;\r\n    using Microsoft.WindowsAzure.MediaServices.Client.DynamicEncryption;\r\n\r\n    namespace EncodeLiveStreamWithAmsClear\r\n    {\r\n        class Program\r\n        {\r\n        private const string ChannelName = \"channel001\";\r\n        private const string AssetlName = \"asset001\";\r\n        private const string ProgramlName = \"program001\";\r\n\r\n        // Read values from the App.config file.\r\n        private static readonly string _AADTenantDomain =\r\n        ConfigurationManager.AppSettings[\"AADTenantDomain\"];\r\n        private static readonly string _RESTAPIEndpoint =\r\n        ConfigurationManager.AppSettings[\"MediaServiceRESTAPIEndpoint\"];\r\n\r\n        private static CloudMediaContext _context = null;\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            var tokenCredentials = new AzureAdTokenCredentials(_AADTenantDomain, AzureEnvironments.AzureChinaCloudEnvironment);\r\n            var tokenProvider = new AzureAdTokenProvider(tokenCredentials);\r\n\r\n            _context = new CloudMediaContext(new Uri(_RESTAPIEndpoint), tokenProvider);\r\n\r\n            IChannel channel = CreateAndStartChannel();\r\n\r\n            // The channel's input endpoint:\r\n            string ingestUrl = channel.Input.Endpoints.FirstOrDefault().Url.ToString();\r\n\r\n            Console.WriteLine(\"Intest URL: {0}\", ingestUrl);\r\n\r\n            // Use the previewEndpoint to preview and verify \r\n            // that the input from the encoder is actually reaching the Channel. \r\n            string previewEndpoint = channel.Preview.Endpoints.FirstOrDefault().Url.ToString();\r\n\r\n            Console.WriteLine(\"Preview URL: {0}\", previewEndpoint);\r\n\r\n            // When Live Encoding is enabled, you can now get a preview of the live feed as it reaches the Channel. \r\n            // This can be a valuable tool to check whether your live feed is actually reaching the Channel. \r\n            // The thumbnail is exposed via the same end-point as the Channel Preview URL.\r\n            string thumbnailUri = new UriBuilder\r\n            {\r\n            Scheme = Uri.UriSchemeHttps,\r\n            Host = channel.Preview.Endpoints.FirstOrDefault().Url.Host,\r\n            Path = \"thumbnails/input.jpg\"\r\n            }.Uri.ToString();\r\n\r\n            Console.WriteLine(\"Thumbain URL: {0}\", thumbnailUri);\r\n\r\n            // Once you previewed your stream and verified that it is flowing into your Channel, \r\n            // you can create an event by creating an Asset, Program, and Streaming Locator. \r\n            IAsset asset = CreateAndConfigureAsset();\r\n\r\n            IProgram program = CreateAndStartProgram(channel, asset);\r\n\r\n            ILocator locator = CreateLocatorForAsset(program.Asset, program.ArchiveWindowLength);\r\n\r\n            // You can use slates and ads only if the channel type is Standard.  \r\n            StartStopAdsSlates(channel);\r\n\r\n            // Once you are done streaming, clean up your resources.\r\n            Cleanup(channel);\r\n        }\r\n\r\n        public static IChannel CreateAndStartChannel()\r\n        {\r\n            var channelInput = CreateChannelInput();\r\n            var channePreview = CreateChannelPreview();\r\n            var channelEncoding = CreateChannelEncoding();\r\n\r\n            ChannelCreationOptions options = new ChannelCreationOptions\r\n            {\r\n            EncodingType = ChannelEncodingType.Standard,\r\n            Name = ChannelName,\r\n            Input = channelInput,\r\n            Preview = channePreview,\r\n            Encoding = channelEncoding\r\n            };\r\n\r\n            Log(\"Creating channel\");\r\n            IOperation channelCreateOperation = _context.Channels.SendCreateOperation(options);\r\n            string channelId = TrackOperation(channelCreateOperation, \"Channel create\");\r\n\r\n            IChannel channel = _context.Channels.Where(c => c.Id == channelId).FirstOrDefault();\r\n\r\n            Log(\"Starting channel\");\r\n            var channelStartOperation = channel.SendStartOperation();\r\n            TrackOperation(channelStartOperation, \"Channel start\");\r\n\r\n            return channel;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Create channel input, used in channel creation options. \r\n        /// </summary>\r\n        /// <returns></returns>\r\n        private static ChannelInput CreateChannelInput()\r\n        {\r\n            return new ChannelInput\r\n            {\r\n            StreamingProtocol = StreamingProtocol.RTPMPEG2TS,\r\n            AccessControl = new ChannelAccessControl\r\n            {\r\n                IPAllowList = new List<IPRange>\r\n                {\r\n                    new IPRange\r\n                    {\r\n                    Name = \"TestChannelInput001\",\r\n                    Address = IPAddress.Parse(\"0.0.0.0\"),\r\n                    SubnetPrefixLength = 0\r\n                    }\r\n                }\r\n            }\r\n            };\r\n        }\r\n\r\n        /// <summary>\r\n        /// Create channel preview, used in channel creation options. \r\n        /// </summary>\r\n        /// <returns></returns>\r\n        private static ChannelPreview CreateChannelPreview()\r\n        {\r\n            return new ChannelPreview\r\n            {\r\n            AccessControl = new ChannelAccessControl\r\n            {\r\n                IPAllowList = new List<IPRange>\r\n                {\r\n                    new IPRange\r\n                    {\r\n                    Name = \"TestChannelPreview001\",\r\n                    Address = IPAddress.Parse(\"0.0.0.0\"),\r\n                    SubnetPrefixLength = 0\r\n                    }\r\n                }\r\n            }\r\n            };\r\n        }\r\n\r\n        /// <summary>\r\n        /// Create channel encoding, used in channel creation options. \r\n        /// </summary>\r\n        /// <returns></returns>\r\n        private static ChannelEncoding CreateChannelEncoding()\r\n        {\r\n            return new ChannelEncoding\r\n            {\r\n            SystemPreset = \"Default720p\",\r\n            IgnoreCea708ClosedCaptions = false,\r\n            AdMarkerSource = AdMarkerSource.Api,\r\n            // You can only set audio if streaming protocol is set to StreamingProtocol.RTPMPEG2TS.\r\n            AudioStreams = new List<AudioStream> { new AudioStream { Index = 103, Language = \"eng\" } }.AsReadOnly()\r\n            };\r\n        }\r\n\r\n        /// <summary>\r\n        /// Create an asset and configure asset delivery policies.\r\n        /// </summary>\r\n        /// <returns></returns>\r\n        public static IAsset CreateAndConfigureAsset()\r\n        {\r\n            IAsset asset = _context.Assets.Create(AssetlName, AssetCreationOptions.None);\r\n\r\n            IAssetDeliveryPolicy policy =\r\n            _context.AssetDeliveryPolicies.Create(\"Clear Policy\",\r\n            AssetDeliveryPolicyType.NoDynamicEncryption,\r\n            AssetDeliveryProtocol.HLS | AssetDeliveryProtocol.SmoothStreaming | AssetDeliveryProtocol.Dash, null);\r\n\r\n            asset.DeliveryPolicies.Add(policy);\r\n\r\n            return asset;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Create a Program on the Channel. You can have multiple Programs that overlap or are sequential;\r\n        /// however each Program must have a unique name within your Media Services account.\r\n        /// </summary>\r\n        /// <param name=\"channel\"></param>\r\n        /// <param name=\"asset\"></param>\r\n        /// <returns></returns>\r\n        public static IProgram CreateAndStartProgram(IChannel channel, IAsset asset)\r\n        {\r\n            IProgram program = channel.Programs.Create(ProgramlName, TimeSpan.FromHours(3), asset.Id);\r\n            Log(\"Program created\", program.Id);\r\n\r\n            Log(\"Starting program\");\r\n            var programStartOperation = program.SendStartOperation();\r\n            TrackOperation(programStartOperation, \"Program start\");\r\n\r\n            return program;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Create locators in order to be able to publish and stream the video.\r\n        /// </summary>\r\n        /// <param name=\"asset\"></param>\r\n        /// <param name=\"ArchiveWindowLength\"></param>\r\n        /// <returns></returns>\r\n        public static ILocator CreateLocatorForAsset(IAsset asset, TimeSpan ArchiveWindowLength)\r\n        {\r\n            // You cannot create a streaming locator using an AccessPolicy that includes write or delete permissions.            \r\n            var locator = _context.Locators.CreateLocator\r\n            (\r\n                LocatorType.OnDemandOrigin,\r\n                asset,\r\n                _context.AccessPolicies.Create\r\n                (\r\n                    \"Live Stream Policy\",\r\n                    ArchiveWindowLength,\r\n                    AccessPermissions.Read\r\n                )\r\n            );\r\n\r\n            return locator;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Perform operations on slates.\r\n        /// </summary>\r\n        /// <param name=\"channel\"></param>\r\n        public static void StartStopAdsSlates(IChannel channel)\r\n        {\r\n            int cueId = new Random().Next(int.MaxValue);\r\n            var path = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, @\"..\\\\..\\\\SlateJPG\\\\DefaultAzurePortalSlate.jpg\"));\r\n\r\n            Log(\"Creating asset\");\r\n            var slateAsset = _context.Assets.Create(\"Slate test asset \" + DateTime.Now.ToString(\"yyyy-MM-dd HH-mm\"), AssetCreationOptions.None);\r\n            Log(\"Slate asset created\", slateAsset.Id);\r\n\r\n            Log(\"Uploading file\");\r\n            var assetFile = slateAsset.AssetFiles.Create(\"DefaultAzurePortalSlate.jpg\");\r\n            assetFile.Upload(path);\r\n            assetFile.IsPrimary = true;\r\n            assetFile.Update();\r\n\r\n            Log(\"Showing slate\");\r\n            var showSlateOpeartion = channel.SendShowSlateOperation(TimeSpan.FromMinutes(1), slateAsset.Id);\r\n            TrackOperation(showSlateOpeartion, \"Show slate\");\r\n\r\n            Log(\"Hiding slate\");\r\n            var hideSlateOperation = channel.SendHideSlateOperation();\r\n            TrackOperation(hideSlateOperation, \"Hide slate\");\r\n\r\n            Log(\"Starting ad\");\r\n            var startAdOperation = channel.SendStartAdvertisementOperation(TimeSpan.FromMinutes(1), cueId, false);\r\n            TrackOperation(startAdOperation, \"Start ad\");\r\n\r\n            Log(\"Ending ad\");\r\n            var endAdOperation = channel.SendEndAdvertisementOperation(cueId);\r\n            TrackOperation(endAdOperation, \"End ad\");\r\n\r\n            Log(\"Deleting slate asset\");\r\n            slateAsset.Delete();\r\n        }\r\n\r\n        /// <summary>\r\n        /// Clean up resources associated with the channel.\r\n        /// </summary>\r\n        /// <param name=\"channel\"></param>\r\n        public static void Cleanup(IChannel channel)\r\n        {\r\n            IAsset asset;\r\n            if (channel != null)\r\n            {\r\n            foreach (var program in channel.Programs)\r\n            {\r\n                asset = _context.Assets.Where(se => se.Id == program.AssetId)\r\n                            .FirstOrDefault();\r\n\r\n                Log(\"Stopping program\");\r\n                var programStopOperation = program.SendStopOperation();\r\n                TrackOperation(programStopOperation, \"Program stop\");\r\n\r\n                program.Delete();\r\n\r\n                if (asset != null)\r\n                {\r\n                Log(\"Deleting locators\");\r\n                foreach (var l in asset.Locators)\r\n                    l.Delete();\r\n\r\n                Log(\"Deleting asset\");\r\n                asset.Delete();\r\n                }\r\n            }\r\n\r\n            Log(\"Stopping channel\");\r\n            var channelStopOperation = channel.SendStopOperation();\r\n            TrackOperation(channelStopOperation, \"Channel stop\");\r\n\r\n            Log(\"Deleting channel\");\r\n            var channelDeleteOperation = channel.SendDeleteOperation();\r\n            TrackOperation(channelDeleteOperation, \"Channel delete\");\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Track long running operations.\r\n        /// </summary>\r\n        /// <param name=\"operation\"></param>\r\n        /// <param name=\"description\"></param>\r\n        /// <returns></returns>\r\n        public static string TrackOperation(IOperation operation, string description)\r\n        {\r\n            string entityId = null;\r\n            bool isCompleted = false;\r\n\r\n            Log(\"starting to track \", null, operation.Id);\r\n            while (isCompleted == false)\r\n            {\r\n            operation = _context.Operations.GetOperation(operation.Id);\r\n            isCompleted = IsCompleted(operation, out entityId);\r\n            System.Threading.Thread.Sleep(TimeSpan.FromSeconds(30));\r\n            }\r\n            // If we got here, the operation succeeded.\r\n            Log(description + \" in completed\", operation.TargetEntityId, operation.Id);\r\n\r\n            return entityId;\r\n        }\r\n\r\n        /// <summary> \r\n        /// Checks if the operation has been completed. \r\n        /// If the operation succeeded, the created entity Id is returned in the out parameter.\r\n        /// </summary> \r\n        /// <param name=\"operationId\">The operation Id.</param> \r\n        /// <param name=\"channel\">\r\n        /// If the operation succeeded, \r\n        /// the entity Id associated with the sucessful operation is returned in the out parameter.</param>\r\n        /// <returns>Returns false if the operation is still in progress; otherwise, true.</returns> \r\n        private static bool IsCompleted(IOperation operation, out string entityId)\r\n        {\r\n            bool completed = false;\r\n\r\n            entityId = null;\r\n\r\n            switch (operation.State)\r\n            {\r\n            case OperationState.Failed:\r\n                // Handle the failure. \r\n                // For example, throw an exception. \r\n                // Use the following information in the exception: operationId, operation.ErrorMessage.\r\n                Log(\"operation failed\", operation.TargetEntityId, operation.Id);\r\n                break;\r\n            case OperationState.Succeeded:\r\n                completed = true;\r\n                entityId = operation.TargetEntityId;\r\n                break;\r\n            case OperationState.InProgress:\r\n                completed = false;\r\n                Log(\"operation in progress\", operation.TargetEntityId, operation.Id);\r\n                break;\r\n            }\r\n            return completed;\r\n        }\r\n\r\n        private static void Log(string action, string entityId = null, string operationId = null)\r\n        {\r\n            Console.WriteLine(\r\n            \"{0,-21}{1,-51}{2,-51}{3,-51}\",\r\n            DateTime.Now.ToString(\"yyyy'-'MM'-'dd HH':'mm':'ss\"),\r\n            action,\r\n            entityId ?? string.Empty,\r\n            operationId ?? string.Empty);\r\n        }\r\n        }\r\n    }\r\n<!--Update_Description: update code to use AAD token instead of ACS-->\r\n"}