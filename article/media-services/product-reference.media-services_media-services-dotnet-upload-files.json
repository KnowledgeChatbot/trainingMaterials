{"Title":"使用 .NET 将文件上传到媒体服务帐户","Description":"了解如何通过创建和上传资产将媒体内容加入媒体服务。","Content":"# <a name=\"upload-files-into-a-media-services-account-using-net\"></a>使用 .NET 将文件上传到媒体服务帐户\r\n> [!div class=\"op_single_selector\"]\r\n> * [.NET](media-services-dotnet-upload-files.md)\r\n> * [REST](media-services-rest-upload-files.md)\r\n> * [门户](media-services-portal-upload-files.md)\r\n> \r\n> \r\n\r\n在媒体服务中，可以将数字文件上传（引入）到资产中。 **资产**实体可以包含视频、音频、图像、缩略图集合、文本轨道和隐藏式字幕文件（以及这些文件的相关元数据。）上传文件完成后，相关内容即安全地存储在云中供后续处理和流式处理。\r\n\r\n资产中的文件称为 **资产文件**。 **AssetFile** 实例和实际媒体文件是两个不同的对象。 AssetFile 实例包含有关媒体文件的元数据，而媒体文件包含实际媒体内容。\r\n\r\n> [!NOTE]\r\n> 请注意以下事项：\r\n> \r\n> * 构建流内容的 URL 时，媒体服务会使用 IAssetFile.Name 属性的值（如 http://{AMSAccount}.origin.mediaservices.chinacloudapi.cn/{GUID}/{IAssetFile.Name}/streamingParameters。）出于这个原因，不允许使用百分号编码。 **Name** 属性的值不能含有任何以下[百分号编码保留字符](http://en.wikipedia.org/wiki/Percent-encoding#Percent-encoding_reserved_characters)：!*'();:@&=+$,/?%#[]\"。 此外，文件扩展名中只能含有一个“.”。\r\n> * 名称长度不应超过 260 个字符。\r\n> * 在媒体服务中进行处理时，系统支持的最大文件大小存在限制。 有关文件大小限制的详细信息，请参阅[此主题](media-services-quotas-and-limitations.md)。\r\n> * 不同 AMS 策略的策略限制为 1,000,000 个（例如，对于定位器策略或 ContentKeyAuthorizationPolicy）。 如果始终使用相同的日期/访问权限，则应使用相同的策略 ID，例如，用于要长期就地保留的定位符的策略（非上传策略）。 有关详细信息，请参阅[此](media-services-dotnet-manage-entities.md#limit-access-policies)主题。\r\n> \r\n\r\n在创建资产时，可以指定以下加密选项。 \r\n\r\n* **无** - 不使用加密。 这是默认值。 请注意，使用此选项时，内容在传送过程中或静态存储过程中都不会受到保护。\r\n  如果计划使用渐进式下载交付 MP4，则使用此选项。 \r\n* **CommonEncryption** - 上传经过通用加密或 PlayReady DRM 加密并保护的内容（例如，受 PlayReady DRM 保护的平滑流式处理）时使用此选项。\r\n* **EnvelopeEncrypted** - 如果要上传使用 AES 加密的 HLS，请使用此选项。 请注意，Transform Manager 必须已对文件进行编码和加密。\r\n* **StorageEncrypted** - 使用 AES-256 位加密在本地加密明文内容，然后将其上传到 Azure Storage 中以加密形式静态存储相关内容。 受存储加密保护的资产将在编码前自动解密并放入经过加密的文件系统中，并可选择在重新上传为新的输出资产前重新加密。 存储加密的主要用例是在磁盘上通过静态增强加密来保护高品质的输入媒体文件。\r\n  \r\n    媒体服务为资产提供磁盘上的存储加密，而不是通过数字权限管理器 (DRM) 等线路提供加密。\r\n  \r\n    如果资产已经过存储加密，则必须配置资产传送策略。 有关详细信息，请参阅[配置资产传送策略](media-services-dotnet-configure-asset-delivery-policy.md)。\r\n\r\n如果指定使用 **CommonEncrypted** 选项或 **EnvelopeEncypted** 选项加密资产，则需要将资产关联到 **ContentKey**。 有关详细信息，请参阅[如何创建 ContentKey](media-services-dotnet-create-contentkey.md)。 \r\n\r\n如果指定使用 **StorageEncrypted** 选项加密资产，适用于 .NET 的媒体服务 SDK 为资产创建 **StorateEncrypted****ContentKey**。\r\n\r\n本主题说明如何使用媒体服务.NET SDK 以及媒体服务.NET SDK 扩展将文件上传到媒体服务资产中。\r\n\r\n## <a name=\"upload-a-single-file-with-media-services-net-sdk\"></a>使用媒体服务 .NET SDK 上传单个文件\r\n以下示例代码使用 .NET SDK 上传单个文件。 AccessPolicy 和 Locator 由 Upload 函数创建和销毁。 \r\n\r\n\r\n        static public IAsset CreateAssetAndUploadSingleFile(AssetCreationOptions assetCreationOptions, string singleFilePath)\r\n        {\r\n            if (!File.Exists(singleFilePath))\r\n            {\r\n                Console.WriteLine(\"File does not exist.\");\r\n                return null;\r\n            }\r\n\r\n            var assetName = Path.GetFileNameWithoutExtension(singleFilePath);\r\n            IAsset inputAsset = _context.Assets.Create(assetName, assetCreationOptions);\r\n\r\n            var assetFile = inputAsset.AssetFiles.Create(Path.GetFileName(singleFilePath));\r\n\r\n            Console.WriteLine(\"Upload {0}\", assetFile.Name);\r\n\r\n            assetFile.Upload(singleFilePath);\r\n            Console.WriteLine(\"Done uploading {0}\", assetFile.Name);\r\n\r\n            return inputAsset;\r\n        }\r\n\r\n\r\n## <a name=\"upload-multiple-files-with-media-services-net-sdk\"></a>使用媒体服务 .NET SDK 上传多个文件\r\n以下代码演示如何创建资产及上传多个文件。\r\n\r\n代码执行以下操作：\r\n\r\n* 使用上一步中定义的 CreateEmptyAsset 方法创建一个空资产。\r\n* 创建用于定义权限以及资产访问持续时间的 **AccessPolicy** 实例。\r\n* 创建用于提供资产访问权限的 **Locator** 实例。\r\n* 创建 **BlobTransferClient** 实例。 此类型表示对 Azure Blob 进行操作的客户端。 此示例中使用客户端来监视上传进度。 \r\n* 枚举指定目录下的所有文件，并为每个文件创建一个 **AssetFile** 实例。\r\n* 使用 **UploadAsync** 方法将文件上传到媒体服务中。 \r\n\r\n> [!NOTE]\r\n> 使用 UploadAsync 方法可确保调用不会阻塞并且文件并行上传。\r\n> \r\n> \r\n\r\n        static public IAsset CreateAssetAndUploadMultipleFiles(AssetCreationOptions assetCreationOptions, string folderPath)\r\n        {\r\n            var assetName = \"UploadMultipleFiles_\" + DateTime.UtcNow.ToString();\r\n\r\n            IAsset asset = _context.Assets.Create(assetName, assetCreationOptions);\r\n\r\n            var accessPolicy = _context.AccessPolicies.Create(assetName, TimeSpan.FromDays(30),\r\n                                                                AccessPermissions.Write | AccessPermissions.List);\r\n\r\n            var locator = _context.Locators.CreateLocator(LocatorType.Sas, asset, accessPolicy);\r\n\r\n            var blobTransferClient = new BlobTransferClient();\r\n            blobTransferClient.NumberOfConcurrentTransfers = 20;\r\n            blobTransferClient.ParallelTransferThreadCount = 20;\r\n\r\n            blobTransferClient.TransferProgressChanged += blobTransferClient_TransferProgressChanged;\r\n\r\n            var filePaths = Directory.EnumerateFiles(folderPath);\r\n\r\n            Console.WriteLine(\"There are {0} files in {1}\", filePaths.Count(), folderPath);\r\n\r\n            if (!filePaths.Any())\r\n            {\r\n                throw new FileNotFoundException(String.Format(\"No files in directory, check folderPath: {0}\", folderPath));\r\n            }\r\n\r\n            var uploadTasks = new List<Task>();\r\n            foreach (var filePath in filePaths)\r\n            {\r\n                var assetFile = asset.AssetFiles.Create(Path.GetFileName(filePath));\r\n                Console.WriteLine(\"Created assetFile {0}\", assetFile.Name);\r\n\r\n                // It is recommended to validate AccestFiles before upload. \r\n                Console.WriteLine(\"Start uploading of {0}\", assetFile.Name);\r\n                uploadTasks.Add(assetFile.UploadAsync(filePath, blobTransferClient, locator, CancellationToken.None));\r\n            }\r\n\r\n            Task.WaitAll(uploadTasks.ToArray());\r\n            Console.WriteLine(\"Done uploading the files\");\r\n\r\n            blobTransferClient.TransferProgressChanged -= blobTransferClient_TransferProgressChanged;\r\n\r\n            locator.Delete();\r\n            accessPolicy.Delete();\r\n\r\n            return asset;\r\n        }\r\n\r\n    static void  blobTransferClient_TransferProgressChanged(object sender, BlobTransferProgressChangedEventArgs e)\r\n    {\r\n        if (e.ProgressPercentage > 4) // Avoid startup jitter, as the upload tasks are added.\r\n        {\r\n            Console.WriteLine(\"{0}% upload competed for {1}.\", e.ProgressPercentage, e.LocalFile);\r\n        }\r\n    }\r\n\r\n\r\n\r\n上传大量资产时，请注意以下事项。\r\n\r\n* 每个线程创建一个新的 **CloudMediaContext** 对象。 **CloudMediaContext** 类不是线程安全的。\r\n* 将 NumberOfConcurrentTransfers 从默认值 2 增加到更高的值（如 5）。 设置此属性会影响 **CloudMediaContext**的所有实例。 \r\n* 将 ParallelTransferThreadCount 保留为默认值 10。\r\n\r\n## <a id=\"ingest_in_bulk\"></a>使用媒体服务 .NET SDK 批量引入资产\r\n上传大型资产文件可能在资产创建过程中形成瓶颈。 批量引入资产（简称“批量引入”）涉及将资产创建过程与上传过程分离。 若要使用批量引入方法，请创建一个描述资产及其关联文件的清单 (IngestManifest)。 然后，用户可以使用所选上传方法将关联的文件上传到该清单的 Blob 容器。 Azure 媒体服务会监视与清单关联的 Blob 容器。 文件上传到 Blob 容器后，Azure 媒体服务基于清单 (IngestManifestAsset) 中资产的配置完成资产创建过程。\r\n\r\n若要创建新的 IngestManifest，请调用 CloudMediaContext 中的 IngestManifests 集合公开的 Create 方法。 此方法会使用你提供的清单名称创建一个新的 IngestManifest。\r\n\r\n    IIngestManifest manifest = context.IngestManifests.Create(name);\r\n\r\n创建将与批量 IngestManifest 关联的资产。 在要批量引入的资产上配置所需的加密选项。\r\n\r\n    // Create the assets that will be associated with this bulk ingest manifest\r\n    IAsset destAsset1 = _context.Assets.Create(name + \"_asset_1\", AssetCreationOptions.None);\r\n    IAsset destAsset2 = _context.Assets.Create(name + \"_asset_2\", AssetCreationOptions.None);\r\n\r\n一个 IngestManifestAsset 将一个资产与一个用于批量引入的批量 IngestManifest 相关联。 它还关联构成每个资产的 AssetFiles。 若要创建 IngestManifestAsset，请使用服务器上下文中的 Create 方法。\r\n\r\n以下示例演示如何添加两个新的 IngestManifestAssets，这两项将以前创建的两个资产关联到批量引入清单。 每个 IngestManifestAsset 还关联一组会在批量引入期间为每个资产上传的文件。  \r\n\r\n    string filename1 = _singleInputMp4Path;\r\n    string filename2 = _primaryFilePath;\r\n    string filename3 = _singleInputFilePath;\r\n\r\n    IIngestManifestAsset bulkAsset1 =  manifest.IngestManifestAssets.Create(destAsset1, new[] { filename1 });\r\n    IIngestManifestAsset bulkAsset2 =  manifest.IngestManifestAssets.Create(destAsset2, new[] { filename2, filename3 });\r\n\r\n可以使用任何能够将资产文件上传到 blob 存储容器 URI（由 IngestManifest 的 **IIngestManifest.BlobStorageUriForUpload** 属性提供）的高速客户端应用程序。 一项引人注目的高速上传服务是 [适用于 Azure 应用程序的点播 Aspera](https://datamarket.azure.com/application/2cdbc511-cb12-4715-9871-c7e7fbbb82a6)。 还可以编写代码来上传资产文件，如以下代码示例所示。\r\n\r\n    static void UploadBlobFile(string destBlobURI, string filename)\r\n    {\r\n        Task copytask = new Task(() =>\r\n        {\r\n            var storageaccount = new CloudStorageAccount(new StorageCredentials(_storageAccountName, _storageAccountKey), true);\r\n            CloudBlobClient blobClient = storageaccount.CreateCloudBlobClient();\r\n            CloudBlobContainer blobContainer = blobClient.GetContainerReference(destBlobURI);\r\n\r\n            string[] splitfilename = filename.Split('\\\\');\r\n            var blob = blobContainer.GetBlockBlobReference(splitfilename[splitfilename.Length - 1]);\r\n\r\n            using (var stream = System.IO.File.OpenRead(filename))\r\n                blob.UploadFromStream(stream);\r\n\r\n            lock (consoleWriteLock)\r\n            {\r\n                Console.WriteLine(\"Upload for {0} completed.\", filename);\r\n            }\r\n        });\r\n\r\n        copytask.Start();\r\n    }\r\n\r\n以下代码示例展示了用于上传本主题中使用的示例资产文件的代码。\r\n\r\n    UploadBlobFile(manifest.BlobStorageUriForUpload, filename1);\r\n    UploadBlobFile(manifest.BlobStorageUriForUpload, filename2);\r\n    UploadBlobFile(manifest.BlobStorageUriForUpload, filename3);\r\n\r\n\r\n可以通过轮询 **IngestManifest** 的 Statistics 属性来确定与 **IngestManifest** 关联的所有资产的批量引入进度。 若要更新进度信息，每次轮询 Statistics 属性时，都必须使用新的 **CloudMediaContext**。\r\n\r\n以下示例演示如何按 **ID**轮询 IngestManifest。\r\n\r\n    static void MonitorBulkManifest(string manifestID)\r\n    {\r\n       bool bContinue = true;\r\n       while (bContinue)\r\n       {\r\n          CloudMediaContext context = GetContext();\r\n          IIngestManifest manifest = context.IngestManifests.Where(m => m.Id == manifestID).FirstOrDefault();\r\n\r\n          if (manifest != null)\r\n          {\r\n             lock(consoleWriteLock)\r\n             {\r\n                Console.WriteLine(\"\\nWaiting on all file uploads.\");\r\n                Console.WriteLine(\"PendingFilesCount  : {0}\", manifest.Statistics.PendingFilesCount);\r\n                Console.WriteLine(\"FinishedFilesCount : {0}\", manifest.Statistics.FinishedFilesCount);\r\n                Console.WriteLine(\"{0}% complete.\\n\", (float)manifest.Statistics.FinishedFilesCount / (float)(manifest.Statistics.FinishedFilesCount + manifest.Statistics.PendingFilesCount) * 100);\r\n\r\n                if (manifest.Statistics.PendingFilesCount == 0)\r\n                {\r\n                   Console.WriteLine(\"Completed\\n\");\r\n                   bContinue = false;\r\n                }\r\n             }\r\n\r\n             if (manifest.Statistics.FinishedFilesCount < manifest.Statistics.PendingFilesCount)\r\n                Thread.Sleep(60000);\r\n          }\r\n          else // Manifest is null\r\n             bContinue = false;\r\n       }\r\n    }\r\n\r\n\r\n\r\n## <a name=\"upload-files-using-net-sdk-extensions\"></a>使用 .NET SDK 扩展上传文件\r\n以下示例演示如何使用 .NET SDK 扩展上传单个文件。 在此情况下，使用 **CreateFromFile** 方法，但也可以使用异步版本 (**CreateFromFileAsync**)。 通过 **CreateFromFile** 方法可以指定文件名、加密选项和回叫，以报告文件的上传进度。\r\n\r\n    static public IAsset UploadFile(string fileName, AssetCreationOptions options)\r\n    {\r\n        IAsset inputAsset = _context.Assets.CreateFromFile(\r\n            fileName,\r\n            options,\r\n            (af, p) =>\r\n            {\r\n                Console.WriteLine(\"Uploading '{0}' - Progress: {1:0.##}%\", af.Name, p.Progress);\r\n            });\r\n\r\n        Console.WriteLine(\"Asset {0} created.\", inputAsset.Id);\r\n\r\n        return inputAsset;\r\n    }\r\n\r\n以下示例调用 UploadFile 函数，并指定存储加密作为资产创建选项。  \r\n\r\n    var asset = UploadFile(@\"C:\\VideoFiles\\BigBuckBunny.mp4\", AssetCreationOptions.StorageEncrypted);\r\n\r\n## <a name=\"next-steps\"></a>后续步骤\r\n\r\n现即可编码已上传的资产。 有关详细信息，请参阅[对资产进行编码](media-services-portal-encode.md)。\r\n\r\n## <a name=\"next-step\"></a>后续步骤\r\n将资产上传到媒体服务后，请转到 [如何获取媒体处理器][How to Get a Media Processor] 主题。\r\n\r\n[How to Get a Media Processor]: media-services-get-media-processor.md\r\n<!--Update_Description:add two links-->\r\n"}