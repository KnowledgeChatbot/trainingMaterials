{"Title":"使用 PlayReady 动态通用加密","Description":"Azure 媒体服务允许传送受 Microsoft PlayReady DRM 保护的 MPEG-DASH 流、平滑流式处理流和 HTTP 实时流式处理 (HLS) 流。","Content":"# <a name=\"using-playready-dynamic-common-encryption\"></a>使用 PlayReady 动态通用加密\r\n\r\n> [!div class=\"op_single_selector\"]\r\n> * [.NET](media-services-protect-with-drm.md)\r\n> * [Java](https://github.com/southworkscom/azure-sdk-for-media-services-java-samples)\r\n> * [PHP](https://github.com/Azure/azure-sdk-for-php/tree/master/examples/MediaServices)\r\n>\r\n>\r\n\r\nAzure 媒体服务允许传送受 [Microsoft PlayReady DRM](https://www.microsoft.com/playready/overview/) 保护的 MPEG-DASH 流、平滑流式处理流和 HTTP 实时流式处理 (HLS) 流。 PlayReady 是按通用加密 (ISO/IEC 23001-7 CENC) 规范加密的。\r\n\r\n媒体服务提供了用于传送 PlayReady DRM 许可证的服务。 媒体服务还提供用于配置所需权限和限制的 API，这样当用户播放受保护的内容时，PlayReady DRM 运行时便会强制实施这些权限和限制。 当用户请求受 DRM 保护的内容时，播放器应用程序从 AMS 许可证服务请求许可证。 如果播放器已获授权，AMS 许可证服务将向播放器颁发许可证。 PlayReady 许可证包含客户端播放器用来对内容进行解密和流式传输的解密密钥。\r\n\r\n媒体服务支持通过多种方式对发出密钥请求的用户进行授权。 内容密钥授权策略可能受到一种或多种授权限制：开放或令牌限制。 令牌限制策略必须附带由安全令牌服务 (STS) 颁发的令牌。 媒体服务支持采用[简单 Web 令牌](https://msdn.microsoft.com/library/gg185950.aspx#BKMK_2) (SWT) 格式和 [JSON Web 令牌](https://msdn.microsoft.com/library/gg185950.aspx#BKMK_3) (JWT) 格式的令牌。 有关详细信息，请参阅“配置内容密钥授权策略”。\r\n\r\n为了充分利用动态加密，资产必须包含一组多码率 MP4 文件或多码率平滑流源文件。 还需要为资产配置传送策略（在本主题后面部分介绍）。 然后，根据流式处理 URL 中指定的格式，按需流式处理服务器会确保使用选定的协议来传送流。 因此，用户只需以单一存储格式存储文件并为其付费，媒体服务就会基于客户端的每个请求构建并提供相应的 HTTP 响应。\r\n\r\n开发应用程序以传送受多个 DRM（例如 PlayReady）保护的媒体的开发人员可以参考本主题。 本主题介绍如何使用授权策略来配置 PlayReady 许可证传送服务，确保只有经过授权的客户端才能接收 PlayReady。 此外，还介绍如何通过 DASH 使用 PlayReady 进行动态加密。\r\n\r\n>[!NOTE]\r\n>创建 AMS 帐户后，会将一个处于“已停止”状态的**默认**流式处理终结点添加到帐户。 若要开始流式传输内容并利用动态打包和动态加密，要从中流式传输内容的流式处理终结点必须处于“正在运行”状态。 \r\n\r\n## <a name=\"download-sample\"></a>下载示例\r\n可以从 [此处](https://github.com/Azure-Samples/media-services-dotnet-dynamic-encryption-with-drm)下载本文所述的示例。\r\n\r\n## <a name=\"configuring-dynamic-common-encryption-and-drm-license-delivery-services\"></a>配置动态通用加密和 DRM 许可证传送服务\r\n\r\n下面是使用 PlayReady 保护资产时需要执行的常规步骤，这些步骤使用媒体服务许可证传送服务，也使用动态加密。\r\n\r\n1. 创建资产并将文件上传到资产。\r\n2. 将包含文件的资产编码为自适应比特率 MP4 集。\r\n3. 创建内容密钥并将其与编码资产相关联。 在媒体服务中，内容密钥包含资产的加密密钥。\r\n4. 配置内容密钥授权策略。 必须配置内容密钥授权策略，客户端必须遵守该策略，才能将内容密钥传送到客户端。\r\n\r\n    在创建内容密钥授权策略时，需要指定以下信息：传送方法 (PlayReady)、限制（开放或令牌），以及用于定义如何将密钥传送到客户端的密钥传送类型的具体信息（[PlayReady](media-services-playready-license-template-overview.md) 许可证模板）。\r\n\r\n5. 为资产配置传送策略。 传送策略配置包括：传送协议（例如 MPEG DASH、HLS、平滑流式处理或所有这些协议）、动态加密类型（例如常用加密）、PlayReady 许可证获取 URL。\r\n\r\n    可以将不同的策略应用到同一资产上的每个协议。 例如，可以将 PlayReady 加密应用到平滑流/DASH，将 AES 信封应用到 HLS。 将阻止流式处理传送策略中未定义的任何协议（例如，添加仅将 HLS 指定为协议的单个策略）。 如果根本没有定义任何传送策略，则情况不是这样。 此时，所有协议都可以通过。\r\n\r\n6. 创建 OnDemand 定位符以获取流 URL。\r\n\r\n可以在主题末尾找到完整的 .NET 示例。\r\n\r\n下图演示了上述工作流。 在图中，使用令牌进行了身份验证。\r\n\r\n![使用 PlayReady 进行保护](./media/media-services-content-protection-overview/media-services-content-protection-with-drm.png)\r\n\r\n本主题的余下部分提供了详细说明、代码示例和主题链接，向你演示如何完成上述任务。\r\n\r\n## <a name=\"current-limitations\"></a>当前限制\r\n如果添加或更新资产的传送策略，则必须删除关联的定位符（如果有）并创建新定位符。\r\n\r\n\r\n## <a name=\"create-an-asset-and-upload-files-into-the-asset\"></a>创建资产并将文件上传到资产\r\n为了对视频进行管理、编码和流式处理，必须首先将内容上传到 Azure 媒体服务中。 上传完成后，相关内容即安全地存储在云中供后续处理和流式处理。\r\n\r\n有关详细信息，请参阅[将文件上传到媒体服务帐户](media-services-dotnet-upload-files.md)。\r\n\r\n## <a name=\"encode-the-asset-containing-the-file-to-the-adaptive-bitrate-mp4-set\"></a>将包含文件的资产编码为自适应比特率 MP4 集。\r\n使用动态加密时，只需创建包含一组多码率 MP4 文件或多码率平滑流源文件的资产。 然后，按需流式处理服务器会确保用户以选定的协议按清单和分段请求中的指定格式接收流。 因此，用户只需以单一存储格式存储文件并为其付费，媒体服务服务就会基于客户端的请求构建并提供相应响应。 有关详细信息，请参阅 [动态打包概述](media-services-dynamic-packaging-overview.md) 主题。\r\n\r\n有关如何编码的说明，请参阅 [如何使用 Media Encoder Standard 对资产进行编码](media-services-dotnet-encode-with-media-encoder-standard.md)。\r\n\r\n## <a id=\"create_contentkey\"></a>创建内容密钥并将其与编码资产相关联\r\n在媒体服务中，内容密钥包含用于加密资产的密钥。\r\n\r\n有关详细信息，请参阅 [创建内容密钥](media-services-dotnet-create-contentkey.md)。\r\n\r\n## <a id=\"configure_key_auth_policy\"></a>配置内容密钥授权策略\r\n媒体服务支持通过多种方式对发出密钥请求的用户进行身份验证。 必须配置内容密钥授权策略，客户端（播放器）必须遵守该策略，才能将密钥传送到客户端。 内容密钥授权策略可能受到一种或多种授权限制：开放或令牌限制。\r\n\r\n有关详细信息，请参阅 [配置内容密钥授权策略](media-services-dotnet-configure-content-key-auth-policy.md#playready-dynamic-encryption)。\r\n\r\n## <a id=\"configure_asset_delivery_policy\"></a>配置资产传送策略\r\n为资产配置传送策略。 资产传送策略配置包括：\r\n\r\n* DRM 许可证获取 URL。\r\n* 资产传送协议（例如 MPEG DASH、HLS、平滑流式处理或全部）。\r\n* 动态加密类型（在本示例中为“常用加密”）。\r\n\r\n有关详细信息，请参阅 [配置资产传送策略 ](media-services-rest-configure-asset-delivery-policy.md)。\r\n\r\n## <a id=\"create_locator\"></a>创建 OnDemand 流定位符以获取流 URL\r\n需要为用户提供平滑流、DASH 或 HLS 的流 URL。\r\n\r\n> [!NOTE]\r\n> 如果添加或更新资产的传送策略，则必须删除现有定位符（如果有）并创建新定位符。\r\n>\r\n>\r\n\r\n有关如何发布资产和生成流 URL 的说明，请参阅 [生成流 URL](media-services-deliver-streaming-content.md)。\r\n\r\n## <a name=\"get-a-test-token\"></a>获取测试令牌\r\n获取用于密钥授权策略的基于令牌限制的测试令牌。\r\n\r\n    // Deserializes a string containing an Xml representation of a TokenRestrictionTemplate\r\n    // back into a TokenRestrictionTemplate class instance.\r\n    TokenRestrictionTemplate tokenTemplate =\r\n        TokenRestrictionTemplateSerializer.Deserialize(tokenTemplateString);\r\n\r\n    // Generate a test token based on the data in the given TokenRestrictionTemplate.\r\n    //The GenerateTestToken method returns the token without the word “Bearer” in front\r\n    //so you have to add it in front of the token string.\r\n    string testToken = TokenRestrictionTemplateSerializer.GenerateTestToken(tokenTemplate);\r\n    Console.WriteLine(\"The authorization token is:\\nBearer {0}\", testToken);\r\n\r\n\r\n可以使用 [AMS Player](http://amsplayer.azurewebsites.net/azuremediaplayer.html) 来测试流。\r\n\r\n## <a name=\"create-and-configure-a-visual-studio-project\"></a>创建和配置 Visual Studio 项目\r\n\r\n1. 设置开发环境，并在 app.config 文件中填充连接信息，如[使用 .NET 进行媒体服务开发](media-services-dotnet-how-to-use.md)中所述。 \r\n2. 将以下元素添加到 app.config 文件中定义的 **appSettings**：\r\n\r\n        <add key=\"Issuer\" value=\"http://testacs.com\"/>\r\n        <add key=\"Audience\" value=\"urn:test\"/>\r\n\r\n## <a name=\"example\"></a>示例\r\n\r\n以下示例演示的功能已引入用于 .Net 的 Azure 媒体服务 SDK - 版本 3.5.2。\r\n\r\n使用本部分中所示的代码覆盖 Program.cs 文件中的代码。\r\n\r\n>[!NOTE]\r\n>不同 AMS 策略的策略限制为 1,000,000 个（例如，对于定位器策略或 ContentKeyAuthorizationPolicy）。 如果始终使用相同的日期/访问权限，则应使用相同的策略 ID，例如，用于要长期就地保留的定位符的策略（非上传策略）。 有关详细信息，请参阅[此](media-services-dotnet-manage-entities.md#limit-access-policies)主题。\r\n\r\n请务必将变量更新为指向输入文件所在的文件夹。\r\n\r\n    using System;\r\n    using System.Collections.Generic;\r\n    using System.Configuration;\r\n    using System.IO;\r\n    using System.Linq;\r\n    using System.Threading;\r\n    using Microsoft.WindowsAzure.MediaServices.Client;\r\n    using Microsoft.WindowsAzure.MediaServices.Client.ContentKeyAuthorization;\r\n    using Microsoft.WindowsAzure.MediaServices.Client.DynamicEncryption;\r\n    using Microsoft.WindowsAzure.MediaServices.Client.Widevine;\r\n    using Newtonsoft.Json;\r\n\r\n    namespace DynamicEncryptionWithDRM\r\n    {\r\n        class Program\r\n        {\r\n        // Read values from the App.config file.\r\n        private static readonly string _AADTenantDomain =\r\n        ConfigurationManager.AppSettings[\"AADTenantDomain\"];\r\n        private static readonly string _RESTAPIEndpoint =\r\n        ConfigurationManager.AppSettings[\"MediaServiceRESTAPIEndpoint\"];\r\n\r\n        private static readonly Uri _sampleIssuer =\r\n            new Uri(ConfigurationManager.AppSettings[\"Issuer\"]);\r\n        private static readonly Uri _sampleAudience =\r\n            new Uri(ConfigurationManager.AppSettings[\"Audience\"]);\r\n\r\n        // Field for service context.\r\n        private static CloudMediaContext _context = null;\r\n\r\n        private static readonly string _mediaFiles =\r\n            Path.GetFullPath(@\"../..\\Media\");\r\n\r\n        private static readonly string _singleMP4File =\r\n            Path.Combine(_mediaFiles, @\"BigBuckBunny.mp4\");\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            var tokenCredentials = new AzureAdTokenCredentials(_AADTenantDomain, AzureEnvironments.AzureChinaCloudEnvironment);\r\n            var tokenProvider = new AzureAdTokenProvider(tokenCredentials);\r\n\r\n            _context = new CloudMediaContext(new Uri(_RESTAPIEndpoint), tokenProvider);\r\n\r\n            bool tokenRestriction = false;\r\n            string tokenTemplateString = null;\r\n\r\n            IAsset asset = UploadFileAndCreateAsset(_singleMP4File);\r\n            Console.WriteLine(\"Uploaded asset: {0}\", asset.Id);\r\n\r\n            IAsset encodedAsset = EncodeToAdaptiveBitrateMP4Set(asset);\r\n            Console.WriteLine(\"Encoded asset: {0}\", encodedAsset.Id);\r\n\r\n            IContentKey key = CreateCommonTypeContentKey(encodedAsset);\r\n            Console.WriteLine(\"Created key {0} for the asset {1} \", key.Id, encodedAsset.Id);\r\n            Console.WriteLine(\"PlayReady License Key delivery URL: {0}\", key.GetKeyDeliveryUrl(ContentKeyDeliveryType.PlayReadyLicense));\r\n            Console.WriteLine();\r\n\r\n            if (tokenRestriction)\r\n            tokenTemplateString = AddTokenRestrictedAuthorizationPolicy(key);\r\n            else\r\n            AddOpenAuthorizationPolicy(key);\r\n\r\n            Console.WriteLine(\"Added authorization policy: {0}\", key.AuthorizationPolicyId);\r\n            Console.WriteLine();\r\n\r\n            CreateAssetDeliveryPolicy(encodedAsset, key);\r\n            Console.WriteLine(\"Created asset delivery policy. \\n\");\r\n            Console.WriteLine();\r\n\r\n            if (tokenRestriction && !String.IsNullOrEmpty(tokenTemplateString))\r\n            {\r\n            // Deserializes a string containing an Xml representation of a TokenRestrictionTemplate\r\n            // back into a TokenRestrictionTemplate class instance.\r\n            TokenRestrictionTemplate tokenTemplate =\r\n                TokenRestrictionTemplateSerializer.Deserialize(tokenTemplateString);\r\n\r\n            // Generate a test token based on the the data in the given TokenRestrictionTemplate.\r\n            // Note, you need to pass the key id Guid because we specified\r\n            // TokenClaim.ContentKeyIdentifierClaim in during the creation of TokenRestrictionTemplate.\r\n            Guid rawkey = EncryptionUtils.GetKeyIdAsGuid(key.Id);\r\n            string testToken = TokenRestrictionTemplateSerializer.GenerateTestToken(tokenTemplate, null, rawkey,\r\n                                        DateTime.UtcNow.AddDays(365));\r\n            Console.WriteLine(\"The authorization token is:\\nBearer {0}\", testToken);\r\n            Console.WriteLine();\r\n            }\r\n\r\n            // You can use the http://amsplayer.azurewebsites.net/azuremediaplayer.html player to test streams.\r\n            // Note that DASH works on IE 11 (via PlayReady), Edge (via PlayReady).\r\n\r\n            string url = GetStreamingOriginLocator(encodedAsset);\r\n            Console.WriteLine(\"Encrypted DASH URL: {0}/manifest(format=mpd-time-csf)\", url);\r\n\r\n            Console.ReadLine();\r\n        }\r\n\r\n        static public IAsset UploadFileAndCreateAsset(string singleFilePath)\r\n        {\r\n            if (!File.Exists(singleFilePath))\r\n            {\r\n            Console.WriteLine(\"File does not exist.\");\r\n            return null;\r\n            }\r\n\r\n            var assetName = Path.GetFileNameWithoutExtension(singleFilePath);\r\n            IAsset inputAsset = _context.Assets.Create(assetName, AssetCreationOptions.None);\r\n\r\n            var assetFile = inputAsset.AssetFiles.Create(Path.GetFileName(singleFilePath));\r\n\r\n            Console.WriteLine(\"Created assetFile {0}\", assetFile.Name);\r\n\r\n            Console.WriteLine(\"Upload {0}\", assetFile.Name);\r\n\r\n            assetFile.Upload(singleFilePath);\r\n            Console.WriteLine(\"Done uploading {0}\", assetFile.Name);\r\n\r\n            return inputAsset;\r\n        }\r\n\r\n        static public IAsset EncodeToAdaptiveBitrateMP4Set(IAsset inputAsset)\r\n        {\r\n            var encodingPreset = \"Adaptive Streaming\";\r\n\r\n            IJob job = _context.Jobs.Create(String.Format(\"Encoding into Mp4 {0} to {1}\",\r\n                        inputAsset.Name,\r\n                        encodingPreset));\r\n\r\n            var mediaProcessors =\r\n            _context.MediaProcessors.Where(p => p.Name.Contains(\"Media Encoder Standard\")).ToList();\r\n\r\n            var latestMediaProcessor =\r\n            mediaProcessors.OrderBy(mp => new Version(mp.Version)).LastOrDefault();\r\n\r\n            ITask encodeTask = job.Tasks.AddNew(\"Encoding\", latestMediaProcessor, encodingPreset, TaskOptions.None);\r\n            encodeTask.InputAssets.Add(inputAsset);\r\n            encodeTask.OutputAssets.AddNew(String.Format(\"{0} as {1}\", inputAsset.Name, encodingPreset), AssetCreationOptions.StorageEncrypted);\r\n\r\n            job.StateChanged += new EventHandler<JobStateChangedEventArgs>(JobStateChanged);\r\n            job.Submit();\r\n            job.GetExecutionProgressTask(CancellationToken.None).Wait();\r\n\r\n            return job.OutputMediaAssets[0];\r\n        }\r\n\r\n        static public IContentKey CreateCommonTypeContentKey(IAsset asset)\r\n        {\r\n\r\n            Guid keyId = Guid.NewGuid();\r\n            byte[] contentKey = GetRandomBuffer(16);\r\n\r\n            IContentKey key = _context.ContentKeys.Create(\r\n                        keyId,\r\n                        contentKey,\r\n                        \"ContentKey\",\r\n                        ContentKeyType.CommonEncryption);\r\n\r\n            // Associate the key with the asset.\r\n            asset.ContentKeys.Add(key);\r\n\r\n            return key;\r\n        }\r\n\r\n        static public void AddOpenAuthorizationPolicy(IContentKey contentKey)\r\n        {\r\n\r\n            // Create ContentKeyAuthorizationPolicy with Open restrictions\r\n            // and create authorization policy          \r\n\r\n            List<ContentKeyAuthorizationPolicyRestriction> restrictions = new List<ContentKeyAuthorizationPolicyRestriction>\r\n                {\r\n                new ContentKeyAuthorizationPolicyRestriction\r\n                {\r\n                    Name = \"Open\",\r\n                    KeyRestrictionType = (int)ContentKeyRestrictionType.Open,\r\n                    Requirements = null\r\n                }\r\n                };\r\n\r\n            // Configure PlayReady license templates.\r\n            string PlayReadyLicenseTemplate = ConfigurePlayReadyLicenseTemplate();\r\n\r\n\r\n            IContentKeyAuthorizationPolicyOption PlayReadyPolicy =\r\n            _context.ContentKeyAuthorizationPolicyOptions.Create(\"\",\r\n                ContentKeyDeliveryType.PlayReadyLicense,\r\n                restrictions, PlayReadyLicenseTemplate);\r\n\r\n            IContentKeyAuthorizationPolicy contentKeyAuthorizationPolicy = _context.\r\n                ContentKeyAuthorizationPolicies.\r\n                CreateAsync(\"Deliver Common Content Key with no restrictions\").\r\n                Result;\r\n\r\n\r\n            contentKeyAuthorizationPolicy.Options.Add(PlayReadyPolicy);\r\n            // Associate the content key authorization policy with the content key.\r\n            contentKey.AuthorizationPolicyId = contentKeyAuthorizationPolicy.Id;\r\n            contentKey = contentKey.UpdateAsync().Result;\r\n        }\r\n\r\n        public static string AddTokenRestrictedAuthorizationPolicy(IContentKey contentKey)\r\n        {\r\n            string tokenTemplateString = GenerateTokenRequirements();\r\n\r\n            List<ContentKeyAuthorizationPolicyRestriction> restrictions = new List<ContentKeyAuthorizationPolicyRestriction>\r\n                {\r\n                new ContentKeyAuthorizationPolicyRestriction\r\n                {\r\n                    Name = \"Token Authorization Policy\",\r\n                    KeyRestrictionType = (int)ContentKeyRestrictionType.TokenRestricted,\r\n                    Requirements = tokenTemplateString,\r\n                }\r\n                };\r\n\r\n            // Configure PlayReady license templates.\r\n            string PlayReadyLicenseTemplate = ConfigurePlayReadyLicenseTemplate();\r\n            IContentKeyAuthorizationPolicyOption PlayReadyPolicy =\r\n            _context.ContentKeyAuthorizationPolicyOptions.Create(\"Token option\",\r\n                ContentKeyDeliveryType.PlayReadyLicense,\r\n                restrictions, PlayReadyLicenseTemplate);\r\n\r\n            IContentKeyAuthorizationPolicy contentKeyAuthorizationPolicy = _context.\r\n                ContentKeyAuthorizationPolicies.\r\n                CreateAsync(\"Deliver Common Content Key with token restrictions\").\r\n                Result;\r\n\r\n            contentKeyAuthorizationPolicy.Options.Add(PlayReadyPolicy);\r\n\r\n            // Associate the content key authorization policy with the content key\r\n            contentKey.AuthorizationPolicyId = contentKeyAuthorizationPolicy.Id;\r\n            contentKey = contentKey.UpdateAsync().Result;\r\n\r\n            return tokenTemplateString;\r\n        }\r\n\r\n        static private string GenerateTokenRequirements()\r\n        {\r\n            TokenRestrictionTemplate template = new TokenRestrictionTemplate(TokenType.SWT);\r\n\r\n            template.PrimaryVerificationKey = new SymmetricVerificationKey();\r\n            template.AlternateVerificationKeys.Add(new SymmetricVerificationKey());\r\n            template.Audience = _sampleAudience.ToString();\r\n            template.Issuer = _sampleIssuer.ToString();\r\n            template.RequiredClaims.Add(TokenClaim.ContentKeyIdentifierClaim);\r\n\r\n            return TokenRestrictionTemplateSerializer.Serialize(template);\r\n        }\r\n\r\n        static private string ConfigurePlayReadyLicenseTemplate()\r\n        {\r\n            // The following code configures PlayReady License Template using .NET classes\r\n            // and returns the XML string.\r\n\r\n            //The PlayReadyLicenseResponseTemplate class represents the template for the response sent back to the end user.\r\n            //It contains a field for a custom data string between the license server and the application\r\n            //(may be useful for custom app logic) as well as a list of one or more license templates.\r\n            PlayReadyLicenseResponseTemplate responseTemplate = new PlayReadyLicenseResponseTemplate();\r\n\r\n            // The PlayReadyLicenseTemplate class represents a license template for creating PlayReady licenses\r\n            // to be returned to the end users.\r\n            //It contains the data on the content key in the license and any rights or restrictions to be\r\n            //enforced by the PlayReady DRM runtime when using the content key.\r\n            PlayReadyLicenseTemplate licenseTemplate = new PlayReadyLicenseTemplate();\r\n            //Configure whether the license is persistent (saved in persistent storage on the client)\r\n            //or non-persistent (only held in memory while the player is using the license).  \r\n            licenseTemplate.LicenseType = PlayReadyLicenseType.Nonpersistent;\r\n\r\n            // AllowTestDevices controls whether test devices can use the license or not.  \r\n            // If true, the MinimumSecurityLevel property of the license\r\n            // is set to 150.  If false (the default), the MinimumSecurityLevel property of the license is set to 2000.\r\n            licenseTemplate.AllowTestDevices = true;\r\n\r\n            // You can also configure the Play Right in the PlayReady license by using the PlayReadyPlayRight class.\r\n            // It grants the user the ability to playback the content subject to the zero or more restrictions\r\n            // configured in the license and on the PlayRight itself (for playback specific policy).\r\n            // Much of the policy on the PlayRight has to do with output restrictions\r\n            // which control the types of outputs that the content can be played over and\r\n            // any restrictions that must be put in place when using a given output.\r\n            // For example, if the DigitalVideoOnlyContentRestriction is enabled,\r\n            //then the DRM runtime will only allow the video to be displayed over digital outputs\r\n            //(analog video outputs won’t be allowed to pass the content).\r\n\r\n            //IMPORTANT: These types of restrictions can be very powerful but can also affect the consumer experience.\r\n            // If the output protections are configured too restrictive,\r\n            // the content might be unplayable on some clients. For more information, see the PlayReady Compliance Rules document.\r\n\r\n            // For example:\r\n            //licenseTemplate.PlayRight.AgcAndColorStripeRestriction = new AgcAndColorStripeRestriction(1);\r\n\r\n            responseTemplate.LicenseTemplates.Add(licenseTemplate);\r\n\r\n            return MediaServicesLicenseTemplateSerializer.Serialize(responseTemplate);\r\n        }\r\n        \r\n        static public void CreateAssetDeliveryPolicy(IAsset asset, IContentKey key)\r\n        {\r\n            // Get the PlayReady license service URL.\r\n            Uri acquisitionUrl = key.GetKeyDeliveryUrl(ContentKeyDeliveryType.PlayReadyLicense);\r\n\r\n            Dictionary<AssetDeliveryPolicyConfigurationKey, string> assetDeliveryPolicyConfiguration =\r\n            new Dictionary<AssetDeliveryPolicyConfigurationKey, string>\r\n            {\r\n                    {AssetDeliveryPolicyConfigurationKey.PlayReadyLicenseAcquisitionUrl, acquisitionUrl.ToString()},\r\n\r\n            };\r\n\r\n            // In this case we only specify Dash streaming protocol in the delivery policy,\r\n            // All other protocols will be blocked from streaming.\r\n            var assetDeliveryPolicy = _context.AssetDeliveryPolicies.Create(\r\n                \"AssetDeliveryPolicy\",\r\n            AssetDeliveryPolicyType.DynamicCommonEncryption,\r\n            AssetDeliveryProtocol.Dash,\r\n            assetDeliveryPolicyConfiguration);\r\n\r\n\r\n            // Add AssetDelivery Policy to the asset\r\n            asset.DeliveryPolicies.Add(assetDeliveryPolicy);\r\n\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets the streaming origin locator.\r\n        /// </summary>\r\n        /// <param name=\"assets\"></param>\r\n        /// <returns></returns>\r\n        static public string GetStreamingOriginLocator(IAsset asset)\r\n        {\r\n\r\n            // Get a reference to the streaming manifest file from the  \r\n            // collection of files in the asset.\r\n\r\n            var assetFile = asset.AssetFiles.Where(f => f.Name.ToLower().\r\n                         EndsWith(\".ism\")).\r\n                         FirstOrDefault();\r\n\r\n            // Create a 30-day readonly access policy.\r\n            IAccessPolicy policy = _context.AccessPolicies.Create(\"Streaming policy\",\r\n            TimeSpan.FromDays(30),\r\n            AccessPermissions.Read);\r\n\r\n            // Create a locator to the streaming content on an origin.\r\n            ILocator originLocator = _context.Locators.CreateLocator(LocatorType.OnDemandOrigin, asset,\r\n            policy,\r\n            DateTime.UtcNow.AddMinutes(-5));\r\n\r\n            // Create a URL to the manifest file.\r\n            return originLocator.Path + assetFile.Name;\r\n        }\r\n\r\n        static private void JobStateChanged(object sender, JobStateChangedEventArgs e)\r\n        {\r\n            Console.WriteLine(string.Format(\"{0}\\n  State: {1}\\n  Time: {2}\\n\\n\",\r\n            ((IJob)sender).Name,\r\n            e.CurrentState,\r\n            DateTime.UtcNow.ToString(@\"yyyy_M_d__hh_mm_ss\")));\r\n        }\r\n\r\n        static private byte[] GetRandomBuffer(int length)\r\n        {\r\n            var returnValue = new byte[length];\r\n\r\n            using (var rng =\r\n            new System.Security.Cryptography.RNGCryptoServiceProvider())\r\n            {\r\n            rng.GetBytes(returnValue);\r\n            }\r\n\r\n            return returnValue;\r\n        }\r\n        }\r\n    }\r\n\r\n<!--Update_Description: update code to use AAD token instead of ACS-->"}