{"Title":"轮询长时间运行的操作","Description":"本主题展示了如何轮询长时间运行的操作。","Content":"# <a name=\"delivering-live-streaming-with-azure-media-services\"></a>使用 Azure 媒体服务传送实时流\r\n\r\n## <a name=\"overview\"></a>概述\r\n\r\nMicrosoft Azure 媒体服务提供了相应的 API 来向媒体服务发送启动操作请求（例如创建、启动、停止或删除频道）。 这些操作是长时间运行的。\r\n\r\n媒体服务 .NET SDK 提供了用来发送请求并等待操作完成的 API（在内部，这些 API 以特定的时间间隔轮询操作进度）。 例如，当调用 channel.Start() 时，该方法将在频道启动后返回。 还可以使用异步版本：await channel.StartAsync()（有关基于任务的异步模式的信息，请参阅 [TAP](https://msdn.microsoft.com/library/hh873175\\(v=vs.110\\).aspx)。 发送操作请求并且在操作完成之前一直轮询操作状态的 API 称作“轮询方法”。 建议为富客户端应用程序和/或有状态服务使用这些方法（特别是异步版本）。\r\n\r\n某些情况下，应用程序不能等待长时运行的 http 请求并且希望手动轮询操作进度。 一个典型的示例是与无状态 Web 服务进行交互的浏览器：当浏览器请求创建频道时，Web 服务会启动一个长时间运行的操作并将操作 ID 返回到浏览器。 然后，浏览器可以根据该 ID 询问 Web 服务来获取操作状态。 媒体服务 .NET SDK 提供了非常适用于此情况的 API。 这些 API 称为“非轮询方法”。\r\n“非轮询方法”具有以下命名模式：Send“OperationName”Operation（例如，SendCreateOperation）。 Send“OperationName”Operation 方法返回 **IOperation** 对象；返回的对象包含可以用来跟踪操作的信息。 Send“OperationName”OperationAsync 方法将返回“Task”**<IOperation>**。\r\n\r\n当前，以下类支持非轮询方法：Channel、StreamingEndpoint 和 Program。\r\n\r\n若要轮询操作状态，请对“OperationBaseCollection”类使用“GetOperation”方法。 使用以下时间间隔来检查操作状态：对于 Channel 和 StreamingEndpoint 操作，使用 30 秒；对于 Program 操作，使用 10 秒。\r\n\r\n## <a name=\"create-and-configure-a-visual-studio-project\"></a>创建和配置 Visual Studio 项目\r\n\r\n设置开发环境，并在 app.config 文件中填充连接信息，如[使用 .NET 进行媒体服务开发](media-services-dotnet-how-to-use.md)中所述。\r\n\r\n## <a name=\"example\"></a>示例\r\n\r\n以下示例定义了一个名为 **ChannelOperations**的类。 可以将该类定义用作 Web 服务类定义的起点。 为简单起见，以下示例使用了方法的非异步版本。\r\n\r\n示例还展示了客户端可以如何使用该类。\r\n\r\n### <a name=\"channeloperations-class-definition\"></a>ChannelOperations 类定义\r\n\r\n    using Microsoft.WindowsAzure.MediaServices.Client;\r\n    using System;\r\n    using System.Collections.Generic;\r\n    using System.Configuration;\r\n    using System.Net;\r\n\r\n    /// <summary> \r\n    /// The ChannelOperations class only implements \r\n    /// the Channel’s creation operation. \r\n    /// </summary> \r\n    public class ChannelOperations\r\n    {\r\n        // Read values from the App.config file.\r\n        private static readonly string _AADTenantDomain =\r\n            ConfigurationManager.AppSettings[\"AADTenantDomain\"];\r\n        private static readonly string _RESTAPIEndpoint =\r\n            ConfigurationManager.AppSettings[\"MediaServiceRESTAPIEndpoint\"];\r\n\r\n        // Field for service context.\r\n        private static CloudMediaContext _context = null;\r\n\r\n        public ChannelOperations()\r\n        {\r\n            var tokenCredentials = new AzureAdTokenCredentials(_AADTenantDomain, AzureEnvironments.AzureChinaCloudEnvironment);\r\n            var tokenProvider = new AzureAdTokenProvider(tokenCredentials);\r\n\r\n            _context = new CloudMediaContext(new Uri(_RESTAPIEndpoint), tokenProvider);\r\n        }\r\n\r\n        /// <summary>  \r\n        /// Initiates the creation of a new channel.  \r\n        /// </summary>  \r\n        /// <param name=\"channelName\">Name to be given to the new channel</param>  \r\n        /// <returns>  \r\n        /// Operation Id for the long running operation being executed by Media Services. \r\n        /// Use this operation Id to poll for the channel creation status. \r\n        /// </returns> \r\n        public string StartChannelCreation(string channelName)\r\n        {\r\n            var operation = _context.Channels.SendCreateOperation(\r\n                new ChannelCreationOptions\r\n                {\r\n                    Name = channelName,\r\n                    Input = CreateChannelInput(),\r\n                    Preview = CreateChannelPreview(),\r\n                    Output = CreateChannelOutput()\r\n                });\r\n\r\n            return operation.Id;\r\n        }\r\n\r\n        /// <summary> \r\n        /// Checks if the operation has been completed. \r\n        /// If the operation succeeded, the created channel Id is returned in the out parameter.\r\n        /// </summary> \r\n        /// <param name=\"operationId\">The operation Id.</param> \r\n        /// <param name=\"channel\">\r\n        /// If the operation succeeded, \r\n        /// the created channel Id is returned in the out parameter.</param>\r\n        /// <returns>Returns false if the operation is still in progress; otherwise, true.</returns> \r\n        public bool IsCompleted(string operationId, out string channelId)\r\n        {\r\n            IOperation operation = _context.Operations.GetOperation(operationId);\r\n            bool completed = false;\r\n\r\n            channelId = null;\r\n\r\n            switch (operation.State)\r\n            {\r\n                case OperationState.Failed:\r\n                    // Handle the failure. \r\n                    // For example, throw an exception. \r\n                    // Use the following information in the exception: operationId, operation.ErrorMessage.\r\n                    break;\r\n                case OperationState.Succeeded:\r\n                    completed = true;\r\n                    channelId = operation.TargetEntityId;\r\n                    break;\r\n                case OperationState.InProgress:\r\n                    completed = false;\r\n                    break;\r\n            }\r\n            return completed;\r\n        }\r\n\r\n        private static ChannelInput CreateChannelInput()\r\n        {\r\n            return new ChannelInput\r\n            {\r\n                StreamingProtocol = StreamingProtocol.RTMP,\r\n                AccessControl = new ChannelAccessControl\r\n                {\r\n                    IPAllowList = new List<IPRange>\r\n                        {\r\n                            new IPRange\r\n                            {\r\n                                Name = \"TestChannelInput001\",\r\n                                Address = IPAddress.Parse(\"0.0.0.0\"),\r\n                                SubnetPrefixLength = 0\r\n                            }\r\n                        }\r\n                }\r\n            };\r\n        }\r\n\r\n        private static ChannelPreview CreateChannelPreview()\r\n        {\r\n            return new ChannelPreview\r\n            {\r\n                AccessControl = new ChannelAccessControl\r\n                {\r\n                    IPAllowList = new List<IPRange>\r\n                        {\r\n                            new IPRange\r\n                            {\r\n                                Name = \"TestChannelPreview001\",\r\n                                Address = IPAddress.Parse(\"0.0.0.0\"),\r\n                                SubnetPrefixLength = 0\r\n                            }\r\n                        }\r\n                }\r\n            };\r\n        }\r\n\r\n        private static ChannelOutput CreateChannelOutput()\r\n        {\r\n            return new ChannelOutput\r\n            {\r\n                Hls = new ChannelOutputHls { FragmentsPerSegment = 1 }\r\n            };\r\n        }\r\n    }\r\n\r\n### <a name=\"the-client-code\"></a>客户端代码\r\n    ChannelOperations channelOperations = new ChannelOperations();\r\n    string opId = channelOperations.StartChannelCreation(\"MyChannel001\");\r\n\r\n    string channelId = null;\r\n    bool isCompleted = false;\r\n\r\n    while (isCompleted == false)\r\n    {\r\n        System.Threading.Thread.Sleep(TimeSpan.FromSeconds(30));\r\n        isCompleted = channelOperations.IsCompleted(opId, out channelId);\r\n    }\r\n\r\n    // If we got here, we should have the newly created channel id.\r\n    Console.WriteLine(channelId);\r\n\r\n\r\n\r\n<!--Update_Description: update code to use AAD token instead of ACS-->"}