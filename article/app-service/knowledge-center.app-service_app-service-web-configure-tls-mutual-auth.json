{"Title":"如何为 Web 应用配置 TLS 相互身份验证","Description":"了解如何将 Web 应用配置为使用 TLS 客户端证书身份验证。","Content":"# <a name=\"how-to-configure-tls-mutual-authentication-for-web-app\"></a>如何为 Web 应用配置 TLS 相互身份验证\r\n\r\n[!INCLUDE [azure-sdk-developer-differences](../../includes/azure-sdk-developer-differences.md)]\r\n\r\n## <a name=\"overview\"></a>概述\r\n通过为 Azure Web 应用启用不同类型的身份验证可以限制对网站的访问。 执行此操作的方法之一是在通过 TLS/SSL 发送请求时使用客户端证书进行身份验证。 此机制称为 TLS 相互身份验证或客户端证书身份验证，本文将详细说明如何将 Web 应用设置为使用客户端证书身份验证。\r\n\r\n> \r\n> **注意：** 如果你通过 HTTP 而不是 HTTPS 访问你的站点，你不会收到任何客户端证书。 因此，如果应用程序需要客户端证书，则你不应允许通过 HTTP 对应用程序发出请求。\r\n> \r\n> \r\n\r\n[!INCLUDE [app-service-web-to-api-and-mobile](../../includes/app-service-web-to-api-and-mobile.md)]\r\n\r\n## <a name=\"configure-web-app-for-client-certificate-authentication\"></a>将 Web 应用配置为使用客户端证书身份验证\r\n要将 Web 应用设置为要求使用客户端证书，你需要为 Web 应用添加 clientCertEnabled 站点设置并将该设置指定为 true。 目前无法通过门户中的管理体验进行此设置，需要使用 REST API 来实现此目的。\r\n\r\n可以使用 [ARMClient 工具](https://github.com/projectkudu/ARMClient) 轻松创建 REST API 调用。 使用该工具登录之后，需要发出以下命令：\r\n\r\n>[!NOTE]\r\n> 使用 `ARMClient.exe login [environment name]` 登录时，`[environment name]` 应该是 `MOONCAKE`。 换而言之，用于登录 Azure 中国区的命令为 `ARMClient.exe login MOONCAKE`。\r\n>\r\n>\r\n\r\n    ARMClient PUT subscriptions/{Subscription Id}/resourcegroups/{Resource Group Name}/providers/Microsoft.Web/sites/{Website Name}?api-version=2015-04-01 @enableclientcert.json -verbose\r\n\r\n将 {} 中的所有内容替换为 Web 应用的信息，并创建包含以下 JSON 内容的 enableclientcert.json 文件：\r\n\r\n    {\r\n        \"location\": \"My Web App Location\",\r\n        \"properties\": {\r\n            \"clientCertEnabled\": true\r\n        }\r\n    }\r\n\r\n确保将“location”的值更改为 Web 应用所在的位置，例如中国北部。\r\n\r\n> 注意：如果在 Powershell 中运行 ARMClient，必须使用重音符 ` 为 JSON 文件转义 @ 符号。\r\n> \r\n> \r\n\r\n## <a name=\"accessing-the-client-certificate-from-your-web-app\"></a>从 Web 应用访问客户端证书\r\n如果要使用 ASP.NET 并将应用配置为使用客户端证书身份验证，可通过 **HttpRequest.ClientCertificate** 属性使用证书。 对于其他应用程序堆栈，可以通过“X-ARR-ClientCert”请求标头中的 base64 编码值在应用中使用客户端证书。 应用程序可以基于此值创建证书，并将它用于应用程序中的身份验证和授权。\r\n\r\n## <a name=\"special-considerations-for-certificate-validation\"></a>有关证书验证的特殊注意事项\r\nAzure Web 应用平台不会针对发送到应用程序的客户端证书进行任何验证。 验证此证书是 Web 应用的责任。 下面是为了进行身份验证而验证证书属性的示例 ASP.NET 代码。\r\n\r\n    using System;\r\n    using System.Collections.Specialized;\r\n    using System.Security.Cryptography.X509Certificates;\r\n    using System.Web;\r\n\r\n    namespace ClientCertificateUsageSample\r\n    {\r\n        public partial class cert : System.Web.UI.Page\r\n        {\r\n            public string certHeader = \"\";\r\n            public string errorString = \"\";\r\n            private X509Certificate2 certificate = null;\r\n            public string certThumbprint = \"\";\r\n            public string certSubject = \"\";\r\n            public string certIssuer = \"\";\r\n            public string certSignatureAlg = \"\";\r\n            public string certIssueDate = \"\";\r\n            public string certExpiryDate = \"\";\r\n            public bool isValidCert = false;\r\n\r\n            //\r\n            // Read the certificate from the header into an X509Certificate2 object\r\n            // Display properties of the certificate on the page\r\n            //\r\n            protected void Page_Load(object sender, EventArgs e)\r\n            {\r\n                NameValueCollection headers = base.Request.Headers;\r\n                certHeader = headers[\"X-ARR-ClientCert\"];\r\n                if (!String.IsNullOrEmpty(certHeader))\r\n                {\r\n                    try\r\n                    {\r\n                        byte[] clientCertBytes = Convert.FromBase64String(certHeader);\r\n                        certificate = new X509Certificate2(clientCertBytes);\r\n                        certSubject = certificate.Subject;\r\n                        certIssuer = certificate.Issuer;\r\n                        certThumbprint = certificate.Thumbprint;\r\n                        certSignatureAlg = certificate.SignatureAlgorithm.FriendlyName;\r\n                        certIssueDate = certificate.NotBefore.ToShortDateString() + \" \" + certificate.NotBefore.ToShortTimeString();\r\n                        certExpiryDate = certificate.NotAfter.ToShortDateString() + \" \" + certificate.NotAfter.ToShortTimeString();\r\n                    }\r\n                    catch (Exception ex)\r\n                    {\r\n                        errorString = ex.ToString();\r\n                    }\r\n                    finally \r\n                    {\r\n                        isValidCert = IsValidClientCertificate();\r\n                        if (!isValidCert) Response.StatusCode = 403;\r\n                        else Response.StatusCode = 200;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    certHeader = \"\";\r\n                }\r\n            }\r\n\r\n            //\r\n            // This is a SAMPLE verification routine. Depending on your application logic and security requirements, \r\n            // you should modify this method\r\n            //\r\n            private bool IsValidClientCertificate()\r\n            {\r\n                // In this example we will only accept the certificate as a valid certificate if all the conditions below are met:\r\n                // 1. The certificate is not expired and is active for the current time on server.\r\n                // 2. The subject name of the certificate has the common name nildevecc\r\n                // 3. The issuer name of the certificate has the common name nildevecc and organization name Microsoft Corp\r\n                // 4. The thumbprint of the certificate is 30757A2E831977D8BD9C8496E4C99AB26CB9622B\r\n                //\r\n                // This example does NOT test that this certificate is chained to a Trusted Root Authority (or revoked) on the server \r\n                // and it allows for self signed certificates\r\n                //\r\n\r\n                if (certificate == null || !String.IsNullOrEmpty(errorString)) return false;\r\n\r\n                // 1. Check time validity of certificate\r\n                if (DateTime.Compare(DateTime.Now, certificate.NotBefore) < 0 || DateTime.Compare(DateTime.Now, certificate.NotAfter) > 0) return false;\r\n\r\n                // 2. Check subject name of certificate\r\n                bool foundSubject = false;\r\n                string[] certSubjectData = certificate.Subject.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\r\n                foreach (string s in certSubjectData)\r\n                {\r\n                    if (String.Compare(s.Trim(), \"CN=nildevecc\") == 0)\r\n                    {\r\n                        foundSubject = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!foundSubject) return false;\r\n\r\n                // 3. Check issuer name of certificate\r\n                bool foundIssuerCN = false, foundIssuerO = false;\r\n                string[] certIssuerData = certificate.Issuer.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\r\n                foreach (string s in certIssuerData)\r\n                {\r\n                    if (String.Compare(s.Trim(), \"CN=nildevecc\") == 0)\r\n                    {\r\n                        foundIssuerCN = true;\r\n                        if (foundIssuerO) break;\r\n                    }\r\n\r\n                    if (String.Compare(s.Trim(), \"O=Microsoft Corp\") == 0)\r\n                    {\r\n                        foundIssuerO = true;\r\n                        if (foundIssuerCN) break;\r\n                    }\r\n                }\r\n\r\n                if (!foundIssuerCN || !foundIssuerO) return false;\r\n\r\n                // 4. Check thumprint of certificate\r\n                if (String.Compare(certificate.Thumbprint.Trim().ToUpper(), \"30757A2E831977D8BD9C8496E4C99AB26CB9622B\") != 0) return false;\r\n\r\n                // If you also want to test if the certificate chains to a Trusted Root Authority you can uncomment the code below\r\n                //\r\n                //X509Chain certChain = new X509Chain();\r\n                //certChain.Build(certificate);\r\n                //bool isValidCertChain = true;\r\n                //foreach (X509ChainElement chElement in certChain.ChainElements)\r\n                //{\r\n                //    if (!chElement.Certificate.Verify())\r\n                //    {\r\n                //        isValidCertChain = false;\r\n                //        break;\r\n                //    }\r\n                //}\r\n                //if (!isValidCertChain) return false;\r\n\r\n                return true;\r\n            }\r\n        }\r\n    }"}