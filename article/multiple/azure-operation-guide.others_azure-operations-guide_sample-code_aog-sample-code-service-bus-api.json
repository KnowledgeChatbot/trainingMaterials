{"Title":"Azure 服务总线 API 调用示例","Description":"Azure 服务总线 API 调用示例","Content":"\r\n# Azure 服务总线 API 调用示例\r\n\r\n编程调用 Azure 服务总线的相关服务，微软有提供基于 .NET 的 dll（[Nuget](https://www.nuget.org/packages/WindowsAzure.ServiceBus/)），也有基于 Java 的 Jar 包（[Mvnrepository](https://mvnrepository.com/artifact/com.microsoft.azure/azure-servicebus)），另外也可以直接调用服务总线 API。这片文章就提供 Azure 服务总线 API 调用示例，以供参考。主要包含以下内容：\r\n\r\n1. 如何从策略生成共享访问令牌。\r\n2. 调用 API 发送消息到服务总线队列。\r\n3. 调用 API 从服务总线队列接收消息，包括 ReceiveAndDelete 模式和 PeekLock 模式。\r\n\r\n## 如何从策略生成共享访问令牌\r\n\r\n当调用服务总线 API 时，必须要提供共享访问令牌（SAS Token）作为 Authorization 头部，以作认证。那么如何生成这个 SAS Token 呢？\r\n\r\nSAS Token 的具体构成是这样的：`SharedAccessSignature sr={资源地址}&sig={签名}&se={过期时间}&skn={策略名称}`。\r\n\r\n- 资源地址：要访问资源的 URL 地址，比如 demo 命名空间下的 q1 队列 `https://demo.servicebus.chinacloudapi.cn/q1`\r\n\r\n- 签名：对由资源地址，换行符和过期时间组成的字符串用策略秘钥通过 SHA-256 哈希后生成的 Base64String。\r\n\r\n- 过期时间：自纪元算起，以秒为单位。\r\n\r\n- 策略名称：相应策略的名称。\r\n\r\n<br>\r\n\r\n```\r\nstatic string createToken(string resourceUri, string keyName, string key)\r\n{\r\n    TimeSpan sinceEpoch = DateTime.UtcNow - new DateTime(1970, 1, 1);\r\n    var week = 60 * 60 * 24 * 7;\r\n    var expiry = Convert.ToString((int)sinceEpoch.TotalSeconds + week);\r\n    string stringToSign = HttpUtility.UrlEncode(resourceUri) + \"\\n\" + expiry;\r\n    HMACSHA256 hmac = new HMACSHA256(Encoding.UTF8.GetBytes(key));\r\n    var signature = Convert.ToBase64String(hmac.ComputeHash(Encoding.UTF8.GetBytes(stringToSign)));\r\n    var sasToken = String.Format(CultureInfo.InvariantCulture, \r\n                \"SharedAccessSignature sr={0}&sig={1}&se={2}&skn={3}\", \r\n                HttpUtility.UrlEncode(resourceUri), \r\n                HttpUtility.UrlEncode(signature), \r\n                expiry, \r\n                keyName);\r\n    return sasToken;\r\n}\r\n```\r\n\r\n## 调用 API 发送消息到服务总线队列\r\n\r\n发送消息的 API 具体描述可参照官方文档：[Send Message](https://docs.microsoft.com/en-us/rest/api/servicebus/send-message-to-queue)。\r\n\r\n最关键的就是将 HTTP 请求的 Authorization 头部的值设置为根据拥有发送权限策略生成的 SAS Token。\r\n\r\n```\r\nstatic async Task SendMessageAsync(ServiceBusHttpMessage message, string token)\r\n{\r\n    var address = $\"https://{serviceBusNamespace}.servicebus.chinacloudapi.cn/{queueName}/messages\";\r\n\r\n    HttpContent postContent = new ByteArrayContent(message.Body);\r\n\r\n    // Serialize BrokerProperties. \r\n    var brokerProps = JsonConvert.SerializeObject(message.SystemProperties,\r\n        Formatting.None,\r\n        new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore, \r\n            DefaultValueHandling = DefaultValueHandling.Ignore });\r\n\r\n    postContent.Headers.Add(\"BrokerProperties\", brokerProps);\r\n\r\n    // Add custom properties. \r\n    foreach (string key in message.CustomProperties)\r\n    {\r\n        postContent.Headers.Add(key, message.CustomProperties.GetValues(key));\r\n    }\r\n\r\n    var httpClient = new HttpClient();\r\n    httpClient.DefaultRequestHeaders.Add(\"Authorization\", token);\r\n    httpClient.DefaultRequestHeaders.Add(\"ContentType\", \"application/atom+xml;type=entry;charset=utf-8\");\r\n\r\n    // Send message. \r\n    HttpResponseMessage response = null;\r\n    try\r\n    {\r\n        response = await httpClient.PostAsync($\"{address}?timeout=60\", postContent);\r\n        response.EnsureSuccessStatusCode();\r\n        Console.WriteLine(\"SendMessage successfully!\");\r\n    }\r\n    catch (HttpRequestException ex)\r\n    {\r\n        Console.WriteLine($\"SendMessage failed: {ex.Message}\");\r\n    }\r\n    response.Dispose();\r\n}\r\n```\r\n\r\n## 调用 API 从服务总线队列接收消息\r\n\r\nReceiveAndDelete 模式 API：[Receive and Delete Message](https://docs.microsoft.com/en-us/rest/api/servicebus/receive-and-delete-message-destructive-read) 。\r\n\r\nPeekLock 模式 API：[Peek-Lock Message](https://docs.microsoft.com/en-us/rest/api/servicebus/peek-lock-message-non-destructive-read) 。\r\n\r\n两者的区别在于，ReceiveAndDelete 模式消息被接收后就自动从队列中删除了，而 PeekLock 模式只是把消息锁住，然后由客户端来删除。所以两种模式的 API URI 是一致的，只是 HTTP 方法不一样，前者是 DELETE，后者是 POST。\r\n\r\n```\r\nstatic async Task<ServiceBusHttpMessage> ReceiveMessageAsync(string token, bool deleteMessage = true)\r\n{\r\n    var address = $\"https://{serviceBusNamespace}.servicebus.chinacloudapi.cn/{queueName}/messages/head\";\r\n\r\n    var httpClient = new HttpClient();\r\n    httpClient.DefaultRequestHeaders.Add(\"Authorization\", token);\r\n\r\n    HttpResponseMessage response = null;\r\n\r\n    try\r\n    {\r\n        if (deleteMessage)\r\n        {\r\n            // receive and delete\r\n            response = await httpClient.DeleteAsync($\"{address}?timeout=60\");\r\n        }\r\n        else\r\n        {\r\n            // peek lock\r\n            response = await httpClient.PostAsync($\"{address}?timeout=60\", new ByteArrayContent(new Byte[0]));\r\n        }\r\n\r\n        response.EnsureSuccessStatusCode();\r\n        Console.WriteLine($\"ReceiveMessage successfully!\");\r\n    }\r\n    catch (HttpRequestException ex)\r\n    {\r\n        Console.WriteLine($\"ReceiveMessage failed: {ex.Message}\");\r\n        return null;\r\n    }\r\n\r\n    var message = await ResolveMessageFromResponse(response);\r\n    response.Dispose();\r\n    return message;\r\n}\r\n```\r\n\r\n完整代码：[SBRestApiDemo](https://github.com/wacn/AOG-CodeSample/tree/master/ServiceBus/CSharp/SBRestApiDemo/)。\r\n\r\n## 更多资源\r\n\r\n- [服务总线REST API](https://docs.microsoft.com/en-us/rest/api/servicebus/service-bus-runtime-rest/)"}