{"Title":"Azure 服务总线性能基准测试示例代码","Description":"Azure 服务总线性能基准测试示例代码","Content":"\r\n# Azure 服务总线性能基准测试示例代码\r\n\r\n本文提供对 Azure 服务总线进行基准测试的示例代码。主要通过设置 Prefetch 和 MaxConcurrentCalls 来加快消息的获取和处理。更多性能优化建议参阅: [使用服务总线消息传递改进性能的最佳实践](/documentation/articles/service-bus-performance-improvements/)。\r\n\r\n## 发送端\r\n\r\n生成消息，并分批，然后按批次异步发送。\r\n\r\n    // Generate message batches\r\n    var batchMsgDic = new Dictionary<int, List<BrokeredMessage>>();\r\n    var batchMsgs = new List<BrokeredMessage>(batchSize);\r\n    var batchCount = 0;\r\n    for (int i = 1; i <= messagesCount; i++)\r\n    {\r\n        // Create message, passing a string message for the body.\r\n        var message = new BrokeredMessage($\"Test message {i}\");\r\n\r\n        // Set additional custom app-specific property.\r\n        message.Properties[\"MessageId\"] = Guid.NewGuid();\r\n        message.Properties[\"CreateTime\"] = DateTime.UtcNow.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture);\r\n        Console.WriteLine($\"{DateTime.UtcNow.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture)} --- Create message {i}\");\r\n\r\n        batchMsgs.Add(message);\r\n        if (i % batchSize == 0)\r\n        {\r\n                batchCount++;\r\n                batchMsgDic.Add(batchCount, batchMsgs);\r\n                batchMsgs = new List<BrokeredMessage>(batchSize);\r\n        }\r\n    }\r\n\r\n    // Send message batches asynchronoursly without waiting\r\n    var sendTasks = new List<Task>(batchCount);\r\n    foreach (var batch in batchMsgDic)\r\n    {\r\n        sendTasks.Add(queueClient.SendBatchAsync(batch.Value));\r\n        Console.WriteLine($\"{DateTime.UtcNow.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture)} --- Sent batch {batch.Key}\");\r\n    }\r\n    Task.WaitAll(sendTasks.ToArray());\r\n    Console.WriteLine(\"All messages are sent!\");\r\n\r\n## 接收端\r\n\r\n设定 Prefetch 使得从服务总线队列中获取消息时，一次性可以获取设定条数的消息，我们这里设定 1000 就相当于一次性获取所有消息。\r\n\r\n设定 MaxConcurrentCalls 使得同时可以有设定数目的线程数来处理消息，我们这里设定 1000 就相当于最多有 1000 个线程来处理消息，从而保证消息的最快处理。\r\n\r\n    // TODO: update the name of your queue\r\n    const string QueueName = \"yourqueuename\";\r\n\r\n    const int PrefetchCount = 1000;\r\n    const int MaxThreadsCount = 1000;\r\n\r\n    // QueueClient is thread-safe. Recommended that you cache \r\n    // rather than recreating it on every request\r\n    QueueClient Client;\r\n    ManualResetEvent CompletedEvent = new ManualResetEvent(false);\r\n\r\n    public override void Run()\r\n    {\r\n        Trace.WriteLine(\"Starting processing of messages\");\r\n\r\n        // Initiates the message pump and callback is invoked for each message that is received, calling close on the client will stop the pump.\r\n        Client.OnMessageAsync(async (receivedMessage) =>\r\n        {\r\n            Trace.WriteLine($\"Rcv Msg {receivedMessage.MessageId} --- C:{receivedMessage.Properties[\"CreateTime\"]} | E:{receivedMessage.EnqueuedTimeUtc.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture)} | R:{DateTime.UtcNow.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture)}\");\r\n            // sleep 1s to simulate processing\r\n            await Task.Delay(1000);\r\n            // Process the message\r\n            Trace.WriteLine($\"End Msg {receivedMessage.MessageId} --- F:{DateTime.UtcNow.ToString(\"HH:mm:ss.fff\", CultureInfo.InvariantCulture)}\");\r\n        }, new OnMessageOptions { AutoComplete = true, MaxConcurrentCalls = MaxThreadsCount });\r\n\r\n        CompletedEvent.WaitOne();\r\n    }\r\n\r\n    public override bool OnStart()\r\n    {\r\n        // Set the maximum number of concurrent connections \r\n        ServicePointManager.DefaultConnectionLimit = 12;\r\n\r\n        // Create the queue if it does not exist already\r\n        string connectionString = CloudConfigurationManager.GetSetting(\"Microsoft.ServiceBus.ConnectionString\");\r\n        var namespaceManager = NamespaceManager.CreateFromConnectionString(connectionString);\r\n        if (!namespaceManager.QueueExists(QueueName))\r\n        {\r\n            namespaceManager.CreateQueue(QueueName);\r\n        }\r\n\r\n        // Initialize the connection to Service Bus Queue\r\n        Client = QueueClient.CreateFromConnectionString(connectionString, QueueName);\r\n        Client.PrefetchCount = PrefetchCount;\r\n        return base.OnStart();\r\n    }\r\n\r\n## 运行\r\n\r\n1. 设置服务总线信息\r\n\r\n    ** 发送端 **\r\n\r\n        // TODO: update with your own value here\r\n        var sbConnStr = \"yourservicebusconnectionstring\";\r\n        var queueName = \"yourqueuename\";\r\n\r\n    ** 接收端 **\r\n\r\n        // TODO: update the name of your queue\r\n        const string QueueName = \"yourqueuename\";\r\n\r\n        <ConfigurationSettings>\r\n        <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=[name];AccountKey=[key];EndpointSuffix=core.chinacloudapi.cn\" />\r\n        <Setting name=\"Microsoft.ServiceBus.ConnectionString\" value=\"Endpoint=sb://[your namespace].servicebus.chinalcoudapi.cn;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=[your key]\" />\r\n        </ConfigurationSettings>\r\n\r\n2. 发布接收端项目 ReceiverWorkerRole 到 Azure 上\r\n\r\n3. 运行发送端来发送消息\r\n\r\n4. 查看步骤 1 中设置的存储账户中的 WADLogsTable 的日志，可通过 Microsoft Storage Explorer 来查看。\r\n\r\n日志分析：\r\n\r\n- Rcv Msg 6ca4a6f26dcd4aaf956e422c90e5aee5 --- C:06:42:17.934 | E:06:42:19.192 | R:06:42:19.61\r\n\r\n    - C代表消息创建时间\r\n    - E代表消息到达服务总线队列时间\r\n    - R代表消息接收到的时间\r\n\r\n- End Msg 6ca4a6f26dcd4aaf956e422c90e5aee5 --- F:06:42:20.652\r\n\r\n    - F代表消息处理完成时间\r\n\r\n源代码\r\n\r\n[https://github.com/wacn/AOG-CodeSample/tree/master/ServiceBus/CSharp/Benchmark%20Testing](\r\nhttps://github.com/wacn/AOG-CodeSample/tree/master/ServiceBus/CSharp/Benchmark%20Testing)"}